{"name":"1575_A. Another Sorting Problem","public_tests":{"input":["5 2\nAA\nAB\nBB\nBA\nAZ\n"],"output":["5 2 1 3 4 \n"]},"solutions":{"language":[2,2,2,2,2,2,3,2,3,4,2,4,2,2,2,2,2,2,2,2,4,2,3,2,4,2,2,2,2,4,4,2,2,2,3,4,2,2,4,2,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,2,2,3,2,2,2,2,2,3,2,2,2,3,2,3,2,2,3,2,2,2,2,4,2,2,3,2,2,2,2,2,2,2,4,2,2,4,2,2,2,2,2,2,2,2,2,4,4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,2,3,4,4,2],"solution":["#include <bits\/stdc++.h>\nusing namespace std;\nbool isrange(int second, int first, int n, int m) {\n  if (0 <= second && second < n && 0 <= first && first < m) return true;\n  return false;\n}\nint dy[4] = {1, 0, -1, 0}, dx[4] = {0, 1, 0, -1},\n    ddy[8] = {1, 0, -1, 0, 1, 1, -1, -1}, ddx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst int MAX = 1e6 + 100;\nint n, m;\npair<string, int> s[MAX];\nbool comp(pair<string, int>& a, pair<string, int>& b) {\n  for (int e = 0; e < m; e++) {\n    if (e % 2 == 0) {\n      if (a.first[e] != b.first[e]) return a.first[e] < b.first[e];\n    } else {\n      if (a.first[e] != b.first[e]) return a.first[e] > b.first[e];\n    }\n  }\n  return true;\n}\nvoid solve(int tc) {\n  cin >> n >> m;\n  for (int e = 0; e < n; e++) {\n    cin >> s[e].first;\n    s[e].second = e + 1;\n  }\n  sort(s, s + n, comp);\n  for (int e = 0; e < n; e++) cout << s[e].second << \" \";\n}\nint main(void) {\n  ios_base ::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int tc = 1;\n  for (int test_number = 1; test_number <= tc; test_number++) {\n    solve(test_number);\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nusing Item = pair<string, int>;\nstruct ItemComparator {\n  inline bool operator()(const Item& lhs, const Item& rhs) {\n    int pos{0};\n    while (lhs.first[pos] == rhs.first[pos]) ++pos;\n    return pos & 1 ? lhs.first[pos] > rhs.first[pos]\n                   : lhs.first[pos] < rhs.first[pos];\n  }\n};\nint main() {\n  int n, m;\n  string s;\n  vector<Item> items;\n  cin >> n >> m;\n  items.reserve(n);\n  for (int i = 1; i <= n; ++i) {\n    cin >> s;\n    items.push_back(make_pair(s, i));\n  }\n  sort(items.begin(), items.end(), ItemComparator());\n  for (int i = 0; i < n; ++i) {\n    cout << items[i].second << \" \";\n  }\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool compare(pair<string, int> aa, pair<string, int> bb) {\n  string a = aa.first;\n  string b = bb.first;\n  int n = a.size();\n  for (int i = 0; i < n; i++) {\n    if (a[i] == b[i]) continue;\n    if (a[i] < b[i]) {\n      if (i % 2)\n        return false;\n      else\n        return true;\n    } else {\n      if (i % 2)\n        return true;\n      else\n        return false;\n    }\n  }\n  return aa.second < bb.second;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i].first;\n    v[i].second = i;\n  }\n  sort(v.begin(), v.end(), compare);\n  for (auto x : v) {\n    cout << x.second + 1 << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint n, m;\nbool comp(pair<string, int> &a, pair<string, int> &b) {\n  int id = 0;\n  for (int i = 0; i < m; i++) {\n    if (a.first[i] != b.first[i]) {\n      id = i;\n      break;\n    }\n  }\n  if (id % 2 == 0) {\n    return a.first[id] < b.first[id];\n  } else {\n    return a.first[id] > b.first[id];\n  }\n}\nvoid TEST_CASES() {\n  cin >> n >> m;\n  vector<pair<string, int> > a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i].first;\n    a[i].second = i + 1;\n  }\n  sort(a.begin(), a.end(), comp);\n  for (auto &it : a) {\n    cout << it.second << \" \";\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t = 1;\n  while (t--) {\n    TEST_CASES();\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int> > v1;\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    pair<string, int> p1;\n    p1.first = s;\n    p1.second = i + 1;\n    v1.push_back(p1);\n  }\n  for (int i = 0; i < n; i++) {\n    string s1 = \"\";\n    for (int j = 0; j < m; j++) {\n      string s2 = \"\";\n      if (j % 2 == 0) {\n        s2 += v1[i].first[j];\n      } else {\n        int x = 90 - int(v1[i].first[j]);\n        s2 += char(65 + x);\n      }\n      s1 += s2;\n    }\n    v1[i].first = s1;\n  }\n  sort(v1.begin(), v1.end());\n  for (int i = 0; i < n; i++) {\n    cout << v1[i].second << \" \";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint n, m;\nstruct Node {\n  string k;\n  int id;\n};\nNode s[1000006];\nbool cmp(Node a, Node b) {\n  for (int i = 0; i < m; i++) {\n    if (i % 2 == 0) {\n      if (a.k[i] < b.k[i]) {\n        return 1;\n      } else if (a.k[i] > b.k[i]) {\n        return 0;\n      }\n    } else {\n      if (a.k[i] < b.k[i]) {\n        return 0;\n      } else if (a.k[i] > b.k[i]) {\n        return 1;\n      }\n    }\n  }\n  return 1;\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> s[i].k;\n    s[i].id = i;\n  }\n  sort(s + 1, s + 1 + n, cmp);\n  for (int i = 1; i <= n; i++) {\n    cout << s[i].id << \" \";\n  }\n  return 0;\n}\n","import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom heapq import heappush,heappop,heapify\nfrom bisect import bisect_right,insort,bisect_left\nfrom functools import lru_cache\nfrom itertools import permutations\n\nsys.setrecursionlimit(10**6)\n\ndef STRIN():return input()\ndef INTIN():return int(input())\ndef LINT():return list(map(int,input().split()))\ndef LSTR():return list(map(str,input().split()))\ndef MINT():return map(int,input().split())\ndef MSTR():return map(str,input().split())\n\n\n\ndef solve():\n   \n   \n    \n    n,m=map(int,input().split())\n\n    s=[]\n    d={}\n\n    for i in range(n):\n        s.append(list(input()))\n\n\n    for j in range(n):\n        for k in range(len(s[i])):\n            if (k+1)%2==0:\n                s[j][k]=chr(90-(ord(s[j][k])+26-91))\n\n\n    for i in range(len(s)):\n        d[''.join(s[i])]=i+1\n\n\n    s.sort()\n\n    for i in s:\n        print(d[''.join(i)],end=\" \")\n\n\n\n    \n\n\n\n    \n\n\n\n \n        \n \n \n    \n\ndef main():\n    #for _ in range(INTIN()):\n    solve()\n        \n\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nbool cmp(pair<string, long long int> s1, pair<string, long long int> s2) {\n  int k = s1.first.size();\n  for (int i = 0; i < k; i++) {\n    if (s1.first[i] == s2.first[i]) continue;\n    if (i % 2 == 0) {\n      return s1.first[i] < s2.first[i];\n    } else {\n      return s1.first[i] > s2.first[i];\n    }\n  }\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, long long int>> s1;\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    s1.push_back(make_pair(s, i + 1));\n  }\n  sort(s1.begin(), s1.end(), cmp);\n  for (int i = 0; i < n; i++) {\n    cout << s1[i].second << \" \";\n  }\n  return 0;\n}\n","from sys import stdin\n\ndef main():\n    input = stdin.readline\n    n,m = [int(i) for i in input().split()]\n    words = [(input(), i) for i in range(n)]\n    words.sort(key=lambda x: tuple(-ord(x[0][i]) if i&1 else ord(x[0][i]) for i in range(len(x[0]))))\n    print(\" \".join(map(str, [i[1]+1 for i in words])))\n\n\nif __name__ == '__main__':\n    main()","import com.sun.source.tree.Tree;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solution solver = new Solution();\n        boolean multipleTC = false;\n        int testCount = multipleTC ? Integer.parseInt(in.next()) : 1;\n        for (int i = 1; i <= testCount; i++) solver.solve(in, out, i);\n        out.close();\n    }\n\n    static class Solution {\n        PrintWriter out;\n        InputReader in;\n\n\n        public void solve(InputReader in, PrintWriter out, int test) {\n            this.out = out;\n            this.in = in;\n            int n = ni();\n            m = ni();\n            Pair[] arr = new Pair[n];\n            for(int i = 0; i < n; i++)\n                arr[i] = new Pair(n(), i);\n            Arrays.sort(arr, com);\n            for(int i = 0; i < n; i++) {\n                out.print(arr[i].ind + 1 + \" \");\n            }\n            pn(\"\");\n        }\n\n        private static int m;\n        static final Comparator<Pair> com = new Comparator<Pair>() {\n            @Override\n            public int compare(Pair o1, Pair o2) {\n                for(int i = 0; i < m; i++) {\n                    if(o1.st.charAt(i) != o2.st.charAt(i)) {\n                        if(i % 2 == 0)\n                            return Character.compare(o1.st.charAt(i), o2.st.charAt(i));\n                        else\n                            return Character.compare(o2.st.charAt(i), o1.st.charAt(i));\n                    }\n                }\n                return Integer.compare(o1.ind, o2.ind);\n            }\n        };\n\n        String n() {\n            return in.next();\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        long nl() {\n            return in.nextLong();\n        }\n\n        void pn(long zx) {\n            out.println(zx);\n        }\n\n        void pn(String sz) {\n            out.println(sz);\n        }\n\n        void pn(double dx) {\n            out.println(dx);\n        }\n\n        class Pair {\n            String st;\n            int ind;\n            Pair(String st, int ind) {\n                this.st = st;\n                this.ind = ind;\n            }\n        }\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new UnknownError();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> a(n);\n  string s;\n  for (int j = 0; j < n; ++j) {\n    cin >> s;\n    for (int i = 0; i < m; ++i)\n      if (i % 2) s[i] = (char)('Z' - s[i]);\n    a[j] = make_pair(s, j + 1);\n  }\n  stable_sort(a.begin(), a.end());\n  for (int j = 0; j < n; ++j) {\n    cout << a[j].second << ' ';\n  }\n}\n","\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\n\npublic class A {\n\tpublic static void main(String[] args)\n    {\n        FastReader s=new FastReader();\n        int t = 1;         \/\/ Number of test cases\n        for (int i = 0; i<t; i++) {\n        \tint n = s.nextInt();\n        \tint k = s.nextInt();\n        \tPriorityQueue<pair> pq = new PriorityQueue<>();\n        \tfor (int j = 0; j<n; j++) {\n        \t\tString str = s.next();\n        \t\tpq.add(new pair(str, j));\n        \t}\n\/\/        \tSystem.out.println(pq);\n        \twhile (pq.size() > 0) {\n        \t\tpair rem = pq.remove();\n        \t\tSystem.out.print(rem.idx+1 + \" \");\n        \t}\n        \tSystem.out.println();\n        }\n\n        \n     \n        \n        \n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    static void sort(int[] a) {\n    \tArrayList<Integer> l = new ArrayList<>();\n    \tfor (int i : a) l.add(i);\n    \tCollections.sort(l);\n    \tfor (int i = 0; i<a.length; i++) {\n    \t\ta[i]=l.get(i);\n    \t}\n    }\n    \n    \n    \/* .......................pair.............................. *\/\n\t static class pair implements Comparable<pair>{\n\t    \tString str;\n\t    \tint idx;\n\n\t    \tpublic pair (String str, int idx) {\n\t    \t\tthis.str = str;\n\t    \t\tthis.idx = idx;\n\t    \t\n\t    \t}\n\t    \tpublic int compareTo(pair o) {\n\t    \t\tint i = 0;\n\t    \t\tint j = 0;\n\t    \t\twhile (this.str.charAt(i) == o.str.charAt(j)) {\n\t    \t\t\ti++;\n\t    \t\t\tj++;\n\t    \t\t}\n\t    \t\tif (i%2 == 0) {\n\t    \t\t\tif (this.str.charAt(i) < o.str.charAt(j)) {\n\t    \t\t\t\treturn -1;\n\t    \t\t\t}else {\n\t    \t\t\t\treturn 1;\n\t    \t\t\t}\n\t    \t\t}else {\n\t    \t\t\tif (this.str.charAt(i) < o.str.charAt(j)) {\n\t    \t\t\t\treturn 1;\n\t    \t\t\t}else {\n\t    \t\t\t\treturn -1;\n\t    \t\t\t}\n\t    \t\t}\n\/\/\t    \t\treturn this.diff-o.diff;                  \/\/ minimum element at peek\n\t    \t}\n\t    }\n\t    \n\t    \n   \n   \n   \n   \n\t\/* .......................lower\/upper bound.............................. *\/\n\tstatic int upper(long A[], long k, int si, int ei) {\n\t\tint l = si;\n\t\tint u = ei;\n\t\tint ans = -1;\n\t\twhile (l <= u) {\n\t\t\tint mid = (l + u) \/ 2;\n\t\t\tif (A[mid] <= k) {\n\t\t\t\tans = mid;\n\t\t\t\tl = mid + 1;\n\t\t\t} else {\n\t\t\t\tu = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic int lower(long A[], long k, int si, int ei) {\n\t\tint l = si;\n\t\tint u = ei;\n\n\t\twhile (l < u) {\n\t\t\tint mid =  l + ((u-l) \/ 2);\n\t\t\tif (A[mid] >= k) {\n\t\t\t\tu = mid;\n\t\t\t} else {\n\t\t\t\tl = mid+1;\n\t\t\t}\n\t\t}\n\t\tif (A[l] >= k) return l;                     \/\/ returns index\n\t\treturn l+1;\n\t}\n   \n   \n    \n    \n\tstatic class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  vector<string> s(n);\n  for (int i = 0; i < n; ++i) cin >> s[i];\n  vector<int> ans(n);\n  const auto b = ans.begin(), e = ans.end();\n  iota(b, e, 0), sort(b, e, [&](int i, int j) {\n    int k = 0;\n    while (s[i][k] == s[j][k]) ++k;\n    const int p = k & 1, x = s[i][k], y = s[j][k];\n    return p ? x > y : x < y;\n  });\n  for (int i = 0; i < n; ++i) cout << ans[i] + 1 << ' ';\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nstruct block {\n  string str;\n  int pos;\n};\nstatic bool compare(block b1, block b2) {\n  int n = b1.str.length();\n  for (int i = 0; i < n; i++) {\n    if (b1.str[i] != b2.str[i]) {\n      if ((i + 1) % 2) {\n        return (b1.str[i] < b2.str[i]);\n      } else {\n        return (b1.str[i] > b2.str[i]);\n      }\n    }\n  }\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<block> arr(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i].str;\n    arr[i].pos = i + 1;\n  }\n  sort(arr.begin(), arr.end(), compare);\n  for (int i = 0; i < n; i++) {\n    cout << arr[i].pos << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int Mod = 1e9 + 7;\nint poww(int a, int b, int mod) {\n  int res = 1;\n  if (b < 0) b = (b % (mod - 1) + mod - 1) % (mod - 1);\n  for (; b; b >>= 1, a = 1ll * a * a % mod)\n    if (b & 1) res = 1ll * res * a % mod;\n  return res;\n}\nvoid Max(int& x, int y) { x = max(x, y); }\nvoid Min(int& x, int y) { x = min(x, y); }\nvoid OK(bool yes) { cout << (yes ? \"Yes\\n\" : \"No\\n\"); }\nconst int N = 200200, M = 2010, LN = (1 << 24), K = 17, inf = 3e18,\n          Mod1 = 1e9 + 7, Mod2 = 999997457;\nconst long double pi = acos(-1), eps = 1e-12;\nint Fact[N], iFact[N];\nvoid init() {\n  Fact[0] = iFact[0] = 1ll;\n  for (int i = 1; i < N; i++) Fact[i] = (1ll * Fact[i - 1] * i) % Mod;\n  iFact[N - 1] = poww(Fact[N - 1], -1, Mod);\n  for (int i = N - 2; i; i--) iFact[i] = (1ll * iFact[i + 1] * (i + 1)) % Mod;\n}\nint Cnk(int x, int y) {\n  if (y > x) return 0;\n  return (((Fact[x] * poww(Fact[y], -1, Mod)) % Mod) *\n          poww(Fact[x - y], -1, Mod)) %\n         Mod;\n}\nvoid Add(int& x, int y, int j = 0) {\n  int mod = Mod;\n  if (j == 1) mod = Mod1;\n  if (j == 2) mod = Mod2;\n  x %= mod;\n  y %= mod;\n  if (x < 0) x += mod;\n  if (y < 0) y += mod;\n  x = (x + y >= mod ? x + y - mod : x + y);\n}\nint n, m;\nstring s[1000010];\nbool asc(int i, int j) { return s[i] < s[j]; }\nbool des(int i, int j) { return s[i] > s[j]; }\nvoid Solve(vector<int>& v, int idx) {\n  if (idx > m) {\n    for (auto p : v) cout << p << ' ';\n    return;\n  }\n  if (idx & 1) {\n    sort(v.begin(), v.end(), des);\n  } else {\n    sort(v.begin(), v.end(), asc);\n  }\n  vector<int> tmp;\n  for (int i = 0; i < v.size(); i++) {\n    if (i == 0) {\n      tmp.push_back(v[i]);\n    } else {\n      if (s[v[i]][idx] == s[v[i - 1]][idx])\n        tmp.push_back(v[i]);\n      else {\n        Solve(tmp, idx + 1);\n        tmp.clear();\n        tmp.push_back(v[i]);\n      }\n    }\n  }\n  Solve(tmp, idx + 1);\n  tmp.clear();\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n  int T = 1;\n  int Case = 1;\n  while (T--) {\n    cin >> n >> m;\n    vector<int> v;\n    for (int i = 1; i <= n; i++) {\n      cin >> s[i];\n      v.push_back(i);\n    }\n    Solve(v, 0);\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool cmp(string a, string b) {\n  for (int i = 0; i < min((int)a.size(), (int)b.size()); ++i) {\n    if (a[i] != b[i]) {\n      if (i % 2 == 0 && a[i] < b[i]) return true;\n      if (i % 2 && a[i] > b[i]) return true;\n      return false;\n    }\n  }\n  return false;\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<string> a(n);\n  vector<pair<string, int>> b(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    b[i].first = a[i];\n    b[i].second = i;\n  }\n  sort(b.begin(), b.end());\n  sort(a.begin(), a.end(), cmp);\n  vector<int> ans(n);\n  for (int i = 0; i < n; ++i) {\n    int idx = lower_bound(b.begin(), b.end(), make_pair(a[i], -1)) - b.begin();\n    if (idx < 0 || idx >= (int)b.size()) {\n      cout << \"-1\\n\";\n      return;\n    }\n    ans[i] = b[idx].second + 1;\n  }\n  for (auto x : ans) cout << x << \" \";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int N = 1e5 + 5;\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  vector<string> in(n);\n  for (auto& x : in) cin >> x;\n  vector<int> order(n);\n  iota(begin(order), end(order), 0);\n  sort(begin(order), end(order), [&](int i, int j) {\n    for (int k = 0; k < m; k++) {\n      if (in[i][k] != in[j][k]) {\n        if (k % 2 == 0) {\n          return in[i][k] < in[j][k];\n        } else {\n          return in[i][k] > in[j][k];\n        }\n      }\n    }\n    return false;\n  });\n  for (int i : order) cout << i + 1 << \"\\n\";\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nstring str[1000000];\nlong long x, y;\nbool compare1(long long i1, long long i2) {\n  long long j, k;\n  for (j = 0; j < x; j++) {\n    if (j % 2 == 1) {\n      if (str[i1][j] > str[i2][j]) {\n        return 1;\n      } else if (str[i1][j] < str[i2][j]) {\n        return 0;\n      }\n    } else {\n      if (str[i1][j] > str[i2][j]) {\n        return 0;\n      } else if (str[i1][j] < str[i2][j]) {\n        return 1;\n      }\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long n, m, i, j, k, l, r;\n  cin >> n >> m;\n  long long ara[n];\n  for (i = 0; i < n; i++) {\n    cin >> str[i];\n    ara[i] = i;\n  }\n  x = m;\n  sort(ara, ara + n, compare1);\n  for (i = 0; i < n; i++) {\n    cout << ara[i] + 1;\n    if (i < n - 1) {\n      cout << \" \";\n    } else {\n      cout << \"\\n\";\n    }\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> vp;\n  for (int i = 1; i <= n; i++) {\n    string s, s2 = \"\";\n    cin >> s;\n    for (int j = 0; j < m; j++) {\n      if (j % 2 == 0) {\n        s2.push_back(s[j]);\n      } else {\n        int z = 25 - (s[j] - 'A');\n        char c = 'A' + z;\n        s2.push_back(c);\n      }\n    }\n    vp.push_back({s2, i});\n  }\n  sort(vp.begin(), vp.end());\n  for (auto e : vp) cout << e.second << \" \";\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nstruct node {\n  string ss;\n  int i;\n} s[1000009];\nint cmp(node x, node y) { return x.ss < y.ss; }\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; ++i) {\n    cin >> s[i].ss;\n    s[i].ss = ' ' + s[i].ss;\n    s[i].i = i + 1;\n    for (int j = 1; j <= m; ++j) {\n      if (j % 2 == 0) {\n        s[i].ss[j] = 'Z' - s[i].ss[j] + 'A';\n      }\n    }\n  }\n  sort(s, s + n, cmp);\n  for (int i = 0; i < n; ++i) {\n    cout << s[i].i << \" \";\n  }\n}\n","import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\npublic class HelloWorld{\n    public static void main(String []args) throws java.io.IOException {\n        BufferedReader scan = new BufferedReader(new InputStreamReader(System.in));\n        String[] nm = scan.readLine().split(\" \");\n        int n = Integer.parseInt(nm[0]);\n        int m = Integer.parseInt(nm[1]);\n        String[] books = new String[n];\n        Map<String, Integer> map = new HashMap<>();\n        for(int i=0; i<n; i++) {\n            books[i] = scan.readLine();\n            map.put(books[i], i+1);\n        }\n        Arrays.sort(books, (a, b) -> {\n            for(int i=0; i<a.length(); i++) {\n                if(a.charAt(i) > b.charAt(i)) {\n                    return ((i+1)%2 == 0) ? -1 : 1;\n                }\n                else if(a.charAt(i) < b.charAt(i)) {\n                    return ((i+1)%2 == 0) ? 1 : -1;\n                }\n            }\n            return 0;\n        });\n        for(String book: books) {\n            System.out.println(map.get(book) + \" \");\n        }\n        System.out.println();\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long FULL = (1e5) + 100;\nconst long long INF = 1e18;\nconst long long MOD = (1e9) + 7;\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.precision(9);\n  map<char, char> mp;\n  for (char i = 'Z', j = 'A'; i <= 'A', j <= 'Z'; i--, j++) {\n    mp[i] = j;\n  }\n  long long n, m;\n  cin >> n >> m;\n  vector<pair<string, long long> > ar(n);\n  for (long long i = 0; i < n; i++) {\n    cin >> ar[i].first;\n    ar[i].second = i + 1;\n    for (long long j = 0; j < m; j++) {\n      if (j & 1) {\n        ar[i].first[j] = mp[ar[i].first[j]];\n      }\n    }\n  }\n  sort(ar.begin(), ar.end());\n  for (auto i : ar) {\n    cout << i.second << ' ';\n  }\n  return 0;\n}\n","l0 = [chr(x) for x in range(65, 91)]\nl1 = reversed(l0)\ndic = dict(zip(l0, l1))\na, b = map(int, input().split())\nl2 = []\nfor _ in range(a):\n    s = list(input())\n    for i in range(1, b, 2):\n        s[i] = dic[s[i]]\n    l2.append(''.join(s))\nl3 = sorted(range(a), key=lambda x: l2[x])\nprint(*[i+1 for i in l3])\n","#include <bits\/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nint MOD = 1e9 + 7;\ndouble eps = 1e-12;\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n, m;\n  cin >> n >> m;\n  string* arr = new string[n];\n  for (long long i = 0; i < n; i++) cin >> arr[i];\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (j % 2 == 1) {\n        arr[i][j] = 'A' + (25 - (arr[i][j] - 'A'));\n      }\n    }\n  }\n  map<string, long long> umap;\n  for (long long i = 0; i < n; i++) {\n    umap[arr[i]] = i + 1;\n  }\n  for (auto i = umap.begin(); i != umap.end(); i++) {\n    cout << i->second << \" \";\n  }\n  cout << \"\\n\";\n}\n","import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class A {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n\n        solve(s.nextInt(), s.nextInt(), s);\n    }\n\n\n    public static void solve(int n, int l, Scanner s) {\n        String a[][] = new String[n][2];\n        for (int i = 1; i <= n; i++) {\n            a[i - 1] = new String[]{s.next(), i + \"\"};\n        }\n\n        Arrays.sort(a, new Comparator<String[]>() {\n            @Override\n            public int compare(String[] o1, String[] o2) {\n                String s1 = o1[0];\n                String s2 = o2[0];\n                for (int i = 0; i < l; i++) {\n                    if (s1.charAt(i) != s2.charAt(i)) return i % 2 == 0 ^ (s1.charAt(i) > s2.charAt(i)) ? -1 : 1;\n                }\n                return 0;\n            }\n        });\n\n        StringBuilder erg = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            erg.append(a[i][1]).append(\" \");\n        }\n\n        System.out.println(erg);\n    }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT sgn(T x) {\n  if (x < 0) return -1;\n  return (x ? x : 0);\n}\ntemplate <typename T>\nint cmp(const void* a, const void* b) {\n  T *x = (T*)a, *y = (T*)b;\n  long long diff = *x - *y;\n  return sgn<T>(diff);\n}\nint n, m;\nstruct obj {\n  string* line;\n  int i;\n};\nint cmp_ascdesc(const void* a, const void* b) {\n  obj c = *(obj*)a;\n  obj d = *(obj*)b;\n  string x = *(c.line);\n  string y = *(d.line);\n  int i = 0;\n  while (i < m && x[i] == y[i]) i++;\n  if (i == m)\n    return 0;\n  else {\n    if (i % 2 == 0) {\n      return x[i] - y[i];\n    } else {\n      return y[i] - x[i];\n    }\n  }\n}\nint main() {\n  int t = 1;\n  while (t-- > 0) {\n    cin >> n >> m;\n    string* line;\n    obj* lines = new obj[n];\n    for (int i = 0; i < n; i++) {\n      line = new string;\n      cin >> (*line);\n      lines[i].line = line;\n      lines[i].i = i + 1;\n    }\n    qsort(lines, n, sizeof(obj), cmp_ascdesc);\n    for (int i = 0; i < n; i++) cout << lines[i].i << \" \";\n    delete[] lines;\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long n;\npair<string, long long> s[1000005];\nlong long m;\nbool cmp(pair<string, long long> a, pair<string, long long> b) {\n  string s = a.first, t = b.first;\n  for (long long i = 0; i < (m); i++)\n    if (s[i] != t[i]) {\n      if (i & 1)\n        return s[i] > t[i];\n      else\n        return s[i] < t[i];\n    }\n  return a.second < b.second;\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (long long i = 0; i < (n); i++) cin >> s[i].first, s[i].second = i + 1;\n  sort(s, s + n, cmp);\n  for (long long i = 0; i < (n); i++) cout << s[i].second << \" \";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long n, m;\nbool cmp(string a, string b) {\n  for (long long i = 0; i < m; i++) {\n    if (i % 2 == 0) {\n      if (a[i] != b[i]) return a[i] < b[i];\n    } else {\n      if (a[i] != b[i]) return a[i] > b[i];\n    }\n  }\n  return a < b;\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cin >> n >> m;\n  map<string, long long> p;\n  vector<string> v(n);\n  for (long long i = 0; i < n; i++) {\n    cin >> v[i];\n    p[v[i]] = i + 1;\n  }\n  sort(v.begin(), v.end(), cmp);\n  for (long long i = 0; i < n; i++) {\n    cout << p[v[i]] << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint32_t main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);\n  long long n, m;\n  cin >> n >> m;\n  vector<pair<string, int> > v;\n  for (int i = 0; i < n; i++) {\n    string x;\n    cin >> x;\n    v.push_back({x, i + 1});\n  }\n  for (int i = 0; i < m; i++) {\n    if (i % 2 == 0) {\n      continue;\n    } else {\n      for (int j = 0; j < n; j++) {\n        char c = v[j].first[i];\n        c = 155 - c;\n        v[j].first[i] = c;\n      }\n    }\n  }\n  sort(v.begin(), v.end());\n  for (int i = 0; i < n; i++) {\n    cout << v[i].second << \" \";\n  }\n  return 0;\n}\n","import java.io.*;\nimport java.util.*;\n\n\/\/ sort the odd digits ascendengly and even digits descendengly\npublic class StringSort { \/\/ start class\n\n\/\/_______________________________main method__________________________________\n\n    public static void main(String args[]) throws IOException { \/\/ start method\n\n        BufferedReader fin = new BufferedReader(new InputStreamReader(System.in));\n\n        StringTokenizer st = new StringTokenizer(fin.readLine());\n        int N = Integer.parseInt(st.nextToken()), M = Integer.parseInt(st.nextToken());\n        String2[] arr = new String2[N];\n        for (int i = 0; i < N; i++) {\n            arr[i] = new String2(fin.readLine(), i+1);\n        }\n\n        \/\/ int N = 3;\n\/\/        String2[] arr = {new String2(\"AA\", 1), new String2(\"AB\", 2), new String2(\"BB\", 3), new String2(\"BA\", 4),\n\/\/                new String2(\"AZ\", 5)};\n\/\/        String2[] arr = {new String2(\"AAD\", 1), new String2(\"AAC\", 2), new String2(\"BAB\", 3)};\n\n        Arrays.sort(arr);\n\n        for (String2 str : arr) {\n            System.out.print(str.index + \" \");\n\/\/            System.out.println(str.str);\n        }\n    }\n}\n\nclass String2 implements Comparable<String2> {\n    String str;\n    int index;\n    public String2(String str, int index) { \/\/ constructor\n        this.str = str;\n        this.index = index;\n    }\n    public int compareTo(String2 o) { \/\/ sorting method\n        int i = 0;\n        while (i < str.length()-1 && str.charAt(i) == o.str.charAt(i)) {\n            if (str.charAt(i+1) != o.str.charAt(i+1)) {\n                if (i % 2 == 1) return str.compareTo(o.str);\n                else return o.str.compareTo(str);\n            }\n            i++;\n        }\n        return str.compareTo(o.str);\n    }\n}\n","import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        String s[]=bu.readLine().split(\" \");\n        int n=Integer.parseInt(s[0]);\n        int i;\n        Trie root=new Trie(0);\n        for(i=0;i<n;i++)\n        {\n            String st=bu.readLine();\n            update(root,st,i+1);\n        }\n\n        dfs(root);\n        \/\/System.out.println(ans);\n        for(int x:ans) sb.append(x+\" \");\n        System.out.print(sb);\n    }\n\n    static void update(Trie root,String s,int id)\n    {\n        Trie cur=root;\n        int i,n=s.length();\n        for(i=0;i<n;i++)\n        {\n            int nx=s.charAt(i)-'A';\n            if(i%2==1) nx=25-nx;\n            if(cur.c[nx]==null) cur.c[nx]=new Trie(0);\n            cur=cur.c[nx];\n        }\n        cur.in=id;\n    }\n\n    static ArrayList<Integer> ans=new ArrayList<>();\n    static void dfs(Trie root)\n    {\n        if(root.in!=0) ans.add(root.in);\n        for(int i=0;i<26;i++)\n        if(root.c[i]!=null) dfs(root.c[i]);\n    }\n\n    static class Trie\n    {\n        Trie c[];\n        int in;\n        Trie(int x)\n        {\n            c=new Trie[26];\n            in=x;\n        }\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  string s;\n  vector<pair<string, int>> vp;\n  for (int i = 0; i < n; i++) {\n    cin >> s;\n    for (int j = 0; j < s.length(); j++) {\n      if (j & 1) {\n        s[j] = 90 - (s[j]) + 65;\n      }\n    }\n    vp.push_back(make_pair(s, i + 1));\n  }\n  sort(vp.begin(), vp.end());\n  for (int i = 0; i < n; i++) {\n    cout << vp[i].second << \" \";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\nint n, m;\nstruct node {\n  int id;\n  string s;\n};\nvector<node> v;\nbool cmp(node a, node b) {\n  for (int i = 0; i < m; i++) {\n    if (i % 2 == 0) {\n      if (a.s[i] == b.s[i]) continue;\n      return a.s[i] < b.s[i];\n    } else {\n      if (a.s[i] == b.s[i]) continue;\n      return a.s[i] > b.s[i];\n    }\n  }\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    string s;\n    cin >> s;\n    v.push_back({i, s});\n  }\n  sort(v.begin(), v.end(), cmp);\n  for (auto x : v) cout << x.id << \" \";\n  cout << endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  string f = \"ZYXWVUTSRQPONMLKJIHGFEDCBA\";\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> v;\n  for (int i = 1; i <= n; i++) {\n    string s;\n    cin >> s;\n    for (int j = 0; j < m; j++) {\n      if (j % 2 == 0) {\n        continue;\n      }\n      s[j] = f[s[j] - 'A'];\n    }\n    v.push_back({s, i});\n  }\n  sort(v.begin(), v.end());\n  for (auto it : v) {\n    cout << it.second << \" \";\n  }\n  return 0;\n}\n","n, m = list(map(int, input().split()))\nl = []\nfor _ in range(n):\n    book = list(input())\n    book[1::2]= map(lambda x : chr(155-ord(x) ), book[1::2])\n    l.append(book)\n \nprint(*sorted(range(1, n+1), key = lambda x : l[x-1]))","import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class AnotherSortingProblem {\n    static class Update implements Comparable<Update>{\n        String s;\n        int idx;\n\n        public Update(String s, int idx) {\n            this.s = s;\n            this.idx = idx;\n        }\n\n        @Override\n        public String toString() {\n            return this.idx+\"\";\n        }\n\n        @Override\n        public int compareTo(Update o) {\n\n            char ch1[]= this.s.toCharArray();\n            char ch2[]= o.s.toCharArray();\n\n            int len = Math.min( ch1.length, ch2.length);\n            int i=0;\n            while ( i <  len){\n\n                if( ch1[i] !=  ch2[i] ){\n                    if( (i&1)==1){\n                        return ch2[i]-ch1[i];\n                    }else\n                        return  ch1[i] - ch2[i];\n                }\n                i++;\n\n            }\n            if (len%2==0)\n                return ch2.length - ch1.length;\n            else\n                return ch1.length - ch2.length;\n\n        }\n    }\n\n\n\n\n\n\n    private static int solve(int n, int k) {\n        return 0;\n    }\n\n    public static void main(String[] args)\n            throws IOException {\n        Scanner s = new Scanner(System.in);\n        int t = 1;\n\/\/        t = s.nextInt();\n        StringBuilder ans = new StringBuilder();\n        int count = 0;\n        int n = s.nextInt();\n        int m = s.nextInt();\n        s.nextLine();\n        Update up[] = new Update[n];\n        while (count < n) {\n\n\n            String str = s.nextLine();\n            up[count] = new Update(str,count+1);\n\n            count++;\n\/\/            System.out.println(str);\n        }\n        Arrays.sort(up);\n\n\/\/        System.out.println(Arrays.toString(up));\n        for ( Update u : up){\n            System.out.print(u.idx+\" \");\n        }\n\n        System.out.println(ans.toString());\n    }\n\n\n    private static void getInputs(Scanner s, int[] a, int n) throws IOException {\n        for (int i = 0; i < n; i++) {\n            a[i] = s.nextInt();\n        }\n    }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool compare(string &s1, string &s2) {\n  bool ans = true;\n  int len = s1.size();\n  for (int i = 0; i < len; i++) {\n    if (s1[i] == s2[i]) {\n      continue;\n    } else {\n      if (i & 1) {\n        return s1[i] > s2[i];\n      } else {\n        return s1[i] < s2[i];\n      }\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  unordered_map<string, int> ch;\n  int n, m;\n  cin >> n >> m;\n  vector<string> vec(n);\n  for (int i = 0; i < n; i++) {\n    vec[i].resize(m);\n    cin >> vec[i];\n    ch[vec[i]] = i + 1;\n  }\n  sort(vec.begin(), vec.end(), compare);\n  for (int i = 0; i < n; i++) {\n    cout << ch[vec[i]] << \" \";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nusing lld = long double;\nusing ll = long long int;\nusing ar = vector<ll>;\nusing mat = vector<vector<ll>>;\nmat cn(ll n, ll m) { return vector<vector<ll>>(n, vector<ll>(m)); }\nll const MOD = 1000000007;\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n  return a > b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline bool chmadp2(T &a, T b) {\n  return a < b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline void add(T &a, T b) {\n  a += b;\n  a >= MOD ? a - MOD : a;\n}\ntemplate <class T>\ninline void sub(T &a, T b) {\n  a -= b;\n  a < 0 ? a + MOD : a;\n}\ntemplate <class T>\ninline void mul(T &a, T b) {\n  return (a * b) % MOD;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  for (auto &dp2 : v) out << dp2 << ' ';\n  return out;\n}\ntemplate <class T>\nvoid remDup(vector<T> &v) {\n  sort((v).begin(), (v).end());\n  v.erase(unique((v).begin(), (v).end()), end(v));\n}\nbool comp1(char &s1, char &s2) { return s1 > s2; }\nbool comp2(const pair<ll, pair<ll, ll>> &a, const pair<ll, pair<ll, ll>> &b) {\n  if (a.first > b.first) return 1;\n  if (a.first == b.first && a.second.second > b.second.second) return 1;\n  return 0;\n}\nclass Pair {\n public:\n  ll first, second;\n};\nbool comp3(const Pair &a, const Pair &b) {\n  if (a.first > b.first) return 1;\n  return 0;\n}\nclass Trips {\n public:\n  ll first, second, third;\n};\nbool comp4(const Trips &a, const Trips &b) {\n  if (a.third > b.third) return 1;\n  return 0;\n}\nvoid readArray(ll a[], int n) {\n  for (ll i = 0; i < n; i++) cin >> a[i];\n}\nll const inf = 1e9 + 7;\nll const maxn = 5e5 + 1;\nbool comp(string &a, string &b) {\n  ll m = a.size();\n  for (int i = 0; i < m; i++) {\n    if (a[i] != b[i]) {\n      if (i & 1) {\n        if (a[i] < b[i])\n          return 0;\n        else\n          return 1;\n      } else {\n        if (a[i] < b[i])\n          return 1;\n        else\n          return 0;\n      }\n    }\n  }\n  return 0;\n}\nvoid solve() {\n  ll t1 = 1;\n  for (ll tt = 1; tt <= t1; tt++) {\n    ll n, m;\n    cin >> n >> m;\n    unordered_map<string, ll> pos;\n    string s[n];\n    for (ll i = 0; i < n; i++) {\n      cin >> s[i];\n      pos[s[i]] = i + 1;\n    }\n    sort(s, s + n, comp);\n    for (ll i = 0; i < n; i++) cout << pos[s[i]] << \" \";\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  solve();\n  return 0;\n}\n","import java.awt.Container;\nimport java.awt.image.SampleModel;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.concurrent.CountDownLatch;\n\nimport javax.naming.TimeLimitExceededException;\n\nimport java.io.PrintStream;\n\n\npublic class Solution {\n\n\tstatic class Pair<T,V>{\n\t\tT first;\n\t\tV second;\n\t\tpublic Pair(T first, V second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n\n\n\t}\n\n\t\/\/ public static final boolean LOCAL = System.getProperty(\"ONLINE_JUDGE\")==null;\n\tprivate static FastScanner fs=new FastScanner();\n\tprivate static Scanner sc=new Scanner(System.in);\n\n\tprivate static int uperBound(long[] arr, long val) {\n\n\t\tint start= 0; \n\t\tint end=arr.length;\n\t\twhile(start<end) {\n\t\t\tint mid=(start+end)\/2;\n\t\t\tif( arr[mid]==val ) {\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t\tif( arr[mid]>val ) {\n\t\t\t\tend=mid-1;\n\t\t\t}else {\n\t\t\t\tstart=mid+1;\n\t\t\t}\n\t\t}\n\n\t\tif( start >= arr.length || arr[start]>val) {\n\t\t\treturn start;\n\t\t}else {\n\t\t\treturn start+1;\n\t\t}\n\n\t}\n\n\n\n\tprivate static void solve(int TC) throws Exception{\n\t\t\/*WRITE CODE HERE*\/\n\n\t\t\n\t\tint n=fs.nextInt();\n\t\tint m=fs.nextInt();\n\t\tArrayList<String> list=new ArrayList<String>();\n\t\tMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tlist.add(fs.next());\n\t\t\tmap.put(list.get(i), i);\n\t\t}\n\t\t\n\t\tCollections.sort(list, new Comparator<String>() {\n\t\t\t\n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\t\/\/ TODO Auto-generated method stub\n\t\t\t\tfor (int i = 0; i < o1.length(); i++) {\n\t\t\t\t\tint t = i+1;\n\t\t\t\t\tif (o1.charAt(i) == o2.charAt(i)) continue;\n\t\t\t\t\tif (t%2==1) {\n\t\t\t\t\t\treturn o1.charAt(i)- o2.charAt(i);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn o2.charAt(i) - o1.charAt(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tSystem.out.print(map.get(list.get(i))+1+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\t\n\t\t\/\/System.out.println(list);\n\t\t\/*for(int i=0;i<m;i++) {\n\t\t\t\n\t\t\tfor(int j=1;j<n;j++) {\n\t\t\t\t\n\t\t\t\tif(i%2==0) {\n\t\t\t\t\tint k=0;\n\t\t\t\t\twhile( j-1-k>=0 && list.get(j-1-k).substring(0,i).equals(list.get(j-k).substring(0,i))  && list.get(j-1-k).charAt(i) > list.get(j-k).charAt(i) ) {\n\t\t\t\t\t\t\/\/System.out.println(list.get(j-1-k)+\" \"+list.get(j-k));\n\t\t\t\t\t\tString temp=list.get(j-1-k);\n\t\t\t\t\t\tlist.set(j-1-k, list.get(j-k));\n\t\t\t\t\t\tlist.set(j-k, temp);\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\/\/System.out.println(list);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}else {\n\t\t\t\t\tint k=0;\n\t\t\t\t\twhile( j-1-k>=0 && list.get(j-1-k).substring(0,i).equals(list.get(j-k).substring(0,i))  && list.get(j-1-k).charAt(i) < list.get(j-k).charAt(i) ) {\n\t\t\t\t\t\tString temp=list.get(j-1-k);\n\t\t\t\t\t\tlist.set(j-1-k, list.get(j-k));\n\t\t\t\t\t\tlist.set(j-k, temp);\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tSystem.out.print(map.get(list.get(i))+1+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\t\/\/System.out.println(list);\n\t\t\n\t\t\n\t\t\n\t\t\/*int a=fs.nextInt();\n\t\tint b=fs.nextInt();\n\t\tint n=fs.nextInt();\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint sum=a;\n\t\t\tfor(int j=0;j<=i;j++) {\n\t\t\t\tsum+=Math.pow(2, j)*b;\n\t\t\t}\n\t\t\tSystem.out.print(sum+\" \");\n\t\t}\n\t\tSystem.out.println();\n\n\t\t\/*int n=fs.nextInt();\n\n\t\tint temp=n;\n\t\tArrayList<Pair<Integer,Integer>> list=new ArrayList<Solution.Pair<Integer,Integer>>();\n\t\tfor(int i=2;i*i<=temp;i++) {\n\t\t\tif(temp%i==0) {\n\n\t\t\t\tint cnt=0;\n\t\t\t\twhile(temp%i==0) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\ttemp\/=i;\n\t\t\t\t}\n\t\t\t\tlist.add(new Pair<Integer, Integer>(i,cnt));\n\n\t\t\t}\n\t\t}\n\t\tif(temp!=1) {\n\t\t\tlist.add(new Pair<Integer, Integer>(temp, 1));\n\t\t}\n\n\t\tif(list.size()==1) {\n\t\t\tif(list.get(0).second<6) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\tint num=list.get(0).first;\n\t\t\t\tSystem.out.println(num+\" \"+(num*num)+\" \"+ (n\/(num*num*num)));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint a=list.get(0).first;\n\t\tint b=list.get(1).first;\n\t\tint c= n\/(a*b);\n\t\tif( a==c || b==c || c==1 ) {\n\t\t\tSystem.out.println(\"NO\");\n\t\t}else {\n\t\t\tSystem.out.println(\"YES\");\n\t\t\tSystem.out.println(a+\" \"+b+\" \"+c);\n\t\t}\n\t\treturn;\n\n\n\n\n\t\t\/*long n=fs.nextLong();\n\n\n\t\tSystem.out.println((-(n-1))+\" \"+n);\n\n\n\n\t\t\/*int n=fs.nextInt();\n\n\t\tint arr[]=new int[n+1];\n\n\t\tfor(int i=2;i<=n;i++) {\n\t\t\t\/\/System.out.println(\"#1\");\n\t\t\tif( arr[i]==0 ) {\n\t\t\t\tfor(int j=2*i;j<=n;j+=i) {\n\t\t\t\t\tarr[j]++;\n\t\t\t\t\t\/\/System.out.println(\"#2\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count=0;\n\t\tfor(int i=2;i<=n;i++) {\n\t\t\t\/\/System.out.println(\"#3\");\n\t\t\tif(arr[i]==2) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(count);\n\n\t\t\/*int n = fs.nextInt(), x = fs.nextInt();\n        int[] a =new int[n];\n        for(int i=0;i<n;i++) {\n        \ta[i]=fs.nextInt();\n        }\n        int[] b = a.clone();\n        Arrays.sort(b);\n        for (int i = 0; i < n; i++) {\n            if (i < x && n - 1 - i < x && a[i] != b[i]) {\n                System.out.println(\"NO\");\n                return;\n            }\n        }\n        System.out.println(\"YES\");\n\n\t\t\/*int n=fs.nextInt();\n\t\tint x=fs.nextInt();\n\t\tArrayList<Long> list=new ArrayList<Long>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tlist.add(fs.nextLong());\n\t\t}\n\n\t\tArrayList<Long> copy=(ArrayList<Long>)list.clone();\n\n\t\tCollections.sort(copy);\n\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif( copy.get(i)!=list.get(i) ) {\n\t\t\t\tif( i < x && n - 1 - i < x ) {\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\n\t\t\/*int n=fs.nextInt();\n\t\tint h=fs.nextInt();\n\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tlist.add(fs.nextInt());\n\t\t}\n\t\tCollections.sort(list, Collections.reverseOrder());\n\t\tint sum=list.get(0)+list.get(1);\n\t\tint count= (h\/sum)*2 ;\n\t\tint left=h%sum;\n\t\tif( left<=list.get(0) && left!=0 ) {\n\t\t\tcount++;\n\t\t}else if(left!=0){\n\t\t\tcount+=2;\n\t\t}\n\n\t\tSystem.out.println(count);\n\n\n\n\n\n\t\t\/*int n=fs.nextInt();\n\n\t\tPriorityQueue<Pair<Integer,Integer>> pq=new PriorityQueue<Solution.Pair<Integer,Integer>>( (o1,o2)-> o2.first.compareTo(o1.first) );\n\n\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint num=fs.nextInt();\n\t\t\tif(num==0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpq.add(new Pair<Integer,Integer>(num, i));\n\t\t}\n\n\t\tArrayList<Pair<Integer,Integer>> ans=new ArrayList<Solution.Pair<Integer,Integer>>();\n\n\t\twhile(pq.size()>1) {\n\t\t\tPair p1=pq.poll();\n\t\t\tPair p2=pq.poll();\n\n\t\t\tans.add(new Pair(p1.second, p2.second));\n\t\t\tp1.first=(int)p1.first-1;\n\t\t\tp2.first=(int)p2.first-1;\n\n\t\t\tif(!p1.first.equals(0)) pq.add(p1);\n\t\t\tif(!p2.first.equals(0)) pq.add(p2);\n\t\t}\n\n\t\tSystem.out.println(ans.size());\n\t\tfor(Pair p:ans) {\n\t\t\tSystem.out.println(p.first+\" \"+p.second);\n\t\t}\n\n\n\t\t\/*int r=fs.nextInt();\n\t\tint col=fs.nextInt();\n\t\tint k=fs.nextInt();\n\n\t\tchar arr[][]=new char[r][col];\n\n\t\tfor(int i=0;i<r;i++) {\n\t\t\tchar  ch[]=fs.next().toCharArray();\n\t\t\tarr[i]=ch;\n\t\t}\n\n\t\tboolean visited[][]=new boolean[r][col];\n\t\tfor(boolean b[]:visited) {\n\t\t\tArrays.fill(b, false);\n\t\t}\n\n\t\tfor(int i=r-1;i>=1;i--) {\n\t\t\tfor(int j=1;j<col-1;j++) {\n\t\t\t\tif( arr[i][j]=='*' ) {\n\n\t\t\t\t\tint len = 0;\n\t                int a1 = i - 1, l1 = j - 1, l2 = j + 1;\n\t                ArrayList<Pair<Integer, Integer>> v=new ArrayList<Solution.Pair<Integer,Integer>>();\n\t                while (a1 >= 0 && l1 >= 0 && l2 < col) {\n\t                    if (arr[a1][l1] == '*' && arr[a1][l2] == '*') {\n\t                        len++;\n\t                        v.add(new Pair(a1,l1));\n\t                        v.add(new Pair(a1,l2));\n\t                        l1--;\n\t                        l2++;\n\t                        a1--;\n\t                        continue;\n\t                    }\n\t                    break;\n\t                }\n\t                if (len < k && visited[i][j] == false) {\n\t                    System.out.println(\"NO\");\n\t                    return;\n\t                }\n\t                if (len >= k) {\n\t                    for (Pair p:v) {\n\t                        visited[(int)p.first][(int)p.second] = true;\n\t                    }\n\t                }\n\t                visited[i][j] = true;\n\n\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i = 0; i < r; i++) {\n\t        for (int j = 0; j < col; j++) {\n\t            if (arr[i][j] == '*' && !visited[i][j]) {\n\t                System.out.println(\"NO\");\n\t                return;\n\t            }\n\t        }\n\t    }\n\n\t\tSystem.out.println(\"YES\");\n\n\n\t\t\/*int n=fs.nextInt();\n\t\tint arr[]=new int[n+1];\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tarr[i]=fs.nextInt();\n\t\t}\n\t\tArrayList<int[]> list=new ArrayList<int[]>();\n\t\tint smallAns[]=new int[3];\n\t\tfor(int i=1;i<=n ;i++) {\n\t\t\tint minI=i;\n\t\t\tfor(int j=i+1;j<=n;j++) {\n\t\t\t\tif(arr[minI]>arr[j]) {\n\t\t\t\t\tminI=j;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(minI==i) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\/\/System.out.println(minI);\n\t\t\tint temp=arr[minI];\n\t\t\tfor(int j=minI;j>i;j--) {\n\t\t\t\tarr[j]=arr[j-1];\n\t\t\t}\n\t\t\tarr[i]=temp;\n\t\t\tsmallAns[0]=i;\n\t\t\tsmallAns[1]=minI;\n\t\t\tsmallAns[2]=minI-i;\n\t\t\tlist.add(Arrays.copyOf(smallAns,smallAns.length));\n\t\t}\n\n\t\tSystem.out.println(list.size());\n\t\tfor(int i=0;i<list.size();i++) {\n\t\t\tSystem.out.println(list.get(i)[0]+\" \"+list.get(i)[1]+\" \"+list.get(i)[2]);\n\t\t}\n\t\t\/*System.out.println(\"sort\");\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\t}\n\t\tSystem.out.println();\n\n\t\t\/*String s=fs.next();\n\t\tint a=0;\n\t\tint b=0;\n\t\tint c=0;\n\t\tfor(int i=0;i<s.length();i++) {\n\t\t\tif(s.charAt(i)=='A') {\n\t\t\t\ta++;\n\t\t\t}else if( s.charAt(i)=='B' ) {\n\t\t\t\tb++;\n\t\t\t}else {\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\n\t\tif( a+c==b ) {\n\t\t\tSystem.out.println(\"YES\");\n\t\t}else {\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\n\t\t\/*int w=fs.nextInt();\n\t\tint h=fs.nextInt();\n\n\t\tint x1=fs.nextInt();\n\t\tint y1=fs.nextInt();\n\t\tint x2=fs.nextInt();\n\t\tint y2=fs.nextInt();\n\n\t\tint tw=fs.nextInt();\n\t\tint th=fs.nextInt();\n\n\t\tif( !( ( w>= (Math.abs(x1-x2)+tw) || h>= (Math.abs(y1-y2)+th) ) || ( w>= ( Math.abs(x1-x2)+th ) || h>= ( Math.abs(y1-y2)+tw ) ) ) ) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn ;\n\t\t}\n\t\tint ans=Integer.MAX_VALUE;\n\t\tif( y1>= th || h-y2>=th ) {\n\t\t\tans=0;\n\t\t}else if( th+y2-y1 <= h ) {\n\t\t\tans= th-y1;\n\n\t\t\tans = Math.min(ans, th-( h-y2 ) );\n\t\t}\n\n\t\tif( x1>=tw || w-x2 >= tw) {\n\t\t\tans=0;\n\t\t}else if( tw+ x2-x1 <= w ) {\n\t\t\tans=Math.min(ans, tw-x1 );\n\n\t\t\tans= Math.min(ans, tw-(w-x2) );\n\t\t}\n\n\t\tif(ans== Integer.MAX_VALUE ) {\n\t\t\tSystem.out.println(-1);\n\t\t}else if( ans<0 ) {\n\t\t\tSystem.out.println(0);\n\t\t}else\n\t\t\tSystem.out.println(ans);\n\n\n\t\t\/*int col=fs.nextInt();\n\n\t\tint in[][]=new int[2][col];\n\t\tfor(int i=0;i<col;i++) {\n\t\t\tin[0][i]=fs.nextInt();\n\t\t}\n\t\tfor(int i=0;i<col;i++) {\n\t\t\tin[1][i]=fs.nextInt();\n\t\t}\n\n\t\tint leftSum[][]=new int[2][col];\n\t\tleftSum[0][0]=in[0][0];\n\t\tleftSum[1][0]=in[1][0];\n\n\t\tfor(int i=1;i<col;i++) {\n\t\t\tleftSum[0][i]=in[0][i]+leftSum[0][i-1];\n\t\t\tleftSum[1][i]=in[1][i]+leftSum[1][i-1];\n\t\t}\n\n\n\t\tint rightSum[][]=new int[2][col];\n\t\trightSum[0][col-1]=in[0][col-1];\n\t\trightSum[1][col-1]=in[1][col-1];\n\n\t\tfor(int i=col-2;i>=0;i--) {\n\t\t\trightSum[0][i]=rightSum[0][i+1] + in[0][i];\n\t\t\trightSum[1][i]=rightSum[1][i+1] + in[1][i];\n\t\t}\n\n\n\t\tint minScore=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<col;i++) {\n\t\t\tint score1= ( i+1<col ) ? rightSum[0][i+1] : 0;\n\t\t\tint score2= (i-1>=0) ? leftSum[1][i-1] : 0;\n\t\t\tminScore= Math.min(minScore, Math.max(score1, score2));\n\t\t}\n\n\t\tSystem.out.println(minScore);\n\n\t\t\/*int n=fs.nextInt();\n\t\tlong input[]=new long[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tinput[i]=fs.nextLong();\n\t\t}\n\n\n\t\tint even=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif( (input[i]&1) ==0 ) {\n\t\t\t\teven++;\n\t\t\t}\n\t\t}\n\t\tint odd=n-even;\n\t\tif( Math.abs(odd-even) > 1 ) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn ;\n\t\t}\n\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tinput[i]= ( (input[i]&1)==1 )?1 :0;\n\t\t}\n\n\t\tint ans=Integer.MAX_VALUE;\n\t\tif( (n&1)==0 ) {\n\t\t\tint output[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\toutput[i] = ( i&1 )==1 ? 1:0;\n\t\t\t}\n\n\t\t\tArrayList<Integer> oddpos=new ArrayList<Integer>();\n\t\t\tArrayList<Integer> evenpos=new ArrayList<Integer>();\n\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif( input[i] != output[i] ) {\n\t\t\t\t\tif( (i&1)==1 ) oddpos.add(i); \n\t\t\t\t\telse evenpos.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint smallAns=0;\n\t\t\tfor(int i=0;i<oddpos.size();i++) {\n\t\t\t\tsmallAns+= Math.abs(oddpos.get(i)-evenpos.get(i));\n\t\t\t}\n\n\t\t\tans=Math.min(ans, smallAns);\n\n\t\t\toutput=new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\toutput[i] = ( i&1 )==0 ? 1:0;\n\t\t\t}\n\n\t\t\toddpos=new ArrayList<Integer>();\n\t\t\tevenpos=new ArrayList<Integer>();\n\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif( input[i] != output[i] ) {\n\t\t\t\t\tif( (i&1)==1 ) oddpos.add(i); \n\t\t\t\t\telse evenpos.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsmallAns=0;\n\t\t\tfor(int i=0;i<oddpos.size();i++) {\n\t\t\t\tsmallAns+= Math.abs(oddpos.get(i)-evenpos.get(i));\n\t\t\t}\n\n\t\t\tans=Math.min(ans, smallAns);\n\t\t}else if( odd> even ) {\n\t\t\tint output[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\toutput[i] = ( i&1 )==0 ? 1:0;\n\t\t\t}\n\n\t\t\tArrayList<Integer> oddpos=new ArrayList<Integer>();\n\t\t\tArrayList<Integer> evenpos=new ArrayList<Integer>();\n\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif( input[i] != output[i] ) {\n\t\t\t\t\tif( (i&1)==1 ) oddpos.add(i); \n\t\t\t\t\telse evenpos.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint smallAns=0;\n\t\t\tfor(int i=0;i<oddpos.size();i++) {\n\t\t\t\tsmallAns+= Math.abs(oddpos.get(i)-evenpos.get(i));\n\t\t\t}\n\n\t\t\tans=Math.min(ans, smallAns);\n\t\t}else {\n\t\t\tint output[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\toutput[i] = ( i&1 )==1 ? 1:0;\n\t\t\t}\n\n\t\t\tArrayList<Integer> oddpos=new ArrayList<Integer>();\n\t\t\tArrayList<Integer> evenpos=new ArrayList<Integer>();\n\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif( input[i] != output[i] ) {\n\t\t\t\t\tif( (i&1)==1 ) oddpos.add(i); \n\t\t\t\t\telse evenpos.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint smallAns=0;\n\t\t\tfor(int i=0;i<oddpos.size();i++) {\n\t\t\t\tsmallAns+= Math.abs(oddpos.get(i)-evenpos.get(i));\n\t\t\t}\n\n\t\t\tans=Math.min(ans, smallAns);\n\t\t}\n\n\n\t\tSystem.out.println(ans);\n\n\t\t\/*\n\t\tint len=fs.nextInt();\n\t\tString row1=fs.next();\n\t\tString row2=fs.next();\n\n\t\tint prev=-1;\n\t\tint count=0;\n\n\t\tfor(int i=0;i<len; i++) {\n\t\t\tif( row1.charAt(i) != row2.charAt(i) ) {\n\t\t\t\tcount+=2;\n\t\t\t\tprev=-1;\n\t\t\t}else if ( row1.charAt(i)=='1') {\n\t\t\t\tif(prev==0) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tprev=-1;\n\t\t\t\t}else {\n\t\t\t\t\tprev=1;\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tif(prev==1) {\n\t\t\t\t\tcount+=2;\n\t\t\t\t\tprev=-1;\n\t\t\t\t}else {\n\t\t\t\t\tcount++;\n\t\t\t\t\tprev=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(count);\n\n\t\t\/*int a=fs.nextInt();\n\t\tint b=fs.nextInt();\n\t\tint c=fs.nextInt();\n\t\tint m=fs.nextInt();\n\n\t\tint max=a+b+c-3;\n\n\t\tint arr[]= {a,b,c};\n\t\tArrays.parallelSort(arr);\n\n\t\tint min=arr[2]-arr[1]-arr[0]-1;\n\t\tif(m>=min && m<=max) {\n\t\t\tSystem.out.println(\"YES\");\n\t\t}else {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t\t *\/\n\t\t\/*\n\t\tint n=fs.nextInt();\n\t\tlong hero[]=new long[n];\n\t\tlong sum=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\thero[i]=Long.parseLong(fs.next());\n\t\t\tsum+=hero[i];\n\t\t}\n\t\t\/\/System.out.println(sum);\n\t\tArrays.sort(hero);\n\t\t\/\/for(long x: hero)\n\t\t\t\/\/System.out.print(x+\" \");\n\t\t\/\/System.out.println();\n\t\tint m=fs.nextInt();\n\t\twhile(m-->0) {\n\n\t\t\tlong df=Long.parseLong(fs.next());\n\t\t\tlong at=Long.parseLong(fs.next());\n\n\n\n\t\t\tlong nextGrt=(long)Math.pow(10, 18);\n\t\t\tlong nextSmall=-1;\n\t\t\tint index=uperBound(hero, df);\n\t\t\t\/\/System.out.println(hero[index]);\n\t\t\t\/\/System.out.println(index);\n\t\t\tif(index>=n) {\n\t\t\t\tnextSmall=hero[n-1];\n\t\t\t}else if(index<=0 ) {\n\t\t\t\tnextGrt=hero[0];\n\t\t\t}else {\n\t\t\t\tnextGrt=hero[index];\n\t\t\t\tnextSmall=hero[index-1];\n\t\t\t}\n\n\t\t\t\/*for(int i=0;i<n;i++) {\n\t\t\t\tif(hero[i]>=df &&  hero[i]<nextGrt  ) {\n\t\t\t\t\tnextGrt=hero[i];\n\t\t\t\t}\n\t\t\t\tif(hero[i]<=df && hero[i]>nextSmall ) {\n\t\t\t\t\tnextSmall=hero[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/\/System.out.println(nextGrt +\" : \"+nextSmall);\n\n\t\t\tif( nextGrt!= (long) Math.pow(10, 18) && sum-nextGrt >=at ) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}else {\n\t\t\t\tif(nextGrt==(long)Math.pow(10, 18)) {\n\n\t\t\t\t\tlong ans= df- nextSmall;\n\t\t\t\t\tans+= ( at<= ( sum-nextSmall ) ) ? 0 : (at- sum+nextSmall);\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t}\n\t\t\t\telse if(nextSmall==-1) {\n\t\t\t\t\tlong ans= ( at <= sum- nextGrt ) ? 0 : ( at- sum+nextGrt);\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t}else {\n\t\t\t\t\tlong ans1=df- nextSmall;\n\t\t\t\t\tans1+= ( at<= ( sum-nextSmall ) ) ? 0 : (at- sum+nextSmall);\n\n\t\t\t\t\tlong ans2= ( at <= sum- nextGrt ) ? 0 : ( at- sum+nextGrt);\n\n\t\t\t\t\tSystem.out.println(Math.min(ans1, ans2));\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t}\n\n\n\t\t\/*int n=fs.nextInt();\n\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tString open=\"\";\n\t\t\tString close=\"\";\n\t\t\tfor(int j=1;j<=i;j++) {\n\t\t\t\topen+=\"(\";\n\t\t\t\tclose+=\")\";\n\t\t\t}\n\n\t\t\tint j=0;\n\t\t\twhile( j+2*i <= 2* n) {\n\t\t\t\tSystem.out.print(open);\n\t\t\t\tSystem.out.print(close);\n\t\t\t\tj=j+2*i;\n\t\t\t}\n\t\t\t\/\/System.out.println(j);\n\t\t\tif(j<2*n) {\n\t\t\t\twhile(j<2*n) {\n\t\t\t\t\tSystem.out.print(\"(\");\n\t\t\t\t\tSystem.out.print(\")\");\n\t\t\t\t\tj+=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\t *\/\n\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tint tcr=1; \n\t\t\/\/tcr = sc.nextInt();\n\t\t\/\/tcr=fs.nextInt();\n\n\t\twhile(tcr-->0) {\n\t\t\tsolve(tcr);\n\n\t\t}\n\n\t\tSystem.gc();\n\n\t}\n\n\n\tstatic int computeXOR(int n)\n\t{\n\t\t\/\/ If n is a multiple of 4\n\t\tif (n % 4 == 0)\n\t\t\treturn n;\n\n\t\t\/\/ If n%4 gives remainder 1\n\t\tif (n % 4 == 1)\n\t\t\treturn 1;\n\n\t\t\/\/ If n%4 gives remainder 2\n\t\tif (n % 4 == 2)\n\t\t\treturn n + 1;\n\n\t\t\/\/ If n%4 gives remainder 3\n\t\treturn 0;\n\t}\n\n\tstatic boolean isSorted (int[] nums) {\n\n\t\tfor (int i = 0; i < nums.length - 1; i++) {\n\n\t\t\tif (nums[i] > nums[i + 1]) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tstatic void firstOperation (int[] nums) {\n\n\t\tfor (int i = 1; i < nums.length; i += 2) {\n\n\t\t\tint temp = nums[i];\n\t\t\tnums[i] = nums[i - 1];\n\t\t\tnums[i - 1] = temp;\n\n\t\t}\n\n\t}\n\n\tstatic void secondOperation (int[] nums) {\n\n\t\tint n = nums.length \/ 2;\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tint temp = nums[i];\n\t\t\tnums[i] = nums[i + n];\n\t\t\tnums[i + n] = temp;\n\n\t\t}\n\n\t}\n\n\n\tprivate static long numOfDigits(long a) {\n\t\tlong ans=0;\n\t\twhile(a!=0) {\n\t\t\tans++;\n\t\t\ta\/=10;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tprivate static String reverse(String s) {\n\t\tString ans=\"\";\n\t\tfor(int i=s.length()-1;i>=0;i--) {\n\t\t\tans+=s.charAt(i);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tprivate static boolean isPalindrome(String s) {\n\t\tint i=0;\n\t\tint j=s.length()-1;\n\n\t\twhile(i<j) {\n\t\t\tif(s.charAt(i)!=s.charAt(j)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic class FastScanner {\n\n\t\tBufferedReader br;\n\t\tStringTokenizer st ;\n\n\t\tFastScanner(){\n\t\t\tbr =  new BufferedReader(new InputStreamReader(System.in));\n\t\t\tst = new StringTokenizer(\"\");\n\t\t}\n\n\t\tFastScanner(String file) {\n\n\t\t\ttry {\n\t\t\t\tbr =  new BufferedReader(new InputStreamReader(new FileInputStream(file)));\n\t\t\t\tst = new StringTokenizer(\"\");\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\t\tSystem.out.println(\"file not found\");\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t}\n\n\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tString readLine() throws IOException{\n\t\t\treturn br.readLine();\n\t\t}\n\t}\n\n\tpublic static long[] sort(long arr[]){\n\t\tList<Long> list = new ArrayList<>();\n\t\tfor(long n : arr){list.add(n);}\n\t\tCollections.sort(list);\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tarr[i] = list.get(i);\n\t\t}\n\t\treturn arr;\n\t}\n\tpublic static int[] sort(int arr[]){\n\t\tList<Integer> list = new ArrayList<>();\n\t\tfor(int n : arr){list.add(n);}\n\t\tCollections.sort(list);\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tarr[i] = list.get(i);\n\t\t}\n\t\treturn arr;\n\t}\n\n\t\/\/ return the (index + 1)\n\t\/\/ where index is the pos of just smaller element\n\t\/\/ i.e count of elemets strictly less than num\n\tpublic static int justSmaller(long arr[],long num){\n\t\t\/\/  System.out.println(num+\"@\");\n\t\tint st = 0;\n\t\tint e = arr.length - 1;\n\n\t\tint ans = -1;\n\n\t\twhile(st <= e){\n\n\t\t\tint mid = (st + e)\/2;\n\n\t\t\tif(arr[mid] >= num){\n\t\t\t\te = mid - 1;\n\t\t\t}else{\n\t\t\t\tans = mid;\n\t\t\t\tst = mid + 1;\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn ans + 1;\n\n\t}\n\n\t\/\/return (index of just greater element)\n\t\/\/count of elements smaller than or equal to num\n\n\tpublic static int justGreater(long arr[],long num){\n\t\tint st = 0;\n\t\tint e = arr.length - 1;\n\n\t\tint ans = arr.length;\n\n\t\twhile(st <= e){\n\n\t\t\tint mid = (st + e)\/2;\n\n\t\t\tif(arr[mid] <= num){\n\t\t\t\tst = mid + 1;\n\t\t\t}else{\n\t\t\t\tans = mid;\n\t\t\t\te = mid - 1;\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\n\t}\n\n\n\tpublic static boolean isPrime(int n) {\n\n\t\tfor(int i=2;i<n;i++) {\n\t\t\tif(n%i==0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void println(Object obj){\n\t\tSystem.out.println(obj.toString());\n\t}\n\n\tpublic static void print(Object obj){\n\t\tSystem.out.println(obj.toString());\n\t}\n\n\tpublic static long gcd(long a,long b){\n\t\tif(b == 0l){\n\t\t\treturn a;\n\t\t}\n\n\t\treturn gcd(b,a%b);\n\t}\n\n\tpublic static int find(int parent[],int v){\n\t\tif(parent[v] == v){\n\t\t\treturn v;\n\t\t}\n\n\t\treturn parent[v] = find(parent, parent[v]);\n\t}\n\n\n\n\tpublic static List<Integer> sieve(){\n\n\t\tList<Integer> prime = new ArrayList<>();\n\n\t\tint arr[] = new int[100001];\n\n\t\tArrays.fill(arr,1);\n\n\t\tarr[1] = 0;\n\t\tarr[2] = 1;\n\n\t\tfor(int i=2;i<=100000;i++){\n\n\t\t\tif(arr[i] == 1){\n\n\t\t\t\tprime.add(i);\n\n\t\t\t\tfor(long j = (i*1l*i);j<100001;j+=i){\n\t\t\t\t\tarr[(int)j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\tstatic boolean isPower(long n,long a){\n\n\t\tlong log = (long)(Math.log(n)\/Math.log(a));\n\n\t\tlong power = (long)Math.pow(a,log);\n\n\t\tif(power == n){return true;}\n\n\t\treturn false;\n\t}\n\n\n\tprivate static int mergeAndCount(int[] arr, int l,int m, int r)\n\t{\n\n\t\t\/\/ Left subarray\n\t\tint[] left =  Arrays.copyOfRange(arr, l, m + 1);\n\n\t\t\/\/ Right subarray\n\t\tint[] right = Arrays.copyOfRange(arr, m + 1, r + 1);\n\n\t\tint i = 0, j = 0, k = l, swaps = 0;\n\n\t\twhile (i < left.length && j < right.length) {\n\t\t\tif (left[i] <= right[j])\n\t\t\t\tarr[k++] = left[i++];\n\t\t\telse {\n\t\t\t\tarr[k++] = right[j++];\n\t\t\t\tswaps += (m + 1) - (l + i);\n\t\t\t}\n\t\t}\n\t\twhile (i < left.length)\n\t\t\tarr[k++] = left[i++];\n\t\twhile (j < right.length)\n\t\t\tarr[k++] = right[j++];\n\t\treturn swaps;\n\t}\n\n\t\/\/ Merge sort function\n\tprivate static int mergeSortAndCount(int[] arr, int l,int r)\n\t{\n\n\t\t\/\/ Keeps track of the inversion count at a\n\t\t\/\/ particular node of the recursion tree\n\t\tint count = 0;\n\n\t\tif (l < r) {\n\t\t\tint m = (l + r) \/ 2;\n\n\t\t\t\/\/ Total inversion count = left subarray count\n\t\t\t\/\/ + right subarray count + merge count\n\n\t\t\t\/\/ Left subarray count\n\t\t\tcount += mergeSortAndCount(arr, l, m);\n\n\t\t\t\/\/ Right subarray count\n\t\t\tcount += mergeSortAndCount(arr, m + 1, r);\n\n\t\t\t\/\/ Merge count\n\t\t\tcount += mergeAndCount(arr, l, m, r);\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tstatic class Debug {\n\t\t\/\/change to System.getProperty(\"ONLINE_JUDGE\")==null; for CodeForces\n\t\tpublic static final boolean LOCAL = System.getProperty(\"ONLINE_JUDGE\")==null;\n\t\tprivate static <T> String ts(T t) {\n\t\t\tif(t==null) {\n\t\t\t\treturn \"null\";\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn ts((Iterable) t);\n\t\t\t}catch(ClassCastException e) {\n\t\t\t\tif(t instanceof int[]) {\n\t\t\t\t\tString s = Arrays.toString((int[]) t);\n\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n\t\t\t\t}else if(t instanceof long[]) {\n\t\t\t\t\tString s = Arrays.toString((long[]) t);\n\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n\t\t\t\t}else if(t instanceof char[]) {\n\t\t\t\t\tString s = Arrays.toString((char[]) t);\n\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n\t\t\t\t}else if(t instanceof double[]) {\n\t\t\t\t\tString s = Arrays.toString((double[]) t);\n\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n\t\t\t\t}else if(t instanceof boolean[]) {\n\t\t\t\t\tString s = Arrays.toString((boolean[]) t);\n\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\treturn ts((Object[]) t);\n\t\t\t\t}catch(ClassCastException e1) {\n\t\t\t\t\treturn t.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate static <T> String ts(T[] arr) {\n\t\t\tStringBuilder ret = new StringBuilder();\n\t\t\tret.append(\"{\");\n\t\t\tboolean first = true;\n\t\t\tfor(T t: arr) {\n\t\t\t\tif(!first) {\n\t\t\t\t\tret.append(\", \");\n\t\t\t\t}\n\t\t\t\tfirst = false;\n\t\t\t\tret.append(ts(t));\n\t\t\t}\n\t\t\tret.append(\"}\");\n\t\t\treturn ret.toString();\n\t\t}\n\t\tprivate static <T> String ts(Iterable<T> iter) {\n\t\t\tStringBuilder ret = new StringBuilder();\n\t\t\tret.append(\"{\");\n\t\t\tboolean first = true;\n\t\t\tfor(T t: iter) {\n\t\t\t\tif(!first) {\n\t\t\t\t\tret.append(\", \");\n\t\t\t\t}\n\t\t\t\tfirst = false;\n\t\t\t\tret.append(ts(t));\n\t\t\t}\n\t\t\tret.append(\"}\");\n\t\t\treturn ret.toString();\n\t\t}\n\t\tpublic static void dbg(Object... o) throws Exception {\n\t\t\tif(LOCAL) {\n\t\t\t\tPrintStream ps = new PrintStream(\"src\/Debug.txt\");\n\t\t\t\tSystem.setErr(ps);\n\t\t\t\tSystem.err.print(\"Line #\"+Thread.currentThread().getStackTrace()[2].getLineNumber()+\": [\");\n\t\t\t\tfor(int i = 0; i<o.length; i++) {\n\t\t\t\t\tif(i!=0) {\n\t\t\t\t\t\tSystem.err.print(\", \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.err.print(ts(o[i]));\n\t\t\t\t}\n\t\t\t\tSystem.err.println(\"]\");\n\t\t\t}\n\t\t}\n\t}\n\n}","#include <bits\/stdc++.h>\nusing namespace std;\nconst int MAX = 1e6;\nstring arr[MAX + 1];\nint n, m;\nbool compare(int i, int j) {\n  for (int z = 0; z < m; z++) {\n    if (arr[i][z] != arr[j][z]) {\n      if (z % 2 == 0) {\n        return arr[i][z] < arr[j][z];\n      } else\n        return arr[i][z] > arr[j][z];\n    }\n  }\n}\nvoid solve() {\n  cin >> n >> m;\n  for (int j = 1; j <= n; j++) cin >> arr[j];\n  vector<int> v(n + 1);\n  for (int j = 1; j <= n; j++) v[j] = j;\n  sort(v.begin(), v.end(), compare);\n  for (int j = 1; j <= n; j++) cout << v[j] << ' ';\n  cout << '\\n';\n  return;\n}\nint main() {\n  int t;\n  t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid read(T &x) {\n  cin >> x;\n}\ntemplate <typename T, typename T0>\nvoid read(T &x, T0 &y) {\n  cin >> x >> y;\n}\ntemplate <typename T, typename T0, typename T1>\nvoid read(T &x, T0 &y, T1 &z) {\n  cin >> x >> y >> z;\n}\ntemplate <typename T, typename T0, typename T1, typename T2>\nvoid read(T &x, T0 &y, T1 &z, T2 &w) {\n  cin >> x >> y >> z >> w;\n}\ntemplate <typename T, typename T0>\nvoid read(pair<T, T0> &p) {\n  cin >> p.first >> p.second;\n}\ntemplate <typename T>\nvoid read(vector<T> &oneD, long long int n) {\n  for (long long int(i) = 0; (i) < (n); ++(i)) {\n    long long int x;\n    read(x);\n    oneD.push_back(x);\n  }\n}\ntemplate <typename T>\nvoid read(T oneD[], long long int n) {\n  for (long long int i = 0; i < n; i++) {\n    read(oneD[i]);\n  }\n}\ntemplate <typename T>\nvoid write(T &x) {\n  cout << x << \" \";\n}\ntemplate <typename T>\nvoid wrtline(T &x) {\n  cout << x << \"\\n\";\n}\ntemplate <typename T, typename T0>\nvoid write(T &x, T0 &y) {\n  cout << x << \" \" << y << \"\\n\";\n}\ntemplate <typename T, typename T0, typename T1>\nvoid write(T &x, T0 &y, T1 &z) {\n  cout << x << \" \" << y << \" \" << z << \"\\n\";\n}\ntemplate <typename T, typename T0, typename T1, typename T2>\nvoid write(T &x, T0 &y, T1 &z, T2 &w) {\n  cout << x << \" \" << y << \" \" << z << \" \" << w << \"\\n\";\n}\ntemplate <typename T, typename T0>\nvoid write(pair<T, T0> &p) {\n  write(p.first);\n  write(p.second);\n  cout << \"\\n\";\n}\ntemplate <typename T>\nvoid write(vector<T> &oneD, long long int n) {\n  for (long long int i = 0; i < n; i++) {\n    cout << oneD[i] << \" \";\n  }\n  cout << \"\\n\";\n}\ntemplate <typename T>\nvoid write(T oneD[], int &n) {\n  for (long long int i = 0; i < n; i++) {\n    write(oneD[i]);\n  }\n  cout << \"\\n\";\n}\ntemplate <typename T, typename T0>\nvoid write(map<T, T0> &mpp) {\n  for (auto it : mpp) {\n    write(it.first);\n    cout << \": \";\n    write(it.second);\n    cout << \"\\n\";\n  }\n  cout << \"\\n\";\n}\ntemplate <typename T>\nvoid write(vector<vector<T>> &rc, T &n, T &m) {\n  for (long long int(i) = 0; (i) < (n); ++(i)) {\n    for (long long int(j) = 0; (j) < (m); ++(j)) {\n      cout << rc[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\ntemplate <typename T>\nvoid _print(T &t) {\n  cerr << t;\n}\ntemplate <class T, class V>\nvoid _print(pair<T, V> &p);\ntemplate <class T>\nvoid _print(vector<T> &v);\ntemplate <class T>\nvoid _print(set<T> &v);\ntemplate <class T, class V>\nvoid _print(map<T, V> &v);\ntemplate <class T>\nvoid _print(multiset<T> &v);\ntemplate <class T, class V>\nvoid _print(pair<T, V> &p) {\n  cerr << \"{\";\n  _print(p.first);\n  cerr << \",\";\n  _print(p.second);\n  cerr << \"}\";\n}\ntemplate <class T>\nvoid _print(vector<T> &v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T>\nvoid _print(set<T> &v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T>\nvoid _print(multiset<T> &v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T, class V>\nvoid _print(map<T, V> &v) {\n  cerr << \"[ \";\n  for (auto i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\nvoid solve() {\n  long long int n, m;\n  read(n, m);\n  vector<pair<string, long long int>> s;\n  for (long long int(i) = 0; (i) < (n); ++(i)) {\n    string t;\n    read(t);\n    s.push_back({t, i + 1});\n  }\n  string alphabets = \"\";\n  for (long long int(i) = 0; (i) < (26); ++(i)) alphabets += 'A' + i;\n  reverse((alphabets).begin(), (alphabets).end());\n  for (long long int i = 1; i < m; i += 2) {\n    for (long long int(j) = 0; (j) < (n); ++(j)) {\n      s[j].first[i] = alphabets[s[j].first[i] - 'A'];\n    }\n  }\n  sort((s).begin(), (s).end());\n  for (long long int(i) = 0; (i) < (n); ++(i)) cout << s[i].second << \" \";\n  cout << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  solve();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long N = 5e5 + 5, MOD = 1e9 + 7, INF = LONG_MAX;\nint dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\nlong long n, m, a[N], sz = 1, lazy[N * 4];\nbool cmp(string a, string b) {\n  for (int i = 0; i < m; ++i) {\n    if (i % 2 == 0 && a[i] != b[i])\n      return (a[i] < b[i]);\n    else if (i & 1 && a[i] != b[i])\n      return (a[i] > b[i]);\n  }\n  return 1;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  map<string, deque<int>> mp;\n  cin >> n >> m;\n  vector<string> v;\n  for (int i = 0; i < n; ++i) {\n    string s;\n    cin >> s;\n    v.push_back(s);\n    mp[s].push_back(i + 1);\n  }\n  sort(v.begin(), v.end(), cmp);\n  for (auto it : v) {\n    cout << mp[it][0] << ' ';\n    mp[it].pop_front();\n  }\n}\n","import sys\n\npl=1\nsys.setrecursionlimit(10**5)\nif pl:\n\tinput=sys.stdin.readline\nelse:\t\n\tsys.stdin=open('input.txt', 'r')\n\tsys.stdout=open('outpt.txt','w')\n\ndef li():\n\treturn [int(xxx) for xxx in input().split()]\ndef fi():\n\treturn int(input())\ndef si():\n\treturn list(input().rstrip())\t\ndef mi():\n\treturn \tmap(int,input().split())\t\ndef ff():\n\tsys.stdout.flush()\ndef google(tc,*ans):\n\tprint(\"Case #\"+str(tc)+\":\",*ans)\t\ndef bits(i,n):\n\tp=bin(i)[2:]\n\treturn (n-len(p))*\"0\"+p\t\t\t\n\nt=1\nf=t\t\nmod=10**9+7\t\n\n\nwhile t:\n\tt-=1\n\tn,m=mi()\n\ta=[]\n\tfor i in range(n):\n\t\ts=si()\n\t\tp=\"\"\n\t\tfor j in range(m):\n\t\t\tif j%2==0:\n\t\t\t\tp+=s[j]\n\t\t\telse:\n\t\t\t\tw=ord(s[j])-ord('a')\n\t\t\t\tp+=chr(ord('a')+25-w)\n\t\ta.append([p,i+1])\n\ta.sort()\n\tfor i in a:\n\t\tprint(i[1],end=\" \")\t\t\t\t\t\t\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<string> arr(n);\n  unordered_map<string, int> map;\n  for (int i{0}; i < n; i++) {\n    cin >> arr[i];\n    map[arr[i]] = i;\n  }\n  auto cmp{[](string &s1, string &s2) {\n    for (int i{0}; i < s1.length(); i++)\n      if (s1[i] != s2[i]) {\n        if (i % 2 != 0)\n          return s1[i] > s2[i];\n        else\n          return s1[i] < s2[i];\n      }\n    return s1 == s2;\n  }};\n  sort(arr.begin(), arr.end(), cmp);\n  for (auto &s : arr) cout << map[s] + 1 << ' ';\n}\nint main() {\n  solve();\n  cout << '\\n';\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> v;\n  for (int i = 0; i < n; ++i) {\n    string s, temp1 = \"\", temp2 = \"\";\n    cin >> s;\n    for (int j = 0; j < m; ++j) {\n      if (j % 2 == 0)\n        continue;\n      else {\n        int ind = s[j] - 'A';\n        s[j] = char((26 - ind) + 'A');\n      }\n    }\n    v.push_back({s, i + 1});\n  }\n  sort(v.begin(), v.end());\n  for (int i = 0; i < n; ++i) {\n    cout << v[i].second << ' ';\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nlong long expo(long long x, long long y, long long m) {\n  long long r = 1;\n  while (y) {\n    if (y % 2) r = (r * x) % m;\n    y \/= 2;\n    x = (x * x) % m;\n  }\n  return r;\n}\nvoid extendgcd(long long a, long long b, long long* v) {\n  if (b == 0) {\n    v[0] = 1;\n    v[1] = 0;\n    v[2] = a;\n    return;\n  }\n  extendgcd(b, a % b, v);\n  long long x = v[1];\n  v[1] = v[0] - v[1] * (a \/ b);\n  v[0] = x;\n  return;\n}\nlong long mminv(long long a, long long b) {\n  long long arr[3];\n  extendgcd(a, b, arr);\n  return arr[0];\n}\nlong long mminvprime(long long a, long long b) { return expo(a, b - 2, b); }\nvoid precision(int a) { cout << setprecision(a) << fixed; }\nlong long i, j;\nvoid solve() {\n  long long n, m;\n  cin >> n >> m;\n  vector<pair<string, long long>> s;\n  for (i = 0; i < n; i++) {\n    string t;\n    cin >> t;\n    s.push_back({t, i});\n  }\n  for (i = 1; i < m; i += 2) {\n    for (j = 0; j < n; j++) {\n      s[j].first[i] = 'A' + ('Z' - s[j].first[i]);\n    }\n  }\n  sort(s.begin(), s.end());\n  for (i = 0; i < n; i++) cout << s[i].second + 1 << \" \";\n  cout << endl;\n}\nint main() {\n  solve();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int MOD = 1000 * 1000 * 1000 + 7;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return (a * b) \/ gcd(a, b); }\nbool sortinrev(long long x, long long y) { return x > y; }\nvoid solve() {\n  long long n, m;\n  cin >> n >> m;\n  vector<string> v(n);\n  map<string, long long> mp;\n  for (long long i = 0; i < n; i++) {\n    cin >> v[i];\n    for (long long j = 0; j < m; j++) {\n      if (j & 1) {\n        v[i][j] = 'Z' - v[i][j] + 'A';\n      }\n    }\n    mp[v[i]] = i + 1;\n  }\n  sort((v).begin(), (v).end());\n  for (auto x : v) cout << mp[x] << \" \";\n  cout << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint mod = 1e9 + 7;\nconst long long INF = 1e18 + 56;\nconst long long NINF = -1 * INF;\nvoid solve(int q) {\n  int n, m;\n  cin >> n >> m;\n  vector<string> arr(n);\n  map<string, int> mm;\n  for (int j = 0; j < n; j++) {\n    cin >> arr[j];\n    for (int i = 0; i < m; i++) {\n      if (i % 2) arr[j][i] = 65 + (90 - arr[j][i]);\n    }\n    mm[arr[j]] = j + 1;\n  }\n  sort(arr.begin(), arr.end());\n  for (int i = 0; i < n; i++) {\n    cout << mm[arr[i]] << \" \";\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(), cout.tie(0);\n  int t = 1;\n  for (int i = 1; i <= t; i++) solve(i);\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long N = 1e6 + 99;\nlong long n, m;\npair<string, long long> a[N];\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> m;\n  string s;\n  for (long long i = 0; i < n; i++) {\n    cin >> s;\n    for (long long j = 1; j < s.size(); j += 2) {\n      s[j] = 'Z' - (s[j] - 'A');\n    }\n    a[i] = {s, i + 1};\n  }\n  sort(a, a + n);\n  for (long long i = 0; i < n; i++) {\n    cout << a[i].second << \" \";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 3;\nconst int md = 1e9 + 7;\nconst int inf = 1e9 + 3;\nint n, m;\nstring a[N];\nint b[N];\nbool cmp(int x, int y) {\n  for (int i = 0; i < m; ++i) {\n    if (a[x][i] != a[y][i]) {\n      if (i & 1) {\n        return a[x][i] > a[y][i];\n      } else {\n        return a[x][i] < a[y][i];\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) cin >> a[i], b[i] = i;\n  sort(b + 1, b + n + 1, cmp);\n  for (int i = 1; i <= n; ++i) cout << b[i] << ' ';\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long n, m;\npair<string, long long> s[1000001];\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (long long i = 0; i < n; i++) {\n    cin >> s[i].first;\n    s[i].second = i + 1;\n    for (long long j = 1; j < m; j += 2)\n      s[i].first[j] = 'A' + 'Z' - s[i].first[j];\n  }\n  sort(s, s + n);\n  for (long long i = 0; i < n; i++) cout << s[i].second << ' ';\n  cout << endl;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int mod = (int)1e9 + 7;\nconst long long MOD = 972663749;\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  string second;\n  map<string, set<int>> make_pair;\n  vector<string> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> second;\n    a[i] = second;\n    make_pair[second].insert((i + 1));\n  }\n  sort(a.begin(), a.end());\n  for (int i = 1; i < m; ++i) {\n    if ((i + 1) & 1) {\n      int l = 0, r = 0;\n      string s1, s2;\n      for (int j = 1; j < n; ++j) {\n        s1 = a[j - 1].substr(0, (i)), s2 = a[j].substr(0, (i));\n        if (s1 == s2) {\n          r = j;\n        } else {\n          sort(a.begin() + l, a.begin() + r + 1);\n          l = j, r = j;\n        }\n      }\n      sort(a.begin() + l, a.begin() + r + 1);\n    } else {\n      int l = 0, r = 0;\n      string s1, s2;\n      for (int j = 1; j < n; ++j) {\n        s1 = a[j - 1].substr(0, (i)), s2 = a[j].substr(0, (i));\n        if (s1 == s2) {\n          r = j;\n        } else {\n          sort(a.begin() + l, a.begin() + r + 1, greater<string>());\n          l = j, r = j;\n        }\n      }\n      sort(a.begin() + l, a.begin() + r + 1, greater<string>());\n    }\n  }\n  vector<int> res;\n  for (int i = 0; i < n; ++i) {\n    auto it = --make_pair[a[i]].end();\n    res.push_back(*it);\n    make_pair[a[i]].erase(it);\n  }\n  for (auto &i : res) cout << i << \" \";\n}\nvoid huykhanh() {\n  int T;\n  T = 1;\n  while (T--) solve();\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  huykhanh();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nbool compare(std::string& a, std::string& b) {\n  for (int i = 0; i < a.size(); ++i) {\n    if (i % 2) {\n      if (std::tolower(a[i]) > std::tolower(b[i])) {\n        return true;\n      }\n      if (std::tolower(a[i]) < std::tolower(b[i])) {\n        return false;\n      }\n    } else {\n      if (std::tolower(a[i]) < std::tolower(b[i])) {\n        return true;\n      }\n      if (std::tolower(a[i]) > std::tolower(b[i])) {\n        return false;\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  int n, m;\n  std::cin >> n >> m;\n  std::vector<std::pair<std::string, int>> arr(n);\n  for (int i = 0; i < n; ++i) {\n    std::cin >> arr[i].first;\n    arr[i].second = i + 1;\n  }\n  std::sort(arr.begin(), arr.end(),\n            [](std::pair<std::string, int>& a, std::pair<std::string, int>& b) {\n              return compare(a.first, b.first);\n            });\n  for (std::pair<std::string, int>& a : arr) {\n    std::cout << a.second << '\\n';\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int i, n, m, j;\n  string s;\n  map<string, int> ma;\n  pair<string, int> p;\n  cin >> n >> m;\n  for (i = 0; i < n; i++) {\n    cin >> s;\n    for (j = 0; j < m; j++) {\n      if (j % 2 == 0) s[j] = 155 - s[j];\n    }\n    ma[s] = i + 1;\n  }\n  map<string, int>::iterator itr;\n  int arr[n];\n  i = 1;\n  for (itr = ma.begin(); itr != ma.end(); itr++) {\n    arr[n - i] = (*itr).second;\n    i++;\n  }\n  for (i = 0; i < n; i++) cout << arr[i] << \" \";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint p = 0;\nbool comp(string &x, string &y) { return x[p] > y[p]; }\nbool comp2(string &x, string &y) { return x[p] < y[p]; }\ntemplate <typename T>\nvoid printv(T &a) {\n  for (auto it = a.begin(); it != a.end(); ++it) cout << *it << ' ';\n  cout << '\\n';\n}\nvoid sol2() {\n  int n;\n  cin >> n;\n  int m;\n  cin >> m;\n  map<string, int> mp;\n  string s[n];\n  for (int i = 0; i < n; ++i) {\n    cin >> s[i];\n    for (int j = 1; j < m; j += 2) {\n      int t = s[i][j] - 'A';\n      t = 25 - t;\n      s[i][j] = 'A' + t;\n    }\n    mp[s[i]] = i + 1;\n  }\n  sort(s, s + n);\n  for (int i = 0; i < n; ++i) {\n    cout << mp[s[i]] << ' ';\n  }\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  sol2();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int64_t M = 1e9 + 7;\nconst int64_t INF = 1e6 + 100;\nconst int MAXN = 2e5 + 5;\nbool prime[INF];\nint64_t spf[INF];\nint64_t d[INF] = {};\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nint dx8[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nint dy8[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nstring ds = \"RLDU\";\nlong long C(int n, int m) {\n  if (m > n) return 0;\n  long long z = 1;\n  for (int i = 0; i < m; i++) z = z * (n - i) \/ (i + 1);\n  return z;\n}\nlong long int invmod(long long int i) {\n  if (i == 1) return 1;\n  return (1000000007 -\n          ((1000000007 \/ i) * invmod(1000000007 % i)) % 1000000007 +\n          1000000007) %\n         1000000007;\n}\nvoid sieve() {\n  spf[1] = 1;\n  for (int i = 2; i < INF; i++) spf[i] = i;\n  for (int i = 4; i < INF; i += 2) spf[i] = 2;\n  for (int i = 3; i * i < INF; i++) {\n    if (spf[i] == i) {\n      for (int j = i * i; j < INF; j += i)\n        if (spf[j] == j) spf[j] = i;\n    }\n  }\n}\nint64_t binpow(int64_t a, int64_t b) {\n  if (b == 0) return 1;\n  if (b == 1) return a;\n  int64_t temp = binpow(a, b \/ 2);\n  if (b % 2 == 0)\n    return (temp * temp);\n  else\n    return (((temp * temp)) * a);\n}\nint64_t tot(int64_t n) {\n  int64_t result = n;\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      while (n % i == 0) n \/= i;\n      result -= result \/ i;\n    }\n  }\n  if (n > 1) result -= result \/ n;\n  return result;\n}\nvoid phi_1_to_n(int n) {\n  vector<int> phi(n + 1);\n  phi[0] = 0;\n  phi[1] = 1;\n  for (int i = 2; i <= n; i++) phi[i] = i;\n  for (int i = 2; i <= n; i++) {\n    if (phi[i] == i) {\n      for (int j = i; j <= n; j += i) phi[j] -= phi[j] \/ i;\n    }\n  }\n}\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nbool is_prime(int64_t n) {\n  if (n == 1) return false;\n  int64_t i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      return false;\n    }\n    i += 1;\n  }\n  return true;\n}\nvoid SieveOfEratosthenes() {\n  memset(prime, 1, sizeof(prime));\n  prime[1] = 0;\n  prime[0] = 0;\n  for (int p = 2; p * p < INF; p++) {\n    if (prime[p] == true) {\n      for (int i = p * p; i < INF; i += p) {\n        prime[i] = false;\n      }\n    }\n  }\n}\nvoid div() {\n  for (int64_t i = 1; i < INF; i++) {\n    for (int64_t j = i; j < INF; j += i) {\n      d[j] += i;\n      d[j] = d[j] % M;\n    }\n  }\n}\nvector<pair<long long, long long>> factors;\nvector<pair<long long, long long>> factorize(long long N) {\n  factors.clear();\n  vector<pair<long long, long long>> res;\n  for (long long a = 2; a * a <= N; ++a) {\n    if (N % a != 0) continue;\n    long long ex = 0;\n    while (N % a == 0) {\n      ++ex;\n      N \/= a;\n    }\n    res.push_back({a, ex});\n  }\n  if (N != 1) res.push_back({N, 1});\n  factors = res;\n  return res;\n}\nvector<int64_t> divisors;\nvoid getDivisors(int64_t ind = 0, int64_t res = 1) {\n  if (ind == (int)factors.size()) {\n    divisors.push_back(res);\n    return;\n  }\n  for (int64_t i = 0; i <= factors[ind].second; i++) {\n    getDivisors(ind + 1, res);\n    res *= factors[ind].first;\n  }\n}\nbool isqr(int64_t n) {\n  int64_t val = sqrt(n);\n  return (val * val) == n;\n}\nlong long binpow(long long a, long long b, long long m) {\n  a %= m;\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a % m;\n    a = a * a % m;\n    b >>= 1;\n  }\n  return res;\n}\nbool cmp(string a, string b) {\n  int n = a.size();\n  for (int i = 0; i < n; i++) {\n    if ((i + 1) % 2 == 1) {\n      if (a[i] != b[i]) {\n        return b > a;\n      }\n    } else {\n      if (a[i] != b[i]) {\n        return a > b;\n      }\n    }\n  }\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  string s[n];\n  map<string, int> mpp;\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    mpp[s[i]] = i + 1;\n  }\n  sort(s, s + n, cmp);\n  for (int i = 0; i < n; i++) cout << mpp[s[i]] << \" \";\n  cout << endl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  { solve(); }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nifstream fi(\n    \"easy\"\n    \".inp\");\nofstream fo(\n    \"easy\"\n    \".out\");\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<string> s;\n  for (int i = 0; i < n; i++) {\n    string x;\n    cin >> x;\n    s.push_back(x);\n  }\n  vector<string> a(n);\n  for (int i = 0; i < n; i++) {\n    string tmp = \"\";\n    for (int j = 0; j < m; j++) {\n      tmp += (j & 1 ? ('Z' - s[i][j]) : (s[i][j] - 'A')) + 'A';\n    }\n    a[i] = tmp;\n  }\n  vector<pair<string, int>> mp;\n  for (int i = 0; i < n; i++) {\n    mp.push_back({a[i], i});\n  }\n  sort((mp).begin(), (mp).end());\n  for (int i = 0; i < n; i++) {\n    cout << mp[i].second + 1 << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nstruct sp {\n  string s1;\n  int id;\n};\nint n, m;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  sp s[n];\n  for (int k = 0; k < n; k++) {\n    string x = \"\";\n    for (int i = 0; i < m; i++) {\n      char c;\n      cin >> c;\n      if (i % 2 == 1) {\n        x += (char)('Z' + 'A' - c);\n      } else {\n        x += c;\n      }\n    }\n    s[k] = {x, k + 1};\n  }\n  sort(s, s + n, [](sp x, sp y) { return x.s1 < y.s1; });\n  for (int p = 0; p < n; p++) cout << s[p].id << \" \";\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\npair<string, int> str[1000005];\nbool cmp(const pair<string, int> &p, const pair<string, int> &q) {\n  for (int i = 0; i < p.first.size(); i++) {\n    if (p.first[i] != q.first[i]) {\n      if (i % 2 == 0)\n        return p.first[i] < q.first[i];\n      else\n        return p.first[i] > q.first[i];\n    }\n  }\n  return false;\n}\nvoid solve() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    char c[1000005];\n    scanf(\"%s\", c);\n    str[i] = make_pair(string(c), i);\n  }\n  sort(str, str + n, cmp);\n  for (int i = 0; i < n; i++) printf(\"%d \", str[i].second + 1);\n}\nint main() {\n  int t = 1;\n  for (int i = 1; i <= t; i++) {\n    solve();\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10, M = 510, mod = 998244353, Mod = 1e9 + 7;\nint n, m, k;\nvector<string> q;\nint cmp(string a, string b) {\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i]) continue;\n    if (i & 1) {\n      return a[i] > b[i];\n    } else {\n      return a[i] < b[i];\n    }\n  }\n}\nvoid solve() {\n  cin >> n >> m;\n  unordered_map<string, int> mp;\n  for (int i = 1; i <= n; i++) {\n    string x;\n    cin >> x;\n    mp[x] = i;\n    q.push_back(x);\n  }\n  sort(q.begin(), q.end(), cmp);\n  for (int i = 0; i < n; i++) cout << mp[q[i]] << \" \";\n  cout << endl;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  std::cout.tie(0);\n  int t, Case = 1;\n  { solve(); }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nsigned main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  long long n, m;\n  std::cin >> n >> m;\n  std::pair<std::string, long long> s[n];\n  for (long long i = 0; i < n; i++) {\n    std::cin >> s[i].first;\n    for (long long j = 1; j < m; j += 2) s[i].first[j] = 'Z' - s[i].first[j];\n    s[i].second = i + 1;\n  }\n  std::sort(s, s + n);\n  for (long long i = 0; i < n; i++) {\n    std::cout << s[i].second << \" \";\n  }\n  std::cout << std::endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int t = 1;\n  while (t--) {\n    int n, m;\n    cin >> n >> m;\n    vector<pair<string, int>> bk(n);\n    for (int i = 0; i < n; i++) {\n      bk[i].second = i + 1;\n      cin >> bk[i].first;\n    }\n    for (int j = 0; j < m; j++) {\n      if (((j + 1) & 1) == 0) {\n        for (int i = 0; i < n; i++) {\n          bk[i].first[j] = 200 - bk[i].first[j];\n        }\n      }\n    }\n    sort(bk.begin(), bk.end());\n    for (int i = 0; i < n; i++) {\n      cout << bk[i].second << \" \";\n    }\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid print(bool n) {\n  if (n)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n  cout << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n, m;\n  cin >> n >> m;\n  pair<string, long long> a[n];\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i].first;\n    for (long long j = 1; j < m; j += 2) a[i].first[j] = 256 - a[i].first[j];\n    a[i].second = i + 1;\n  }\n  sort(a, a + n);\n  for (long long i = 0; i < n; i++) cout << a[i].second << ' ';\n  return 0;\n}\n","\n\ndef to_tuple(s: str) -> tuple:\n    return tuple(ord(c) if i % 2 == 0 else -ord(c) for i, c in enumerate(s))\n\n\ndef main():\n    n, m = map(int, input().split())\n\n    for e in sorted([(to_tuple(input()), i) for i in range(1, n+1)]):\n        print(e[-1])\n\n\nif __name__ == \"__main__\":\n    main()\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool cmp(string x, string y) {\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == y[i]) continue;\n    if (i % 2)\n      return x[i] > y[i];\n    else\n      return x[i] < y[i];\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int a, b;\n  cin >> a >> b;\n  map<string, int> v;\n  vector<string> s;\n  for (int i = 1; i <= a; i++) {\n    string t;\n    cin >> t;\n    v[t] = i;\n    s.push_back(t);\n  }\n  sort(s.begin(), s.end(), cmp);\n  for (auto &it : s) cout << v[it] << \" \";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e6 + 15;\nconst long long oo = ((long long)1e18) + 7;\nint N, M, T, K, Q;\nstring A[MAXN];\nint B[MAXN];\nbool minimize(int &x, const int &y) {\n  if (x > y) {\n    x = y;\n    return 1;\n  }\n  return 0;\n}\nbool maximize(int &x, const int &y) {\n  if (x < y) {\n    x = y;\n    return 1;\n  }\n  return 0;\n}\nbool cmp(int x, int y) {\n  for (int i = 1; i <= A[x].size(); i++)\n    if (A[x][i - 1] != A[y][i - 1])\n      return (i & 1) ? A[x][i - 1] < A[y][i - 1] : A[x][i - 1] > A[y][i - 1];\n  return false;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  if (fopen(\"A\"\n            \".inp\",\n            \"r\")) {\n    freopen(\n        \"A\"\n        \".inp\",\n        \"r\", stdin);\n    freopen(\n        \"A\"\n        \".out\",\n        \"w\", stdout);\n  }\n  cin >> N >> M;\n  for (int i = 1; i <= N; i++) {\n    cin >> A[i];\n    B[i] = i;\n  }\n  sort(B + 1, B + N + 1, cmp);\n  for (int i = 1; i <= N; i++) cout << B[i] << ' ';\n}\n","def main():\n    \n    lista = []\n    line, lenght = input().split()\n    line = int(line)\n    lenght = int(lenght)\n    dicio: dict = {}\n    \n    for i in range(line):    \n        text = input()\n        dicio[text] = i+1\n        lista.append(text)\n    \n    for i in range (lenght - 1, -1 , -1):\n        \n        if (i + 1) % 2 != 0:\n            lista.sort(key=lambda x: x[i])\n        \n        else:\n            lista.sort(key=lambda x: x[i], reverse=True)\n    \n    for word in lista:\n        print(dicio[word], end=' ')\n    \nif __name__ == '__main__':\n    main()\n\t  \t     \t\t\t\t\t  \t\t \t\t\t    \t\t\t","#include <bits\/stdc++.h>\nusing namespace std;\nint mon[20] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nlong long gcd(long long x, long long y) {\n  return ((y == 0) ? x : gcd(y, x % y));\n}\ninline int read() {\n  int x = 0;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') ch = getchar();\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x;\n}\nconst int GJMAX = 1005;\nstruct Int {\n  int a[GJMAX];\n  int len;\n  Int(int k) { *this = k; }\n  Int() { *this = 0; }\n  void clean() {\n    while (len > 1 && !a[len - 1]) len--;\n  }\n  void operator=(int k) {\n    if (!k) {\n      len = 1;\n      a[0] = 0;\n      return;\n    }\n    len = 0;\n    while (k) a[len++] = k % 10, k \/= 10;\n  }\n  void operator=(string k) {\n    len = k.length();\n    for (int i = 0; i < len; i++) {\n      a[i] = k[len - i - 1] - '0';\n    }\n  }\n  Int operator+(Int &B) {\n    Int C;\n    C.len = len > B.len ? len : B.len;\n    for (int i = len; i < C.len; i++) a[i] = 0;\n    for (int i = B.len; i < C.len; i++) B.a[i] = 0;\n    int d = 0;\n    for (int i = 0; i < C.len; i++) {\n      C.a[i] = a[i] + B.a[i] + d;\n      d = C.a[i] \/ 10;\n      C.a[i] %= 10;\n    }\n    if (d) C.a[C.len++] = d;\n    return C;\n  }\n  Int operator+=(Int B) {\n    *this = *this + B;\n    return *this;\n  }\n  Int operator+(int &b) {\n    Int B = b;\n    return *this + B;\n  }\n  Int operator+(const int &b) {\n    Int B = b;\n    return *this + B;\n  }\n  Int operator-(Int &B) {\n    Int C;\n    C.len = len;\n    for (int i = B.len; i < C.len; i++) B.a[i] = 0;\n    int d = 0;\n    for (int i = 0; i < C.len; i++) {\n      C.a[i] = a[i] - B.a[i] - d;\n      d = 0;\n      while (C.a[i] < 0) d++, C.a[i] += 10;\n    }\n    while (C.len > 0 && !C.a[C.len - 1]) C.len--;\n    if (C.len == 0) C = 0;\n    return C;\n  }\n  Int operator-=(Int B) {\n    *this = *this - B;\n    return *this;\n  }\n  Int operator-(int &b) {\n    Int B = b;\n    return *this - B;\n  }\n  Int operator-(const int &b) {\n    Int B = b;\n    return *this - B;\n  }\n  Int operator*(Int &B) {\n    int i, j;\n    Int C;\n    C.len = len + B.len;\n    for (j = 0; j < B.len; j++)\n      for (i = 0; i < len; i++) C.a[i + j] += a[i] * B.a[j];\n    for (i = 0; i < C.len - 1; i++) C.a[i + 1] += C.a[i] \/ 10, C.a[i] %= 10;\n    C.clean();\n    return C;\n  }\n  Int operator*=(Int B) {\n    *this = *this * B;\n    return *this;\n  }\n  Int operator*(int &b) {\n    Int B = b;\n    return *this * B;\n  }\n  Int operator*(const int &b) {\n    Int B = b;\n    return *this * B;\n  }\n  Int operator*=(int b) {\n    *this = *this * b;\n    return *this;\n  }\n  Int operator\/(Int &b) {\n    int i, j;\n    Int c = *this, d = 0;\n    for (i = len - 1; i >= 0; i--) {\n      d = d * 10 + a[i];\n      for (j = 0; j < 10; j++)\n        if (d < b * (j + 1)) break;\n      c.a[i] = j;\n      d -= b * j;\n    }\n    c.clean();\n    return c;\n  }\n  Int operator\/(const int &b) {\n    Int B = b;\n    return *this \/ B;\n  }\n  Int operator\/=(Int B) {\n    *this = *this \/ B;\n    return *this;\n  }\n  Int operator\/(int &b) {\n    Int B = b;\n    return *this \/ B;\n  }\n  Int operator\/=(int b) {\n    *this = *this \/ b;\n    return *this;\n  }\n  Int operator%(Int &b) {\n    int i, j;\n    Int d = 0;\n    for (i = len - 1; i >= 0; i--) {\n      d = d * 10 + a[i];\n      for (j = 0; j < 10; j++)\n        if (d < b * (j + 1)) break;\n      d -= b * j;\n    }\n    return d;\n  }\n  Int operator%=(Int B) {\n    *this = *this % B;\n    return *this;\n  }\n  bool operator<=(Int B) {\n    if (len < B.len) return 1;\n    if (len > B.len) return 0;\n    for (int i = len - 1; i >= 0; i--) {\n      if (a[i] < B.a[i]) return 1;\n      if (a[i] > B.a[i]) return 0;\n    }\n    return 1;\n  }\n  bool operator<(Int B) {\n    if (len < B.len) return 1;\n    if (len > B.len) return 0;\n    for (int i = len - 1; i >= 0; i--) {\n      if (a[i] < B.a[i]) return 1;\n      if (a[i] > B.a[i]) return 0;\n    }\n    return 0;\n  }\n  bool operator>(Int B) { return !(*this <= B); }\n  bool operator>=(Int B) { return !(*this < B); }\n  bool operator==(Int B) { return *this <= B && *this >= B; }\n  bool operator!=(Int B) { return !(*this == B); }\n  bool zero() { return len == 1 && a[0] == 0; }\n  void printout() {\n    for (int i = len - 1; i >= 0; i--) printf(\"%d\", a[i]);\n  }\n  string str() const {\n    char s[GJMAX] = {};\n    for (int i = 0; i < len; i++) s[len - 1 - i] = a[i] + '0';\n    return s;\n  }\n};\nistream &operator>>(istream &in, Int &x) {\n  string s;\n  in >> s;\n  x = s.c_str();\n  return in;\n}\nostream &operator<<(ostream &out, const Int &x) {\n  out << x.str();\n  return out;\n}\nint n;\nint m;\nstring s[1000005];\nmap<string, int> mp;\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    for (int j = 1; j < s[i].size(); j += 2)\n      s[i][j] = 26 - (s[i][j] - 'A') + 'A';\n    mp[s[i]] = i + 1;\n  }\n  sort(s, s + n);\n  for (int i = 0; i < n; i++) cout << mp[s[i]] << ' ';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int t;\n  t = 1;\n  while (t--) solve();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 5;\nint t, n, m;\npair<string, int> a[N];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> m;\n  for (int i = 0; i <= n - 1; ++i) {\n    cin >> a[i].first;\n    for (int j = 0; j <= m - 1; ++j)\n      if (j & 1) a[i].first[j] = char(155 - int(a[i].first[j]));\n    a[i].second = i + 1;\n  }\n  sort(a, a + n);\n  for (int i = 0; i <= n - 1; ++i) cout << a[i].second << \" \";\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 10, maxm = 1e6 + 10, mod = 998244353, inf = 0x3f3f3f3f;\nconst double pi = acos(-1), eps = 1e-7;\nint n, m;\nstring s[maxn];\nmap<string, int> mp;\nbool cmp(string a, string b) {\n  for (int i = 0; i < m; i++) {\n    if (a[i] == b[i]) continue;\n    if (i & 1)\n      return a[i] > b[i];\n    else\n      return a[i] < b[i];\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> s[i];\n    mp[s[i]] = i;\n  }\n  sort(s + 1, s + 1 + n, cmp);\n  for (int i = 1; i <= n; i++) {\n    cout << mp[s[i]] << \" \";\n  }\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint n, m;\nvector<pair<string, int>> v;\nbool cmp(pair<string, int> a, pair<string, int> b) {\n  string s1 = a.first, s2 = b.first;\n  for (int i = 0; i < m; ++i) {\n    if (i % 2 == 0) {\n      if (s1[i] != s2[i]) return s1[i] < s2[i];\n    } else {\n      if (s1[i] != s2[i]) return s1[i] > s2[i];\n    }\n  }\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    string s;\n    cin >> s;\n    v.push_back({s, i});\n  }\n  sort(v.begin(), v.end(), cmp);\n  for (auto p : v) {\n    cout << p.second << \" \";\n  }\n  cout << endl;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst bool ready = []() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(12);\n  return true;\n}();\nusing ld = long double;\nconst ld PI = acos((ld)-1);\nusing ll = long long;\nusing pii = pair<ll, ll>;\nusing pdd = pair<ld, ld>;\nusing vd = vector<ld>;\nusing vb = vector<bool>;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nvoid solve() {\n  ll n;\n  cin >> n;\n  ;\n  ll m;\n  cin >> m;\n  ;\n  vs s(n);\n  for (ll i = 0; i < ll(n); i++) {\n    cin >> s[i];\n  };\n  vi id(n);\n  iota((id).begin(), (id).end(), 0LL);\n  for (ll i = 0; i < n; i++) {\n    for (ll j = 1; j < m; j += 2) {\n      s[i][j] = 'Z' - s[i][j];\n    }\n  }\n  sort((id).begin(), (id).end(), [&](ll i1, ll i2) { return s[i1] < s[i2]; });\n  for (ll i = 0; i < n; i++) cout << id[i] + 1 << \" \";\n  cout << \"\\n\";\n}\nsigned main() { solve(); }\n","# import functools\n# def customSort(aa,bb):\n# \ta = aa[1]\n# \tb = bb[1]\n# \tfor i in range(len(a)):\n# \t\tif a[i] == b[i]:\n# \t\t\tcontinue\n# \t\tif (i+1) % 2 != 0:\n# \t\t\tif a[i] < b[i]:\n# \t\t\t\treturn -1\n# \t\t\treturn 1\n# \t\telse:\n# \t\t\tif a[i] > b[i]:\n# \t\t\t\treturn -1\n# \t\t\treturn 1\n# \treturn 0\n\n# n, m =[int(x) for x in input().strip().split()]\n# strings = [\"\"]*n\n# for i in range(n):\n# \tstrings[i] = (i+1, input().rstrip())\n\n# strings.sort(key = functools.cmp_to_key(customSort))\n# print(' '.join([str(x[0]) for x in strings]))\n\nn, m =[int(x) for x in input().strip().split()]\n\ndef encode(x):\n\taccum = 1\n\tres = 0\n\tbase_A = ord('A')\n\tbase_Z = ord('Z')\n\tfor idx in range(m,0,-1):\n\t\tc = x[idx-1]\n\t\tif idx % 2 != 0:\n\t\t\tres += (ord(c) - base_A)*accum\n\t\telse:\n\t\t\tres += (base_Z - ord(c) )*accum\n\t\taccum *= 26\n\treturn res\n\n\nstrings = [[0,0] for _ in range(n)]\nfor i in range(n):\n\tx = input().rstrip()\n\tstrings[i] = (i+1, encode(x))\n\nstrings.sort(key=lambda x: x[1])\nprint(' '.join([str(x[0]) for x in strings]))","#include <bits\/stdc++.h>\nusing namespace std;\nbool ketan(pair<string, long long> &p1, pair<string, long long> &p2) {\n  for (long long i = 0; i < p1.first.length(); i++) {\n    if (i % 2 == 0 && p1.first[i] != p2.first[i]) {\n      return p1.first[i] > p2.first[i];\n    }\n    if (i % 2 == 1 && p1.first[i] != p2.first[i]) {\n      return p1.first[i] < p2.first[i];\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n, m;\n  cin >> n >> m;\n  vector<pair<string, long long>> v;\n  for (long long i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    v.push_back(make_pair(s, i));\n  }\n  sort(v.begin(), v.end(), ketan);\n  for (long long i = n - 1; i >= 0; i--) {\n    cout << v[i].second + 1 << \" \";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 50, mod = 998244353;\nvector<pair<string, int>> s;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    string a;\n    cin >> a;\n    for (int j = 1; j < a.size(); j += 2) a[j] = 'Z' - (a[j] - 'A');\n    s.push_back({a, i});\n  }\n  sort(s.begin(), s.end());\n  for (int i = 0; i < s.size(); i++) {\n    cout << s[i].second << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nnamespace FullPre {\nconst int L = 1 << 15;\nchar buf[L], *s = buf, *t = buf;\ntemplate <typename T>\ninline void read(T& x) {\n  T f = 1;\n  x = 0;\n  int c = getchar();\n  while (c < 48 || c > 57) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= 48 && c <= 57) {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  x *= f;\n}\ntemplate <typename T, typename... args>\ninline void read(T& x, args&... Args) {\n  read(x), read(Args...);\n}\ntemplate <typename T>\ninline void write(T x) {\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  if (x > 9) write(x \/ 10);\n  putchar(x % 10 + '0');\n}\ntemplate <typename T>\ninline void print_char(T x, char ch) {\n  write(x), putchar(ch);\n}\ntemplate <typename T>\ninline void char_print(char ch, T x) {\n  putchar(ch), write(x);\n}\ntemplate <typename T>\ninline void print_space(T x) {\n  print_char(x, ' ');\n}\ntemplate <typename T>\ninline void print_space_mul(T x) {\n  print_space(x);\n}\ntemplate <typename T, typename... args>\ninline void print_space_mul(T x, args... Args) {\n  print_space(x), print_space_mul(Args...);\n}\ntemplate <typename T>\ninline void space_print(T x) {\n  char_print(' ', x);\n}\ntemplate <typename T>\ninline void space_print_mul(T x) {\n  space_print(x);\n}\ntemplate <typename T, typename... args>\ninline void space_print_mul(T x, args... Args) {\n  space_print(x), space_print_mul(Args...);\n}\ntemplate <typename T>\ninline void println(T x) {\n  print_char(x, '\\n');\n}\ntemplate <typename T>\ninline void println_mul(T x) {\n  println(x);\n}\ntemplate <typename T, typename... args>\ninline void println_mul(T x, args... Args) {\n  println(x), println_mul(Args...);\n}\ntemplate <typename T>\ninline void lnprint(T x) {\n  char_print('\\n', x);\n}\ntemplate <typename T>\ninline void lnprint_mul(T x) {\n  lnprint(x);\n}\ntemplate <typename T, typename... args>\ninline void lnprint_mul(T x, args... Args) {\n  lnprint(x), lnprint_mul(Args...);\n}\ninline void filein(string s) { freopen((s + \".in\").c_str(), \"r\", stdin); }\ninline void fileout(string s) { freopen((s + \".out\").c_str(), \"w\", stdout); }\ninline void file(string s) { filein(s), fileout(s); }\ntemplate <typename T>\ninline T mymin(T a, T b) {\n  return a < b ? a : b;\n}\ntemplate <typename T, typename... args>\ninline T mymin(T a, T b, args... Args) {\n  return mymin(mymin(a, b), Args...);\n}\ntemplate <typename T>\ninline T mymax(T a, T b) {\n  return a > b ? a : b;\n}\ntemplate <typename T, typename... args>\ninline T mymax(T a, T b, args... Args) {\n  return mymax(mymax(a, b), Args...);\n}\ntemplate <typename T>\ninline T myabs(T a) {\n  return a < 0 ? -a : a;\n}\ntemplate <typename T>\ninline T mysq(T a) {\n  return a * a;\n}\ntemplate <typename T>\ninline T mygcd(T a, T b) {\n  return !b ? a : mygcd(b, a % b);\n}\ntemplate <typename T, typename... args>\ninline T mygcd(T a, T b, args... Args) {\n  return mygcd(mygcd(a, b), Args...);\n}\ntemplate <typename T>\ninline T mylcm(T a, T b) {\n  return a \/ mygcd(a, b) * b;\n}\ntemplate <typename T, typename... args>\ninline T mylcm(T a, T b, args... Args) {\n  return mylcm(mylcm(a, b), Args...);\n}\ntemplate <typename T>\ninline T myswap(T& a, T& b) {\n  a ^= b ^= a ^= b;\n}\n}  \/\/ namespace FullPre\nusing namespace FullPre;\nnamespace Solution {\nstruct node {\n  string str;\n  int id;\n  bool operator<(const node& t) const { return str < t.str; }\n} a[1000007];\ninline void Main() {\n  int n, m;\n  read(n, m);\n  for (int(i) = (1); (i) <= (n); ++(i)) {\n    cin >> a[i].str;\n    a[i].id = i, a[i].str = \" \" + a[i].str;\n    for (int(j) = (2); (j) <= (m); (j) += (2))\n      a[i].str[j] = 'Z' - a[i].str[j] + 'A';\n  }\n  sort(a + 1, a + n + 1);\n  for (int(i) = (1); (i) <= (n); ++(i)) printf(\"%d%c\", a[i].id, \" \\n\"[i == n]);\n  return;\n}\n}  \/\/ namespace Solution\nint main() {\n  Solution ::Main();\n  return 0;\n}\n","# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------- fast io --------------------\nfrom math import ceil\n\n\ndef prod(a, mod=10 ** 9 + 7):\n    ans = 1\n    for each in a:\n        ans = (ans * each) % mod\n    return ans\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n\ndef lcm(a, b): return a * b \/\/ gcd(a, b)\n\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\nfrom functools import cmp_to_key\n\nfor _ in range(int(input()) if not True else 1):\n    # n = int(input())\n    n, m = map(int, input().split())\n    # a, b = map(int, input().split())\n    # c, d = map(int, input().split())\n    # a = list(map(int, input().split()))\n    # b = list(map(int, input().split()))\n    # s = input()\n    words = [\"\"]\n    for i in range(n):\n        words += [list(map(ord, input()))]\n    a = list(range(1, n+1))\n    def compare(x, y):\n        for i in range(m):\n            if not i % 2:\n                if words[x][i] != words[y][i]:\n                    return 1 if words[x][i] > words[y][i] else -1\n            else:\n                if words[x][i] != words[y][i]:\n                    return -1 if words[x][i] > words[y][i] else 1\n        return 0\n    \n    a = sorted(a, key=cmp_to_key(compare))\n    for i in a:\n        print(i)","#include <bits\/stdc++.h>\nusing namespace std;\nint t, n, m;\npair<string, int> p[1000001];\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    string s;\n    cin >> s;\n    for (int j = 1; j < m; j += 2) s[j] = 155 - s[j];\n    p[i] = {s, i};\n  }\n  sort(p + 1, p + n + 1);\n  for (int i = 1; i <= n; i++) cout << p[i].second << ' ';\n}\n","n , m = map(int, input().split())\nc = lambda x : chr(ord(\"Z\")-ord(x)+ord(\"A\"))\np = lambda x, ind: x if ind%2==0 else c(x)\nfor_sort = lambda x: x[1]\nlam = lambda x,i: [i+1,[p(x[j],j) for j in range(m)]]\nprint(*[i[0] for i in sorted([(lam(input(),i)) for i in range(n)], key=for_sort)])","#include <bits\/stdc++.h>\nusing namespace std;\nint n, m;\npair<string, int> s[1000005];\nbool cmp(const pair<string, int> p1, const pair<string, int> p2) {\n  string s1 = p1.first, s2 = p2.first;\n  for (int i = 0; i < m; i++) {\n    if (s1[i] != s2[i]) {\n      if (i % 2 == 0)\n        return s1[i] < s2[i];\n      else\n        return s1[i] > s2[i];\n    }\n  }\n  return false;\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> s[i].first;\n    s[i].second = i;\n  }\n  sort(s + 1, s + 1 + n, cmp);\n  for (int i = 1; i <= n; i++) {\n    cout << s[i].second << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  string s[n];\n  map<string, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    for (int j = 1; j < s[i].length(); j += 2) {\n      s[i][j] = 'Z' - (s[i][j] - 'A');\n    }\n    mp[s[i]] = i + 1;\n  }\n  sort(s, s + n);\n  for (int i = 0; i < n; i++) {\n    cout << mp[s[i]] << \" \";\n  }\n}\n","\n\n\n\nn,m = list(map(int,input().split()))\narr = []\nfor i in range(n):\n    arr.append([list(input()),i+1])\n#print(arr)\nalps = list(map(chr, range(65, 91)))\nd = {}\nfor a in range(len(alps)):\n    d[alps[a]] = alps[len(alps)-1-a]\n#print(d)\n#print(arr[1][0][1])\n\nfor i in range(n):\n    for j in range(m):\n        if j%2:\n            arr[i][0][j] = d[arr[i][0][j]]\n\narr.sort()\nfor i in range(n):\n    print(arr[i][1],end = \" \")\n\n\n\n\n\n\n\n\n\n","#include <bits\/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid _p(T a) {\n  cout << a << '\\n';\n}\ntemplate <class T>\nvoid _pa(T a) {\n  cout << a << ' ';\n}\ntemplate <class T1, class T2>\nvoid _p(T1 a, T2 b) {\n  cout << a << ' ' << b << '\\n';\n}\ntemplate <class T1, class T2, class T3>\nvoid _p(T1 a, T2 b, T3 c) {\n  cout << a << ' ' << b << ' ' << c << '\\n';\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid _p(T1 a, T2 b, T3 c, T4 d) {\n  cout << a << ' ' << b << ' ' << c << ' ' << d << ' ' << '\\n';\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid _p(T1 a, T2 b, T3 c, T4 d, T5 e) {\n  cout << a << ' ' << b << ' ' << c << ' ' << d << ' ' << e << ' ' << '\\n';\n}\ntemplate <class T>\nvoid _pa(T a[], long long n) {\n  long long i;\n  for (i = 0; i < n; i++) cout << a[i] << ' ';\n  cout << '\\n';\n}\ntemplate <class T>\nvoid _p(vector<T> v) {\n  for (auto x : v) cout << x << ' ';\n  cout << '\\n';\n}\ntemplate <class T>\nvoid _p(list<T> l) {\n  for (auto x : l) cout << x << ' ';\n  cout << '\\n';\n}\ntemplate <class T>\nvoid _p(set<T> s) {\n  for (auto x : s) cout << x << ' ';\n  cout << '\\n';\n}\ntemplate <class T>\nvoid _p(multiset<T> s) {\n  for (auto x : s) cout << x << ' ';\n  cout << '\\n';\n}\ntemplate <class T>\nvoid _p(unordered_set<T> s) {\n  for (auto x : s) cout << x << ' ';\n  cout << '\\n';\n}\ntemplate <class T1, class T2>\nvoid _p(map<T1, T2> m) {\n  for (auto x : m) cout << x.first << \"->\" << x.second << '\\n';\n  cout << '\\n';\n}\ntemplate <class T1, class T2>\nvoid _p(unordered_map<T1, T2> m) {\n  for (auto x : m) cout << x.first << \"->\" << x.second << '\\n';\n  cout << '\\n';\n}\ntemplate <class T1, class T2>\nvoid _p(map<T1, vector<T2>> m) {\n  for (auto x : m) {\n    cout << x.first << \"->\";\n    _p(x.second);\n  }\n  cout << '\\n';\n}\ntemplate <class T1, class T2>\nvoid _p(unordered_map<T1, vector<T2>> m) {\n  for (auto x : m) {\n    cout << x.first << \"->\";\n    _p(x.second);\n  }\n  cout << '\\n';\n}\nint n, m;\nstring s[1000004];\nchar ulta(char x) {\n  int p = x;\n  if (p >= 78)\n    p = 65 + (78 - p);\n  else\n    p = 78 + (65 - p);\n  return p;\n}\nstring str(int n) {\n  string x = \"\";\n  char z;\n  while (n > 0) {\n    z = 48 + n % 10;\n    x = z + x;\n    n \/= 10;\n  }\n  return x;\n}\nvoid solution() {\n  int i, j;\n  cin >> n >> m;\n  for (i = 0; i < n; i++) cin >> s[i];\n  for (j = 0; j < m; j++)\n    if (j & 1)\n      for (i = 0; i < n; i++) s[i][j] = ulta(s[i][j]);\n  for (i = 0; i < n; i++) s[i] += str(i + 1);\n  sort(s, s + n);\n  for (i = 0; i < n; i++) _pa(s[i].substr(m, 10));\n  cout << '\\n';\n}\nint32_t main() { solution(); }\n","#include <bits\/stdc++.h>\nusing namespace std;\nstruct Node {\n  string data;\n  int pos;\n};\nbool cmp(Node p1, Node p2) {\n  string a = p1.data;\n  string b = p2.data;\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i]) continue;\n    if (i % 2 == 0) {\n      if (a[i] < b[i]) return true;\n      return false;\n    } else {\n      if (a[i] > b[i]) return true;\n      return false;\n    }\n  }\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<Node> s(n);\n  for (int i = 0; i < n; i++) {\n    cin >> s[i].data;\n    s[i].pos = i + 1;\n  }\n  sort(s.begin(), s.end(), cmp);\n  for (int i = 0; i < n; i++) {\n    cout << s[i].pos << ' ';\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  solve();\n}\n","#include <bits\/stdc++.h>\nbool test = false;\nlong long mod1 = 1e9 + 7;\nlong long mod2 = 998244353;\nlong long inf = 1e10 + 5;\nvoid testCase() {\n  long long n, m;\n  std::cin >> n >> m;\n  std::vector<std::pair<std::string, long long>> s(n);\n  for (int i = 0; i <= n - 1; i++) {\n    std::cin >> s[i].first;\n    s[i].second = i;\n  }\n  for (int i = 0; i <= n - 1; i++) {\n    for (int j = 1; j <= m - 1; j += 2) {\n      s[i].first[j] = 'Z' - s[i].first[j];\n    }\n  }\n  std::sort(s.begin(), s.end());\n  for (int i = 0; i <= n - 1; i++) {\n    std::cout << s[i].second + 1 << \" \";\n  }\n  std::cout << \"\\n\";\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(NULL);\n  std::cout.precision(15);\n  long long t = 1;\n  if (test) {\n    std::cin >> t;\n  }\n  for (long long i = 0; i <= t - 1; i++) {\n    testCase();\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool compare(const pair<string, int>& x, const pair<string, int>& y) {\n  string xs = x.first;\n  string ys = y.first;\n  int m = xs.length();\n  for (int i = 0; i < m; i++) {\n    if (i % 2 == 0) {\n      if (xs[i] < ys[i]) return true;\n      if (xs[i] > ys[i]) return false;\n    } else {\n      if (ys[i] < xs[i]) return true;\n      if (ys[i] > xs[i]) return false;\n    }\n  }\n  return false;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> a(n);\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    a[i] = {s, i + 1};\n  }\n  sort(a.begin(), a.end(), compare);\n  for (pair<string, int> p : a) {\n    cout << p.second << \" \";\n  }\n  cout << endl;\n}\n","import java.io.*;\n\nimport java.util.*;\n\/*\n\n*\/\n\n \n public class A{\n\tstatic FastReader sc=null;\n\t\n\tpublic static void main(String[] args) {\n\t\tsc=new FastReader();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tint n=sc.nextInt(),m=sc.nextInt();\n\t\tString a[]=new String[n];\n\t\tMap<String,Integer> map=new HashMap<>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i]=sc.next();\n\t\t\tmap.put(a[i], i+1);\n\t\t}\n\t\t\n\t\tArrays.sort(a,new comp());\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\tout.print(map.get(a[i])+\" \");\n\t\t\n\t\tout.close();\n\t\t\n\t}\n\tstatic class comp implements Comparator<String>{\n\t\t\n\t\tpublic int compare(String s1,String s2) {\n\t\t\tint m=s1.length();\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint c=s1.charAt(i)-s2.charAt(i);\n\t\t\t\tif(c!=0) {\n\t\t\t\t\treturn (i%2==0?c:-c);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tstatic int[] ruffleSort(int a[]) {\n\t\tArrayList<Integer> al=new ArrayList<>();\n\t\tfor(int i:a)al.add(i);\n\t\tCollections.sort(al);\n\t\tfor(int i=0;i<a.length;i++)a[i]=al.get(i);\n\t\treturn a;\n\t}\n\t\n\tstatic void print(int a[]) {\n\t\tfor(int e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic class FastReader{\n\t\t\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString next() {\n\t\t\twhile(!st.hasMoreTokens()) \n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t   catch(IOException e){\n\t\t\t\t   e.printStackTrace();\n\t\t\t   }\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tint[] readArray(int n) {\n\t\t\tint a[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++)a[i]=sc.nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n\t\n\t\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int n, b;\n  cin >> n >> b;\n  vector<pair<string, int>> v;\n  string a[n];\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    a[i] = s;\n    v.push_back(make_pair(s, i));\n  }\n  for (int i = 0; i < n; i++) {\n    string s3 = \"\";\n    for (int j = 0; j < b; j++) {\n      string s2 = \"\";\n      if ((j + 1) % 2 == 0) {\n        int c = 90 - int(a[i][j]);\n        s2 += char(c + 65);\n      } else {\n        int c = int(a[i][j]);\n        s2 += char(c);\n      }\n      s3 += s2;\n    }\n    v[i].first = s3;\n  }\n  sort(v.begin(), v.end());\n  for (int i = 0; i < n; i++) {\n    cout << v[i].second + 1 << \" \";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint t, ans = 0, tot = 0, kk = 0;\nconst int mxn = 2e7 + 10, mod = 1e9 + 7;\nsigned main() {\n  int n, m, a, b, c, d, e, i, j, k, sm = 0, sm1 = 0, cn = 0, cn1 = 0, mx = -1e9,\n                                    mn = 1e9;\n  string s, ss, sr, sa;\n  bool f = false, ff = true;\n  char ch;\n  cin >> n >> m;\n  pair<vector<int>, int> pr[n + 1];\n  for (i = 1; i <= n; i++) {\n    for (j = 0; j < m; j++) {\n      cin >> ch;\n      if (j % 2 == 0)\n        pr[i].first.push_back((int)ch);\n      else\n        pr[i].first.push_back(-(int)ch);\n    }\n    pr[i].second = i;\n  }\n  sort(pr + 1, pr + n + 1);\n  for (i = 1; i <= n; i++) cout << pr[i].second << \" \";\n  cout << \"\\n\";\n}\n","if __name__ == \"__main__\":\n    n, m = input().split(\" \")\n    n = int(n)\n    m = int(m)\n    \n    strings = []\n    str_idxs = {}\n    sol = []\n    \n    for i in range(n):\n        string = input()\n        s = [None] * m\n        for j in range(1, m, 2):\n            c = ord(string[j]) - ord(\"A\")\n            s[j] = chr(ord(\"A\") + (25 - c))\n        for j, letter in enumerate(s):\n            if letter == None:\n                s[j] = string[j]  \n        aux = \"\"\n        new_s = aux.join(s)\n        str_idxs[new_s] = i + 1\n        sol.append(new_s)\n            \n    sol.sort()\n    for i in range(n):\n         print(str_idxs[sol[i]], end=\" \")\n  \t\t\t\t \t\t\t   \t\t\t\t \t\t\t \t \t\t   \t","#include <bits\/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<int, int>;\nusing VI = vector<int>;\nvoid prec() {}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<string> vs(n);\n  for (auto &s : vs) {\n    cin >> s;\n    for (int i = 1; i < m; i += 2) {\n      s[i] = 'A' + (25 - (s[i] - 'A'));\n    }\n  }\n  VI ixs(n);\n  iota(ixs.begin(), ixs.end(), 0);\n  sort(ixs.begin(), ixs.end(),\n       [&](int i, int j) -> bool { return vs[i] < vs[j]; });\n  for (int i : ixs) cout << (i + 1) << ' ';\n  cout << '\\n';\n}\nint main(int argc, char *argv[]) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  prec();\n  int t = 1;\n  for (int it = 1; it <= t; it++) {\n    solve();\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconstexpr double EPS = 1e-8;\nconstexpr int MOD = 1000000007;\nconstexpr int DY[]{1, 0, -1, 0}, DX[]{0, -1, 0, 1};\nconstexpr int DY8[]{1, 1, 0, -1, -1, -1, 0, 1},\n    DX8[]{0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U>\ninline bool chmax(T &a, U b) {\n  return a < b ? (a = b, true) : false;\n}\ntemplate <typename T, typename U>\ninline bool chmin(T &a, U b) {\n  return a > b ? (a = b, true) : false;\n}\nstruct IOSetup {\n  IOSetup() {\n    std::cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    std::cout << fixed << setprecision(20);\n  }\n} iosetup;\ntemplate <typename T = std::string>\nstruct RollingHash {\n  T str;\n  RollingHash(const T &s, const int base = 10007, const int md = 1000000007)\n      : str(s), base(base), md(md) {\n    int n = str.size();\n    hash_val.resize(n + 1);\n    hash_val[0] = 0;\n    power.resize(n + 1);\n    power[0] = 1;\n    for (int i = 0; i < n; ++i) {\n      hash_val[i + 1] = (hash_val[i] * base % md + str[i]) % md;\n      power[i + 1] = power[i] * base % md;\n    }\n  }\n  long long get(int left, int right) const {\n    long long res = hash_val[right] - hash_val[left] * power[right - left] % md;\n    return res < 0 ? res + md : res;\n  }\n  void add(const T &t) {\n    for (auto c : t) {\n      hash_val.emplace_back((hash_val.back() * base % md + c) % md);\n      power.emplace_back(power.back() * base % md);\n    }\n  }\n  int lcp(int i, int j) const {\n    int n = str.size(), lb = 0, ub = n + 1 - std::max(i, j);\n    while (ub - lb > 1) {\n      int mid = (lb + ub) >> 1;\n      (get(i, i + mid) == get(j, j + mid) ? lb : ub) = mid;\n    }\n    return lb;\n  }\n  template <typename U>\n  int lcp(const RollingHash<U> &t, int i, int j) const {\n    int lb = 0, ub = std::min(static_cast<int>(str.size()) - i,\n                              static_cast<int>(t.str.size()) - j) +\n                     1;\n    while (ub - lb > 1) {\n      int mid = (lb + ub) >> 1;\n      (get(i, i + mid) == t.get(j, j + mid) ? lb : ub) = mid;\n    }\n    return lb;\n  }\n\n private:\n  int base, md;\n  std::vector<long long> hash_val, power;\n};\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<string> s(n);\n  for (int i = (0); i < (n); ++i) cin >> s[i];\n  vector<RollingHash<>> hash;\n  for (int i = (0); i < (n); ++i) hash.emplace_back(s[i]);\n  vector<int> ans(n);\n  iota((ans).begin(), (ans).end(), 0);\n  sort((ans).begin(), (ans).end(), [&](int i, int j) -> bool {\n    int lb = 0, ub = m;\n    while (ub - lb > 1) {\n      int mid = (lb + ub) \/ 2;\n      (hash[i].get(0, mid) == hash[j].get(0, mid) ? lb : ub) = mid;\n    }\n    if (lb % 2 == 0) {\n      return s[i][lb] < s[j][lb];\n    } else {\n      return s[i][lb] > s[j][lb];\n    }\n  });\n  for (int i = (0); i < (n); ++i) cout << ans[i] + 1 << \" \\n\"[i + 1 == n];\n  return 0;\n}\n","#include <bits\/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> A(n);\n  for (int i = 0; i < n; i++) {\n    cin >> A[i].first;\n    A[i].second = i + 1;\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 1; j < m; j += 2) {\n      A[i].first[j] = 'Z' - A[i].first[j];\n    }\n  }\n  sort(A.begin(), A.end());\n  for (auto it : A) {\n    cout << it.second << \" \";\n  }\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int i, p, j, n, m;\n  cin >> n >> m;\n  string s[n];\n  char q = 'A';\n  vector<pair<string, int>> v;\n  for (i = 0; i < n; i++) cin >> s[i];\n  for (i = 0; i < n; i++) {\n    for (j = 1; j < m; j += 2) {\n      p = s[i][j] - 'A';\n      p = 25 - p;\n      q += p;\n      s[i][j] = q;\n      q = 'A';\n    }\n  }\n  for (i = 0; i < n; i++) v.push_back(make_pair(s[i], i + 1));\n  sort(v.begin(), v.end());\n  for (i = 0; i < n; i++) cout << v[i].second << \" \";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N_MAX = 1000000;\nint n, m;\nstring s[N_MAX];\nint p[N_MAX];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    for (int j = 1; j < m; j += 2) s[i][j] = char('A' + ('Z' - s[i][j]));\n  }\n  for (int i = 0; i < n; i++) p[i] = i;\n  sort(p, p + n, [&](const int &i, const int &j) { return s[i] < s[j]; });\n  for (int i = 0; i < n; i++) cout << p[i] + 1 << \" \";\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvector<string> v;\nvector<int> id;\nbool comp(int &a, int &b) { return v[a].compare(v[b]) < 0; }\nint main() {\n  int n, m;\n  ios_base::sync_with_stdio(false);\n  cin >> n >> m;\n  v = vector<string>(n);\n  id = vector<int>(n);\n  for (int i = 0; i < n; ++i) id[i] = i;\n  for (int i = 0; i < n; ++i) cin >> v[i];\n  for (int i = 0; i < n; ++i)\n    for (int j = 1; j < m; j += 2) v[i][j] = 'Z' - (v[i][j] - 'A');\n  sort(id.begin(), id.end(), comp);\n  for (int i = 0; i < n; ++i) cout << id[i] + 1 << (i == n - 1 ? '\\n' : ' ');\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int maxn = 1000010;\nint n, m, p[maxn];\nstring s[maxn];\nbool cmp(int i, int j) {\n  for (int k = 0; k < m; k++) {\n    if (s[i][k] != s[j][k]) {\n      if (k % 2 == 0)\n        return s[i][k] < s[j][k];\n      else\n        return s[i][k] > s[j][k];\n    }\n  }\n  return false;\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    p[i] = i;\n  }\n  sort(p, p + n, cmp);\n  for (int i = 0; i < n; i++) cout << p[i] + 1 << \" \";\n  return 0;\n}\n","import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class A{\n\t\n\tstatic int n,m;\n\t\n\tstatic class S implements Comparable<S>{\n\t\tchar[] c;\n\t\tint i;\n\t\tpublic S(char[] a, int j) {\n\t\t\tc=a;\n\t\t\ti=j;\n\t\t}\n\t\tpublic int compareTo(S o) {\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint t = i+1;\n\t\t\t\tif (c[i] == o.c[i]) continue;\n\t\t\t\tif (t%2==0) {\n\t\t\t\t\treturn o.c[i] - c[i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn c[i] - o.c[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws IOException{\n\t\t\/\/ br = new BufferedReader(new FileReader(\".in\"));\n\t\t\/\/ out = new PrintWriter(new FileWriter(\".out\"));\n\t\t\/\/ new Thread(null, new (), \"fisa balls\", 1<<28).start();\n\t\tn=readInt();\n\t\tm=readInt();\n\t\t\n\t\tS[] s = new S[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts[i] = new S(read().toCharArray(), i+1);\n\t\t}\n\t\t\n\t\tArrays.sort(s);\n\t\tfor (S str: s) out.print(str.i + \" \");\n\t\tout.println();\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tstatic StringTokenizer st = new StringTokenizer(\"\");\n\tstatic String read() throws IOException{\n\t\twhile (!st.hasMoreElements()) st = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(read());}\n\tpublic static long readLong() throws IOException{return Long.parseLong(read());}\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, m;\n  cin >> n >> m;\n  vector<string> a(n);\n  for (string &x : a) cin >> x;\n  vector<pair<string, int>> b;\n  for (int i = 0; i < n; i++) b.push_back({a[i], i});\n  sort(b.begin(), b.end(),\n       [&](const pair<string, int> &i, const pair<string, int> &j) {\n         if (i.first == j.first) return i.second < j.second;\n         for (int c = 0; c < m; c++) {\n           if (i.first[c] == j.first[c]) continue;\n           if (c % 2 == 0) return i.first[c] < j.first[c];\n           return i.first[c] > j.first[c];\n         }\n       });\n  for (pair<string, int> &x : b) cout << x.second + 1 << \" \";\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint n, m;\ntypedef struct Node {\n  string element;\n  int id;\n} node;\nstruct cmp {\n  bool operator()(const node& x, const node& y) {\n    for (int i = 0; i < m; i++) return x.element > y.element;\n  }\n};\npriority_queue<node, vector<node>, cmp> mid;\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    node shu;\n    cin >> shu.element;\n    shu.id = i;\n    for (int j = 0; j < m; j++) {\n      if (j % 2 == 1) shu.element[j] = 'Z' - shu.element[j] + 'A';\n    }\n    mid.push(shu);\n  }\n  while (!mid.empty()) {\n    cout << mid.top().id << \" \";\n    mid.pop();\n  }\n  return 0;\n}\n","import java.util.*;\npublic class P1575AL {\n\tpublic static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n \n        solve(s.nextInt(), s.nextInt(), s);\n    }\n \n \n    public static void solve(int n, int l, Scanner s) {\n        String arr[][] = new String[n][2];\n        for (int i = 1; i <= n; i++) {\n            arr[i - 1] = new String[]{s.next(), i + \"\"};\n        }\n \n        Arrays.sort(arr, new Comparator<String[]>() {\n            @Override\n            public int compare(String[] a, String[] b) {\n                String s1 = a[0];\n                String s2 = b[0];\n                for (int i = 0; i < l; i++) {\n                    if (s1.charAt(i) != s2.charAt(i)) return i % 2 == 0 ^ (s1.charAt(i) > s2.charAt(i)) ? -1 : 1;\n                }\n                return 0;\n            }\n        });\n \n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            sb.append(arr[i][1]+\" \");\n        }\n \n        System.out.println(sb);\n    }\n\t\/*\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.next()), m = Integer.parseInt(s.next());\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tArrayList<String> a = new ArrayList<String>();\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tString x = s.next();\n\t\t\ta.add(x);\n\t\t\tmap.put(x, i);\n\t\t}\n\t\t\/\/sort\n\t\tCollections.sort(a);\n\t\ta = solve(a, 0, m);\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tSystem.out.println(map.get(a.get(i)));\n\t\t}\n\t\ts.close();\n\t}\n\tpublic static ArrayList<String> sort(ArrayList<String> arr, int a, int b, int curr, int m) {\n\t\tArrayList<String> tem = new ArrayList<String>();\n\t\tArrayList<Character> temp = new ArrayList<Character>();\n\t\tArrayList<String> ans = new ArrayList<String>();\n\t\tfor(int i = a; i<b; i++) {\n\t\t\ttem.add(arr.get(i));\n\t\t\ttemp.add(arr.get(i).charAt(curr+1));\n\t\t}\n\t\tCollections.sort(temp);\n\t\tif(curr%2==1) { \/\/descending\n\t\t\tCollections.reverse(temp);\n\t\t}\n\t\t\/\/assign\n\t\tfor(int i = temp.size()-1; i>=0; i--) {\n\t\t\tint index = 0;\n\t\t\tloop: for(int j = 0; j<tem.size(); j++) {\n\t\t\t\tif(tem.get(j).charAt(curr)==temp.get(0)) {\n\t\t\t\t\tindex = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans.add(tem.get(index));\n\t\t\ttem.remove(index);\n\t\t\ttemp.remove(0);\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic static ArrayList<String> solve(ArrayList<String> arr, int curr, int m) {\n\t\t\/\/exit case\n\t\tif(curr==m) {\n\t\t\treturn arr;\n\t\t}\n\t\t\/\/generate partitions\n\t\tchar cu = arr.get(0).charAt(curr);\n\t\tint beg = 0, end = 0;\n\t\tfor(int i = 0; i<arr.size(); i++) {\n\t\t\tif(arr.get(i).charAt(curr)==cu)\n\t\t\t\tend++;\n\t\t\telse {\n\t\t\t\tArrayList<String> temp = sort(arr, beg, end, curr, m);\n\t\t\t\tfor(int j = end; j>=beg; j--) {\n\t\t\t\t\tarr.remove(i);\n\t\t\t\t}\n\t\t\t\tfor(int j = temp.size()-1; j>=0; j--) {\n\t\t\t\t\tarr.add(0, temp.get(i));\n\t\t\t\t}\n\t\t\t\tif(end==arr.size()-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbeg = end+1;\n\t\t\t\t\tend = beg;\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\treturn solve(arr, curr+1, m); \/\/recurse\n\t}*\/\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n, m;\n  cin >> n >> m;\n  vector<string> s(n);\n  for (long long i = 0; i < n; i++) cin >> s[i];\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (j & 1) s[i][j] = 'Z' - s[i][j] + 'A';\n    }\n  }\n  map<string, long long> mp;\n  for (long long i = 0; i < n; i++) mp.insert({s[i], i + 1});\n  for (auto it : mp) {\n    cout << it.second << \" \";\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nlong long int mod = 1000000007;\nbool cmp(pair<string, long long int> &a, pair<string, long long int> &b) {\n  for (int i = 0; i < a.first.size(); i++) {\n    if (a.first[i] != b.first[i]) {\n      if (i % 2 == 0) {\n        return a.first[i] < b.first[i];\n      } else {\n        return a.first[i] > b.first[i];\n      }\n    }\n  }\n  return true;\n}\nvoid solve() {\n  long long int n, m;\n  cin >> n >> m;\n  string s;\n  vector<pair<string, long long int>> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i].first;\n    v[i].second = i + 1;\n  }\n  sort(v.begin(), v.end(), cmp);\n  ;\n  for (auto it : v) {\n    cout << it.second << \" \";\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  solve();\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid FAST_IO(string filein = \"\", string fileout = \"\", string fileerr = \"\") {\n  if (fopen(filein.c_str(), \"r\")) {\n    freopen(filein.c_str(), \"r\", stdin);\n    freopen(fileout.c_str(), \"w\", stdout);\n  }\n  cin.tie(0), cout.tie(0)->sync_with_stdio(0);\n}\nvoid Hollwo_Pelw();\nsigned main() {\n  FAST_IO(\"hollwo_pelw.inp\", \"hollwo_pelw.out\");\n  int testcases = 1;\n  for (int test = 1; test <= testcases; test++) {\n    Hollwo_Pelw();\n  }\n  return 0;\n}\nconst int N = 2e5 + 5;\nvoid Hollwo_Pelw() {\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> st(n);\n  for (int i = 0; i < n; i++) {\n    cin >> st[i].first, st[i].second = i;\n    for (int j = 1; j < st[i].first.size(); j += 2)\n      st[i].first[j] = 'A' + 'Z' - st[i].first[j];\n  }\n  sort(st.begin(), st.end());\n  for (auto [v, p] : st) cout << p + 1 << ' ';\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool cmp(string& a, string& b) {\n  for (int i = 0; i < a.size(); ++i) {\n    if (a[i] != b[i]) return pow(-1, i) * a[i] < pow(-1, i) * b[i];\n  }\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<string> arr(n);\n  for (int i = 0; i < n; ++i) cin >> arr[i];\n  map<string, int> mm;\n  for (int i = 0; i < n; ++i) mm[arr[i]] = i;\n  sort(arr.begin(), arr.end(), cmp);\n  for (string str : arr) cout << mm[str] + 1 << ' ';\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool comp(string &a, string &b) {\n  for (int i = 0; i < (int)a.size(); i++) {\n    if (a[i] != b[i]) {\n      if (i % 2 == 0)\n        return a[i] < b[i];\n      else\n        return a[i] > b[i];\n    }\n  }\n  return false;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int tests;\n  tests = 1;\n  while (tests--) {\n    int n, m;\n    cin >> n >> m;\n    string second[n];\n    map<string, long long int> mp;\n    for (int i = 0; i < n; i++) {\n      cin >> second[i];\n      mp[second[i]] = i + 1;\n    }\n    sort(second, second + n, comp);\n    for (auto u : second) cout << mp[u] << \" \";\n    cout << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  pair<string, int> p[n];\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    for (int j = 1; j < s.size(); j += 2) {\n      s[j] = 'Z' - (s[j] - 'A');\n    }\n    p[i].first = s;\n    p[i].second = i;\n  }\n  sort(p, p + n);\n  for (int i = 0; i < n; i++) {\n    cout << p[i].second + 1 << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> a(n);\n  int c = 1;\n  for (auto &t : a) {\n    cin >> t.first;\n    t.second = c++;\n  }\n  for (auto &t : a) {\n    for (int i = 1; i < m; i += 2) {\n      t.first[i] = 'z' - t.first[i] + 'a';\n    }\n  }\n  sort(a.begin(), a.end());\n  for (auto t : a) {\n    cout << t.second << \" \";\n  }\n}\nint main() {\n  solve();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nstruct Orz {\n  int id;\n  string str;\n  bool operator<(const Orz& oth) const { return str < oth.str; }\n};\nint n, m;\nvector<Orz> vec;\nsigned main() {\n  std::cin.tie(nullptr)->sync_with_stdio(false);\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    Orz orz;\n    orz.id = i;\n    cin >> orz.str;\n    for (int j = 0; j < orz.str.size(); ++j) {\n      if (j & 1) {\n        orz.str[j] = 'z' - orz.str[j] + 'a';\n      }\n    }\n    vec.emplace_back(orz);\n  }\n  sort(vec.begin(), vec.end());\n  for (const auto& orz : vec) {\n    cout << orz.id << ' ';\n  }\n  cout << '\\n';\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int N, M;\n  cin >> N >> M;\n  vector<pair<string, int> > A(N);\n  for (int i = 0; i < N; i++) {\n    string S;\n    cin >> S;\n    for (int j = 1; j < S.size(); j += 2) S[j] = 'Z' - (S[j] - 'A');\n    A[i] = make_pair(S, i + 1);\n  }\n  sort(A.begin(), A.end());\n  for (int i = 0; i < N; i++) cout << A[i].second << (i + 1 == N ? \"\\n\" : \" \");\n}\n","import java.io.*;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class AnotherSortingProblem  {\n\n\n    static int mod = 1000000007;\n    static int maxStringLen = 0;\n\n    public static void main(String[] args) throws IOException {\n\n        FastReader reader = new FastReader();\n        FastWriter writer = new FastWriter();\n        int[] nm = reader.readIntArray(2);\n        int n = nm[0], m = nm[1];\n        maxStringLen = m;\n\n\n        ArrayList<String> original = new ArrayList<>();\n        ArrayList<String> sorted = new ArrayList<>();\n        for(int i = 0; i<n; i++){\n            String s = reader.readString();\n            original.add(s);\n            sorted.add(s);\n        }\n\n        int[] ans = new int[n];\n        HashMap<String, Integer> indices = new HashMap<>();\n        sorted = sortRecursive(sorted, 0);\n\n        for(int i = 0; i<original.size(); i++){\n            indices.put(original.get(i), i+1);\n        }\n\n        for(int i = 0; i<sorted.size(); i++){\n            ans[i] = indices.get(sorted.get(i));\n        }\n\n        writer.writeIntArrayWithSpaces(ans);\n\n    }\n\n\n    public static ArrayList<String> sortRecursive(ArrayList<String> bucket, int index){\n\n        ArrayList<String>[] buckets = new ArrayList[26];\n        for(int i = 0 ; i<26; i++){\n            buckets[i] = new ArrayList<>();\n        }\n\n        for(int i = 0; i<bucket.size(); i++){\n            buckets[bucket.get(i).charAt(index)-65].add(bucket.get(i));\n        }\n\n        if(index < maxStringLen-1) {\n            for(int i = 0; i<buckets.length; i++){\n                if(buckets[i].size() > 0) {\n                    buckets[i] = sortRecursive(buckets[i], index+1);\n                }\n            }\n        }\n\n        ArrayList<String> ans = new ArrayList<>();\n        if((index+1)%2 == 0){\n            for(int i = 25; i>= 0; i--){\n                for(int j = 0; j<buckets[i].size(); j++){\n                    ans.add(buckets[i].get(j));\n                }\n            }\n        } else {\n            for(int i = 0; i<26; i++){\n                for(int j = 0; j<buckets[i].size(); j++){\n                    ans.add(buckets[i].get(j));\n                }\n            }\n        }\n\n        return ans;\n    }\n\n\n\n\n\n\n    public static void mergeSort(int[] a, int n) {\n        if (n < 2) {\n            return;\n        }\n        int mid = n \/ 2;\n        int[] l = new int[mid];\n        int[] r = new int[n - mid];\n\n        for (int i = 0; i < mid; i++) {\n            l[i] = a[i];\n        }\n        for (int i = mid; i < n; i++) {\n            r[i - mid] = a[i];\n        }\n        mergeSort(l, mid);\n        mergeSort(r, n - mid);\n\n        merge(a, l, r, mid, n - mid);\n    }\n\n\n    public static void merge(int[] a, int[] l, int[] r, int left, int right) {\n\n        int i = 0, j = 0, k = 0;\n        while (i < left && j < right) {\n            if (l[i] <= r[j]) {\n                a[k++] = l[i++];\n            }\n            else {\n                a[k++] = r[j++];\n            }\n        }\n        while (i < left) {\n            a[k++] = l[i++];\n        }\n        while (j < right) {\n            a[k++] = r[j++];\n        }\n    }\n\n\n    public static class FastReader {\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer;\n\n\n        public int readSingleInt() throws IOException {\n            return Integer.parseInt(reader.readLine());\n        }\n\n        public int[] readIntArray(int numInts) throws IOException {\n            int[] nums = new int[numInts];\n            tokenizer = new StringTokenizer(reader.readLine());\n            for(int i = 0; i<numInts; i++){\n                nums[i] = Integer.parseInt(tokenizer.nextToken());\n            }\n            return nums;\n        }\n\n        public String readString() throws IOException {\n            return reader.readLine();\n        }\n\n    }\n\n\n\n    public static class FastWriter {\n\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n\n\n        public void writeSingleInteger(int i) throws IOException {\n            writer.write(Integer.toString(i));\n            writer.newLine();\n            writer.flush();\n        }\n\n        public void writeSingleLong(long i) throws IOException {\n            writer.write(Long.toString(i));\n            writer.newLine();\n            writer.flush();\n        }\n\n        public void writeIntArrayWithSpaces(int[] nums) throws IOException {\n            for(int i = 0; i<nums.length; i++){\n                writer.write(nums[i] + \" \");\n            }\n            writer.newLine();\n            writer.flush();\n        }\n\n        public void writeIntArrayListWithSpaces(ArrayList<Integer> nums) throws IOException {\n            for(int i = 0; i<nums.size(); i++){\n                writer.write(nums.get(i) + \" \");\n            }\n            writer.newLine();\n            writer.flush();\n        }\n\n        public void writeIntArrayWithoutSpaces(int[] nums) throws IOException {\n            for(int i = 0; i<nums.length; i++){\n                writer.write(Integer.toString(nums[i]));\n            }\n            writer.newLine();\n            writer.flush();\n        }\n\n        public void writeString(String s) throws IOException {\n            writer.write(s);\n            writer.newLine();\n            writer.flush();\n        }\n\n    }\n\n\n\n}\n","import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class AnotherSortingProblem {\n    static class Update implements Comparable<Update>{\n        String s;\n        int idx;\n\n        public Update(String s, int idx) {\n            this.s = s;\n            this.idx = idx;\n        }\n\n\n        @Override\n        public int compareTo(Update o) {\n\n            char ch1[]= this.s.toCharArray();\n            char ch2[]= o.s.toCharArray();\n\n            int len2 = ch2.length;\n            int len1 = ch1.length;\n            int len = Math.min(len1, len2);\n            int i=0;\n            while ( i <  len){\n\n                if( ch1[i] !=  ch2[i] ){\n                    if( (i&1)==1){\n                        return ch2[i]-ch1[i];\n                    }else\n                        return  ch1[i] - ch2[i];\n                }\n                i++;\n\n            }\n            return 0;\n\n        }\n    }\n\n\n\n\n\n\n    private static int solve(int n, int k) {\n        return 0;\n    }\n\n    public static void main(String[] args)\n            throws IOException {\n        Scanner s = new Scanner(System.in);\n        int t = 1;\n\/\/        t = s.nextInt();\n        StringBuilder ans = new StringBuilder();\n        int count = 0;\n        int n = s.nextInt();\n        int m = s.nextInt();\n        s.nextLine();\n        Update up[] = new Update[n];\n        while (count < n) {\n\n\n            String str = s.nextLine();\n            up[count] = new Update(str,count+1);\n\n            count++;\n        }\n        Arrays.sort(up);\n\n\n        for ( Update u : up){\n            System.out.print(u.idx+\" \");\n        }\n    }\n\n\n    private static void getInputs(Scanner s, int[] a, int n) throws IOException {\n        for (int i = 0; i < n; i++) {\n            a[i] = s.nextInt();\n        }\n    }\n}\n","import java.io.*;\nimport java.util.*;\n\npublic class compar{\n    \/\/--------------------------INPUT READER--------------------------------\/\/\n    static class fs {\n        public BufferedReader br;\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        public fs() { this(System.in); }\n        public fs(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n        String next() {\n            while (!st.hasMoreTokens()) {\n                try { st = new StringTokenizer(br.readLine()); }\n                catch (IOException e) { e.printStackTrace(); }\n            }\n            return st.nextToken();\n        }\n\n        int ni() { return Integer.parseInt(next()); }\n        long nl() { return Long.parseLong(next()); }\n        double nd() { return Double.parseDouble(next()); }\n        String ns() { return next(); }\n\n        int[] na(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = ni();\n            return a;\n        }\n\n        long[] nal(int n) {\n            long[] l = new long[n];\n            for(int i = 0; i < n; i++) l[i] = nl();\n            return l;\n        }\n    }\n    \/\/-----------------------------------------------------------------------\/\/\n\n    \/\/---------------------------PRINTER-------------------------------------\/\/\n    static class Printer {\n        static PrintWriter w;\n        public Printer() {this(System.out);}\n        public Printer(OutputStream os) {\n            w = new PrintWriter(os);\n        }\n        public void p(int i) {w.println(i);};\n        public void p(long l) {w.println(l);};\n        public void p(double d) {w.println(d);};\n        public void p(String s) { w.println(s);};\n        public void pr(int i) {w.println(i);};\n        public void pr(long l) {w.print(l);};\n        public void pr(double d) {w.print(d);};\n        public void pr(String s) { w.print(s);};\n        public void pl() {w.println();};\n        public void close() {w.close();};\n    }\n    \/\/------------------------------------------------------------------------\/\/\n\n    \/\/--------------------------VARIABLES------------------------------------\/\/\n    static fs sc = new fs();\n    static OutputStream outputStream = System.out;\n    static Printer w = new Printer(outputStream);\n    \/\/-----------------------------------------------------------------------\/\/\n\n    \/\/--------------------------ADMIN_MODE-----------------------------------\/\/\n    private static void ADMIN_MODE() throws IOException {\n        if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n            w = new Printer(new FileOutputStream(\"output.txt\"));\n            sc = new fs(new FileInputStream(\"input.txt\"));\n        }\n    }\n    \/\/-----------------------------------------------------------------------\/\/\n\n    \/\/----------------------------START--------------------------------------\/\/\n    public static void main(String[] args)\n            throws IOException {\n\n        ADMIN_MODE();\n\n\/\/        int t = sc.ni();while(t-->0)\n            solve();\n\n\n        w.close();\n    }\n\n    static void solve() throws IOException {\n        long n = sc.nl(), m = sc.nl();\n        List<obj> li = new ArrayList<>();\n        for(int i = 0; i < n; i++) {\n            li.add(new obj(i, sc.ns().toCharArray()));\n        }\n        Comparator<obj> cmp = new Comparator<>() {\n            public int compare(obj s1, obj s2) {\n                for(int i = 0; i < m; i++) {\n                    if(s1.str[i]==s2.str[i]) continue;\n                    if(i%2==0) {\n                        return Integer.compare(s1.str[i], s2.str[i]);\n                    } else return -1*Integer.compare(s1.str[i], s2.str[i]);\n                }\n                return 0;\n            }\n        };\n        li.sort(cmp);\n        for(int i = 0; i < n; i++) {\n            w.pr((li.get(i).id+1)+\" \");\n        }\n        w.pl();\n    }\n\n    static class obj {\n        int id;\n        char[] str;\n\n        public obj(int id, char[] str) {\n            this.id = id;\n            this.str = str;\n        }\n    }\n}","\nimport javafx.util.Pair;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class A {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = in.nextInt(), m = in.nextInt();\n        ArrayList<Pair<String, Integer>> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(new Pair<>(in.next(), (i + 1)));\n        }\n        Collections.sort(list, (a, b)->{\n            for (int i = 0; i < m; i++) {\n                if (a.getKey().charAt(i) == b.getKey().charAt(i)) continue;\n                if (i % 2 == 0) {\n                    return Integer.compare(a.getKey().charAt(i), b.getKey().charAt(i));\n                }\n                return Integer.compare(b.getKey().charAt(i), a.getKey().charAt(i));\n            }\n            return 0;\n        });\n        for (int i = 0; i < n; i++) {\n            pw.print(list.get(i).getValue() + \" \");\n        }\n        pw.println();\n        pw.close();\n    }\n\n    static void debug(Object... obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<string> arr;\n  for (int i = 0; i < n; i++) {\n    string val;\n    cin >> val;\n    arr.push_back(val);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 1; j < m; j += 2) {\n      arr[i][j] = (char)(90 - (int)arr[i][j] + 65);\n    }\n  }\n  map<string, int> indices;\n  for (int i = 0; i < n; i++) {\n    indices[arr[i]] = i + 1;\n  }\n  sort(arr.begin(), arr.end());\n  for (int i = 0; i < n; i++) {\n    cout << indices[arr[i]] << \" \";\n  }\n  cout << endl;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvector<long long> arr;\nstruct phantu {\n  int l;\n  int r;\n  int d;\n};\nlong long gcd(long long a, long long b) {\n  long long tmp;\n  while (b != 0) {\n    tmp = a % b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n}\nint gcd(int a, int b) {\n  int tmp;\n  while (b != 0) {\n    tmp = a % b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n}\nint isprime(int n) {\n  for (int i = 2; i <= sqrt(n); i++)\n    if (n % i == 0) return 1;\n  return 0;\n}\nint find(vector<pair<int, int>> arr, int l, int r, int x) {\n  if (l > r) return -1;\n  if (arr[l].first >= x) return arr[l].second;\n  if (arr[r].first >= x) return arr[r].second;\n  int a = (l + r) \/ 2;\n  if (arr[a].first >= x)\n    return arr[a].second;\n  else if (arr[a].first < x)\n    return find(arr, a + 1, r, x);\n  else\n    return find(arr, l, a - 1, x);\n}\nint check(string s, int i, int j) {\n  int cnt = 0, cnt1 = 0;\n  for (int k = i; k <= j; k++)\n    if (s[i] == 'a')\n      cnt++;\n    else\n      cnt1++;\n  if (cnt == cnt1) return 1;\n  return 0;\n}\nint mu(int n, int j) {\n  int k = 1;\n  for (int i = 0; i < j; i++) k *= 10;\n  return k;\n}\nint check(int a, int n) {\n  string s = to_string(a), ch = to_string(n);\n  int cnt = 0, i = 0, j = 0;\n  while (i < s.length() && j < ch.length()) {\n    if (ch[j] == s[i]) {\n      i++;\n      cnt++;\n    }\n    j++;\n  }\n  return s.length() + ch.length() - 2 * cnt;\n}\nbool cmp(pair<string, int> a, pair<string, int> b) { return 1; }\nlong long count(long long a, long long x) {\n  long long cnt = 0;\n  while (a % x == 0) {\n    cnt++;\n    a \/= x;\n  }\n  return cnt;\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> arr(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i].first;\n    arr[i].second = i + 1;\n    for (int j = 0; j < m; j++)\n      if (j % 2 != 0) arr[i].first[j] = 'Z' - (arr[i].first[j] - 'A');\n  }\n  sort(arr.begin(), arr.end());\n  for (int i = 0; i < n; i++) cout << arr[i].second << \" \";\n  cout << endl;\n}\nint main() {\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long int mod = 1000000007;\npriority_queue<long long int, vector<long long int>, greater<long long int> >\n    san;\nbool sortBysec(pair<long long int, long long int> a,\n               pair<long long int, long long int> b) {\n  return a.second < b.second;\n}\nbool sortbysecTuple(const tuple<int, int, int>& a,\n                    const tuple<int, int, int>& b) {\n  return (get<1>(a) < get<1>(b));\n}\nlong long int bigMod(long long int a, long long int n, long long int m) {\n  long long int res = 1;\n  while (n) {\n    if (n % 2 == 1) {\n      res = (res * a) % m;\n      n--;\n    } else {\n      a = (a * a) % m;\n      n = n \/ 2;\n    }\n  }\n  return res;\n}\nlong long int power(long long int n, long long int m) {\n  long long int ans = 1;\n  while (m) {\n    ans *= n;\n    m--;\n  }\n  return ans;\n}\nlong long int tree[3 * 200005];\nlong long int query(long long int node, long long int b, long long int e,\n                    long long int i, long long int j) {\n  if (i > e || j < b) {\n    return 0;\n  }\n  if (b >= i && e <= j) return tree[node];\n  long long int l = 2 * node;\n  long long int r = l + 1;\n  long long int m = (b + e) \/ 2;\n  long long int x1 = query(l, b, m, i, j);\n  long long int x2 = query(r, m + 1, e, i, j);\n  return x1 + x2;\n}\nvoid update(long long int node, long long int b, long long int e,\n            long long int i, long long int newval) {\n  if (i > e || i < b) return;\n  if (b >= i && e <= i) {\n    tree[node] += newval;\n    return;\n  }\n  long long int l = 2 * node;\n  long long int r = l + 1;\n  long long int m = (b + e) \/ 2;\n  update(l, b, m, i, newval);\n  update(r, m + 1, e, i, newval);\n  tree[node] = tree[l] + tree[r];\n}\nlong long int uniquePathsWithObstacles(long long int ara[], long long int n,\n                                       long long int m) {\n  long long int path[n + 1][m + 1];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int t = 1, i = 0, n, m, j, l, k, x, y, z, d, a, h, w, b, c, p, e, q,\n                tt = 0, r;\n  while (t--) {\n    cin >> n >> m;\n    vector<long long int> ans;\n    vector<long long int> let[26];\n    string s[n + 5];\n    for (i = 1; i <= n; i++) {\n      cin >> s[i];\n      ans.push_back(i);\n    }\n    for (i = m - 1; i >= 0; i--) {\n      for (j = 0; j < 26; j++) {\n        let[j].clear();\n      }\n      for (j = 1; j <= n; j++) {\n        p = ans[j - 1];\n        x = s[p][i] - 'A';\n        let[x].push_back(ans[j - 1]);\n      }\n      ans.clear();\n      if (i % 2 == 0) {\n        for (j = 0; j <= 25; j++) {\n          for (k = 0; k < let[j].size(); k++) {\n            ans.push_back(let[j][k]);\n          }\n        }\n      } else {\n        for (j = 25; j >= 0; j--) {\n          for (k = 0; k < let[j].size(); k++) {\n            ans.push_back(let[j][k]);\n          }\n        }\n      }\n    }\n    for (i = 0; i < ans.size(); i++) {\n      cout << ans[i] << \" \";\n    }\n    cout << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long int mod = 1000000007;\nlong long int fastmodexp(long long int a, long long int b, long long int c) {\n  long long int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = (res * a) % c;\n    }\n    a = (a * a) % c;\n    b = b >> 1;\n  }\n  return res;\n}\nlong long int fastexp(long long int a, long long int b) {\n  long long int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = (res * a);\n    }\n    a = (a * a);\n    b = b >> 1;\n  }\n  return res;\n}\nlong long int fact(long long int n) {\n  long long int ans[n + 1];\n  ans[0] = ans[1] = 1LL;\n  for (long long int i = 2; i <= n; i++) {\n    ans[i] = (i % mod * ans[i - 1] % mod) % mod;\n  }\n  return ans[n];\n}\nfloat roundoff(float value, unsigned char prec) {\n  float pow_10 = pow(10.0f, (float)prec);\n  return round(value * pow_10) \/ pow_10;\n}\nbool comparator(pair<string, long long int> arr1,\n                pair<string, long long int> arr2) {\n  string a = arr1.first, b = arr2.first;\n  for (long long int i = 0; i < a.size(); i++) {\n    if (a[i] != b[i]) {\n      if ((i + 1) % 2 == 1) {\n        if (a[i] < b[i])\n          return true;\n        else\n          return false;\n      } else {\n        if (a[i] > b[i])\n          return true;\n        else\n          return false;\n      }\n    }\n  }\n  return true;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int t;\n  t = 1;\n  while (t--) {\n    long long int n, m;\n    cin >> n >> m;\n    vector<pair<string, long long int>> arr;\n    for (long long int i = 0; i < n; i++) {\n      string x;\n      cin >> x;\n      arr.push_back(make_pair(x, i + 1));\n    }\n    sort(arr.begin(), arr.end(), comparator);\n    for (long long int i = 0; i < arr.size(); i++) cout << arr[i].second << \" \";\n    cout << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\ntemplate <typename T>\nvoid swap(T &a, T &b) {\n  T tmp = a;\n  a = b;\n  b = tmp;\n}\nchar buffer[2000000];\nint n, m;\nchar *inp[1000000];\nint perm[1000000];\nint bucket[1000000];\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  char *offset = buffer;\n  std::cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    inp[i] = offset;\n    offset += m + 1;\n    std::cin >> std::ws;\n    std::cin.getline(inp[i], 2 * (m + 1));\n    perm[i] = i;\n    bucket[i] = 0;\n  }\n  for (int i = 0; i < m; i++) {\n    int c = 0;\n    while (c < n) {\n      int b = c;\n      if (i % 2 == 0) {\n        for (char ch = 'A'; ch <= 'Z'; ch++) {\n          int buck = b;\n          for (; c < n && bucket[buck] == bucket[c]; c++) {\n            if (inp[perm[c]][i] == ch) {\n              swap(perm[c], perm[b]);\n              b++;\n            }\n          }\n          for (int j = buck; j < b; j++) {\n            bucket[j] = buck;\n          }\n          c = b;\n          if (b < n && bucket[b] != bucket[buck]) {\n            break;\n          }\n        }\n      } else {\n        for (char ch = 'Z'; ch >= 'A'; ch--) {\n          int buck = b;\n          for (; c < n && bucket[buck] == bucket[c]; c++) {\n            if (inp[perm[c]][i] == ch) {\n              swap(perm[c], perm[b]);\n              b++;\n            }\n          }\n          for (int j = buck; j < b; j++) {\n            bucket[j] = buck;\n          }\n          c = b;\n          if (b < n && bucket[b] != bucket[buck]) {\n            break;\n          }\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    std::cout << perm[i] + 1 << \" \";\n  }\n  std::cout << std::endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\ntemplate <typename T, size_t N>\nint SIZE(const T (&t)[N]) {\n  return N;\n}\ntemplate <typename T>\nint SIZE(const T &t) {\n  return t.size();\n}\nstring to_string(const string s, int x1 = 0, int x2 = 1e9) {\n  return '\"' + ((x1 < s.size()) ? s.substr(x1, x2 - x1 + 1) : \"\") + '\"';\n}\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(const bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(const char c) { return string({c}); }\ntemplate <size_t N>\nstring to_string(const bitset<N> &b, int x1 = 0, int x2 = 1e9) {\n  string t = \"\";\n  for (int __iii__ = min(x1, SIZE(b)), __jjj__ = min(x2, SIZE(b) - 1);\n       __iii__ <= __jjj__; ++__iii__) {\n    t += b[__iii__] + '0';\n  }\n  return '\"' + t + '\"';\n}\ntemplate <typename A, typename... C>\nstring to_string(const A(&v), int x1 = 0, int x2 = 1e9, C... coords);\nint l_v_l_v_l = 0, t_a_b_s = 0;\ntemplate <typename A, typename B>\nstring to_string(const pair<A, B> &p) {\n  l_v_l_v_l++;\n  string res = \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n  l_v_l_v_l--;\n  return res;\n}\ntemplate <typename A, typename... C>\nstring to_string(const A(&v), int x1, int x2, C... coords) {\n  int rnk = rank<A>::value;\n  string tab(t_a_b_s, ' ');\n  string res = \"\";\n  bool first = true;\n  if (l_v_l_v_l == 0) res += '\\n';\n  res += tab + \"[\";\n  x1 = min(x1, SIZE(v)), x2 = min(x2, SIZE(v));\n  auto l = begin(v);\n  advance(l, x1);\n  auto r = l;\n  advance(r, (x2 - x1) + (x2 < SIZE(v)));\n  for (auto e = l; e != r; e = next(e)) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    l_v_l_v_l++;\n    if (e != l) {\n      if (rnk > 1) {\n        res += '\\n';\n        t_a_b_s = l_v_l_v_l;\n      };\n    } else {\n      t_a_b_s = 0;\n    }\n    res += to_string(*e, coords...);\n    l_v_l_v_l--;\n  }\n  res += \"]\";\n  if (l_v_l_v_l == 0) res += '\\n';\n  return res;\n}\nvoid dbgm() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgm(Heads H, Tails... T) {\n  cerr << to_string(H) << \" | \";\n  dbgm(T...);\n}\nbool custom_compare(pair<string, int> &a, pair<string, int> &b) {\n  string x = a.first;\n  string y = b.first;\n  int size = x.size();\n  for (int i = 1; i <= size; i++) {\n    if (x[i - 1] == y[i - 1]) continue;\n    if (i & 1) {\n      return x[i - 1] < y[i - 1];\n    } else {\n      return x[i - 1] > y[i - 1];\n    }\n  }\n  return false;\n}\nlong long calc_power(long long n, long long b, long long modd = -1) {\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      if (modd == -1)\n        res = (res * n);\n      else\n        res = (res * n) % modd;\n    }\n    if (modd == -1)\n      n = n * n;\n    else\n      n = n * n % (modd);\n    b >>= 1;\n  }\n  return modd == -1 ? res : res % modd;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return a \/ gcd(a, b) * b; }\nlong long modinv(long long a, long long m) { return calc_power(a, m - 2, m); }\nint n, m;\nvector<pair<string, int>> p;\nvoid testcase() {\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    p.push_back({s, i + 1});\n  }\n  sort(p.begin(), p.end(), custom_compare);\n  for (int i = 0; i < n; i++) cout << p[i].second << \" \";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  ;\n  testcase();\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  vector<pair<string, int> > inputs(n);\n  for (int i = 0; i < n; i++) {\n    pair<string, int> p1;\n    string s;\n    cin >> s;\n    for (int i = 1; i < m; i += 2) {\n      s[i] = ('Z' - (s[i] - 'A')) + 'A';\n    }\n    p1.first = s;\n    p1.second = i;\n    inputs[i] = p1;\n  }\n  sort(inputs.begin(), inputs.end());\n  for (int i = 0; i < n; i++) {\n    cout << inputs[i].second + 1 << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int INF = 1e6;\nconst int maxn = 100;\nconst int LOG = 20;\nconst unsigned long long mod = 1000000007;\nbool comp(pair<string, int> x, pair<string, int> y) {\n  string s1 = x.first;\n  string s2 = y.first;\n  for (int i = 0; i < s1.size(); i++) {\n    if (s1[i] != s2[i]) {\n      if (i % 2 == 0) {\n        return s1[i] < s2[i];\n      } else\n        return s1[i] > s2[i];\n    }\n  }\n}\nvoid solve() {\n  int a, m;\n  cin >> a >> m;\n  vector<pair<string, int>> b(a);\n  for (int i = 0; i < a; i++) {\n    cin >> b[i].first;\n    b[i].second = i + 1;\n  }\n  sort(b.begin(), b.end(), comp);\n  for (int i = 0; i < a; i++) cout << b[i].second << \" \";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t = 1;\n  while (t--) {\n    solve();\n    cout << '\\n';\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001;\nvector<pair<string, int> > v;\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i < (n + 1); i++) {\n    string second;\n    cin >> second;\n    for (int j = 1; j < m; j += 2) {\n      second[j] = 'Z' - (second[j] - 'A');\n    }\n    v.push_back(make_pair(second, i));\n  }\n  sort(v.begin(), v.end());\n  for (int i = 0; i < (v.size()); i++) cout << v[i].second << \" \";\n}\nint main() {\n  solve();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool comp(pair<string, int> a, pair<string, int> b) {\n  for (int i = 0; i < a.first.length(); i++) {\n    if (a.first[i] == b.first[i]) continue;\n    if (i % 2 == 0) return a.first[i] < b.first[i];\n    return a.first[i] > b.first[i];\n  }\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> s(n);\n  for (int i = 0; i < n; i++) {\n    cin >> s[i].first;\n    s[i].second = i + 1;\n  }\n  sort(s.begin(), s.end(), comp);\n  for (int i = 0; i < n; i++) cout << s[i].second << \" \";\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout.precision(6);\n  solve();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint n, m, x;\nbool cmp(pair<int, string> a, pair<int, string> b) {\n  int ind = 0;\n  string as = a.second, ab = b.second;\n  while (as[ind] == ab[ind]) ind++;\n  if (ind % 2 == 0) return as[ind] < ab[ind];\n  return as[ind] > ab[ind];\n}\nint main() {\n  cin >> n >> m;\n  pair<int, string> arr[n], arr2[n];\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i].second;\n    arr[i].first = i + 1;\n    arr2[i].first = i + 1;\n    arr2[i].second = arr[i].second;\n  }\n  sort(arr, arr + n, cmp);\n  for (int i = 0; i < n; i++, x = 0) {\n    cout << arr[i].first << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool isPrime(long long n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long long i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nlong long nextPrime(long long N) {\n  if (N <= 1) return 2;\n  long long prime = N;\n  bool found = false;\n  while (!found) {\n    prime++;\n    if (isPrime(prime)) found = true;\n  }\n  return prime;\n}\nlong long cl(long long n, long long d) { return (n + d - 1) \/ d; }\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return (a * b) \/ (gcd(a, b)); }\nlong long madd(long long a, long long b) {\n  return ((a % 1000000007) + (b % 1000000007)) % 1000000007;\n}\nlong long mmul(long long a, long long b) {\n  return ((a % 1000000007) * (b % 1000000007)) % 1000000007;\n}\nlong long msub(long long a, long long b) {\n  return ((a % 1000000007) - (b % 1000000007) + 1000000007) % 1000000007;\n}\nlong long fpow(long long x, long long y, long long p = 1000000007) {\n  x %= p;\n  long long sum = 1;\n  while (y) {\n    if (y & 1) sum = sum * x;\n    sum %= p;\n    y = y >> 1;\n    x = x * x;\n    x %= p;\n  }\n  return sum;\n}\nbool isPerSquare(long double a) {\n  if (a < 0) return false;\n  long long sr = sqrt(a);\n  return (sr * sr == a);\n}\nstring bin(long long n) { return bitset<64>(n).to_string(); }\nlong long countBits(long long number) { return (long long)log2(number) + 1; }\nbool is(string temp) {\n  char c = temp[0];\n  string s((temp).size(), c);\n  return s <= temp;\n}\nvoid print(std::vector<long long> a) {\n  for (auto i : a) cout << i << \" \";\n  \"\\n\";\n}\nvoid LetsSolveIt() {\n  long long n;\n  cin >> n;\n  long long k;\n  cin >> k;\n  vector<pair<string, long long>> v;\n  for (long long i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    v.push_back(make_pair(s, i + 1));\n  }\n  for (long long j = 1; j < k; j++) {\n    if (j % 2 == 0) continue;\n    for (long long i = 0; i < n; i++) {\n      v[i].first[j] = char(90 - v[i].first[j] + 65);\n    }\n  }\n  sort(v.begin(), v.end());\n  for (long long i = 0; i < n; i++) {\n    cout << v[i].second << \" \";\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  LetsSolveIt();\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool cmp(string x, string y) {\n  for (int i = 0; i < x.size(); ++i) {\n    if (x[i] < y[i] && i & 1) {\n      return x > y;\n    }\n    if (x[i] < y[i] && !(i & 1)) {\n      return x < y;\n    }\n    if (x[i] > y[i] && i & 1) {\n      return x > y;\n    }\n    if (x[i] > y[i] && !(i & 1)) {\n      return x < y;\n    }\n  }\n  return x < y;\n}\nint main() {\n  int n, m;\n  vector<string> vec;\n  map<string, int> mp;\n  cin >> n >> m;\n  for (int i = 0; i < n; ++i) {\n    string x;\n    cin >> x;\n    vec.emplace_back(x);\n    mp[x] = i + 1;\n  }\n  sort(vec.begin(), vec.end(), cmp);\n  for (int i = 0; i < n; ++i) {\n    cout << mp[vec[i]] << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m, t;\n  cin >> n >> m;\n  vector<pair<string, int> > v;\n  string s, mp = \"ZYXWVUTSRQPONMLKJIHGFEDCBA\";\n  for (int i = 1; i <= n; i++) {\n    cin >> s;\n    for (int j = 0; j < m; j++) {\n      if (j & 1) s[j] = mp[s[j] - 'A'];\n    }\n    v.push_back({s, i});\n  }\n  sort(v.begin(), v.end());\n  for (int i = 0; i < n; i++) {\n    if (i != 0) cout << \" \";\n    cout << v[i].second;\n  }\n  cout << endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint m;\nbool comp(pair<string, int> &x, pair<string, int> &y) {\n  string sx = x.first, sy = y.first;\n  int i = 0;\n  while (i < m) {\n    if (sx[i] == sy[i])\n      i++;\n    else\n      return i % 2 ? sx[i] > sy[i] : sx[i] < sy[i];\n  }\n  return true;\n}\nvoid solve() {\n  int n;\n  cin >> n >> m;\n  vector<pair<string, int>> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i].first;\n    v[i].second = i + 1;\n  }\n  sort(v.begin(), v.end(), comp);\n  for (auto &e : v) cout << e.second << \" \";\n  cout << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","n,m=map(int,input().split())\nl=[(lambda x:[i+1,[x[j]if j%2==0 else chr(155-ord(x[j]))for j in range(m)]])(input())for i in range(n)]\nprint(*[i[0]for i in sorted(l,key=lambda x:x[1])])","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long maxn = 1e6;\nvector<pair<string, long long> > v;\nint32_t main() {\n  long long n, m;\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) {\n    string s, t;\n    cin >> s;\n    for (long long j = 0; j < m; j++) {\n      if (j % 2 == 0)\n        t += s[j];\n      else {\n        long long x = s[j] - 'A';\n        x = (25 - x) + 'A';\n        t += char(x);\n      }\n    }\n    v.push_back(pair<string, long long>(t, i));\n  }\n  sort(v.begin(), v.end());\n  for (long long i = 0; i < n; i++) cout << v[i].second << ' ';\n  cout << endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool my_compare(pair<string, long long int> a, pair<string, long long int> b) {\n  long long int n = a.first.length();\n  for (long long int i = 0; i < n; i++) {\n    if (a.first[i] == b.first[i])\n      continue;\n    else if (i % 2 == 0)\n      return a.first[i] < b.first[i];\n    else\n      return b.first[i] < a.first[i];\n  }\n  return a < b;\n}\nint main() {\n  {\n    long long int n, m;\n    cin >> n >> m;\n    vector<pair<string, long long int> > s;\n    for (long long int i = 0; i < n; i++) {\n      string s1;\n      cin >> s1;\n      s.push_back(make_pair(s1, i + 1));\n    }\n    sort(s.begin(), s.end(), my_compare);\n    for (long long int i = 0; i < n; i++) cout << s[i].second << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18;\nconst int imax = INT_MAX;\nconst int imin = INT_MIN;\nconst int mod = 1e9 + 7;\ntemplate <class T>\nvoid _print(vector<T> arr) {\n  cerr << \"[ \";\n  for (auto x : arr) {\n    cerr << x << \" \";\n  }\n  cerr << \"]\";\n  cerr << \"\\n\";\n}\ntemplate <class T, class V>\nvoid _print(map<T, V> map) {\n  cerr << \"{ \\n\";\n  for (auto x : map) {\n    cerr << \"\\t\" << x.first << \" : \" << x.second << \"\\n\";\n  }\n  cerr << \"}\";\n  cerr << \"\\n\";\n}\ntemplate <class T, class V>\nvoid _print(unordered_map<T, V> map) {\n  cerr << \"{ \\n\";\n  for (auto x : map) {\n    cerr << \"\\t\" << x.first << \" : \" << x.second << \"\\n\";\n  }\n  cerr << \"}\";\n  cerr << \"\\n\";\n}\ntemplate <class T, class V>\nvoid _print(pair<T, V> p) {\n  cerr << \"{ \" << p.first << \" \" << p.second << \" }\"\n       << \"\\n\";\n}\ntemplate <class T>\nvoid _print(T x) {\n  cerr << x << \"\\n\";\n}\nbool f(pair<string, int> p1, pair<string, int> p2) {\n  for (int i = 0; i < p1.first.size(); i++) {\n    if (p1.first[i] != p2.first[i]) {\n      if (i % 2) {\n        return p2.first[i] < p1.first[i];\n      } else {\n        return p2.first[i] > p1.first[i];\n      }\n    }\n  }\n  return true;\n}\nvoid solve() {\n  long long n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> ar(n);\n  for (int i = 0; i < n; i++) {\n    string temp;\n    cin >> temp;\n    ar[i].first = temp;\n    ar[i].second = i + 1;\n  }\n  sort(ar.begin(), ar.end(), f);\n  for (int i = 0; i < n; i++) {\n    cout << ar[i].second << \" \";\n  }\n  return;\n}\nint main() {\n  chrono::time_point<chrono::system_clock> start, end;\n  start = chrono::system_clock::now();\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  end = chrono::system_clock::now();\n  chrono::duration<double> elapsed_seconds = end - start;\n  cerr << \"Time Taken : \" << elapsed_seconds.count() << \"s\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int x, y;\n  cin >> x >> y;\n  vector<pair<string, int> > A(x);\n  for (int i = 0; i < x; i++) {\n    string r;\n    cin >> r;\n    for (int j = 1; j < r.size(); j += 2) r[j] = 'Z' - (r[j] - 'A');\n    A[i] = make_pair(r, i + 1);\n  }\n  sort(A.begin(), A.end());\n  for (int i = 0; i < x; i++) cout << A[i].second << (i + 1 == x ? \"\\n\" : \" \");\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> v(n);\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    v[i].first = s;\n    v[i].second = i + 1;\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (j % 2 == 1) {\n        v[i].first[j] = (char)('Z' - v[i].first[j]);\n      }\n    }\n  }\n  sort(v.begin(), v.end());\n  for (int i = 0; i < n; i++) {\n    cout << v[i].second << \" \";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint n, m, o[1000555];\nstring s[1000555];\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) cin >> s[i], o[i] = i;\n  random_shuffle(o + 1, o + 1 + n);\n  sort(o + 1, o + 1 + n, [&](int p, int q) {\n    for (int j = 0; j < m; ++j) {\n      if (s[p][j] != s[q][j]) return (s[p][j] < s[q][j]) ^ (j & 1);\n    }\n    return 0;\n  });\n  for (int i = 1; i <= n; ++i) printf(\"%d \", o[i]);\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> s;\n  for (long long i = 0; i < n; i++) {\n    string k;\n    cin >> k;\n    for (long long j = 0; j < m; j++) {\n      if (j % 2 != 0) {\n        k[j] = 155 - k[j];\n      }\n    }\n    s.push_back({k, i + 1});\n  }\n  sort(s.begin(), s.end());\n  for (long long i = 0; i < n; i++) cout << s[i].second << \" \";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid fast() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n}\nlong long md = 1000000007;\nbool fn(string l, string r) {\n  for (int i = 1; i <= l.size(); i++) {\n    if (l[i - 1] != r[i - 1]) {\n      return (i % 2 && r[i - 1] < l[i - 1] ||\n              i % 2 == 0 && r[i - 1] > l[i - 1]);\n    }\n  }\n}\nint main() {\n  fast();\n  int n, k;\n  cin >> n >> k;\n  vector<string> s;\n  map<string, int> m;\n  for (int i = 0; i < n; i++) {\n    string a;\n    cin >> a;\n    s.push_back(a);\n    m[a] = i + 1;\n  }\n  sort(s.begin(), s.end(), fn);\n  reverse(s.begin(), s.end());\n  for (auto i : s) {\n    cout << m[i] << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  pair<string, int>* arr = new pair<string, int>[n];\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i].first;\n    arr[i].second = i;\n  }\n  bool flag1 = 1, flag2 = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (j % 2) {\n        arr[i].first[j] = 'Z' - arr[i].first[j] + 'A';\n      }\n    }\n  }\n  sort(arr, arr + n);\n  for (int i = 0; i < n; i++) {\n    cout << arr[i].second + 1 << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint n, m;\npair<string, int> s[1010101];\nstring a, b;\nbool cmp(pair<string, int> x, pair<string, int> y) {\n  a = x.first;\n  b = y.first;\n  for (int i = 0; i < m; i++) {\n    if (a[i] == b[i]) {\n      continue;\n    }\n    if (i % 2 == 0) {\n      if (a[i] < b[i]) {\n        return true;\n      }\n      return false;\n    } else {\n      if (a[i] > b[i]) {\n        return true;\n      }\n      return false;\n    }\n  }\n  return true;\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> s[i].first;\n    s[i].second = i + 1;\n  }\n  sort(s, s + n, cmp);\n  for (int i = 0; i < n; i++) {\n    cout << s[i].second << ' ';\n  }\n  cout << endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nconst long long mod = 998244353;\nconst long long maxn = 1e18 + 7;\nusing namespace std;\nlong long power(long long b, long long p) {\n  b %= mod;\n  long long ans = 1;\n  while (p > 0) {\n    if (p % 2 == 1) {\n      ans *= b;\n      ans %= mod;\n    }\n    b *= b;\n    b %= mod;\n    p \/= 2;\n  }\n  return ans;\n}\nbool cstsort(pair<string, long long> a, pair<string, long long> b) {\n  long long j = 0;\n  string s = a.first;\n  string t = b.first;\n  long long n = s.size();\n  while (s[j] == t[j]) j++;\n  if ((j + 1) % 2) {\n    return s[j] < t[j];\n  } else {\n    return s[j] > t[j];\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n, m;\n  cin >> n >> m;\n  string s[n];\n  vector<pair<string, long long>> pa;\n  for (long long i = 0; i < n; i++) {\n    cin >> s[i];\n    pa.push_back({s[i], i});\n  }\n  sort((pa).begin(), (pa).end(), cstsort);\n  long long ans[n];\n  for (long long i = 0; i < n; i++) {\n    cout << (pa[i].second + 1) << \" \";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 50;\nstring a[N];\nchar str[N];\nint b[N];\nint cmp(int x, int y) { return a[x] < a[y]; }\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = (1), _t = (n); i <= _t; ++i) {\n    scanf(\"%s\", str);\n    for (int j = (0), _t = (m - 1); j <= _t; ++j) {\n      if (j % 2 == 0)\n        a[i] += str[j];\n      else\n        a[i] += 'Z' - str[j] + 'A';\n    }\n    b[i] = i;\n  }\n  sort(b + 1, b + n + 1, cmp);\n  for (int i = (1), _t = (n); i <= _t; ++i) printf(\"%d \", b[i]);\n  putchar('\\n');\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid f(vector<int> &v, vector<string> &s, int t = 0) {\n  if (v.empty()) return;\n  if (v.size() == 1) {\n    cout << v[0] + 1 << ' ';\n    return;\n  }\n  vector<vector<int>> vv(26);\n  for (auto &i : v) vv[s[i][t] - 'A'].emplace_back(i);\n  for (auto &i : vv) f(i, s, t + 1);\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  int n, m;\n  cin >> n >> m;\n  vector<string> s(n);\n  for (auto &i : s) {\n    cin >> i;\n    for (int j = 1; j < m; j += 2) i[j] = 155 - i[j];\n  }\n  vector<int> v(n);\n  for (int i = 0; i < n; i++) v[i] = i;\n  f(v, s);\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint n, m;\nstruct node {\n  string s;\n  int id;\n} lt[1000010];\nbool cmp(node a, node b) {\n  for (int i = 0; i < a.s.length(); i++) {\n    if (a.s[i] == b.s[i]) continue;\n    if (i % 2)\n      return a.s[i] > b.s[i];\n    else\n      return a.s[i] < b.s[i];\n  }\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> lt[i].s, lt[i].id = i;\n  sort(lt + 1, lt + n + 1, cmp);\n  for (int i = 1; i <= n; i++) cout << lt[i].id << ' ';\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long int M = 1000000007;\nlong long int Boostpower(long long int x, long long int y, long long int p) {\n  long long int res = 1;\n  x = x % p;\n  if (x == 0) return 0;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nlong long int binarySearch(long long int arr[], long long int l,\n                           long long int r, long long int x) {\n  while (l <= r) {\n    long long int m = l + (r - l) \/ 2;\n    if (arr[m] == x) return m;\n    if (arr[m] < x)\n      l = m + 1;\n    else\n      r = m - 1;\n  }\n  return -1;\n}\nbool sortbysec(const pair<long long int, long long int> &a,\n               const pair<long long int, long long int> &b) {\n  return (a.second < b.second);\n}\nlong long int Stoi(string s) {\n  stringstream geek(s);\n  long long int x = 0;\n  geek >> x;\n  return x;\n}\nlong long int maxPrimeFactors(long long int n) {\n  long long int maxPrime = -1;\n  while (n % 2 == 0) {\n    maxPrime = 2;\n    n >>= 1;\n  }\n  for (long long int i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      maxPrime = i;\n      n = n \/ i;\n    }\n  }\n  if (n > 2) maxPrime = n;\n  return maxPrime;\n}\nlong long int leastdev(long long int n) {\n  for (long long int i = 1; i <= n; i++) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 0;\n}\nbool isPrime(long long int n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long long int i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nlong long int checkperfectsquare(long long int n) {\n  if (ceil((double)sqrtl(n)) == floor((double)sqrtl(n))) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\nlong long int Ceil(long long int a, long long int b) {\n  if (a < 0 || b < 0) {\n    return a \/ b;\n  }\n  if (a % b) {\n    return a \/ b + 1;\n  }\n  return a \/ b;\n}\nvoid primecount(long long int n) {\n  map<long long int, long long int> mp;\n  if (isPrime(n)) {\n    mp[n] = 1;\n  }\n  long long int count = 0;\n  while (!(n % 2)) {\n    n >>= 1;\n    count++;\n  }\n  if (count) {\n    mp[2] = count;\n  }\n  for (long long i = 3; i <= sqrt(n); i += 2) {\n    count = 0;\n    while (n % i == 0) {\n      count++;\n      n = n \/ i;\n    }\n    if (count) {\n      mp[i] = count;\n    }\n  }\n  if (n > 2) {\n    mp[n] = 1;\n  }\n}\nvoid rotate(vector<long long int> &vec, long long int d) {\n  if (d == 0) return;\n  for (long long int i = 0; i < d; i++) {\n    vec.push_back(vec[0]);\n    vec.erase(vec.begin());\n  }\n}\nlong long int binpow(long long int a, long long int b) {\n  long long int res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a;\n    a = a * a;\n    b >>= 1;\n  }\n  return res;\n}\nlong long int mx = 2e5 + 5;\nvector<long long int> fact(mx, 1), inv(mx, 1);\nvoid precompute() {\n  fact[0] = inv[0] = 1;\n  fact[1] = inv[1] = 1;\n  for (long long int i = 2; i < mx; i++) {\n    fact[i] = i * fact[i - 1];\n    fact[i] %= M;\n    long long int inverse = binpow(i, M - 2);\n    inverse %= M;\n    inv[i] = inv[i - 1] * inverse;\n    inv[i] %= M;\n  }\n}\nlong long int ncr(long long int n, long long int r) {\n  long long int ans = (fact[n] * inv[n - r]);\n  ans %= M;\n  ans *= inv[r];\n  ans %= M;\n  ans += M;\n  ans %= M;\n  return ans;\n}\nlong long int andOperator(long long int x, long long int y) {\n  for (long long int i = 0; i < (long long int)log2(y) + 1; i++) {\n    if (y <= x) {\n      return y;\n    }\n    if (y & (1 << i)) {\n      y &= ~(1UL << i);\n    }\n  }\n  return y;\n}\nlong long int ask(long long int l, long long int r) {\n  cout << \"? \";\n  cout << l;\n  cout << \" \";\n  cout << r;\n  cout << endl;\n  cout.flush();\n  long long int x;\n  cin >> x;\n  return x;\n}\nlong long int rangeSum(long long int i, long long int j, long long int pre[]) {\n  if (i == 0) return pre[j];\n  return pre[j] - pre[i - 1];\n}\nvoid output(long long int ans) {\n  cout << \"! \";\n  cout << ans;\n  cout << endl;\n  cout.flush();\n}\nbool matching(char a, char b) {\n  return ((a == '(' && b == ')') || (a == '[' && b == ']') ||\n          (a == '{' && b == '}'));\n}\nbool comparator(pair<long long int, string> p1,\n                pair<long long int, string> p2) {\n  string s1 = p1.second;\n  string s2 = p2.second;\n  for (long long int i = 0; i < s1.size(); i++) {\n    if (s1[i] != s2[i]) {\n      long long int v1 = s1[i] - '0';\n      long long int v2 = s2[i] - '0';\n      if (i % 2) {\n        if (v2 > v1) {\n          return false;\n        } else {\n          return true;\n        }\n      } else {\n        if (v1 > v2) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int t;\n  t = 1;\n  string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n  while (t--) {\n    long long int n, k;\n    cin >> n >> k;\n    vector<pair<long long int, string>> vp;\n    for (long long int i = 0; i < n; i++) {\n      string s1;\n      cin >> s1;\n      vp.push_back({i, s1});\n    }\n    sort(vp.begin(), vp.end(), comparator);\n    for (auto x : vp) {\n      cout << x.first + 1 << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\n","#include <bits\/stdc++.h>\nbool test = false;\nlong long mod1 = 1e9 + 7;\nlong long mod2 = 998244353;\nlong long inf = 1e10 + 5;\nvoid testCase() {\n  long long n, m;\n  std::cin >> n >> m;\n  std::vector<std::pair<std::string, long long>> s(n);\n  for (int i = 0; i <= n - 1; i++) {\n    std::cin >> s[i].first;\n    s[i].second = i;\n  }\n  for (int i = 0; i <= n - 1; i++) {\n    for (int j = 1; j <= m - 1; j += 2) {\n      s[i].first[j] = 'Z' - s[i].first[j] + 'A';\n    }\n  }\n  std::sort(s.begin(), s.end());\n  for (int i = 0; i <= n - 1; i++) {\n    std::cout << s[i].second + 1 << \" \";\n  }\n  std::cout << \"\\n\";\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(NULL);\n  std::cout.precision(15);\n  long long t = 1;\n  if (test) {\n    std::cin >> t;\n  }\n  for (long long i = 0; i <= t - 1; i++) {\n    testCase();\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 1;\nint n, m, p[maxn];\nstring s[maxn];\nbool cmp(int x, int y) {\n  for (int i = 0; i < m; i++) {\n    if (s[x][i] == s[y][i]) continue;\n    if (i % 2 == 0)\n      return s[x][i] < s[y][i];\n    else\n      return s[x][i] > s[y][i];\n  }\n  return false;\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    p[i] = i;\n  }\n  sort(p, p + n, cmp);\n  for (int i = 0; i < n; i++) cout << p[i] + 1 << \" \";\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst int infi = INT_MAX;\nconst long long infll = LLONG_MAX;\nconst long double PI = 3.1415926535897932384626;\nbool cmp(pair<string, int> &p1, pair<string, int> &p2) {\n  for (int i = 0; i < p1.first.length(); i++) {\n    if (p1.first[i] == p2.first[i]) continue;\n    if (i & 1) {\n      return (p1.first[i] > p2.first[i]);\n    }\n    return (p1.first[i] < p2.first[i]);\n  }\n  return true;\n}\nvoid solve(int test_case) {\n  int n, k;\n  cin >> n >> k;\n  vector<pair<string, int>> arr(n);\n  for (int i = 1; i <= n; i++) {\n    string s;\n    cin >> s;\n    arr[i - 1].first = s;\n    arr[i - 1].second = i;\n  }\n  sort(arr.begin(), arr.end(), cmp);\n  for (auto &itr : arr) {\n    cout << itr.second << \" \";\n  }\n  cout << endl;\n}\nint main() {\n  ios_base ::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int tc = 1;\n  while (tc--) solve(tc);\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nunsigned long long m;\nbool cmp(pair<string, unsigned long long> &x,\n         pair<string, unsigned long long> &y) {\n  unsigned long long i;\n  for (i = 0; i < m; i++) {\n    if (i % 2 == 0) {\n      if (x.first[i] != y.first[i]) return x.first[i] < y.first[i];\n    } else {\n      if (x.first[i] != y.first[i]) return x.first[i] > y.first[i];\n    }\n  }\n}\nint main() {\n  unsigned long long n;\n  cin >> n >> m;\n  vector<pair<string, unsigned long long>> res;\n  for (unsigned long long i = 0; i < n; i++) {\n    string buf;\n    cin >> buf;\n    res.push_back(make_pair(buf, i + 1));\n  }\n  sort(res.begin(), res.end(), cmp);\n  for (auto i : res) {\n    cout << i.second << \" \";\n  }\n  return 0;\n}\n","n , m = map(int, input().split())\n\nl = [(lambda x: [i+1,[x[j] if j%2==0 else chr(ord(\"Z\")-ord(x[j])+ord(\"A\")) for j in range(m)]])(input()) for i in range(n)]\nprint(*[i[0] for i in sorted(l, key=lambda x: x[1])])","#include <bits\/stdc++.h>\nusing namespace std;\nint m;\nbool comp(pair<string, int> &x, pair<string, int> &y) {\n  string sx = x.first, sy = y.first;\n  int i = 0;\n  while (i < m) {\n    if (sx[i] == sy[i])\n      i++;\n    else\n      return i % 2 ? sx[i] > sy[i] : sx[i] < sy[i];\n  }\n}\nvoid solve() {\n  int n;\n  cin >> n >> m;\n  vector<pair<string, int>> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i].first;\n    v[i].second = i + 1;\n  }\n  sort(v.begin(), v.end(), comp);\n  for (auto &e : v) cout << e.second << \" \";\n  cout << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","l0 = [chr(x) for x in range(65, 91)]\nl1 = reversed(l0)\ndic = dict(zip(l0, l1))\na, b = map(int, input().split())\nl2 = []\nfor _ in range(a):\n    s = list(input())\n    for i in range(1, b, 2):\n        s[i] = dic[s[i]]\n    l2.append(''.join(s))\nl3 = sorted(range(a), key=lambda x: l2[x])\nfor i in range(a):\n    l3[i] += 1\nprint(*l3)\n","\/\/package codeforces;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class ProblemB {\n    private final static FastScanner scanner = new FastScanner();\n    private final static long M = 1000000007L;\n\n    public static void main(String[] args) throws IOException {\n\/\/        int n = scanner.nextInt();\n\/\/        for (int i = 0; i < n; i++) {\n\/\/            solve();\n\/\/        }\n        solve();\n    }\n\n    public static void solve() {\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        String[] arr = new String[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = scanner.next();\n        }\n        Map<String, Integer> map = new HashMap<>();\n        for (int i = 0; i < arr.length; i++) {\n            map.put(arr[i], i + 1);\n        }\n        Arrays.sort(arr, (o1, o2) -> {\n            for (int i = 0; i < m; i++) {\n                if (o1.charAt(i) == o2.charAt(i)) continue;\n                if ((i + 1) % 2 == 0) {\n                    return o2.charAt(i) - o1.charAt(i);\n                } else {\n                    return o1.charAt(i) - o2.charAt(i);\n                }\n            }\n            return 0;\n        });\n        for (String s : arr) {\n            System.out.print(map.get(s) + \" \");\n        }\n        System.out.println();\n    }\n\n    public static long getManhattanDistance(long x1, long y1, long x2, long y2) {\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n    }\n\n    public static long lcm(long number1, long number2) {\n        if (number1 == 0 || number2 == 0) {\n            return 0;\n        }\n        long absNumber1 = Math.abs(number1);\n        long absNumber2 = Math.abs(number2);\n        long absHigherNumber = Math.max(absNumber1, absNumber2);\n        long absLowerNumber = Math.min(absNumber1, absNumber2);\n        long lcm = absHigherNumber;\n        while (lcm % absLowerNumber != 0) {\n            lcm += absHigherNumber;\n        }\n        return lcm;\n    }\n\n    static void swap(int[] arr, int l, int r) {\n        int temp = arr[l];\n        arr[l] = arr[r];\n        arr[r] = temp;\n    }\n\n    static void swap(long[] arr, int l, int r) {\n        long temp = arr[l];\n        arr[l] = arr[r];\n        arr[r] = temp;\n    }\n\n    private static int getTickSize(char[][] mat, int i, int j) {\n        if (i < 0 || j < 0 || i >= mat.length || j >= mat[0].length || mat[i][j] == '.') return 0;\n        mat[i][j] = '.';\n        return Math.min(getTickSize(mat, i - 1, j - 1), getTickSize(mat, i - 1, j + 1));\n    }\n\n    private static Boolean isSquare(long x) {\n        long y = (long) Math.sqrt(x);\n        return y * y == x;\n    }\n\n    private static int getMax(int[] arr) {\n        int[] copy = Arrays.copyOf(arr, arr.length);\n        Arrays.sort(copy);\n        return copy[arr.length - 1];\n    }\n\n    private static double customLog(double logNumber, double base) {\n        return Math.log(logNumber) \/ Math.log(base);\n    }\n\n\n    static int checkSim(String n1, String n2, int i, int j) {\n        if (i >= n1.length() || j >= n2.length()) return 0;\n        if (n1.charAt(i) == n2.charAt(j)) return 1 + checkSim(n1, n2, i + 1, j + 1);\n        return checkSim(n1, n2, i + 1, j);\n    }\n\n    static int computeXOR(int n) {\n        if (n % 4 == 0)\n            return n;\n        if (n % 4 == 1)\n            return 1;\n        if (n % 4 == 2)\n            return n + 1;\n        return 0;\n    }\n\n    static boolean isPowerOfTwo(long n) {\n        if (n == 0)\n            return false;\n\n        double v = Math.log(n) \/ Math.log(2);\n        return (long) (Math.ceil(v)) == (long) (Math.floor(v));\n    }\n\n    static boolean isPrime(int n) {\n        if (n <= 1)\n            return false;\n\n        else if (n == 2)\n            return true;\n\n        else if (n % 2 == 0)\n            return false;\n\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\n    static boolean checkSorted(int[] arr) {\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i - 1] > arr[i]) return false;\n        }\n        return true;\n    }\n\n    static void print(int from, int to) {\n        if (from <= to) {\n            for (int i = from; i <= to; i++) {\n                System.out.print(i + \" \");\n            }\n        } else {\n            System.out.print(from + \" \");\n            for (int i = 1; i <= to; i++) {\n                System.out.print(i + \" \");\n            }\n        }\n    }\n\n    static long moduloMultiplication(long a, long b, long mod) {\n        long res = 0;\n        a %= mod;\n        while (b > 0) {\n            if ((b & 1) > 0) {\n                res = (res + a) % mod;\n            }\n            a = (2 * a) % mod;\n            b >>= 1;\n        }\n        return res;\n    }\n\n    static long moduloPower(long x, long y, long p) {\n        long res = 1L;\n        x = x % p;\n        while (y > 0) {\n            if ((y & 1) > 0)\n                res = (res * x) % p;\n\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res % p;\n    }\n\n    static int lowerBound(long a[], long x) { \/\/ x is the target value or key\n        int l = -1, r = a.length;\n        while (l + 1 < r) {\n            int m = (l + r) >>> 1;\n            if (a[m] >= x) r = m;\n            else l = m;\n        }\n        return r;\n    }\n\n    static int upperBound(long a[], long x) {\/\/ x is the key or target value\n        int l = -1, r = a.length;\n        while (l + 1 < r) {\n            int m = (l + r) >>> 1L;\n            if (a[m] <= x) l = m;\n            else r = m;\n        }\n        return l + 1;\n    }\n\n    static long upperBound(long[] arr, int start, int end, long k) {\n        int N = end;\n        while (start < end) {\n            int mid = start + (end - start) \/ 2;\n            if (k >= arr[mid]) {\n                start = mid + 1;\n            } else {\n                end = mid;\n            }\n        }\n        if (start < N && arr[start] <= k) {\n            start++;\n        }\n        return start;\n    }\n\n    static long lowerBound(long[] arr, int start, int end, long k) {\n        int N = end;\n        while (start < end) {\n            int mid = start + (end - start) \/ 2;\n            if (k <= arr[mid]) {\n                end = mid;\n            } else {\n                start = mid + 1;\n            }\n        }\n        if (start < N && arr[start] < k) {\n            start++;\n        }\n        return start;\n    }\n\n    static int getDistance(int x1, int y1, int x2, int y2) {\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n    }\n\n    static int sumOfNNaturalNumbers(int n) {\n        return (n * (n + 1)) \/ 2;\n    }\n\n    static long sumOfNNaturalNumbers(long n) {\n        return (n * (n + 1)) \/ 2;\n    }\n\n    static int gcd(int a, int b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}","import java.util.*;\nimport java.io.*;\npublic class Main\n{\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(\n                    new InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() { return Integer.parseInt(next()); }\n\n        long nextLong() { return Long.parseLong(next()); }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    public static void main(String args[]) throws IOException\n    {\n        FastReader scn = new FastReader();\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n        int n = scn.nextInt();\n        int m = scn.nextInt();\n        String[] arr = new String[n];\n\n        int i = 0;\n        HashMap<String, Integer> map = new HashMap<>();\n        while(i < n)\n        {\n            arr[i] = scn.nextLine();\n            map.put(arr[i], i+1);\n            i++;\n        }\n\n        Arrays.sort(arr);\n        i = 1;\n        while(i <= m)\n        {\n            String pre = arr[0].substring(0, i);\n            int j = 0;\n            while(j < n)\n            {\n                int k = j+1;\n                while(k < n)\n                {\n                    if(!arr[k].substring(0, i).equals(arr[j].substring(0, i)))\n                    {\n                        break;\n                    }\n                    k++;\n                }\n\n                int st = j;\n                int en = k;\n                String[] temp_arr = new String[k-j];\n                int index = 0;\n                while(st < en)\n                {\n                    temp_arr[index] = arr[st];\n                    index++;\n                    st++;\n                }\n                Arrays.sort(temp_arr);\n                if(i%2 == 1)\n                {\n                    Arrays.sort(temp_arr, Collections.reverseOrder());\n                }\n                st = j;\n                index = 0;\n                while(st < en)\n                {\n                    arr[st] = temp_arr[index];\n                    index++;\n                    st++;\n                }\n                j = k;\n                if(j < n)\n                {\n                    pre = arr[j].substring(0, i);\n                }\n            }\n            i++;\n        }\n        for(String g: arr)\n        {\n            out.write(map.get(g) + \" \");\n        }\n        out.write(\"\\n\");\n        out.flush();\n    }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool cmp(pair<string, int>& a, pair<string, int>& b) {\n  int i = 0;\n  while (a.first[i] == b.first[i]) {\n    i++;\n  }\n  int x = a.first[i] - 26;\n  int y = b.first[i] - 26;\n  if (i % 2 == 0) {\n    return y > x;\n  } else {\n    return x > y;\n  }\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> s(n);\n  for (int i = 0; i < n; i++) {\n    cin >> s[i].first;\n    s[i].second = i + 1;\n  }\n  sort(s.begin(), s.end(), cmp);\n  for (int i = 0; i < n; i++) {\n    cout << s[i].second << \" \";\n  }\n  cout << endl;\n}\n"]},"incorrect_solutions":{"language":[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,2,2,2,3,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"solution":["#include <bits\/stdc++.h>\nusing namespace std;\nmt19937 rnd(time(0));\nconst long long inf = 0x3f3f3f3f3f3f3f3fLL;\nlong long N = 3e5 + 10;\nconst long long MOD = 1e9 + 7;\nint32_t main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  string s;\n  vector<pair<long long, long long>> a;\n  for (long long i = 0; i < n; i++) {\n    cin >> s;\n    long long c = 0;\n    for (long long j = 0; j < m; j++) {\n      if (j & 1)\n        c -= (s[j] - 'A');\n      else\n        c += (s[j] - 'A');\n    }\n    a.emplace_back(c, i);\n  }\n  sort(a.begin(), a.end());\n  for (auto i : a) cout << i.second + 1 << ' ';\n  cout << '\\n';\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int N = 1e5 + 5;\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  vector<string> in(n);\n  for (auto& x : in) cin >> x;\n  vector<int> order(n);\n  iota(begin(order), end(order), 0);\n  sort(begin(order), end(order), [&](int i, int j) {\n    for (int k = 0; k < m; k++) {\n      if (in[i][k] != in[i][j]) {\n        if (k % 2 == 0) {\n          return in[i][k] < in[j][k];\n        } else {\n          return in[i][k] > in[j][k];\n        }\n      }\n    }\n    return false;\n  });\n  for (int i : order) cout << i + 1 << \"\\n\";\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid sxseven();\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  sxseven();\n  return 0;\n}\nconst int N = 1e6 + 5;\nint m, k;\nstring s[N];\nint a[N];\nbool cmp0(int x, int y) { return s[x][k] < s[y][k]; }\nbool cmp1(int x, int y) { return s[x][k] > s[y][k]; }\nvoid js(int l, int r, int op, int kk) {\n  if (l >= r) return;\n  k = kk;\n  if (op == 0) {\n    sort(a + l, a + r + 1, cmp0);\n  } else {\n    sort(a + l, a + r + 1, cmp1);\n  }\n  if (kk == m - 1) return;\n  int cnt = 1;\n  for (int i = l + 1; i <= r; ++i) {\n    if (s[a[i]][kk] == s[a[i - 1]][kk] &&\n        s[a[i]][kk + 1] != s[a[i - 1]][kk + 1]) {\n      cnt++;\n    } else {\n      if (cnt > 1) {\n        js(i - cnt, i - 1, 1 - op, kk + 1);\n      }\n      cnt = 1;\n    }\n  }\n}\nvoid sxseven() {\n  int n;\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    cin >> s[i];\n    a[i] = i;\n  }\n  js(1, n, 0, 0);\n  for (int i = 1; i <= n; ++i) printf(\"%d \", a[i]);\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nstring str[1000000];\nlong long x;\nbool compare1(long long i1, long long i2) { return (str[i1][x] < str[i2][x]); }\nbool compare2(long long i1, long long i2) { return (str[i1][x] > str[i2][x]); }\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long n, m, i, j, k, l, r;\n  cin >> n >> m;\n  long long ara[n];\n  for (i = 0; i < n; i++) {\n    cin >> str[i];\n    ara[i] = i;\n  }\n  sort(ara, ara + n, compare1);\n  x = 1;\n  for (i = 1; i < m; i++, x++) {\n    l = 0;\n    r = 0;\n    for (j = 0; j < n - 1; j++) {\n      if (str[ara[j]][i - 1] == str[ara[j + 1]][i - 1]) {\n        r++;\n      } else {\n        if (i % 2 == 1) {\n          sort(ara + l, ara + r + 1, compare2);\n        } else {\n          sort(ara + l, ara + r + 1, compare1);\n        }\n        l = r + 1;\n        r = r + 1;\n      }\n    }\n    if (l != r) {\n      if (i % 2 == 1) {\n        sort(ara + l, ara + r + 1, compare2);\n      } else {\n        sort(ara + l, ara + r + 1, compare1);\n      }\n    }\n  }\n  for (i = 0; i < n; i++) {\n    cout << ara[i] + 1;\n    if (i < n - 1) {\n      cout << \" \";\n    } else {\n      cout << \"\\n\";\n    }\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint t, ans = 0, tot = 0, kk = 0;\nconst int mxn = 2e7 + 10, mod = 1e9 + 7;\nbool cmp(string s, string ss) {\n  string s1, s2, ss1, ss2;\n  int i;\n  for (i = 0; i < s.size(); i += 2) s1 += s[i];\n  for (i = 1; i < s.size(); i += 2) s2 += s[i];\n  for (i = 0; i < ss.size(); i += 2) ss1 += ss[i];\n  for (i = 1; i < ss.size(); i += 2) ss2 += ss[i];\n  if (s1 != ss1) return s < ss;\n  return s > ss;\n}\nsigned main() {\n  int n, m, a, b, c, d, e, i, j, k, sm = 0, sm1 = 0, cn = 0, cn1 = 0, mx = -1e9,\n                                    mn = 1e9;\n  string s, ss, sr, sa;\n  bool f = false, ff = true;\n  cin >> n >> m;\n  string str[n];\n  map<string, int> mp;\n  for (i = 0; i < n; i++) cin >> str[i], mp[str[i]] = i + 1;\n  sort(str, str + n, cmp);\n  for (i = 0; i < n; i++) cout << mp[str[i]] << \" \";\n  cout << \"\\n\";\n}\n","#include <bits\/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\nusing namespace std;\nbool compare(pair<string, int>& A, pair<string, int>& B) {\n  int k = A.first.size();\n  bool flag = true;\n  for (int i = 0; i < k; i++) {\n    if ((i + 1) % 2) {\n      if (A.first[i] > B.first[i]) {\n        flag = false;\n        break;\n      }\n    } else {\n      if (A.first[i] < B.first[i]) {\n        flag = false;\n        break;\n      }\n    }\n  }\n  if (A.first == B.first) {\n    if (A.second < B.second) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  return flag;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> A(n);\n  for (int i = 0; i < n; i++) {\n    cin >> A[i].first;\n    A[i].second = i + 1;\n  }\n  sort(A.begin(), A.end(), compare);\n  for (auto it : A) {\n    cout << it.second << \" \";\n  }\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<pair<int, int> > v1;\n  string a1[n];\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    a1[i] = s;\n    pair<int, int> p1;\n    p1.first = 0;\n    p1.second = i + 1;\n    v1.push_back(p1);\n  }\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i % 2 == 0) {\n        v1[j].first += int(a1[j][i]) - 65;\n      } else {\n        v1[j].first += -(int(a1[j][i]) - 90);\n      }\n    }\n  }\n  sort(v1.begin(), v1.end());\n  for (int i = 0; i < n; i++) {\n    cout << v1[i].second << \" \";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\n#include <ext\/pb_ds\/assoc_container.hpp>\n#include <ext\/pb_ds\/tree_policy.hpp>\n\nusing namespace std;\n\nusing namespace __gnu_pbds;\n\nusing ll = long long;\n\ntemplate <typename T>\nusing ordered_set = tree<T, null_type,\n        less<T>, rb_tree_tag,\n        tree_order_statistics_node_update>;\n\nvoid fastIO() {\n\tios::sync_with_stdio(false);\n\tcout.tie(nullptr);\n\tcin.tie(nullptr);\n}\n\nint main() {\n\tfastIO();\n\tint t = 1;\/\/ cin >> t;\n\twhile (t--) {\n\t\tint n, m; cin >> n >> m;\n\t\tvector<string> v(n);\n\t\tvector<int> indices(n);\n\t\tfor (string &s : v) {\n\t\t\tcin >> s;\n\t\t}\n\t\tiota(indices.begin(), indices.end(), 0);\n\t\tsort(indices.begin(), indices.end(), [&v](int i1, int i2) -> bool {\n\t\t\treturn v[i1] < v[i2];\n\t\t});\n\t\tvector<int> ans;\n\t\tfor (int p = 1, i = 0, j = n - 1; i <= j; p ^= 1) {\n\/\/\t\t\tcerr << i << ' ' << j << '\\n';\n\t\t\tif (p) {\n\t\t\t\tans.push_back(indices[i++] + 1);\n\t\t\t} else {\n\t\t\t\tans.push_back(indices[j--] + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcout << ans[i] << (\" \\n\"[i + 1 == n]);\n\t\t}\n\t}\n\treturn 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int mod = (int)1e9 + 7;\nconst long long MOD = 972663749;\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  string second;\n  map<string, set<int>> make_pair;\n  vector<string> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> second;\n    a[i] = second;\n    make_pair[second].insert((i + 1));\n  }\n  sort(a.begin(), a.end());\n  for (int i = 1; i < m; ++i) {\n    if (i & 1) {\n      int l = 0, r = 0;\n      for (int j = 1; j < n; ++j) {\n        if (a[j - 1][i - 1] == a[j][i - 1]) {\n          r = j;\n        } else {\n          sort(a.begin() + l, a.begin() + r + 1, greater<string>());\n          l = j, r = j;\n        }\n      }\n      sort(a.begin() + l, a.begin() + r + 1, greater<string>());\n    } else {\n      int l = 0, r = 0;\n      for (int j = 1; j < n; ++j) {\n        if (a[j - 1][i - 1] == a[j][i - 1]) {\n          r = j;\n        } else {\n          sort(a.begin() + l, a.begin() + r + 1);\n          l = j, r = j;\n        }\n      }\n      sort(a.begin() + l, a.begin() + r + 1);\n    }\n  }\n  vector<int> res;\n  for (int i = 0; i < n; ++i) {\n    auto it = --make_pair[a[i]].end();\n    res.push_back(*it);\n    make_pair[a[i]].erase(it);\n  }\n  for (auto &i : res) cout << i << \" \";\n}\nvoid huykhanh() {\n  int T;\n  T = 1;\n  while (T--) solve();\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  huykhanh();\n  return 0;\n}\n","#include <bits\/stdc++.h>\n#include <ext\/pb_ds\/assoc_container.hpp>\n#include <ext\/pb_ds\/tree_policy.hpp>\n\nusing namespace std;\n\nusing namespace __gnu_pbds;\n\nusing ll = long long;\n\ntemplate <typename T>\nusing ordered_set = tree<T, null_type,\n        less<T>, rb_tree_tag,\n        tree_order_statistics_node_update>;\n\nvoid fastIO() {\n\tios::sync_with_stdio(false);\n\tcout.tie(nullptr);\n\tcin.tie(nullptr);\n}\n\nint main() {\n\tfastIO();\n\tint t = 1;\/\/ cin >> t;\n\twhile (t--) {\n\t\tint n, m; cin >> n >> m;\n\t\tvector<string> v(n);\n\t\tvector<int> indices(n);\n\t\tfor (string &s : v) {\n\t\t\tcin >> s;\n\t\t}\n\t\tiota(indices.begin(), indices.end(), 0);\n\t\tsort(indices.begin(), indices.end(), [&v](int i1, int i2) -> bool {\n\t\t\tconst string &s1 = v[i1];\n\t\t\tconst string &s2 = v[i2];\n\t\t\tconst int n = min(s1.size(), s2.size());\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (s1[i] == s2[i]) { continue; }\n\t\t\t\tif (i & 1) { \/\/ odd in 1-based\n\t\t\t\t\treturn s1[i] < s2[i];\n\t\t\t\t} else { \/\/ even in 1-based\n\t\t\t\t\treturn s2[i] < s1[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false);\n\t\t});\n\t\tfor (int index : indices) {\n\t\t\tcout << index + 1 << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n\treturn 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nusing ll = long long int;\nconst long long MAXN = 1600010;\nvoid fast_stream() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nll power(ll a, ll b) {\n  ll res = 1;\n  while (b > 0) {\n    if (b % 2) {\n      res = (res * a) % 1000000007;\n      --b;\n    } else {\n      a = (a * a) % 1000000007;\n      b = b >> 1;\n    }\n  }\n  return res % 1000000007;\n}\nll max(ll a, ll b) { return a > b ? a : b; }\nint gcd(int a, int b) {\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\nbool myCmp(pair<int, string>& a, pair<int, string>& b) {\n  return a.second < b.second;\n}\nbool isPrime(int x) {\n  if (x <= 1) {\n    return false;\n  }\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> vec;\n  for (int i = 1; i <= n; i++) {\n    string s;\n    cin >> s;\n    vec.push_back({s, i});\n  }\n  for (int i = 0; i < n; i++) {\n    string s = vec[i].first;\n    for (int j = 0; j < m; j++) {\n      if (j % 2) {\n        int c = s[j] - 'A';\n        c = 25 - c;\n        s[j] = 'A' + c;\n      }\n    }\n    vec[i].first = s;\n  }\n  sort(vec.begin(), vec.end());\n  vector<int> ans;\n  for (int i = 0; i < n; i++) {\n    ans.push_back(vec[i].second);\n  }\n  for (auto x : ans) {\n    cout << x << \" \";\n  }\n  cout << '\\n';\n  return;\n}\nint main() {\n  fast_stream();\n  ll t;\n  cin >> t;\n  t = 1;\n  while (t--) {\n    solve();\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001;\nvector<pair<string, int> > v;\nbool cmp(pair<string, int> x, pair<string, int> y) {\n  bool oke = true;\n  string fi = x.first, se = y.first;\n  for (int i = 0; i < (fi.size()); i++) {\n    if (i % 2 == 0) {\n      if (fi[i] > se[i]) oke = false;\n    } else if (fi[i] < se[i])\n      oke = false;\n  }\n  return oke;\n}\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i < (n + 1); i++) {\n    string tmp;\n    cin >> tmp;\n    v.push_back(make_pair(tmp, i));\n  }\n  sort(v.begin(), v.end(), cmp);\n  for (int i = 0; i < (v.size()); i++) cout << v[i].second << \" \";\n}\nint main() {\n  solve();\n  return 0;\n}\n","#include <bits\/stdc++.h>\n#include<ext\/pb_ds\/assoc_container.hpp>\n#include<ext\/pb_ds\/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define For(i, a, b) for (int i = (a); i <= (b); i++)\n#define Forx(i, a, b, x) for (int i = (a); i <= (b); i+=x)\n#define read(a) ll a; cin >> a;\n#define Ford(i, a, b) for (ll i = (a); i >= (b); i--)\n#define pb(a) push_back(a)\n#define pf(a) push_front(a)\n#define fast_io \n#define ll long long int\n#define vi         vector<int>\n#define vll        vector<ll>\n#define vpii       vector<pair<int,int>>\n#define pr         pair<ll,ll>\n#define vpll       vector<pair<ll,ll>>\n#define all(v)     v.begin(),v.end()\n#define sz(container) int((container).size())\n#define cut(x) {cout<<x<<\"\\n\"; continue;}\n#define setprec(x) cout << fixed << showpoint << setprecision(15)<<x<<\"\\n\";\n#define endl '\\n';\n#define fi first\n#define se second\n\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\nvoid __print(int x) {cout << x;}\nvoid __print(long x) {cout << x;}\nvoid __print(long long x) {cout << x;}\nvoid __print(unsigned x) {cout << x;}\nvoid __print(unsigned long x) {cout << x;}\nvoid __print(unsigned long long x) {cout << x;}\nvoid __print(float x) {cout << x;}\nvoid __print(double x) {cout << x;}\nvoid __print(long double x) {cout << x;}\nvoid __print(char x) {cout << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cout << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cout << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cout << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x)\n {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}\ntemplate<typename T>\nvoid __print(const T &x) \n{int f = 0; cout << '{'; for (auto &i: x) cout << (f++ ? \",\" : \"\"), __print(i); cout << \"}\";}\nvoid _print() {cout << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cout << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() \/ CLOCKS_PER_SEC << \" s.\\n\";\n#endif\ntypedef tree<pr,null_type,less<pr>,rb_tree_tag,tree_order_statistics_node_update> ordered_set; \n\n\/\/\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n\n\/\/*s.find_by_order() ->returns an iterator to the k-th largest element (counting from zero);\n\/\/s.order_of_key() ->number of elements strictly smaller then our item;\n\/\/st.rbegin()->second; last element in se\n\/\/st.erase(prev(st.end())); delete last element in set;\n\/\/sort(a+1,a+n+1,[](ll x,ll y){return abs(x)>abs(y);});\n\/\/sort(v.begin(), v.end(), greater<int>()); -> not sure work for first also if second are equal;\n\/\/q=lower_bound(all(v[a[i]]),i)-v[a[i]].begin()+1;\n\/\/ s.substr(start_ind,length);\n\/\/ vpll shift={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}} ->shift operator;\n\/\/bool comp(pr a,pr b){return a.second<b.second;} \/\/ use for differentiate order of comparision;\n\/\/ cntbit(x) __builtin_popcount(x); -> no. of bits in given no.;\n\/\/ true false; memset(dp,-1,sizeof(dp));\n\/\/ std::random_shuffle(all(vec));\n\n\/\/\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\nconst ll Maxn=2e5+5;\nconst ll Inf=1e18;\n\n\n\nvector<int> sort_cyclic_shifts(string const& s) \n{\n    int n = s.size();\n    const int alphabet = 256;\n     vector<int> p(n), c(n), cnt(max(alphabet, n), 0);\n\n    \/\/ Basic step 0th iteration\n\n    for (int i = 0; i < n; i++)\n        cnt[s[i]]++;\n    for (int i = 1; i < alphabet; i++)\n        cnt[i] += cnt[i-1];\n    for (int i = 0; i < n; i++)\n        p[--cnt[s[i]]] = i;\n    c[p[0]] = 0;\n    int classes = 1;\n    for (int i = 1; i < n; i++) {\n        if (s[p[i]] != s[p[i-1]])\n            classes++;\n        c[p[i]] = classes - 1;\n    }\n\n    \/\/ basic iteration ends\n    \n\n    vector<int> pn(n), cn(n);\n\n    for (int h = 0; (1 << h) < n; ++h) \n    {\n      \/\/ kth iteration form k-1th;\n\n        for (int i = 0; i < n; i++) {\n            pn[i] = p[i] - (1 << h);\n            if (pn[i] < 0)\n                pn[i] += n;\n        }\n        fill(cnt.begin(), cnt.begin() + classes, 0);\n        for (int i = 0; i < n; i++)\n            cnt[c[pn[i]]]++;\n        for (int i = 1; i < classes; i++)\n            cnt[i] += cnt[i-1];\n        for (int i = n-1; i >= 0; i--)\n            p[--cnt[c[pn[i]]]] = pn[i];\n        cn[p[0]] = 0;\n        classes = 1;\n        for (int i = 1; i < n; i++) {\n            pair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};\n            pair<int, int> prev = {c[p[i-1]], c[(p[i-1] + (1 << h)) % n]};\n            if (cur != prev)\n                ++classes;\n            cn[p[i]] = classes - 1;\n        }\n        c.swap(cn);\n    }\n\n    \/\/ done all steps;\n\n    return p;\n\n}\n\n\nvector<int> suffix_array_construction(string s) \n{\n    s += \"$\";\n    vector<int> sorted_shifts = sort_cyclic_shifts(s);\n    sorted_shifts.erase(sorted_shifts.begin());\n    return sorted_shifts;\n}\n\nvector<int> lcp_construction(string const& s, vector<int> const& p) {\n    int n = s.size();\n    vector<int> rank(n, 0);\n    for (int i = 0; i < n; i++)\n        rank[p[i]] = i;\n\n    int k = 0;\n    vector<int> lcp(n-1, 0);\n    for (int i = 0; i < n; i++) {\n        if (rank[i] == n - 1) {\n            k = 0;\n            continue;\n        }\n        int j = p[rank[i] + 1];\n        while (i + k < n && j + k < n && s[i+k] == s[j+k])\n            k++;\n        lcp[rank[i]] = k;\n        if (k)\n            k--;\n    }\n    return lcp;\n}\n\n\nstruct sparse_table\n{\n  vector<vector<int>> st;\n  vector<int> lt;\n\n  sparse_table(vector<int> & vec)\n  {\n    int n=vec.size();\n    int k=log2(n);\n    st.resize(n,vector<int>(k+1));\n\n    for (int i = 0; i < n; i++)\n    st[i][0] = vec[i];\n\n    for (int j = 1; j <= k; j++)\n    for (int i = 0; i + (1 << j) <= n; i++)\n    st[i][j] = min(st[i][j-1], st[i + (1 << (j - 1))][j - 1]);\n\n   \/\/ fill log table;\n   \n   lt.resize(n+1);\n   lt[1]=0;\n   for (int i = 2; i <= n; i++)\n   lt[i] = lt[i\/2] + 1;\n\n  }\n\n  int query(int l,int r)\n  {\n    int p=lt[r-l+1];\n\n    return min(st[l][p],st[r-(1<<p)+1][p]);\n  }\n};\n\nint main()\n{\n  ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);\n  \/\/\u201cone of them is all alone and ever more shall be so\u201d;\n  #ifndef ONLINE_JUDGE\n  freopen(\"input.txt\", \"r\", stdin);\n  freopen(\"output.txt\", \"w\", stdout);\n  #endif\n  \n  \/\/ we need lcp,lcs,range min,haromoic values;\n\n  \/\/ all take nlogn time;\n\n  string s; cin>>s;\n  int n=s.size();\n  \n  if(n==1)\n  {\n    cout<<1;\n    return 0;\n  }\n\n  string str=s;\n  reverse(all(str));\n\n  vi p = suffix_array_construction(s);\n  vi lcp = lcp_construction(s,p);\n\n  vi p1 = suffix_array_construction(str);\n  vi lcs = lcp_construction(str,p1);\n  \n\n  For(i,0,n-1) p1[i]=n-1-p1[i];\n\n  vi idp(n),ids(n); \/\/ mapping of each ind with corr posn in p;\n  For(i,0,n-1) idp[p[i]]=i,ids[p1[i]]=i;\n  \n  sparse_table lcs_table(lcs);\n  sparse_table lcp_table(lcp);\n  \n  int ans=1;\n  \n  debug(lcp);\n  debug(p);\n  debug(lcs);\n  debug(p1);\n\n  For(len,1,n)\n  {\n    \/\/ can we change here for len->k to k->len;\n    \/\/ oh yeah\n    \n    Forx(i,0,n-1,len)\n    {\n      \n      int idl1=idp[i];\n      int idr1=idp[i];\n      \n      int idl2=ids[i];\n      int idr2=ids[i];\n      \n      \/\/ we can slide it tho\n\n      For(k,1,n) \/\/ k+1 consecutive;\n      {\n        if(i+k*len>=n) break;\n\n        idl1=min(idl1,idp[i+k*len]);\n        idr1=max(idr1,idp[i+k*len]);\n\n        int Lcp=lcp_table.query(idl1,idr1-1);\n        \n        idl2=min(idl2,ids[(i+k*len)]);\n        idr2=max(idr2,ids[(i+k*len)]);\n\n        int Lcs=lcs_table.query(idl2,idr2-1);\n\n        int curr=min(Lcs,len)+min(Lcp,len)-len;\n\n        if(curr>0)\n        {\n          ans=max(ans,k+1);\n          debug(len,i,k+1);\n        }\n      }\n\n    }\n\n    debug(len,ans);\n  }\n\n  cout<<ans;\n  \n\n }","\/*\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2593\u2593\u2593\u2593\u2588\u2593\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2593\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u256c\u256c\u256c\u256c\u256c\u256c\u2588\u2588\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2588\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2588\u2588\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u256c\u256c\u2593\u2593\u2593\u2593\u2593\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u256c\u256c\u256c\u256c\u2593\u2593\u2593\u2593\u2593\u2593\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2588\u2593\u2593\u2593\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2588\u2588\u2593\u2593\u2593\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2588\u2593\u2593\u2593\u2593\u2588\u2588\u2593\u2593\u2593\u2593\u2588\u2588\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2588\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2588\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2588\u2593\u256c\u2593\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2588\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2588\u2588\u2588\u2588\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2588\u2593\u2588\u2588\u2588\u2593\u2593\u2593\u2588\u2588\u2588\u2588\u256c\u2593\u2588\u2593\u2593\u256c\u256c\u256c\u2593\u2593\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2588\u2588\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u256c\u256c\u256c\u2593\u2593\u256c\u2593\u2593\u2588\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2588\u2593\u2593\u2593\u2593\u2593\u2588\u2588\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2588\u2593\u2593\u2593\u256c\u2593\u2588\u2588\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2588\u2593\u2593\u2593\u2593\u2588\u2588\u2588\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2588\u2588\u2588\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u256c\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2588\u2588\u2593\u2593\u256c\u256c\u256c\u256c\u256c\u256c\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n *\/\n\/*\n  ______  __    __ __       __ ________ _______       __    __  ______   ______   ______   ______  __    __\n \/      \\|  \\  |  \\  \\     \/  \\        \\       \\     |  \\  |  \\\/      \\ \/      \\ \/      \\ \/      \\|  \\  |  \\\n|  \u2593\u2593\u2593\u2593\u2593\u2593\\ \u2593\u2593  | \u2593\u2593 \u2593\u2593\\   \/  \u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\\    | \u2593\u2593  | \u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\\  \u2593\u2593\u2593\u2593\u2593\u2593\\  \u2593\u2593\u2593\u2593\u2593\u2593\\  \u2593\u2593\u2593\u2593\u2593\u2593\\ \u2593\u2593\\ | \u2593\u2593\n| \u2593\u2593__| \u2593\u2593 \u2593\u2593__| \u2593\u2593 \u2593\u2593\u2593\\ \/  \u2593\u2593\u2593 \u2593\u2593__   | \u2593\u2593  | \u2593\u2593    | \u2593\u2593__| \u2593\u2593 \u2593\u2593__| \u2593\u2593 \u2593\u2593___\\\u2593\u2593 \u2593\u2593___\\\u2593\u2593 \u2593\u2593__| \u2593\u2593 \u2593\u2593\u2593\\| \u2593\u2593\n| \u2593\u2593    \u2593\u2593 \u2593\u2593    \u2593\u2593 \u2593\u2593\u2593\u2593\\  \u2593\u2593\u2593\u2593 \u2593\u2593  \\  | \u2593\u2593  | \u2593\u2593    | \u2593\u2593    \u2593\u2593 \u2593\u2593    \u2593\u2593\\\u2593\u2593    \\ \\\u2593\u2593    \\| \u2593\u2593    \u2593\u2593 \u2593\u2593\u2593\u2593\\ \u2593\u2593\n| \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\\\u2593\u2593 \u2593\u2593 \u2593\u2593 \u2593\u2593\u2593\u2593\u2593  | \u2593\u2593  | \u2593\u2593    | \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593_\\\u2593\u2593\u2593\u2593\u2593\u2593\\_\\\u2593\u2593\u2593\u2593\u2593\u2593\\ \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\\\u2593\u2593 \u2593\u2593\n| \u2593\u2593  | \u2593\u2593 \u2593\u2593  | \u2593\u2593 \u2593\u2593 \\\u2593\u2593\u2593| \u2593\u2593 \u2593\u2593_____| \u2593\u2593__\/ \u2593\u2593    | \u2593\u2593  | \u2593\u2593 \u2593\u2593  | \u2593\u2593  \\__| \u2593\u2593  \\__| \u2593\u2593 \u2593\u2593  | \u2593\u2593 \u2593\u2593 \\\u2593\u2593\u2593\u2593\n| \u2593\u2593  | \u2593\u2593 \u2593\u2593  | \u2593\u2593 \u2593\u2593  \\\u2593 | \u2593\u2593 \u2593\u2593     \\ \u2593\u2593    \u2593\u2593    | \u2593\u2593  | \u2593\u2593 \u2593\u2593  | \u2593\u2593\\\u2593\u2593    \u2593\u2593\\\u2593\u2593    \u2593\u2593 \u2593\u2593  | \u2593\u2593 \u2593\u2593  \\\u2593\u2593\u2593\n \\\u2593\u2593   \\\u2593\u2593\\\u2593\u2593   \\\u2593\u2593\\\u2593\u2593      \\\u2593\u2593\\\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\\\u2593\u2593\u2593\u2593\u2593\u2593\u2593      \\\u2593\u2593   \\\u2593\u2593\\\u2593\u2593   \\\u2593\u2593 \\\u2593\u2593\u2593\u2593\u2593\u2593  \\\u2593\u2593\u2593\u2593\u2593\u2593 \\\u2593\u2593   \\\u2593\u2593\\\u2593\u2593   \\\u2593\u2593\n\n\n\n __    __                         __ __                          __                    ______   ______  _______   ______       __\n|  \\  |  \\                       |  \\  \\                        |  \\                  \/      \\ \/      \\|       \\ \/      \\     |  \\\n| \u2593\u2593  | \u2593\u2593 ______   ______   ____| \u2593\u2593\\\u2593\u2593_______   ______       _| \u2593\u2593_    ______      |  \u2593\u2593\u2593\u2593\u2593\u2593\\  \u2593\u2593\u2593\u2593\u2593\u2593\\ \u2593\u2593\u2593\u2593\u2593\u2593\u2593\\  \u2593\u2593\u2593\u2593\u2593\u2593\\     \\\u2593\u2593 _______  ______\n| \u2593\u2593__| \u2593\u2593\/      \\ |      \\ \/      \u2593\u2593  \\       \\ \/      \\     |   \u2593\u2593 \\  \/      \\     | \u2593\u2593__| \u2593\u2593 \u2593\u2593   \\\u2593\u2593 \u2593\u2593__\/ \u2593\u2593 \u2593\u2593   \\\u2593\u2593    |  \\\/       \\|      \\\n| \u2593\u2593    \u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\\ \\\u2593\u2593\u2593\u2593\u2593\u2593\\  \u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\\  \u2593\u2593\u2593\u2593\u2593\u2593\\     \\\u2593\u2593\u2593\u2593\u2593\u2593 |  \u2593\u2593\u2593\u2593\u2593\u2593\\    | \u2593\u2593    \u2593\u2593 \u2593\u2593     | \u2593\u2593    \u2593\u2593 \u2593\u2593          | \u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593 \\\u2593\u2593\u2593\u2593\u2593\u2593\\\n| \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593    \u2593\u2593\/      \u2593\u2593 \u2593\u2593  | \u2593\u2593 \u2593\u2593 \u2593\u2593  | \u2593\u2593 \u2593\u2593  | \u2593\u2593      | \u2593\u2593 __| \u2593\u2593  | \u2593\u2593    | \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593   __| \u2593\u2593\u2593\u2593\u2593\u2593\u2593| \u2593\u2593   __     | \u2593\u2593\\\u2593\u2593    \\ \/      \u2593\u2593\n| \u2593\u2593  | \u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593__| \u2593\u2593 \u2593\u2593 \u2593\u2593  | \u2593\u2593 \u2593\u2593__| \u2593\u2593      | \u2593\u2593|  \\ \u2593\u2593__\/ \u2593\u2593    | \u2593\u2593  | \u2593\u2593 \u2593\u2593__\/  \\ \u2593\u2593     | \u2593\u2593__\/  \\    | \u2593\u2593_\\\u2593\u2593\u2593\u2593\u2593\u2593\\  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\n| \u2593\u2593  | \u2593\u2593\\\u2593\u2593     \\\\\u2593\u2593    \u2593\u2593\\\u2593\u2593    \u2593\u2593 \u2593\u2593 \u2593\u2593  | \u2593\u2593\\\u2593\u2593    \u2593\u2593       \\\u2593\u2593  \u2593\u2593\\\u2593\u2593    \u2593\u2593    | \u2593\u2593  | \u2593\u2593\\\u2593\u2593    \u2593\u2593 \u2593\u2593      \\\u2593\u2593    \u2593\u2593    | \u2593\u2593       \u2593\u2593\\\u2593\u2593    \u2593\u2593\n \\\u2593\u2593   \\\u2593\u2593 \\\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \\\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \\\u2593\u2593\u2593\u2593\u2593\u2593\u2593\\\u2593\u2593\\\u2593\u2593   \\\u2593\u2593_\\\u2593\u2593\u2593\u2593\u2593\u2593\u2593        \\\u2593\u2593\u2593\u2593  \\\u2593\u2593\u2593\u2593\u2593\u2593      \\\u2593\u2593   \\\u2593\u2593 \\\u2593\u2593\u2593\u2593\u2593\u2593 \\\u2593\u2593       \\\u2593\u2593\u2593\u2593\u2593\u2593      \\\u2593\u2593\\\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \\\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n                                                |  \\__| \u2593\u2593\n                                                 \\\u2593\u2593    \u2593\u2593\n                                                  \\\u2593\u2593\u2593\u2593\u2593\u2593\n\n *\/\n\n#include<bits\/stdc++.h>\nusing namespace std;\n#define ll                  long long\n#define ld                  long double\n#define f(i,n)              for(ll i=0;i<(n);i++)\n#define f1(i,n)             for(ll i=1;i<=n;i++)\n#define el  \t            \"\\n\"\n#define sq(a)               (a)*(a)\n#define pb                  push_back\n#define asort(a,n)          sort(a,a+n)\n#define dsort(a,n)          sort(a,a+n,greater<>())\n#define vasort(v)           sort(v.begin(), v.end());\n#define vdsort(v)           sort(v.begin(), v.end(),greater<>());\n#define cina(arr)           f(i,n) cin >> arr[i];\n#define YES                 cout << \"YES\\n\"\n#define Yes                 cout << \"Yes\"<<el\n#define yes                 cout << \"yes\"<<el\n#define NO                  cout << \"NO\\n\"\n#define No                  cout << \"No\"<<el\n#define no                  cout << \"no\"<<el\n#define covid19             ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define rep(i, begin, end)  for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n#define TC                  int t; cin >> t; while(t--)\n\ntypedef pair<int,int> pii;\ntypedef map<int,int>mii;\ntypedef vector<int>vi;\ntypedef vector<pii>vii;\ntypedef set<int> si;\ntypedef set<char> sc;\n\nconst double pi=acos(-1);\n\nbool as_second(const pair<ll,ll> &a, const pair<ll,ll> &b) {return (a.second < b.second); }\/\/sort the vector pair in assending order according to second element\nbool ds_first(const pair<ll,ll> &a, const pair<ll,ll> &b){ return (a.first > b.first);}\/\/sort the vector pair in decending order according to first element\nbool ds_second(const pair<ll,ll> &a, const pair<ll,ll> &b) {return a.second>b.second;}\/\/sort the vector pair in decending order according to second element\n\nbool isPrime(ll n)\n{\n    if (n < 1)\n        return false;\n    for (int i = 2; i <= sqrt(n); i++)\n        if (n % i == 0)\n            return false;\n    return true;\n}\nll factorial(ll n)\n{\n    if (n == 0)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\nbool primeFactors(int n, int l, int r, bool notFound)\n{\n    for (int i = l; i <= r; i++)\n    {\n        if (i == 1)\n            i++;\n        if (n % i == 0)\n        {\n            cout << i << \" \";\n            notFound = false;\n        }\n        while (n % i == 0)\n        {\n            n = n \/ i;\n        }\n    }\n    return notFound;\n}\nbool IsInBinarySequence(ll number) {\n    ll numberToCheck = 1;\n    do {\n        if (number == numberToCheck) return true;\n        numberToCheck *= 2;\n    } while (numberToCheck <= number);\n    return false;\n}\nll nextPowerOf2(ll n)\n{\n    if (n && !(n & (n - 1)))\n        return n;\n    ll cnt = 0;\n    while (n != 0)\n    {\n        n >>= 1;\n        cnt++;\n    }\n    ll x = 1;\n    x = x << cnt;\n    return x;\n}\nll highestPowerof2(ll n)\n{\n    ll res = 0;\n    for (ll i = n; i >= 1; i--)\n    {\n        \/\/ If i is a power of 2\n        if ((i & (i - 1)) == 0)\n        {\n            res = i;\n            break;\n        }\n    }\n    return res;\n}\n\nvector<ll> first50fib1_1_2()\n{\n    vector<ll>v = { 1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155, 165580141 ,267914296 ,433494437 ,701408733 ,1134903170 ,1836311903 ,2971215073 ,4807526976 ,7778742049,12586269025,20365011074 };\n    return v;\n}\nvoid first50fib0_0_1()\n{\n    ll arr[51]={0, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368,75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049};\n}\nll fib(ll n) {\n    if (n == 1)\n        return 0;\n    if (n == 2)\n        return 1;\n    return fib(n - 1) + fib(n - 2);\n}\nll binets_formula(ll n) {\n    double sqrt5 = sqrt(5);\n\n    int F_n = (pow((1 + sqrt5), n) - pow((1 - sqrt5), n)) \/ (pow(2, n) * sqrt5);\n\n    return F_n;\n}\n\n\/*const int N = 1e7;\nbool prime[N+3];\nvoid Sieve() {\n    memset(prime, true, sizeof(prime));\n\n    for (int p = 2; p * p <= N; p++) {\n        if (prime[p]) {\n            for (int i = p * p; i <= N; i += p)\n                prime[i] = false;\n        }\n    }\n}\n*\/\n\/*\nvoid Sieve(int n) {\n    memset(prime, true, sizeof(prime));\n    prime[0] = prime[1] = false;\n    for (int i = 2; i <= n; i++) {\n        if (prime[i]) {\n            for (int j = 2 * i; j <= n; j += i) {\n                prime[j] = false;\n            }\n        }\n    }\n}\n *\/\n\nvoid firstLuckyto1e9()\n{\n    vector<ll>v = { 4, 7, 44, 47, 74, 77, 444, 447, 474, 477, 744, 747, 774, 777, 4444, 4447, 4474, 4477, 4744, 4747, 4774, 4777, 7444, 7447\n            , 7474, 7477, 7744, 7747, 7774, 7777, 44444, 44447, 44474, 44477, 44744, 44747, 44774, 44777, 47444, 47447, 47474, 47477\n            , 47744, 47747, 47774, 47777, 74444, 74447, 74474, 74477, 74744, 74747, 74774, 74777, 77444, 77447, 77474, 77477, 77744,\n                    77747, 77774, 77777, 444444, 444447, 444474, 444477, 444744, 444747, 444774, 444777, 447444, 447447, 447474, 447477, 447744, 447747, 447774, 447777, 474444, 474447, 474474, 474477, 474744, 474747, 474774, 474777, 477444, 477447, 477474, 477477, 477744, 477747, 477774, 477777, 744444, 744447, 744474, 744477, 744744, 744747, 744774, 744777, 747444, 747447, 747474, 747477, 747744, 747747, 747774, 747777, 774444, 774447, 774474, 774477, 774744, 774747, 774774, 774777, 777444, 777447, 777474, 777477, 777744, 777747, 777774, 777777, 4444444, 4444447, 4444474, 4444477, 4444744, 4444747, 4444774, 4444777, 4447444, 4447447, 4447474, 4447477, 4447744, 4447747, 4447774, 4447777, 4474444, 4474447, 4474474, 4474477, 4474744, 4474747, 4474774, 4474777, 4477444, 4477447, 4477474, 4477477, 4477744, 4477747, 4477774, 4477777, 4744444, 4744447,\n                    4744474, 4744477, 4744744, 4744747, 4744774, 4744777, 4747444, 4747447, 4747474, 4747477, 4747744, 4747747, 4747774, 4747777, 4774444, 4774447, 4774474, 4774477, 4774744, 4774747, 4774774, 4774777, 4777444, 4777447, 4777474, 4777477, 4777744, 4777747, 4777774, 4777777, 7444444, 7444447, 7444474, 7444477, 7444744, 7444747, 7444774, 7444777, 7447444, 7447447,\n                    7447474, 7447477, 7447744, 7447747, 7447774, 7447777, 7474444, 7474447, 7474474, 7474477, 7474744, 7474747, 7474774, 7474777, 7477444, 7477447, 7477474, 7477477, 7477744, 7477747, 7477774, 7477777, 7744444, 7744447, 7744474, 7744477, 7744744, 7744747, 7744774, 7744777, 7747444, 7747447, 7747474, 7747477, 7747744, 7747747, 7747774, 7747777, 7774444, 7774447,\n                    7774474, 7774477, 7774744, 7774747, 7774774, 7774777, 7777444, 7777447, 7777474, 7777477, 7777744, 7777747, 7777774, 7777777, 44444444, 44444447, 44444474, 44444477, 44444744, 44444747, 44444774, 44444777, 44447444, 44447447, 44447474, 44447477, 44447744, 44447747, 44447774, 44447777, 44474444, 44474447, 44474474, 44474477, 44474744, 44474747, 44474774, 44474777, 44477444, 44477447, 44477474, 44477477, 44477744, 44477747, 44477774, 44477777, 44744444, 44744447, 44744474, 44744477, 44744744, 44744747, 44744774, 44744777, 44747444, 44747447, 44747474, 44747477, 44747744, 44747747, 44747774, 44747777, 44774444, 44774447, 44774474, 44774477, 44774744, 44774747, 44774774, 44774777, 44777444, 44777447, 44777474, 44777477, 44777744, 44777747, 44777774, 44777777, 47444444, 47444447, 47444474, 47444477, 47444744, 47444747, 47444774, 47444777, 47447444, 47447447, 47447474, 47447477, 47447744, 47447747, 47447774, 47447777, 47474444, 47474447, 47474474, 47474477, 47474744, 47474747, 47474774, 47474777, 47477444, 47477447, 47477474, 47477477, 47477744, 47477747, 47477774, 47477777, 47744444, 47744447, 47744474, 47744477, 47744744, 47744747, 47744774, 47744777, 47747444, 47747447, 47747474, 47747477, 47747744, 47747747, 47747774, 47747777, 47774444, 47774447, 47774474, 47774477, 47774744, 47774747, 47774774, 47774777, 47777444, 47777447, 47777474, 47777477, 47777744, 47777747, 47777774, 47777777, 74444444, 74444447, 74444474, 74444477, 74444744, 74444747, 74444774, 74444777, 74447444, 74447447, 74447474, 74447477, 74447744, 74447747, 74447774, 74447777, 74474444, 74474447, 74474474, 74474477, 74474744, 74474747, 74474774, 74474777, 74477444, 74477447, 74477474, 74477477, 74477744, 74477747, 74477774, 74477777, 74744444, 74744447, 74744474, 74744477, 74744744, 74744747, 74744774, 74744777, 74747444, 74747447, 74747474, 74747477, 74747744, 74747747, 74747774, 74747777, 74774444, 74774447, 74774474, 74774477, 74774744, 74774747, 74774774, 74774777, 74777444, 74777447, 74777474, 74777477, 74777744, 74777747, 74777774, 74777777, 77444444, 77444447, 77444474, 77444477, 77444744, 77444747, 77444774, 77444777, 77447444, 77447447, 77447474, 77447477, 77447744, 77447747, 77447774, 77447777, 77474444, 77474447, 77474474, 77474477, 77474744, 77474747, 77474774, 77474777, 77477444, 77477447, 77477474, 77477477, 77477744, 77477747, 77477774, 77477777, 77744444, 77744447, 77744474, 77744477, 77744744, 77744747, 77744774, 77744777, 77747444, 77747447, 77747474, 77747477, 77747744, 77747747, 77747774, 77747777, 77774444, 77774447, 77774474, 77774477, 77774744, 77774747, 77774774, 77774777, 77777444, 77777447, 77777474, 77777477, 77777744, 77777747, 77777774, 77777777, 444444444, 444444447, 444444474, 444444477, 444444744, 444444747, 444444774, 444444777, 444447444, 444447447, 444447474, 444447477, 444447744, 444447747, 444447774, 444447777, 444474444, 444474447, 444474474, 444474477, 444474744, 444474747, 444474774, 444474777, 444477444, 444477447, 444477474, 444477477, 444477744, 444477747, 444477774, 444477777, 444744444, 444744447, 444744474, 444744477, 444744744, 444744747, 444744774, 444744777, 444747444, 444747447, 444747474, 444747477, 444747744, 444747747, 444747774, 444747777, 444774444, 444774447, 444774474, 444774477, 444774744, 444774747, 444774774, 444774777, 444777444, 444777447, 444777474, 444777477, 444777744, 444777747, 444777774, 444777777, 447444444, 447444447, 447444474, 447444477, 447444744, 447444747, 447444774, 447444777, 447447444, 447447447, 447447474, 447447477, 447447744, 447447747, 447447774, 447447777, 447474444, 447474447, 447474474, 447474477, 447474744, 447474747, 447474774, 447474777, 447477444, 447477447, 447477474, 447477477, 447477744, 447477747,447477774, 447477777, 447744444, 447744447, 447744474, 447744477, 447744744, 447744747, 447744774, 447744777, 447747444,447747447, 447747474, 447747477, 447747744, 447747747, 447747774, 447747777, 447774444, 447774447, 447774474, 447774477\n            , 447774744, 447774747, 447774774, 447774777, 447777444, 447777447, 447777474, 447777477, 447777744, 447777747, 447777774, 447777777, 474444444, 474444447, 474444474, 474444477, 474444744, 474444747, 474444774, 474444777, 474447444, 474447447, 474447474, 474447477, 474447744, 474447747, 474447774, 474447777, 474474444, 474474447, 474474474, 474474477, 474474744, 474474747, 474474774, 474474777, 474477444, 474477447, 474477474, 474477477, 474477744, 474477747, 474477774, 474477777, 474744444, 474744447, 474744474, 474744477, 474744744, 474744747, 474744774, 474744777, 474747444, 474747447, 474747474, 474747477, 474747744, 474747747, 474747774, 474747777, 474774444, 474774447, 474774474, 474774477, 474774744, 474774747, 474774774, 474774777, 474777444, 474777447, 474777474, 474777477, 474777744, 474777747, 474777774, 474777777, 477444444, 477444447, 477444474, 477444477, 477444744, 477444747, 477444774, 477444777, 477447444, 477447447, 477447474, 477447477, 477447744, 477447747, 477447774, 477447777, 477474444, 477474447, 477474474, 477474477, 477474744, 477474747,477474774, 477474777, 477477444, 477477447, 477477474, 477477477, 477477744, 477477747, 477477774, 477477777, 477744444,477744447, 477744474, 477744477, 477744744, 477744747, 477744774, 477744777, 477747444, 477747447, 477747474, 477747477\n            , 477747744, 477747747, 477747774, 477747777, 477774444, 477774447, 477774474, 477774477, 477774744, 477774747, 477774774, 477774777, 477777444, 477777447, 477777474, 477777477, 477777744, 477777747, 477777774, 477777777, 744444444, 744444447, 744444474, 744444477, 744444744, 744444747, 744444774, 744444777, 744447444, 744447447, 744447474, 744447477, 744447744, 744447747, 744447774, 744447777, 744474444, 744474447, 744474474, 744474477, 744474744, 744474747, 744474774, 744474777, 744477444, 744477447, 744477474, 744477477, 744477744, 744477747, 744477774, 744477777, 744744444, 744744447, 744744474, 744744477, 744744744, 744744747, 744744774, 744744777, 744747444, 744747447, 744747474, 744747477, 744747744, 744747747, 744747774, 744747777, 744774444, 744774447, 744774474, 744774477, 744774744, 744774747, 744774774, 744774777, 744777444, 744777447, 744777474, 744777477, 744777744, 744777747, 744777774, 744777777, 747444444, 747444447, 747444474, 747444477, 747444744, 747444747, 747444774, 747444777, 747447444, 747447447, 747447474, 747447477, 747447744, 747447747,747447774, 747447777, 747474444, 747474447, 747474474, 747474477, 747474744, 747474747, 747474774, 747474777, 747477444,747477447, 747477474, 747477477, 747477744, 747477747, 747477774, 747477777, 747744444, 747744447, 747744474, 747744477\n            , 747744744, 747744747, 747744774, 747744777, 747747444, 747747447, 747747474, 747747477, 747747744, 747747747, 747747774, 747747777, 747774444, 747774447, 747774474, 747774477, 747774744, 747774747, 747774774, 747774777, 747777444, 747777447, 747777474, 747777477, 747777744, 747777747, 747777774, 747777777, 774444444, 774444447, 774444474, 774444477, 774444744, 774444747, 774444774, 774444777, 774447444, 774447447, 774447474, 774447477, 774447744, 774447747, 774447774, 774447777, 774474444, 774474447, 774474474, 774474477, 774474744, 774474747, 774474774, 774474777, 774477444, 774477447, 774477474, 774477477, 774477744, 774477747, 774477774, 774477777, 774744444, 774744447, 774744474, 774744477, 774744744, 774744747, 774744774, 774744777, 774747444, 774747447, 774747474, 774747477, 774747744, 774747747, 774747774, 774747777, 774774444, 774774447, 774774474, 774774477, 774774744, 774774747, 774774774, 774774777, 774777444, 774777447, 774777474, 774777477, 774777744, 774777747, 774777774, 774777777, 777444444, 777444447, 777444474, 777444477, 777444744, 777444747,\n                    777444774, 777444777, 777447444, 777447447, 777447474, 777447477, 777447744, 777447747, 777447774, 777447777, 777474444,\n                    777474447, 777474474, 777474477, 777474744, 777474747, 777474774, 777474777, 777477444, 777477447, 777477474, 777477477\n            , 777477744, 777477747, 777477774, 777477777, 777744444, 777744447, 777744474, 777744477, 777744744, 777744747, 777744774, 777744777, 777747444, 777747447, 777747474, 777747477, 777747744, 777747747, 777747774, 777747777, 777774444, 777774447, 777774474, 777774477, 777774744, 777774747, 777774774, 777774777, 777777444, 777777447, 777777474, 777777477, 777777744, 777777747, 777777774, 777777777, 4444444444 };\n\n}\nvoid  luckyGenerator() {\n    vector<ll> lucky;\n    lucky.pb(0);\n    int idx = 0;\n    while (lucky.back() < 1e10) {\n        lucky.push_back(((lucky[idx] * 10) + 4));\n        lucky.push_back((lucky[idx] * 10) + 7);\n        idx++;\n    }\n}\nint binarySearch(int a[], int first, int last, int search_num) {\n    int middle;\n    if (last >= first) {\n        middle = (first + last) \/ 2;\n        \/\/Checking if the element is present at middle loc\n        if (a[middle] == search_num)\n            return middle + 1;\n\n            \/\/Checking if the search element is present in greater half\n        else if (a[middle] < search_num)\n            return binarySearch(a, middle + 1, last, search_num);\n\n            \/\/Checking if the search element is present in lower half\n        else\n            return binarySearch(a, first, middle - 1, search_num);\n    }\n    return -1;\n}\nvoid factorize(long long n) {\n    int count = 0;\n    while (!(n % 2)) {\n        n \/= 2;\n        count++;\n    }\n    if (count)\n        cout << 2 << \"^\" << count << endl;\n    for (long long i = 3; i <= sqrt(n); i += 2) {\n        count = 0;\n        while (n % i == 0) {\n            count++;\n            n = n \/ i;\n        }\n        if (count)\n            cout << i << \"^\" << count << endl;\n    }\n    if (n > 2)\n        cout << n << \"^\" << 1 << endl;\n}\nvoid primeFactors(ll num) {\n    ll fac = 2;\n    while (num > 1) {\n        if (num % fac == 0) {\n            cout << fac << \" \";\n            num \/= fac;\n            ll pow = 1;\n            while (num % fac == 0) {\n                num \/= fac;\n                pow++;\n            }\n            cout << pow << el;\n        }\n        else {\n            fac++;\n        }\n    }\n}\nbool onePrimeFactor(ll num) {\n    ll fac = 2;\n    int cnt = 0;\n    while (num > 1) {\n        if (num % fac == 0) {\n            cnt++;\n            while (num % fac == 0)\n                num \/= fac;\n        } else\n            fac++;\n        if (cnt >= 2)\n            return false;\n    }\n    return true;\n}\nbool isPerfect(ll d)\n{\n    double temp = d;\n    d = sqrt(d);\n    temp = sqrt(temp);\n    if (temp == d)\n        return true;\n    return false;\n}\nvoid sort(string s[], int n)\/\/sort string according to length\n{\n    for (int i = 1; i < n; i++)\n    {\n        string temp = s[i];\n        int j = i - 1;\n        while (j >= 0 && temp.length() < s[j].length())\n        {\n            s[j + 1] = s[j];\n            j--;\n        }\n        s[j + 1] = temp;\n    }\n}\nbool IsPowerOfTwo(ll x)\n{\n    return (x & (x - 1)) == 0;\n}\nint binarySearchCount(ll arr[], int n, ll key)\n{\n    int left = 0, right = n;\n\n    int mid;\n    while (left < right) {\n        mid = (right + left) >> 1;\n\n        if (arr[mid] == key) {\n            while (mid + 1 < n && arr[mid + 1] == key)\n                mid++;\n            break;\n        }\n\n        else if (arr[mid] > key)\n            right = mid;\n\n        else\n            left = mid + 1;\n    }\n\n    while (mid > -1 && arr[mid] > key)\n        mid--;\n\n    return mid + 1;\n}\nint countOnesInBin(ll n) {\n    int cnt = 0;\n    while (n) {\n        cnt += n & 1;\n        n >>= 1;\n    }\n    return cnt;\n}\nstring convertToBinary(ll x) {\n    string s;\n    while (x > 0) {\n        if (x % 2)\n            s += '1';\n        else\n            s += '0';\n        x \/= 2;\n    }\n    reverse(s.begin(), s.end());\n    return s;\n}\nll convertToDecimal(string s) {\n    reverse(s.begin(), s.end());\n    ll ans = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == '1')\n            ans += (1 << i);\n    }\n    return ans;\n}\nlong long lcm(int a, int b)\n{\n    return (a \/ __gcd(a, b)) * b;\n}\nbool palindrome(string s) {\n    for (int i = 0; i < s.length() \/ 2; i++) {\n        if (s[i] != s[s.length() - i - 1])\n            return false;\n    }\n    return true;\n}\nint sumOfDigits(ll n) {\n    int sum = 0;\n    string s = to_string(n);\n    f(i, s.length())sum += s[i] - '0';\n    return sum;\n}\nbool isUnique(ll x) {\n    int size = log10(x) + 1;\n    set<int> s;\n    while (x > 0) {\n        s.insert(x % 10);\n        x \/= 10;\n    }\n    if (s.size() == size)\n        return true;\n    else\n        return false;\n}\nvoid subString(string s, int n) {\n    for (int i = 0; i < n; i++)\n        for (int len = 1; len <= n - i; len++)\n            cout << s.substr(i, len) << el;\n}\n\nbool sortByVal(const pair<string, int> &a,\n               const pair<string, int> &b)\n{\n    return (a.second > b.second);\n}\n\nll Round(double n) {\n    ll y = n;\n    if (y == n)\n        return y;\n    else\n        return y + 1;\n}\nbool isLetter(char x) {\n    if (x >= 'A' && x <= 'Z')\n        return true;\n    else if (x >= 'a' && x <= 'z')\n        return true;\n    else\n        return false;\n}\nint findLastIndex(string& str, char x)\n{\n    int index = -1;\n    for (int i = 0; i < str.length(); i++)\n        if (str[i] == x)\n            index = i;\n    return index;\n}\nbool isVowel(char c) {\n    c = tolower(c);\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'u' || c == 'o' || c == 'y')\n        return true;\n    else\n        return false;\n}\nbool isOdd(char c) {\n    if (c == '1' || c == '3' || c == '5' || c == '7' || c == '9')\n        return true;\n    else\n        return false;\n}\nll sum(ll n) {\n    ll sum = (n * (n + 1)) \/ 2;\n    return sum;\n}\nll sumInRange(ll l , ll r) {\n    ll ans = sum(r) - sum(l - 1);\n    return ans;\n}\nbool sortedAsc(ll arr[],ll n) {\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[i-1])\n            return false;\n    }\n    return true;\n}\nbool sortedDesc(ll arr[],ll n) {\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > arr[i - 1])\n            return false;\n    }\n    return true;\n}\nll decimalDigitRoot(ll n) {\n    return ((n - 1) % 9) + 1;\n}\n\nconst ll mod = 1e9 + 7;\nconst int mod1 = 1e9 + 7;\nconst int inf = 1e9 + 10;\n\nbool equal(char x , char y) {\n    if (x == '.')\n        return true;\n    return x == y;\n}\nstring add(string s , int n) {\n    string temp = \"\";\n    while (n--)\n        temp += s;\n    return temp;\n}\nbool regularBracketSequence(string s) {\n    stack<char> s1;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '(')\n            s1.push('(');\n        else {\n            if (s1.empty())\n                return false;\n            else\n                s1.pop();\n        }\n    }\n    return s1.empty();\n}\nbool sumDigits(int n) {\n    int rem = 0;\n    while (n) {\n        rem += n % 10;\n        n \/= 10;\n    }\n    return rem == 10;\n}\nbool sortedA(int arr[],int n) {\n    for (int i = 1; i < n; i++)\n        if (arr[i] < arr[i - 1])\n            return false;\n    return true;\n}\nbool sortedD(int arr[],int n) {\n    for (int i = 1; i < n; i++)\n        if (arr[i] > arr[i - 1])\n            return false;\n    return true;\n}\n\n\/\/int ans[N];\n\/*\nvector<int>adjList[N];\nint dfs(int node,int parent) {\n    visited[node] = true;\n    for (auto adjNode : adjList[node]) {\n        if (!visited[adjNode]) {\n            group.pb(adjNode);\n            dfs(adjNode, node);\n        }\n        else if (visited[adjNode] && adjNode != parent)\n            return 1;\n    }\n    return 0;\n}\n *\/\n\/*\nvoid bfs(int node) {\n    queue<int> q;\n    q.push(node);\n    visited[node] = 1;\n    while (!q.empty()) {\n        group.pb(q.front());\n        for (auto adjNode : adjList[q.front()])\n            if (!visited[adjNode])\n                q.push(adjNode), visited[adjNode] = 1;\n        q.pop();\n    }\n}\n\nvoid dijkstra(int source, vector<vector<pair<int,int>>>&graph) {\n    int n = graph.size();\n    vector<int> dist(n, inf), pre(n, -1);\n    \/\/ cost , node\n    priority_queue<pair<int, int>> nextToVisit;\n\n    dist[source] = 0;\n    pre[source] = source;\n    nextToVisit.push({0, source});\n\n    while (!nextToVisit.empty()) {\n        int u = nextToVisit.top().second;\n        nextToVisit.pop();\n        if (visited[u])continue;\n        visited[u] = 1;\n        for (auto e : graph[u]) {\n            int v = e.first;\n            int c = e.second;\n            if (dist[u] + c < dist[v]) {\n                dist[v] = dist[u] + c;\n                pre[v] = u;\n                nextToVisit.push({-dist[v], v});\n            }\n        }\n    }\n}\n*\/\nstring onlyAlphaString(string s) {\n    string temp = \"\";\n    for (int i = 0; i < s.size(); i++)\n        if (isalpha(s[i]))temp += tolower(s[i]);\n    return temp;\n}\nint computeXOR(ll a) {\n    if (a % 4 == 0) return a;\n    else if (a % 4 == 1) return 1;\n    else if (a % 4 == 2) return a + 1;\n    else return 0;\n}\nvoid sort3(int& a, int& b, int& c) {\n    if (a > b)swap(a, b);\n    if (b > c)swap(b, c);\n    if (a > b)swap(a, b);\n}\nint lis(vector<int>&a) {\n    int n = a.size();\n    vector<int> dp(n, 1);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < i; j++)\n            if (a[j] < a[i])dp[i] = max(dp[i], dp[j] + 1);\n    int ans = dp[0];\n    for (int i = 1; i < n; i++)ans = max(ans, dp[i]);\n    return ans;\n}\nbool oneCharacterString(string s) {\n    vasort(s);\n    return s[0] == s[s.size() - 1];\n}\n \/\/ #pragma GCC optimize(\"O3\")\n\n int main() {\n     covid19\n     int n, m;\n     cin >> n >> m;\n     vector<pair<string, int>> v(n);\n     f(i, n) {\n         cin >> v[i].first;\n         v[i].second = i + 1;\n     }\n     if (m > 1) {\n         for (int i = 0; i < n; i++)\n             v[i].first[1] = ('Z' - v[i].first[1]) + 'A';\n     }\n     vasort(v);\n     f(i, n) cout << v[i].second << \" \";\n }\n\n\n\/*  NOTESSS\ndecimal digit root ::\n d(n)=1+((n\u22121)mod9)\n *\/\n\n\/*\n Staff to Remember :\n\n1) STRING :\n     substr()\n     find()\n     size()\n     length()\n *\/","#include <bits\/stdc++.h>\nusing namespace std;\nint t, n, m;\npair<string, int> p[1000001];\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    string s;\n    cin >> s;\n    for (int j = 1; j < m; j += 2) s[j] = 155 - s[j];\n    p[i] = {s, i};\n  }\n  sort(p + 1, p + n + 1);\n  for (int i = 0; i <= n; i++) cout << p[i].second << ' ';\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int p = 1e9 + 7;\nconst int N = 2e5 + 10;\nint n, k, a[N];\nvector<pair<int, int> > g[N];\ninline void A(int &x, int y) { x = (x + y >= p ? x + y - p : x + y); }\ninline void U(int &x, int y) { x = (x > y ? x : y); }\nint del[N], si[N];\nint mnsi, mnid;\ninline void GetSi(int x, int fa) {\n  si[x] = 1;\n  for (auto e : g[x])\n    if (e.second != fa && !del[e.second]) {\n      GetSi(e.second, x);\n      si[x] += si[e.second];\n    }\n}\ninline void GetMx(int x, int fa, int al) {\n  int mx = al - si[x];\n  for (auto e : g[x])\n    if (e.second != fa && !del[e.second]) {\n      mx = max(mx, si[e.second]);\n      GetMx(e.second, x, al);\n    }\n  if (mx < mnsi) mnsi = mx, mnid = x;\n}\nint f1[N], f2[N], sw1, sw2;\nint ans;\nvoid PushIn(int x, int fa, int fe, int sm, int sw, int *f, int &mxsw) {\n  if (sw > k) return;\n  if (sw > mxsw) f[sw] = f[mxsw], mxsw = sw;\n  A(sm, a[x]);\n  A(f[sw], sm);\n  for (auto e : g[x]) {\n    int y = e.second, z = e.first;\n    if (del[y] || y == fa) continue;\n    PushIn(y, x, z, sm, sw + (fe != z), f, mxsw);\n  }\n}\ninline int Get(int *f, int sz, int y) { return f[y <= sz ? y : sz]; }\nvoid Calc(int x, int fa, int fe, int sm, int sw) {\n  if (sw > k) return;\n  if (sw < k)\n    ans = (ans +\n           1ll * sm * (Get(f1, sw1, k - sw - 1) - Get(f2, sw2, k - sw - 1))) %\n          p;\n  A(sm, a[x]);\n  ans = (ans + 1ll * sm * Get(f2, sw2, k - sw)) % p;\n  for (auto e : g[x]) {\n    int y = e.second, z = e.first;\n    if (del[y] || y == fa) continue;\n    Calc(y, x, z, sm, sw + (fe != z));\n  }\n}\ninline void Solve(int x) {\n  GetSi(x, 0);\n  mnsi = 1e9;\n  GetMx(x, 0, si[x]);\n  int u = mnid;\n  printf(\"Solve %d\\n\", u);\n  sw1 = 0, sw2 = 0;\n  A(f1[0], a[u]);\n  A(f2[0], a[u]);\n  ++ans;\n  int la = -1;\n  for (auto e : g[u]) {\n    int y = e.second, z = e.first;\n    if (z != la) {\n      for (int i = 0; i <= sw2; ++i) f2[i] = 0;\n      sw2 = 0;\n      la = z;\n      A(f2[0], a[u]);\n    }\n    if (del[y]) continue;\n    Calc(y, x, z, 0, 0);\n    PushIn(y, x, z, a[u], 0, f1, sw1);\n    PushIn(y, x, z, a[u], 0, f2, sw2);\n  }\n  printf(\"ans = %d\\n\", ans);\n  for (int i = 0; i <= sw1; ++i) f1[i] = 0;\n  del[u] = 1;\n  for (auto e : g[u])\n    if (!del[e.second]) Solve(e.second);\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n  for (int i = 1, x, y, z; i < n; ++i) {\n    scanf(\"%d%d%d\", &x, &y, &z);\n    g[x].push_back(pair<int, int>(z, y));\n    g[y].push_back(pair<int, int>(z, x));\n  }\n  for (int i = 1; i <= n; ++i) sort(g[i].begin(), g[i].end());\n  Solve(1);\n  if (ans < 0) ans += p;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool isPrime(long long n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long long i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nlong long nextPrime(long long N) {\n  if (N <= 1) return 2;\n  long long prime = N;\n  bool found = false;\n  while (!found) {\n    prime++;\n    if (isPrime(prime)) found = true;\n  }\n  return prime;\n}\nlong long cl(long long n, long long d) { return (n + d - 1) \/ d; }\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return (a * b) \/ (gcd(a, b)); }\nlong long madd(long long a, long long b) {\n  return ((a % 1000000007) + (b % 1000000007)) % 1000000007;\n}\nlong long mmul(long long a, long long b) {\n  return ((a % 1000000007) * (b % 1000000007)) % 1000000007;\n}\nlong long msub(long long a, long long b) {\n  return ((a % 1000000007) - (b % 1000000007) + 1000000007) % 1000000007;\n}\nlong long fpow(long long x, long long y, long long p = 1000000007) {\n  x %= p;\n  long long sum = 1;\n  while (y) {\n    if (y & 1) sum = sum * x;\n    sum %= p;\n    y = y >> 1;\n    x = x * x;\n    x %= p;\n  }\n  return sum;\n}\nbool isPerSquare(long double a) {\n  if (a < 0) return false;\n  long long sr = sqrt(a);\n  return (sr * sr == a);\n}\nstring bin(long long n) { return bitset<64>(n).to_string(); }\nlong long countBits(long long number) { return (long long)log2(number) + 1; }\nbool is(string temp) {\n  char c = temp[0];\n  string s((temp).size(), c);\n  return s <= temp;\n}\nvoid print(std::vector<long long> a) {\n  for (auto i : a) cout << i << \" \";\n  \"\\n\";\n}\nvoid LetsSolveIt() {\n  long long n;\n  cin >> n;\n  long long k;\n  cin >> k;\n  vector<pair<string, long long>> v;\n  for (long long i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    v.push_back(make_pair(s, i + 1));\n  }\n  sort(v.begin(), v.end());\n  for (long long j = 1; j < k; j++) {\n    for (long long i = 1; i < n; i++) {\n      long long temp = i - 1;\n      while (i < n && v[i].first[j - 1] == v[i - 1].first[j - 1]) i++;\n      for (long long k = 0; k < (i - temp) \/ 2; k++) {\n        swap(v[k + temp], v[i - k - 1]);\n      }\n    }\n  }\n  for (long long i = 0; i < n; i++) {\n    cout << v[i].second << \" \";\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  LetsSolveIt();\n}\n","#include<bits\/stdc++.h>\n#include <ext\/pb_ds\/assoc_container.hpp>\n#include <ext\/pb_ds\/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <class K,class V> using omap = tree<K, V, less<K>, rb_tree_tag, tree_order_statistics_node_update>;\nvoid __print(int x){cout<<x;}void __print(long long x){cout<<x;}\nvoid __print(double x){cout<<x;}void __print(long double x){cout<<x;}\nvoid __print(char x){cout<<'\\''<<x<<'\\'';}void __print(const char *x){cout<<'\\\"'<<x<<'\\\"';}\nvoid __print(const string &x){cout<<'\\\"'<<x<<'\\\"';}void __print(bool x){cout<<(x?\"True\":\"False\");}\ntemplate<typename T,typename V>\nvoid __print(const pair<T,V>&x){cout<<'{';__print(x.first);cout<<',';__print(x.second);cout<<'}';}\ntemplate<typename T>\nvoid __print(const T &x){int f=0;cout<<'{';for(auto &i:x)cout<<(f++?\",\":\"\"),__print(i);cout<<\"}\";}\nvoid _print(){cout<<\"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cout << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n\n#define lp(i,a,b)       for (int i=a;i<=b;i++)\n#define rp(i,a,b)       for (int i=a;i>=b;i--)\n#define ms(a,x)         memset(a,x,sizeof a)\n\/\/#define int             long long \n#define ff              first\n#define ss              second\n#define all(a)          a.begin(),a.end()\n#define rall(a)         a.rbegin(),a.rend()\n#define pb              push_back\n#define nl              cout<<\"\\n\"\n#define index           find_by_order\n#define less            order_of_key\n#define gcd(a,b)        __gcd((a),(b))\n#define lcm(a,b)        (((a)*(b))\/(gcd(a,b)))\n#define sq(a)           ((a)*(a))\n#define sz(a)           (int) a.size()\n#define mod             1000000007\nconst int N=1e6+5;\nstring arr[N];\nint n,m;\nbool cmp(string& a,string& b)\n{\n  lp(i,0,m-1)\n  {\n    if(a[i]==b[i])\n      continue;\n    if(i%2==0)\n      return a[i]<b[i];\n    else\n      return a[i]>b[i];\n  }\n  return 1;\n}\nvoid mergE(int l , int mid , int r)\n{\n    vector < string > lef , rig;\n    for(int i = l ; i<=mid ; i++) lef.push_back(arr[i]);\n    for(int i = mid + 1 ; i<=r ; i++) rig.push_back(arr[i]);\n \n    int i = 0 , j = 0, cur = l; \n    while(i<lef.size() && j<rig.size()){\n        if(cmp(lef[i],rig[j])){\n            arr[cur] = lef[i];\n            i++;\n        }\n        else{\n            arr[cur] = rig[j];\n            j++;\n        }\n        cur++;\n    }\n \n    while(i<lef.size()){\n        arr[cur] = lef[i];\n        i++;\n        cur++;\n    }\n \n    while(j<rig.size()){\n        arr[cur] = rig[j];\n        cur++;\n        j++;\n    }\n \n}\n \nvoid merge_sort(int l, int r)\n{\n    if(l<r)\n    {\n      int mid = (l+r)\/2;\n      merge_sort(l,mid);\n      merge_sort(mid+1,r);\n      mergE(l,mid,r);\n    }\n}\nvoid solve()\n{\n  cin>>n>>m;\n  lp(i,1,n)\n  {\n    cin>>arr[i];\n    arr[i]+=(char)(i+'0');\n  }\n  merge_sort(1,n);\n  lp(i,1,n)\n    cout<<arr[i].back()<<' ';\n}\n\nsigned main()\n{\n  ios_base::sync_with_stdio(false); \n  cin.tie(NULL); cout.tie(NULL);\n  int T=1; \n  \/\/cin>>T;\n  while(T--) solve();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nlong long int mod = 1000000007;\nbool cmp(pair<string, long long int> &a, pair<string, long long int> &b) {\n  int cnt1 = 0, cnt2 = 0;\n  for (int i = 0; i < a.first.size(); i++) {\n    if (i % 2 == 0) {\n      if (a.first[i] == b.first[i]) {\n        continue;\n      } else if (a.first[i] > b.first[i]) {\n        cnt2++;\n      } else {\n        cnt1++;\n      }\n    } else {\n      if (a.first[i] == b.first[i]) {\n        continue;\n      } else if (a.first[i] > b.first[i]) {\n        cnt1++;\n      } else {\n        cnt2++;\n      }\n    }\n  }\n  return cnt2 < cnt1;\n}\nvoid solve() {\n  long long int n, m;\n  cin >> n >> m;\n  string s;\n  vector<pair<string, long long int>> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i].first;\n    v[i].second = i + 1;\n  }\n  sort(v.begin(), v.end(), cmp);\n  ;\n  for (auto it : v) {\n    cout << it.second << \" \";\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  solve();\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid fail(string s) {\n  cout << s;\n  exit(0);\n}\nvoid fail(long long s) {\n  cout << s;\n  exit(0);\n}\nlong long read() {\n  long long n;\n  cin >> n;\n  return n;\n}\ntemplate <typename T>\nvoid Mx(T &a, T b) {\n  a = max(a, b);\n}\ntemplate <typename T>\nvoid Mi(T &a, T b) {\n  a = min(a, b);\n}\nconst long long dx[4] = {-1, 1, 0, 0};\nconst long long dy[4] = {0, 0, -1, 1};\nstring al[1000006];\nbool cmp(long long a, long long b) {\n  string s = al[a], t = al[b];\n  for (long long i = (0); i < (((long long)s.size())); i++) {\n    if (s[i] != t[i]) {\n      if (i % 2 == 0) {\n        return s[i] < t[i];\n      } else {\n        return s[i] > t[i];\n      }\n    }\n  }\n  return 0;\n}\nvoid run_test_case() {\n  long long n, m;\n  cin >> n >> m;\n  vector<long long> id(n);\n  for (long long i = (0); i < (n); i++) cin >> al[i], id[i] = i;\n  sort(id.begin(), id.end(), cmp);\n  for (long long i = (0); i < (n); i++) cout << id[i] << ' ';\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long test_cases = 1;\n  while (test_cases--) run_test_case();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  string f = \"ZYXWVUTSRQPONMLKJIHGFEDCAB\";\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> v;\n  for (int i = 1; i <= n; i++) {\n    string s;\n    cin >> s;\n    for (int j = 0; j < m; j++) {\n      if (j % 2 == 0) {\n        continue;\n      }\n      s[j] = f[s[j] - 'A'];\n    }\n    v.push_back({s, i});\n  }\n  sort(v.begin(), v.end());\n  for (auto it : v) {\n    cout << it.second << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT sgn(T x) {\n  if (x < 0) return -1;\n  return (x ? x : 0);\n}\ntemplate <typename T>\nint cmp(const void* a, const void* b) {\n  T *x = (T*)a, *y = (T*)b;\n  long long diff = *x - *y;\n  return sgn<T>(diff);\n}\nint n, m;\nstruct obj {\n  string line;\n  int i;\n};\nint cmp_ascdesc(const void* a, const void* b) {\n  obj c = *(obj*)a;\n  obj d = *(obj*)b;\n  string x = c.line;\n  string y = d.line;\n  int i = 0;\n  while (i < m && x[i] == y[i]) i++;\n  if (i == m)\n    return 0;\n  else {\n    if (i % 2 == 0) {\n      return x[i] - y[i];\n    } else {\n      return y[i] - x[i];\n    }\n  }\n}\nint main() {\n  int t = 1;\n  while (t-- > 0) {\n    cin >> n >> m;\n    string line;\n    obj* lines = new obj[n];\n    for (int i = 0; i < n; i++) {\n      cin >> line;\n      lines[i] = obj{line, i + 1};\n    }\n    qsort(lines, n, sizeof(obj), cmp_ascdesc);\n    for (int i = 0; i < n; i++) cout << lines[i].line << \"\\n\";\n    delete[] lines;\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst long double pi = 2 * acos(0.0);\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 5;\nint x = 0, y = 1;\nbool comp1(pair<string, int> a, pair<string, int> b) {\n  return a.first[x] < b.first[x];\n}\nbool comp2(pair<string, int> a, pair<string, int> b) {\n  return a.first[y] > b.first[y];\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int m, n;\n  cin >> n >> m;\n  vector<pair<string, int>> v(n);\n  string s;\n  for (int i = 0; i < n; i++) {\n    cin >> s;\n    v[i].first = s;\n    v[i].second = i + 1;\n  }\n  sort(v.begin(), v.end(), comp1);\n  x += 2;\n  for (int i = 1; i < m; i++) {\n    int j = 0;\n    if (i % 2 == 1) {\n      for (int a = 0; a < n - 1;) {\n        while (v[a].first[x - 2] == v[a + 1].first[x - 2]) {\n          a++;\n          if (a == n - 1) {\n            break;\n          }\n        }\n        a++;\n        sort(v.begin() + j, v.begin() + a, comp2);\n        j = a;\n      }\n      y += 2;\n    } else {\n      for (int a = 0; a < n - 1;) {\n        while (v[a].first[y - 2] == v[a + 1].first[y - 2]) {\n          a++;\n          if (a == n - 1) {\n            break;\n          }\n        }\n        a++;\n        sort(v.begin() + j, v.begin() + a, comp1);\n        j = a;\n      }\n      x += 2;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    cout << v[i].second << \" \";\n  }\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long int mod = 1000000007;\nlong long int fastmodexp(long long int a, long long int b, long long int c) {\n  long long int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = (res * a) % c;\n    }\n    a = (a * a) % c;\n    b = b >> 1;\n  }\n  return res;\n}\nlong long int fastexp(long long int a, long long int b) {\n  long long int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = (res * a);\n    }\n    a = (a * a);\n    b = b >> 1;\n  }\n  return res;\n}\nlong long int fact(long long int n) {\n  long long int ans[n + 1];\n  ans[0] = ans[1] = 1LL;\n  for (long long int i = 2; i <= n; i++) {\n    ans[i] = (i % mod * ans[i - 1] % mod) % mod;\n  }\n  return ans[n];\n}\nfloat roundoff(float value, unsigned char prec) {\n  float pow_10 = pow(10.0f, (float)prec);\n  return round(value * pow_10) \/ pow_10;\n}\nbool comparator(pair<string, long long int> arr1,\n                pair<string, long long int> arr2) {\n  string a = arr1.first, b = arr2.first;\n  for (long long int i = 0; i < a.size(); i++) {\n    if (a[i] != b[i]) {\n      if (i % 2 == 1) {\n        if (a[i] < b[i])\n          return false;\n        else\n          return true;\n      } else {\n        if (a[i] > b[i]) return false;\n      }\n    }\n  }\n  return true;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int t;\n  t = 1;\n  while (t--) {\n    long long int n, m;\n    cin >> n >> m;\n    vector<pair<string, long long int>> arr;\n    for (long long int i = 0; i < n; i++) {\n      string x;\n      cin >> x;\n      arr.push_back(make_pair(x, i + 1));\n    }\n    sort(arr.begin(), arr.end(), comparator);\n    for (long long int i = 0; i < arr.size(); i++) cout << arr[i].second << \" \";\n    cout << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool compare(pair<string, int> aa, pair<string, int> bb) {\n  string a = aa.first;\n  string b = bb.first;\n  int n = a.size();\n  for (int i = 0; i < n; i++) {\n    if (a[i] == b[i]) continue;\n    if (a[i] < b[i]) {\n      if (i % 2)\n        return false;\n      else\n        return true;\n    } else {\n      if (i % 2)\n        return true;\n      else\n        return false;\n    }\n  }\n  return aa.second < bb.second;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i].first;\n    v[i].second;\n  }\n  sort(v.begin(), v.end(), compare);\n  for (auto x : v) {\n    cout << x.second + 1 << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint t, ans = 0, tot = 0, kk = 0;\nconst int mxn = 2e7 + 10, mod = 1e9 + 7;\nbool cmp(string s, string ss) {\n  string s1, s2, ss1, ss2;\n  int i;\n  for (i = 0; i < s.size(); i += 2) s1 += s[i];\n  for (i = 1; i < s.size(); i += 2) s2 += s[i];\n  for (i = 0; i < ss.size(); i += 2) ss1 += ss[i];\n  for (i = 1; i < ss.size(); i += 2) ss2 += ss[i];\n  if (s1 == ss1) return s2 > ss2;\n  return s1 < ss1;\n}\nsigned main() {\n  int n, m, a, b, c, d, e, i, j, k, sm = 0, sm1 = 0, cn = 0, cn1 = 0, mx = -1e9,\n                                    mn = 1e9;\n  string s, ss, sr, sa;\n  bool f = false, ff = true;\n  cin >> n >> m;\n  string str[n];\n  map<string, int> mp;\n  for (i = 0; i < n; i++) cin >> str[i], mp[str[i]] = i + 1;\n  sort(str, str + n, cmp);\n  for (i = 0; i < n; i++) cout << mp[str[i]] << \" \";\n  cout << \"\\n\";\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nclass md {\n public:\n  int id, s1, s2;\n};\nbool px(md a, md b) {\n  if (a.s1 == b.s1) {\n    return a.s2 > b.s2;\n  } else {\n    return a.s1 < b.s1;\n  }\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  md a[n + 5];\n  for (int i = 0; i < n; i++) {\n    char s;\n    cin >> s;\n    a[i].s1 = s - '0';\n    cin >> s;\n    a[i].s2 = s - '0';\n    a[i].id = i;\n  }\n  sort(a, a + n, px);\n  for (int i = 0; i < n; i++) {\n    cout << a[i].id + 1 << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid _p(T a) {\n  cout << a << '\\n';\n}\ntemplate <class T>\nvoid _pa(T a) {\n  cout << a << ' ';\n}\ntemplate <class T1, class T2>\nvoid _p(T1 a, T2 b) {\n  cout << a << ' ' << b << '\\n';\n}\ntemplate <class T1, class T2, class T3>\nvoid _p(T1 a, T2 b, T3 c) {\n  cout << a << ' ' << b << ' ' << c << '\\n';\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid _p(T1 a, T2 b, T3 c, T4 d) {\n  cout << a << ' ' << b << ' ' << c << ' ' << d << ' ' << '\\n';\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid _p(T1 a, T2 b, T3 c, T4 d, T5 e) {\n  cout << a << ' ' << b << ' ' << c << ' ' << d << ' ' << e << ' ' << '\\n';\n}\ntemplate <class T>\nvoid _pa(T a[], long long n) {\n  long long i;\n  for (i = 0; i < n; i++) cout << a[i] << ' ';\n  cout << '\\n';\n}\ntemplate <class T>\nvoid _p(vector<T> v) {\n  for (auto x : v) cout << x << ' ';\n  cout << '\\n';\n}\ntemplate <class T>\nvoid _p(list<T> l) {\n  for (auto x : l) cout << x << ' ';\n  cout << '\\n';\n}\ntemplate <class T>\nvoid _p(set<T> s) {\n  for (auto x : s) cout << x << ' ';\n  cout << '\\n';\n}\ntemplate <class T>\nvoid _p(multiset<T> s) {\n  for (auto x : s) cout << x << ' ';\n  cout << '\\n';\n}\ntemplate <class T>\nvoid _p(unordered_set<T> s) {\n  for (auto x : s) cout << x << ' ';\n  cout << '\\n';\n}\ntemplate <class T1, class T2>\nvoid _p(map<T1, T2> m) {\n  for (auto x : m) cout << x.first << \"->\" << x.second << '\\n';\n  cout << '\\n';\n}\ntemplate <class T1, class T2>\nvoid _p(unordered_map<T1, T2> m) {\n  for (auto x : m) cout << x.first << \"->\" << x.second << '\\n';\n  cout << '\\n';\n}\ntemplate <class T1, class T2>\nvoid _p(map<T1, vector<T2>> m) {\n  for (auto x : m) {\n    cout << x.first << \"->\";\n    _p(x.second);\n  }\n  cout << '\\n';\n}\ntemplate <class T1, class T2>\nvoid _p(unordered_map<T1, vector<T2>> m) {\n  for (auto x : m) {\n    cout << x.first << \"->\";\n    _p(x.second);\n  }\n  cout << '\\n';\n}\nint n, m;\nstring s[1000004];\nchar ulta(char x) {\n  int p = x;\n  if (p >= 78)\n    p = 65 + (78 - p);\n  else\n    p = 78 + (65 - p);\n  return p;\n}\nvoid solution() {\n  int i, j;\n  cin >> n >> m;\n  for (i = 0; i < n; i++) cin >> s[i];\n  for (j = 0; j < m; j++)\n    if (j & 1)\n      for (i = 0; i < n; i++) s[i][j] = ulta(s[i][j]);\n  for (i = 0; i < n; i++) s[i] += i + 49;\n  sort(s, s + n);\n  for (i = 0; i < n; i++) _pa(s[i][m]);\n  cout << '\\n';\n}\nint32_t main() { solution(); }\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long int mod = 1000000007;\nlong long int fastmodexp(long long int a, long long int b, long long int c) {\n  long long int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = (res * a) % c;\n    }\n    a = (a * a) % c;\n    b = b >> 1;\n  }\n  return res;\n}\nlong long int fastexp(long long int a, long long int b) {\n  long long int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = (res * a);\n    }\n    a = (a * a);\n    b = b >> 1;\n  }\n  return res;\n}\nlong long int fact(long long int n) {\n  long long int ans[n + 1];\n  ans[0] = ans[1] = 1LL;\n  for (long long int i = 2; i <= n; i++) {\n    ans[i] = (i % mod * ans[i - 1] % mod) % mod;\n  }\n  return ans[n];\n}\nfloat roundoff(float value, unsigned char prec) {\n  float pow_10 = pow(10.0f, (float)prec);\n  return round(value * pow_10) \/ pow_10;\n}\nbool comparator(pair<string, long long int> arr1,\n                pair<string, long long int> arr2) {\n  string a = arr1.first, b = arr2.first;\n  for (long long int i = 0; i < a.size(); i++) {\n    if (a[i] != b[i]) {\n      if ((i + 1) % 2 == 1) {\n        if (a[i] < b[i])\n          return true;\n        else\n          return false;\n      } else {\n        if (a[i] > b[i]) return true;\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int t;\n  t = 1;\n  while (t--) {\n    long long int n, m;\n    cin >> n >> m;\n    vector<pair<string, long long int>> arr;\n    for (long long int i = 0; i < n; i++) {\n      string x;\n      cin >> x;\n      arr.push_back(make_pair(x, i + 1));\n    }\n    sort(arr.begin(), arr.end(), comparator);\n    for (long long int i = 0; i < arr.size(); i++) cout << arr[i].second << \" \";\n    cout << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N_MAX = 1000000;\nint n, m;\nstring s[N_MAX];\nint p[N_MAX];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    for (int j = 1; j < m; j++) s[i][j] = char('z' - 1 - s[i][j]);\n  }\n  for (int i = 0; i < n; i++) p[i] = i;\n  sort(p, p + n, [&](const int &i, const int &j) { return s[i] < s[j]; });\n  for (int i = 0; i < n; i++) cout << p[i] + 1 << \" \";\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int tests;\n  tests = 1;\n  while (tests--) {\n    int n, m;\n    cin >> n >> m;\n    string second[n];\n    vector<pair<long long int, long long int>> vp;\n    for (int i = 0; i < n; i++) {\n      cin >> second[i];\n      long long int val = 0;\n      for (int j = 0; j < second[i].size(); j++) {\n        if (j % 2 == 0) {\n          val += ('Z' - second[i][j]) * (-1);\n        } else {\n          val += ('Z' - second[i][j]);\n        }\n      }\n      vp.push_back({val, i + 1});\n    }\n    sort(vp.begin(), vp.end());\n    for (auto u : vp) cout << u.second << \" \";\n    cout << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nifstream fi(\n    \"easy\"\n    \".inp\");\nofstream fo(\n    \"easy\"\n    \".out\");\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<string> s;\n  for (int i = 0; i < n; i++) {\n    string x;\n    cin >> x;\n    s.push_back(x);\n  }\n  vector<vector<int>> a(n, vector<int>(m + 1, 0));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      a[i][j + 1] = (j & 1 ? ('Z' - s[i][j]) : (s[i][j] - 'A')) + a[i][j];\n    }\n  }\n  vector<pair<int, int>> mp;\n  for (int i = 0; i < n; i++) {\n    mp.push_back(make_pair(a[i][m], i));\n  }\n  sort((mp).begin(), (mp).end());\n  for (int i = 0; i < n; i++) {\n    cout << mp[i].second + 1 << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  pair<string, int>* arr = new pair<string, int>[n];\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i].first;\n    arr[i].second = i;\n  }\n  bool flag1 = 1, flag2 = 0;\n  while (flag1) {\n    for (int j = 0; j < n - 1; j++) {\n      bool flag = 0;\n      for (int k = 0; k < m && flag == 0; k++) {\n        if (arr[j].first[k] != arr[j + 1].first[k]) {\n          if (k % 2) {\n            if (arr[j].first[k] < arr[j + 1].first[k]) {\n              swap(arr[j], arr[j + 1]);\n              flag2 = 1;\n            }\n          }\n          if (k % 2 == 0) {\n            if (arr[j].first[k] > arr[j + 1].first[k]) {\n              swap(arr[j], arr[j + 1]);\n              flag2 = 1;\n            }\n          }\n          flag = 1;\n        }\n      }\n    }\n    flag1 = (flag1 && flag2);\n    flag2 = 0;\n    cout << flag1 << \" \" << flag2 << endl;\n  }\n  for (int i = 0; i < n; i++) {\n    cout << arr[i].second + 1 << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid read(T &x) {\n  cin >> x;\n}\ntemplate <typename T, typename T0>\nvoid read(T &x, T0 &y) {\n  cin >> x >> y;\n}\ntemplate <typename T, typename T0, typename T1>\nvoid read(T &x, T0 &y, T1 &z) {\n  cin >> x >> y >> z;\n}\ntemplate <typename T, typename T0, typename T1, typename T2>\nvoid read(T &x, T0 &y, T1 &z, T2 &w) {\n  cin >> x >> y >> z >> w;\n}\ntemplate <typename T, typename T0>\nvoid read(pair<T, T0> &p) {\n  cin >> p.first >> p.second;\n}\ntemplate <typename T>\nvoid read(vector<T> &oneD, long long int n) {\n  for (long long int(i) = 0; (i) < (n); ++(i)) {\n    long long int x;\n    read(x);\n    oneD.push_back(x);\n  }\n}\ntemplate <typename T>\nvoid read(T oneD[], long long int n) {\n  for (long long int i = 0; i < n; i++) {\n    read(oneD[i]);\n  }\n}\ntemplate <typename T>\nvoid write(T &x) {\n  cout << x << \" \";\n}\ntemplate <typename T>\nvoid wrtline(T &x) {\n  cout << x << \"\\n\";\n}\ntemplate <typename T, typename T0>\nvoid write(T &x, T0 &y) {\n  cout << x << \" \" << y << \"\\n\";\n}\ntemplate <typename T, typename T0, typename T1>\nvoid write(T &x, T0 &y, T1 &z) {\n  cout << x << \" \" << y << \" \" << z << \"\\n\";\n}\ntemplate <typename T, typename T0, typename T1, typename T2>\nvoid write(T &x, T0 &y, T1 &z, T2 &w) {\n  cout << x << \" \" << y << \" \" << z << \" \" << w << \"\\n\";\n}\ntemplate <typename T, typename T0>\nvoid write(pair<T, T0> &p) {\n  write(p.first);\n  write(p.second);\n  cout << \"\\n\";\n}\ntemplate <typename T>\nvoid write(vector<T> &oneD, long long int n) {\n  for (long long int i = 0; i < n; i++) {\n    cout << oneD[i] << \" \";\n  }\n  cout << \"\\n\";\n}\ntemplate <typename T>\nvoid write(T oneD[], int &n) {\n  for (long long int i = 0; i < n; i++) {\n    write(oneD[i]);\n  }\n  cout << \"\\n\";\n}\ntemplate <typename T, typename T0>\nvoid write(map<T, T0> &mpp) {\n  for (auto it : mpp) {\n    write(it.first);\n    cout << \": \";\n    write(it.second);\n    cout << \"\\n\";\n  }\n  cout << \"\\n\";\n}\ntemplate <typename T>\nvoid write(vector<vector<T>> &rc, T &n, T &m) {\n  for (long long int(i) = 0; (i) < (n); ++(i)) {\n    for (long long int(j) = 0; (j) < (m); ++(j)) {\n      cout << rc[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\ntemplate <typename T>\nvoid _print(T &t) {\n  cerr << t;\n}\ntemplate <class T, class V>\nvoid _print(pair<T, V> &p);\ntemplate <class T>\nvoid _print(vector<T> &v);\ntemplate <class T>\nvoid _print(set<T> &v);\ntemplate <class T, class V>\nvoid _print(map<T, V> &v);\ntemplate <class T>\nvoid _print(multiset<T> &v);\ntemplate <class T, class V>\nvoid _print(pair<T, V> &p) {\n  cerr << \"{\";\n  _print(p.first);\n  cerr << \",\";\n  _print(p.second);\n  cerr << \"}\";\n}\ntemplate <class T>\nvoid _print(vector<T> &v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T>\nvoid _print(set<T> &v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T>\nvoid _print(multiset<T> &v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T, class V>\nvoid _print(map<T, V> &v) {\n  cerr << \"[ \";\n  for (auto i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\nlong long int x;\nbool compareFn(pair<string, long long int> &a, pair<string, long long int> &b) {\n  if (x % 2 == 0)\n    return a.first[x] < b.first[x];\n  else\n    return a.first[x] > b.first[x];\n}\nvoid solve() {\n  long long int n, m;\n  read(n, m);\n  vector<pair<string, long long int>> s;\n  for (long long int(i) = 0; (i) < (n); ++(i)) {\n    string t;\n    read(t);\n    s.push_back({t, i + 1});\n  }\n  x = 0;\n  sort((s).begin(), (s).end(), compareFn);\n  x++;\n  while (x < m) {\n    long long int i = 0, j = 0;\n    while (j != n) {\n      while (j < n - 1 and s[j].first[x - 1] == s[j + 1].first[x - 1]) j++;\n      j++;\n      sort(s.begin() + i, s.begin() + j, compareFn);\n      i = j;\n    }\n    x++;\n  }\n  for (long long int(i) = 0; (i) < (n); ++(i)) cout << s[i].second << \" \";\n  cout << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  solve();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool compare(pair<string, int> const& x, pair<string, int> const& y) {\n  if (y.first[0] != x.first[0]) {\n    return y.first[0] > x.first[0];\n  } else {\n    return y.first[1] < x.first[1];\n  }\n}\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  vector<pair<string, int> > inputs(n);\n  for (int i = 0; i < n; i++) {\n    pair<string, int> p1;\n    string s;\n    cin >> s;\n    p1.first = s;\n    p1.second = i;\n    inputs[i] = p1;\n  }\n  auto cmp = [](string const& x, string const& y) {\n    return y[0] > x[0] || y[1] < x[1];\n  };\n  sort(inputs.begin(), inputs.end(), compare);\n  for (int i = 0; i < n; i++) {\n    cout << inputs[i].second + 1 << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 5;\nstring arr[N];\nbool cmp(string x, string y) {\n  for (int i = 0; i < x.size(); ++i) {\n    if (x[i] < y[i] && i & 1) {\n      return x > y;\n    }\n    if (x[i] < y[i] && !(i & 1)) {\n      return x < y;\n    }\n    if (x[i] > y[i] && i & 1) {\n      return x > y;\n    }\n    if (x[i] > y[i] && !(i & 1)) {\n      return x < y;\n    }\n  }\n  return x < y;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; ++i) {\n    cin >> arr[i];\n  }\n  sort(arr, arr + n, cmp);\n  for (int i = 0; i < n; ++i) {\n    cout << arr[i] << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int x, y;\n  cin >> x >> y;\n  vector<pair<string, int> > A(x);\n  for (int i = 0; i < x; i++) {\n    string r;\n    cin >> r;\n    for (int j = 1; j < r.size(); j += 2) r[j] = 'Z' - (r[j] - 'A');\n    A[i] = make_pair(r, i + 1);\n  }\n  for (int i = 0; i < x; i++) cout << A[i].second << (i + 1 == x ? \"\\n\" : \" \");\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nstring ss;\nstruct node {\n  string a, b;\n  int i;\n} s[1000009];\nint cmp(node x, node y) {\n  if (x.a == y.a) return x.b > y.b;\n  return x.a < y.a;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; ++i) {\n    cin >> ss;\n    s[i].a.resize(m \/ 2 + 1);\n    s[i].b.resize(m \/ 2 + 1);\n    s[i].a = ss.substr(0, (m + 1) \/ 2);\n    s[i].b = ss.substr((m + 1) \/ 2, m);\n    s[i].i = i + 1;\n  }\n  sort(s, s + n, cmp);\n  for (int i = 0; i < n; ++i) {\n    cout << s[i].i << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\ntemplate <typename T, size_t N>\nint SIZE(const T (&t)[N]) {\n  return N;\n}\ntemplate <typename T>\nint SIZE(const T &t) {\n  return t.size();\n}\nstring to_string(const string s, int x1 = 0, int x2 = 1e9) {\n  return '\"' + ((x1 < s.size()) ? s.substr(x1, x2 - x1 + 1) : \"\") + '\"';\n}\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(const bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(const char c) { return string({c}); }\ntemplate <size_t N>\nstring to_string(const bitset<N> &b, int x1 = 0, int x2 = 1e9) {\n  string t = \"\";\n  for (int __iii__ = min(x1, SIZE(b)), __jjj__ = min(x2, SIZE(b) - 1);\n       __iii__ <= __jjj__; ++__iii__) {\n    t += b[__iii__] + '0';\n  }\n  return '\"' + t + '\"';\n}\ntemplate <typename A, typename... C>\nstring to_string(const A(&v), int x1 = 0, int x2 = 1e9, C... coords);\nint l_v_l_v_l = 0, t_a_b_s = 0;\ntemplate <typename A, typename B>\nstring to_string(const pair<A, B> &p) {\n  l_v_l_v_l++;\n  string res = \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n  l_v_l_v_l--;\n  return res;\n}\ntemplate <typename A, typename... C>\nstring to_string(const A(&v), int x1, int x2, C... coords) {\n  int rnk = rank<A>::value;\n  string tab(t_a_b_s, ' ');\n  string res = \"\";\n  bool first = true;\n  if (l_v_l_v_l == 0) res += '\\n';\n  res += tab + \"[\";\n  x1 = min(x1, SIZE(v)), x2 = min(x2, SIZE(v));\n  auto l = begin(v);\n  advance(l, x1);\n  auto r = l;\n  advance(r, (x2 - x1) + (x2 < SIZE(v)));\n  for (auto e = l; e != r; e = next(e)) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    l_v_l_v_l++;\n    if (e != l) {\n      if (rnk > 1) {\n        res += '\\n';\n        t_a_b_s = l_v_l_v_l;\n      };\n    } else {\n      t_a_b_s = 0;\n    }\n    res += to_string(*e, coords...);\n    l_v_l_v_l--;\n  }\n  res += \"]\";\n  if (l_v_l_v_l == 0) res += '\\n';\n  return res;\n}\nvoid dbgm() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgm(Heads H, Tails... T) {\n  cerr << to_string(H) << \" | \";\n  dbgm(T...);\n}\nbool custom_compare(pair<int, int> &a, pair<int, int> &b) {\n  if (a.second != b.second)\n    return a.second < b.second;\n  else\n    return a.first > b.first;\n}\nlong long calc_power(long long n, long long b, long long modd = -1) {\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      if (modd == -1)\n        res = (res * n);\n      else\n        res = (res * n) % modd;\n    }\n    if (modd == -1)\n      n = n * n;\n    else\n      n = n * n % (modd);\n    b >>= 1;\n  }\n  return modd == -1 ? res : res % modd;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return a \/ gcd(a, b) * b; }\nlong long modinv(long long a, long long m) { return calc_power(a, m - 2, m); }\nvoid testcase() {\n  int n;\n  char c;\n  string s;\n  cin >> n >> c >> s;\n  bool ok = 1;\n  for (int i = 1; i <= n; i++) {\n    if (s[i - 1] != c) ok = 0;\n  }\n  if (ok) {\n    cout << 0 << \"\\n\";\n    return;\n  }\n  for (int i = 2; i <= (n + 1) \/ 2; i++) {\n    bool ok = 1;\n    for (int j = i; j <= n; j += i) {\n      if (s[j - 1] != c) {\n        ok = 0;\n        break;\n      }\n    }\n    if (ok) {\n      cout << 1 << \"\\n\" << i << \"\\n\";\n      return;\n    }\n  }\n  cout << 2 << \"\\n\" << n << \" \" << n - 1 << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  ;\n  int t;\n  cin >> t;\n  for (int i = 1; i <= t; i++) testcase();\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid sxseven();\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  sxseven();\n  return 0;\n}\nconst int N = 1e6 + 5;\nint m, k;\nstring s[N];\nint a[N];\nbool cmp0(int x, int y) { return s[x][k] < s[y][k]; }\nbool cmp1(int x, int y) { return s[x][k] > s[y][k]; }\nvoid js(int l, int r, int op, int kk) {\n  if (l >= r) return;\n  k = kk;\n  if (op == 0) {\n    sort(a + l, a + r + 1, cmp0);\n  } else {\n    sort(a + l, a + r + 1, cmp1);\n  }\n  if (kk == m) return;\n  int cnt = 1;\n  for (int i = l + 1; i <= r; ++i) {\n    if (s[a[i]][kk] == s[a[i - 1]][kk]) {\n      cnt++;\n    } else {\n      if (cnt > 1) {\n        js(i - cnt, i - 1, 1 - op, kk + 1);\n      }\n      cnt = 1;\n    }\n  }\n  if (cnt > 1) {\n    js(r - cnt, r - 1, 1 - op, kk + 1);\n  }\n}\nvoid sxseven() {\n  int n;\n  cin >> n >> m;\n  m--;\n  for (int i = 1; i <= n; ++i) {\n    cin >> s[i];\n    a[i] = i;\n  }\n  js(1, n, 0, 0);\n  for (int i = 1; i <= n; ++i) cout << a[i] << ' ';\n  cout << endl;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  string arr[n];\n  string ans[n];\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n  for (int j = 0; j < m; j += 2) {\n    map<int, vector<int>> nextChar;\n    for (int i = 0; i < n; i++) {\n      nextChar[(int)arr[i][j]].push_back((int)arr[i][j + 1]);\n    }\n    for (auto &it : nextChar) {\n      sort(it.second.begin(), it.second.end(), greater<int>());\n    }\n    int index = 0;\n    for (auto it : nextChar) {\n      for (auto iter = it.second.begin(); iter != it.second.end(); iter++) {\n        ans[index].push_back((char)it.first);\n        ans[index].push_back((char)*iter);\n        index++;\n      }\n    }\n  }\n  map<string, int> indices;\n  for (int i = 0; i < n; i++) {\n    indices[arr[i]] = i + 1;\n  }\n  for (int i = 0; i < n; i++) {\n    cout << indices[ans[i]] << \" \";\n  }\n  cout << endl;\n}\n","import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic Scanner scanner = new Scanner(System.in);\n\tstatic String[] array;\n\tstatic int maxChar;\n\t\n\tpublic static void main(String[] args) {\n\t\tif (scanner.hasNextInt()) {\n\t\t\tarray = new String[scanner.nextInt()];\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (scanner.hasNextInt()) {\n\t\t\tmaxChar = scanner.nextInt();\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\t\t\n\t\tif (scanner.hasNextLine()) { \n\t\t\tscanner.nextLine();\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint i = 0;\n\t\twhile (i<array.length) {\n\t\t        array[i]=new String(scanner.nextLine());\n\t\t        i++;\n\t\t}\n\t\t\t\t\n\t\tif (array.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tInteger [] indices = new Integer[array.length];\n\t\tfor (i = 0; i <array.length ; i++) {\n            indices[i]=i+1;\n\t\t}\n\t\t\n\t\tArrays.sort(indices, new Comparator<Integer>(){  \n\t\t    @Override  \n\t\t    public int compare(Integer i1, Integer i2){  \n\t\t    \tint counter = 0;\n\t\t\t\twhile (array[i1-1].charAt(counter) == array[i2-1].charAt(counter)) {\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\tif (counter >= maxChar) {\n\t\t\t\t\treturn 0;\n\t\t\t\t} else if (counter % 2 == 0) {\n\t\t\t\t\treturn array[i1-1].charAt(counter) < array[i2-1].charAt(counter) ? -1 : 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn array[i1-1].charAt(counter) < array[i2-1].charAt(counter) ? 1 : -1;\n\t\t\t\t}\n\t\t    }\n\t\t});\n\t\t\n\t}\n\t\t\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst long double pi = 2 * acos(0.0);\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 5;\nint x = 0, y = 1;\nbool comp1(pair<string, int> a, pair<string, int> b) {\n  return a.first[x] < b.first[x];\n}\nbool comp2(pair<string, int> a, pair<string, int> b) {\n  return a.first[y] > b.first[y];\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int m, n, flag;\n  cin >> n >> m;\n  vector<pair<string, int>> v(n);\n  string s;\n  for (int i = 0; i < n; i++) {\n    cin >> s;\n    v[i].first = s;\n    v[i].second = i + 1;\n  }\n  sort(v.begin(), v.end(), comp1);\n  x += 2;\n  for (int a = 0; a < n - 1; a++) {\n    if (v[a].first[x - 2] == v[a + 1].first[x - 2]) {\n      flag = 1;\n      break;\n    }\n  }\n  if (flag == 0) {\n    for (int i = 1; i < m; i++) {\n      flag = 0;\n      int j = 0;\n      if (i % 2 == 1) {\n        for (int a = 0; a < n - 1;) {\n          while (v[a].first[x - 2] == v[a + 1].first[x - 2]) {\n            a++;\n            if (a == n - 1) {\n              break;\n            }\n          }\n          a++;\n          if (a - j > 1) sort(v.begin() + j, v.begin() + a, comp2);\n          j = a;\n        }\n        y += 2;\n        for (int a = 0; a < n - 1; a++) {\n          if (v[a].first[y - 2] == v[a + 1].first[y - 2]) {\n            flag = 1;\n            break;\n          }\n        }\n      } else {\n        for (int a = 0; a < n - 1;) {\n          while (v[a].first[y - 2] == v[a + 1].first[y - 2]) {\n            a++;\n            if (a == n - 1) {\n              break;\n            }\n          }\n          a++;\n          if (a - j > 1) sort(v.begin() + j, v.begin() + a, comp1);\n          j = a;\n        }\n        x += 2;\n        for (int a = 0; a < n - 1; a++) {\n          if (v[a].first[x - 2] == v[a + 1].first[x - 2]) {\n            flag = 1;\n            break;\n          }\n        }\n      }\n      if (flag == 0) break;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    cout << v[i].second << \" \";\n  }\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint p = 0;\nbool comp(string &x, string &y) { return x[p] > y[p]; }\nbool comp2(string &x, string &y) { return x[p] < y[p]; }\ntemplate <typename T>\nvoid printv(T &a) {\n  for (auto it = a.begin(); it != a.end(); ++it) cout << *it << ' ';\n  cout << '\\n';\n}\nlong long int ans;\nstd::vector<long long int> pow2;\nvoid solve() {\n  map<int, int> freq;\n  set<int> hsh;\n  ans = 0;\n  bool ok = false;\n  long long int h, p;\n  cin >> h >> p;\n  auto lb = lower_bound(pow2.begin(), pow2.end(), p + 1);\n  int indx = lb - pow2.begin();\n  ans += indx;\n  long long int rem = pow2[h] - *lb;\n  ans += (rem + p - 1) \/ p;\n  cout << ans;\n  cout << '\\n';\n}\nvoid sol() {\n  pow2 = {1};\n  for (int i = 0; i < 50; ++i) {\n    pow2.push_back(2 * pow2.back());\n  }\n}\nvoid sol2() {\n  int n;\n  cin >> n;\n  int m;\n  cin >> m;\n  map<string, int> mp;\n  string s[n];\n  for (int i = 0; i < n; ++i) {\n    cin >> s[i];\n    mp[s[i]] = i + 1;\n  }\n  sort(s, s + n, comp2);\n  for (int i = 1; i < m; ++i) {\n    int last = 0;\n    for (int j = 1; j < n; ++j) {\n      if (s[j][i - 1] != s[j - 1][i - 1]) {\n        p = i;\n        if (i % 2) {\n          sort(s + last, s + j, comp);\n        } else {\n          sort(s + last, s + j, comp2);\n        }\n        last = j;\n      }\n    }\n    if (i % 2) {\n      sort(s + last, s + n, comp);\n    } else {\n      sort(s + last, s + n, comp2);\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    cout << mp[s[i]] << ' ';\n  }\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  sol2();\n  return 0;\n  int testcases = 1;\n  cin >> testcases;\n  for (int t = 0; t < testcases; ++t) {\n    solve();\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nstruct sp {\n  string s1, s2;\n  int id;\n};\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  sp a[n];\n  for (int i = 0; i < n; i++) {\n    string s1 = \"\", s2 = \"\";\n    for (int j = 0; j < m; j++) {\n      char c;\n      cin >> c;\n      if (j % 2 == 0) {\n        s1 += c;\n      } else {\n        s2 += c;\n      }\n    }\n    a[i] = {s1, s2, i + 1};\n  }\n  sort(a, a + n,\n       [](sp A, sp B) { return A.s1 == B.s1 ? A.s2 > B.s2 : A.s1 < B.s1; });\n  for (int i = 0; i < n; i++) {\n    cout << a[i].id << \" \";\n  }\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst int infi = INT_MAX;\nconst long long infll = LLONG_MAX;\nconst long double PI = 3.1415926535897932384626;\nbool cmp(pair<string, int> &a, pair<string, int> &b) {\n  for (int i = 0; i < a.first.length(); i++) {\n    if (a.first[i] == b.first[i])\n      continue;\n    else if (i + 1 % 2 == 1) {\n      return a.first[i] < b.first[i];\n    } else {\n      return a.first[i] > b.first[i];\n    }\n  }\n  return true;\n}\nvoid solve(int test_case) {\n  int n, k;\n  cin >> n >> k;\n  vector<pair<string, int>> arr(n);\n  for (int i = 1; i <= n; i++) {\n    string s;\n    cin >> s;\n    arr[i - 1].first = s;\n    arr[i - 1].second = i;\n  }\n  sort(arr.begin(), arr.end(), cmp);\n  for (auto &itr : arr) {\n    cout << itr.second << \" \";\n  }\n  cout << endl;\n}\nint main() {\n  ios_base ::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int tc = 1;\n  while (tc--) solve(tc);\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint p = 0;\nbool comp(string &x, string &y) { return x[p] > y[p]; }\nbool comp2(string &x, string &y) { return x[p] < y[p]; }\ntemplate <typename T>\nvoid printv(T &a) {\n  for (auto it = a.begin(); it != a.end(); ++it) cout << *it << ' ';\n  cout << '\\n';\n}\nvoid sol2() {\n  int n;\n  cin >> n;\n  int m;\n  cin >> m;\n  map<string, int> mp;\n  string s[n];\n  for (int i = 0; i < n; ++i) {\n    cin >> s[i];\n    mp[s[i]] = i + 1;\n  }\n  for (int i = m - 1; i >= 0; --i) {\n    p = i;\n    if (i % 2 == 0) {\n      sort(s, s + n, comp2);\n    } else {\n      sort(s, s + n, comp);\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    cout << mp[s[i]] << ' ';\n  }\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  sol2();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int mod = (int)1e9 + 7;\nconst long long MOD = 972663749;\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  string second;\n  map<string, set<int>> make_pair;\n  vector<string> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> second;\n    a[i] = second;\n    make_pair[second].insert((i + 1));\n  }\n  sort(a.begin(), a.end());\n  for (int i = 1; i < m; ++i) {\n    if ((i + 1) & 1) {\n      int l = 0, r = 0;\n      for (int j = 1; j < n; ++j) {\n        if (a[j - 1][0] == a[j][0]) {\n          r = j;\n        } else {\n          sort(a.begin() + l, a.begin() + r + 1);\n          l = j, r = j;\n        }\n      }\n      sort(a.begin() + l, a.begin() + r + 1);\n    } else {\n      int l = 0, r = 0;\n      for (int j = 1; j < n; ++j) {\n        if (a[j - 1][0] == a[j][0]) {\n          r = j;\n        } else {\n          sort(a.begin() + l, a.begin() + r + 1, greater<string>());\n          l = j, r = j;\n        }\n      }\n      sort(a.begin() + l, a.begin() + r + 1, greater<string>());\n    }\n  }\n  vector<int> res;\n  for (int i = 0; i < n; ++i) {\n    auto it = --make_pair[a[i]].end();\n    res.push_back(*it);\n    make_pair[a[i]].erase(it);\n  }\n  for (auto &i : res) cout << i << \" \";\n}\nvoid huykhanh() {\n  int T;\n  T = 1;\n  while (T--) solve();\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  huykhanh();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int tests;\n  tests = 1;\n  while (tests--) {\n    int n, m;\n    cin >> n >> m;\n    string second[n];\n    vector<pair<long long int, long long int>> vp;\n    for (int i = 0; i < n; i++) {\n      cin >> second[i];\n      long long int val = 0;\n      for (int j = 0; j < second[i].size(); j++) {\n        if (j % 2 == 0) {\n          val += ('Z' - second[i][j]) * (-1) * ((n - i) * (n - i + 1) \/ 2);\n        } else {\n          val += ('Z' - second[i][j]) * ((n - i) * (n - i + 1) \/ 2);\n        }\n      }\n      vp.push_back({val, i + 1});\n    }\n    sort(vp.begin(), vp.end());\n    for (auto u : vp) cout << u.second << \" \";\n    cout << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool compare(string &s1, string &s2) {\n  bool ans = true;\n  int len = s1.size();\n  for (int i = 0; i < len; i++) {\n    if (i & 1) {\n      ans &= (s1[i] >= s2[i]);\n      if (ans == false) {\n        return ans;\n      }\n    } else {\n      ans &= (s1[i] <= s2[i]);\n      if (ans == false) {\n        return ans;\n      }\n    }\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  unordered_map<string, int> ch;\n  int n, m;\n  cin >> n >> m;\n  vector<string> vec(n);\n  for (int i = 0; i < n; i++) {\n    cin >> vec[i];\n    ch[vec[i]] = i + 1;\n  }\n  sort(vec.begin(), vec.end(), compare);\n  for (int i = 0; i < n; i++) {\n    cout << ch[vec[i]] << \" \";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N_MAX = 100000;\nint n, m;\nstring s[N_MAX];\nint p[N_MAX];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    for (int j = 1; j < m; j++) s[i][j] = char('z' - 1 - s[i][j]);\n  }\n  for (int i = 0; i < n; i++) p[i] = i;\n  sort(p, p + n, [&](const int &i, const int &j) { return s[i] < s[j]; });\n  for (int i = 0; i < n; i++) cout << p[i] + 1 << \" \";\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 2e3 + 1e2 + 7;\nint n, m;\nchar s[N][N];\nlong long ans[N][N], g[N][N];\nint le[N];\nstruct Line {\n  int k, b;\n  long long eval(int x) { return k * x + b; }\n};\nint cnt;\nstruct T {\n  int l, r, ls, rs;\n  Line v;\n} t[N * 2 + 1];\nint build(int l, int r) {\n  int x = ++cnt;\n  t[x].v.k = 0, t[x].v.b = 1e9;\n  if (l == r) return x;\n  int mid = (l + r) >> 1;\n  t[x].ls = build(l, mid);\n  t[x].rs = build(mid + 1, r);\n  return x;\n}\nvoid change(int x, Line v) {\n  if (!t[x].v.k) {\n    t[x].v = v;\n    return;\n  }\n  int mid = (t[x].l + t[x].r) >> 1;\n  if (t[x].v.eval(mid) > v.eval(mid)) swap(t[x].v, v);\n  if (t[x].ls && v.eval(t[x].l) < t[x].v.eval(t[x].l)) change(t[x].ls, v);\n  if (t[x].rs && v.eval(t[x].r) < t[x].v.eval(t[x].r)) change(t[x].rs, v);\n}\nlong long qry(int x, int p) {\n  if (t[x].l == t[x].r) return t[x].v.eval(p);\n  int mid = (t[x].l + t[x].r) >> 1;\n  if (p <= mid)\n    return min(t[x].v.eval(p), qry(t[x].ls, p));\n  else\n    return min(t[x].v.eval(p), qry(t[x].rs, p));\n}\nvoid solve() {\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) g[i][j] = 1e9;\n  for (int j = 1; j <= m; j++) {\n    int la = -1;\n    for (int i = 1; i <= n; i++) {\n      if (s[i][j] == '1') la = i;\n      if (la != -1) g[i][j] = min(g[i][j], 1ll * (i - la) * (i - la));\n    }\n    la = -1;\n    for (int i = n; i >= 1; i--) {\n      if (s[i][j] == '1') la = i;\n      if (la != -1) g[i][j] = min(g[i][j], 1ll * (i - la) * (i - la));\n    }\n  }\n  for (int j = 2; j <= m; j++) {\n    for (int i = 1; i <= n; i++) le[i] = (s[i][j - 1] == '1' ? j - 1 : le[i]);\n    cnt = 0;\n    build(1, n);\n    for (int p = 1; p <= n; p++)\n      if (le[p]) change(1, {-2 * p, p * p + (j - le[p]) * (j - le[p])});\n    for (int i = 1; i <= n; i++) g[i][j] = min(g[i][j], qry(1, i) + i * i);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  n++, m++;\n  for (int i = 1; i <= n; i++) scanf(\"%s\", s[i] + 1);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) ans[i][j] = 1e9;\n  solve();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) ans[i][j] = min(ans[i][j], g[i][j]);\n  for (int i = 1; i <= n; i++) reverse(s[i] + 1, s[i] + m + 1);\n  solve();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) ans[i][j] = min(ans[i][j], g[i][m - j + 1]);\n  long long sum = 0;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      sum += ans[i][j];\n      printf(\"%lld%c\", ans[i][j], \" \\n\"[j == m]);\n    }\n  printf(\"%lld\\n\", sum);\n}\n","#include <bits\/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\nusing namespace std;\nbool compare(pair<string, int>& A, pair<string, int>& B) {\n  int k = A.first.size();\n  bool flag = true;\n  for (int i = 0; i < k; i++) {\n    if ((i + 1) % 2) {\n      if (A.first[i] > B.first[i]) {\n        flag = false;\n        break;\n      }\n    } else {\n      if (A.first[i] < B.first[i]) {\n        flag = false;\n        break;\n      }\n    }\n  }\n  if (A.first == B.first) {\n    return A.second > B.second;\n  }\n  return flag;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> A(n);\n  for (int i = 0; i < n; i++) {\n    cin >> A[i].first;\n    A[i].second = i + 1;\n  }\n  sort(A.begin(), A.end(), compare);\n  for (auto it : A) {\n    cout << it.second << \" \";\n  }\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT sgn(T x) {\n  if (x < 0) return -1;\n  return (x ? x : 0);\n}\ntemplate <typename T>\nint cmp(const void* a, const void* b) {\n  T *x = (T*)a, *y = (T*)b;\n  long long diff = *x - *y;\n  return sgn<T>(diff);\n}\nint n, m;\nstruct obj {\n  string line;\n  int i;\n};\nint cmp_ascdesc(const void* a, const void* b) {\n  obj c = *(obj*)a;\n  obj d = *(obj*)b;\n  string x = c.line;\n  string y = d.line;\n  int i = 0;\n  while (i < m && x[i] == y[i]) i++;\n  if (i == m)\n    return 0;\n  else {\n    if (i % 2 == 0) {\n      return x[i] - y[i];\n    } else {\n      return y[i] - x[i];\n    }\n  }\n}\nint main() {\n  int t = 1;\n  while (t-- > 0) {\n    cin >> n >> m;\n    string line;\n    obj* lines = new obj[n];\n    for (int i = 0; i < n; i++) {\n      cin >> line;\n      lines[i] = obj{line, i + 1};\n    }\n    qsort(lines, n, sizeof(obj), cmp_ascdesc);\n    for (int i = 0; i < n; i++) cout << lines[i].i << \" \";\n    delete[] lines;\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint p = 0;\nbool comp(string &x, string &y) { return x[p] > y[p]; }\nbool comp2(string &x, string &y) { return x[p] < y[p]; }\ntemplate <typename T>\nvoid printv(T &a) {\n  for (auto it = a.begin(); it != a.end(); ++it) cout << *it << ' ';\n  cout << '\\n';\n}\nvoid sol2() {\n  int n;\n  cin >> n;\n  int m;\n  cin >> m;\n  map<string, int> mp;\n  string s[n];\n  for (int i = 0; i < n; ++i) {\n    cin >> s[i];\n    mp[s[i]] = i + 1;\n  }\n  sort(s, s + n, comp2);\n  for (int i = m - 1; i >= 0; --i) {\n    p = i;\n    if (i % 2 == 0) {\n      sort(s, s + n, comp2);\n    } else {\n      sort(s, s + n, comp);\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    cout << mp[s[i]] << ' ';\n  }\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  sol2();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nbool test = false;\nlong long mod1 = 1e9 + 7;\nlong long mod2 = 998244353;\nlong long inf = 1e10 + 5;\nvoid testCase() {\n  long long n, m;\n  std::cin >> n >> m;\n  std::vector<std::pair<std::string, long long>> s(n);\n  for (int i = 0; i <= n - 1; i++) {\n    std::cin >> s[i].first;\n    s[i].second = i;\n  }\n  for (int i = 0; i <= n - 1; i++) {\n    for (int j = 1; j <= m - 1; j += 2) {\n      s[i].first[j] = 'Z' - s[i].first[j] + 'A';\n      std::cout << s[i].first << \" \";\n    }\n  }\n  std::sort(s.begin(), s.end());\n  for (int i = 0; i <= n - 1; i++) {\n    std::cout << s[i].second + 1 << \" \";\n  }\n  std::cout << \"\\n\";\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(NULL);\n  std::cout.precision(15);\n  long long t = 1;\n  if (test) {\n    std::cin >> t;\n  }\n  for (long long i = 0; i <= t - 1; i++) {\n    testCase();\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> s;\n  for (long long i = 0; i < n; i++) {\n    string k;\n    cin >> k;\n    s.push_back({k, i + 1});\n  }\n  sort(s.begin(), s.end());\n  vector<int> ans(n);\n  int j = 0;\n  for (int i = 0; i < n; i += 2) {\n    ans[i] = s[j].second;\n    j++;\n  }\n  if (n >= 2) {\n    for (int i = n - 2; i > 0; i -= 2) {\n      ans[i] = s[j].second;\n      j++;\n    }\n  }\n  for (long long i = 0; i < n; i++) cout << ans[i] << \" \";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  freopen(\"input.txt\", \"r\", stdin);\n  freopen(\"output.txt\", \"w\", stdout);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<int, int> > v1;\n  string a1[n];\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    a1[i] = s;\n    pair<int, int> p1;\n    p1.first = 0;\n    p1.second = i + 1;\n    v1.push_back(p1);\n  }\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i % 2 == 0) {\n        v1[j].first += int(a1[j][i]) - 65;\n      } else {\n        v1[j].first += -(int(a1[j][i]) - 90);\n      }\n    }\n  }\n  sort(v1.begin(), v1.end());\n  for (int i = 0; i < n; i++) {\n    cout << v1[i].second << \" \";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid sxseven();\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  sxseven();\n  return 0;\n}\nconst int N = 1e6 + 5;\nint m, k;\nstring s[N];\nint a[N];\nbool cmp0(int x, int y) { return s[x][k] < s[y][k]; }\nbool cmp1(int x, int y) { return s[x][k] > s[y][k]; }\nvoid js(int l, int r, int op, int kk) {\n  if (l >= r) return;\n  k = kk;\n  if (op == 0) {\n    sort(a + l, a + r + 1, cmp0);\n  } else {\n    sort(a + l, a + r + 1, cmp1);\n  }\n  if (kk == m - 1) return;\n  int cnt = 1;\n  for (int i = l + 1; i <= r; ++i) {\n    if (s[a[i]][kk] == s[a[i - 1]][kk]) {\n      cnt++;\n    } else {\n      if (cnt > 1) {\n        js(i - cnt, i - 1, 1 - op, kk + 1);\n      }\n      cnt = 1;\n    }\n  }\n}\nvoid sxseven() {\n  int n;\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    cin >> s[i];\n    a[i] = i;\n  }\n  js(1, n, 0, 0);\n  for (int i = 1; i <= n; ++i) printf(\"%d \", a[i]);\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int tests;\n  tests = 1;\n  while (tests--) {\n    int n, m;\n    cin >> n >> m;\n    string second[n];\n    vector<pair<long long int, long long int>> vp;\n    for (int i = 0; i < n; i++) {\n      cin >> second[i];\n      long long int val = 0;\n      for (int j = 0; j < second[i].size(); j++) {\n        if (j % 2 == 0) {\n          val += ('Z' - second[i][j]) * (-1) * (n - i);\n        } else {\n          val += ('Z' - second[i][j]) * (n - i);\n        }\n      }\n      vp.push_back({val, i + 1});\n    }\n    sort(vp.begin(), vp.end());\n    for (auto u : vp) cout << u.second << \" \";\n    cout << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nstruct node {\n  string a;\n  int b;\n} s[10000006];\nint cmp(node x, node y) { return x.a < y.a; }\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    cin >> s[i].a;\n    s[i].b = i;\n    int x = s[i].a.length();\n    for (int j = 0; i < x; i++) {\n      if (j % 2 != 0) {\n        s[i].a[j] = s[i].a[j] - (s[i].a[j] - 'a');\n      }\n    }\n  }\n  sort(s + 1, s + 1 + n, cmp);\n  for (int i = 1; i <= n; i++) {\n    printf(\"%d \", s[i].b);\n  }\n}\n","#include <bits\/stdc++.h>\nconst long long mod = 998244353;\nconst long long maxn = 1e18 + 7;\nusing namespace std;\nlong long power(long long b, long long p) {\n  b %= mod;\n  long long ans = 1;\n  while (p > 0) {\n    if (p % 2 == 1) {\n      ans *= b;\n      ans %= mod;\n    }\n    b *= b;\n    b %= mod;\n    p \/= 2;\n  }\n  return ans;\n}\nbool cstsort(pair<string, long long> a, pair<string, long long> b) {\n  long long j = 0;\n  string s = a.first;\n  string t = b.first;\n  long long n = s.size();\n  while (s[j] == t[j]) j++;\n  if ((j + 1) % 2) {\n    return s[j] < t[j];\n  } else {\n    return s[j] > t[j];\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n, m;\n  cin >> n >> m;\n  string s[n];\n  vector<pair<string, long long>> pa;\n  for (long long i = 0; i < n; i++) {\n    cin >> s[i];\n    pa.push_back({s[i], i});\n  }\n  sort((pa).begin(), (pa).end(), cstsort);\n  long long ans[n];\n  for (long long i = 0; i < n; i++) {\n    long long ind = pa[i].second;\n    ans[ind] = i + 1;\n  }\n  for (long long i = 0; i < n; i++) {\n    cout << ans[i] << \" \";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool sortinrev(long long x, long long y) { return x > y; }\nvoid swap(long long* a, long long* b) {\n  long long temp = *a;\n  *a = *b;\n  *b = temp;\n}\nlong long div_ceil(long long a, long long b) { return (a + b - 1) \/ b; }\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst long long INF = 1e18L + 5;\nconst int nax = 2005;\nconst int N = int(1e6);\nbool isPrime(long long x) {\n  for (long long i = 2; i * i <= x; i++) {\n    if (x % i == 0) return false;\n  }\n  return true;\n}\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> arr(n);\n  for (long long i = 0; i < n; ++i) cin >> arr[i];\n  set<long long> s;\n  for (long long i = 0; i < n; ++i) {\n    for (long long j = i + 1; j < n; j++) {\n      s.insert(abs(arr[i] - arr[j]));\n    }\n  }\n  if (s.size() == 1 && *s.begin() == 0) {\n    cout << -1 << \"\\n\";\n    return;\n  }\n  long long res = *s.begin();\n  for (auto x : s) {\n    res = gcd(res, x);\n  }\n  cout << res << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  cerr << \"\\nTime elapsed: \" << 1000 * clock() \/ CLOCKS_PER_SEC << \"ms\\n\";\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint mod = 1e9 + 7;\nconst long long INF = 1e18 + 56;\nconst long long NINF = -1 * INF;\nvoid solve(int q) {\n  int n, m;\n  cin >> n >> m;\n  vector<string> arr(n);\n  for (int j = 0; j < n; j++) {\n    cin >> arr[j];\n    for (int i = 0; i < m; i++) {\n      if (i % 2) arr[j][i] = 65 + (90 - arr[j][i]);\n    }\n  }\n  sort(arr.begin(), arr.end());\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (j % 2 == 0)\n        cout << arr[i][j];\n      else {\n        arr[i][j] = 65 + (90 - arr[i][j]);\n        cout << arr[i][j];\n      }\n    }\n    cout << \"\\n\";\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(), cout.tie(0);\n  int t = 1;\n  for (int i = 1; i <= t; i++) solve(i);\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long n, m;\npair<string, long long> s[1000001];\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (long long i = 0; i < n; i++) {\n    cin >> s[i].first;\n    s[i].second = i + 1;\n    for (long long j = 1; j < m; j++) s[i].first[j] = 'A' + 'Z' - s[i].first[j];\n  }\n  sort(s, s + n);\n  for (long long i = 0; i < n; i++) cout << s[i].second << ' ';\n  cout << endl;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint t, n, m;\npair<string, int> p[1000001];\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    string s;\n    cin >> s;\n    for (int j = 1; j < m; j += 2) s[j] = 155 - s[j];\n    p[i] = {s, i};\n  }\n  sort(p + 1, p + n + 1);\n  for (int i = 1; i < n; i++) cout << p[i].second << ' ';\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool compare(pair<string, int> const &x, pair<string, int> const &y) {\n  if (y.first[0] != x.first[0]) {\n    return y.first[0] >= x.first[0];\n  } else {\n    return y.first[1] < x.first[1];\n  }\n}\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  vector<pair<string, int> > inputs(n);\n  for (int i = 0; i < n; i++) {\n    pair<string, int> p1;\n    string s;\n    cin >> s;\n    p1.first = s;\n    p1.second = i;\n    inputs[i] = p1;\n  }\n  sort(inputs.begin(), inputs.end(), compare);\n  for (int i = 0; i < n; i++) {\n    cout << inputs[i].second + 1 << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint p = 0;\nbool comp(string &x, string &y) { return x[p] > y[p]; }\nbool comp2(string &x, string &y) { return x[p] < y[p]; }\ntemplate <typename T>\nvoid printv(T &a) {\n  for (auto it = a.begin(); it != a.end(); ++it) cout << *it << ' ';\n  cout << '\\n';\n}\nvoid sol2() {\n  int n;\n  cin >> n;\n  int m;\n  cin >> m;\n  map<string, int> mp;\n  string s[1000000];\n  for (int i = 0; i < n; ++i) {\n    cin >> s[i];\n    mp[s[i]] = i + 1;\n  }\n  sort(s, s + n, comp2);\n  for (int i = 1; i < m; ++i) {\n    int last = 0;\n    for (int j = 1; j < n; ++j) {\n      if (s[j][i - 1] != s[j - 1][i - 1]) {\n        p = i;\n        if (i % 2) {\n          sort(s + last, s + j, comp);\n        } else {\n          sort(s + last, s + j, comp2);\n        }\n        last = j;\n      }\n    }\n    p = i;\n    if (i % 2) {\n      sort(s + last, s + n, comp);\n    } else {\n      sort(s + last, s + n, comp2);\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    cout << mp[s[i]] << ' ';\n  }\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  sol2();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 5;\nint t, n, m;\npair<string, int> a[N];\nbool check(pair<string, int> a, pair<string, int> b) {\n  for (int i = 0; i <= m - 1; ++i)\n    if ((i & 1 && a.first[i] < b.first[i]) ||\n        (!(i & 1) && a.first[i] > b.first[i]))\n      return false;\n  return true;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> m;\n  for (int i = 0; i <= n - 1; ++i) {\n    cin >> a[i].first;\n    a[i].second = i + 1;\n  }\n  sort(a, a + n, check);\n  for (int i = 0; i <= n - 1; ++i) cout << a[i].second << \" \";\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint t, ans = 0, tot = 0, kk = 0;\nconst int mxn = 2e7 + 10, mod = 1e9 + 7;\nbool cmp(string s, string ss) {\n  string s1, s2, ss1, ss2;\n  int i;\n  for (i = 0; i < s.size(); i += 2) s1 += s[i];\n  for (i = 1; i < s.size(); i += 2) s2 += s[i];\n  for (i = 0; i < ss.size(); i += 2) ss1 += ss[i];\n  for (i = 1; i < ss.size(); i += 2) ss2 += ss[i];\n  if (s1 != ss1) return s1 < ss1;\n  return s2 > ss2;\n}\nsigned main() {\n  int n, m, a, b, c, d, e, i, j, k, sm = 0, sm1 = 0, cn = 0, cn1 = 0, mx = -1e9,\n                                    mn = 1e9;\n  string s, ss, sr, sa;\n  bool f = false, ff = true;\n  cin >> n >> m;\n  string str[n];\n  map<string, int> mp;\n  for (i = 0; i < n; i++) cin >> str[i], mp[str[i]] = i + 1;\n  sort(str, str + n, cmp);\n  for (i = 0; i < n; i++) cout << mp[str[i]] << \" \";\n  cout << \"\\n\";\n}\n","#include <bits\/stdc++.h>\ntemplate <typename T>\nvoid swap(T &a, T &b) {\n  T tmp = a;\n  a = b;\n  b = tmp;\n}\nchar buffer[2000000];\nint n, m;\nchar *inp[1000000];\nint perm[1000000];\nint bucket[1000000];\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  char *offset = buffer;\n  std::cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    inp[i] = offset;\n    offset += m + 1;\n    std::cin >> std::ws;\n    std::cin.getline(inp[i], 2 * (m + 1));\n    perm[i] = i;\n    bucket[i] = 0;\n  }\n  for (int i = 0; i < m; i++) {\n    int c = 0;\n    while (c < n) {\n      int b = c;\n      if (i % 2 == 0) {\n        for (char ch = 'A'; ch <= 'Z'; ch++) {\n          int buck = b;\n          for (; c < n && bucket[buck] == bucket[c]; c++) {\n            if (inp[perm[c]][i] == ch) {\n              swap(perm[c], perm[b]);\n              b++;\n            }\n          }\n          for (int j = buck; j < b; j++) {\n            bucket[j] = buck;\n          }\n          c = b;\n        }\n      } else {\n        for (char ch = 'Z'; ch >= 'A'; ch--) {\n          int buck = b;\n          for (; c < n && bucket[buck] == bucket[c]; c++) {\n            if (inp[perm[c]][i] == ch) {\n              swap(perm[c], perm[b]);\n              b++;\n            }\n          }\n          for (int j = buck; j < b; j++) {\n            bucket[j] = buck;\n          }\n          c = b;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    std::cout << perm[i] + 1 << \" \";\n  }\n  std::cout << std::endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint mon[20] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nlong long gcd(long long x, long long y) {\n  return ((y == 0) ? x : gcd(y, x % y));\n}\ninline int read() {\n  int x = 0;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') ch = getchar();\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x;\n}\nconst int GJMAX = 1005;\nstruct Int {\n  int a[GJMAX];\n  int len;\n  Int(int k) { *this = k; }\n  Int() { *this = 0; }\n  void clean() {\n    while (len > 1 && !a[len - 1]) len--;\n  }\n  void operator=(int k) {\n    if (!k) {\n      len = 1;\n      a[0] = 0;\n      return;\n    }\n    len = 0;\n    while (k) a[len++] = k % 10, k \/= 10;\n  }\n  void operator=(string k) {\n    len = k.length();\n    for (int i = 0; i < len; i++) {\n      a[i] = k[len - i - 1] - '0';\n    }\n  }\n  Int operator+(Int &B) {\n    Int C;\n    C.len = len > B.len ? len : B.len;\n    for (int i = len; i < C.len; i++) a[i] = 0;\n    for (int i = B.len; i < C.len; i++) B.a[i] = 0;\n    int d = 0;\n    for (int i = 0; i < C.len; i++) {\n      C.a[i] = a[i] + B.a[i] + d;\n      d = C.a[i] \/ 10;\n      C.a[i] %= 10;\n    }\n    if (d) C.a[C.len++] = d;\n    return C;\n  }\n  Int operator+=(Int B) {\n    *this = *this + B;\n    return *this;\n  }\n  Int operator+(int &b) {\n    Int B = b;\n    return *this + B;\n  }\n  Int operator+(const int &b) {\n    Int B = b;\n    return *this + B;\n  }\n  Int operator-(Int &B) {\n    Int C;\n    C.len = len;\n    for (int i = B.len; i < C.len; i++) B.a[i] = 0;\n    int d = 0;\n    for (int i = 0; i < C.len; i++) {\n      C.a[i] = a[i] - B.a[i] - d;\n      d = 0;\n      while (C.a[i] < 0) d++, C.a[i] += 10;\n    }\n    while (C.len > 0 && !C.a[C.len - 1]) C.len--;\n    if (C.len == 0) C = 0;\n    return C;\n  }\n  Int operator-=(Int B) {\n    *this = *this - B;\n    return *this;\n  }\n  Int operator-(int &b) {\n    Int B = b;\n    return *this - B;\n  }\n  Int operator-(const int &b) {\n    Int B = b;\n    return *this - B;\n  }\n  Int operator*(Int &B) {\n    int i, j;\n    Int C;\n    C.len = len + B.len;\n    for (j = 0; j < B.len; j++)\n      for (i = 0; i < len; i++) C.a[i + j] += a[i] * B.a[j];\n    for (i = 0; i < C.len - 1; i++) C.a[i + 1] += C.a[i] \/ 10, C.a[i] %= 10;\n    C.clean();\n    return C;\n  }\n  Int operator*=(Int B) {\n    *this = *this * B;\n    return *this;\n  }\n  Int operator*(int &b) {\n    Int B = b;\n    return *this * B;\n  }\n  Int operator*(const int &b) {\n    Int B = b;\n    return *this * B;\n  }\n  Int operator*=(int b) {\n    *this = *this * b;\n    return *this;\n  }\n  Int operator\/(Int &b) {\n    int i, j;\n    Int c = *this, d = 0;\n    for (i = len - 1; i >= 0; i--) {\n      d = d * 10 + a[i];\n      for (j = 0; j < 10; j++)\n        if (d < b * (j + 1)) break;\n      c.a[i] = j;\n      d -= b * j;\n    }\n    c.clean();\n    return c;\n  }\n  Int operator\/(const int &b) {\n    Int B = b;\n    return *this \/ B;\n  }\n  Int operator\/=(Int B) {\n    *this = *this \/ B;\n    return *this;\n  }\n  Int operator\/(int &b) {\n    Int B = b;\n    return *this \/ B;\n  }\n  Int operator\/=(int b) {\n    *this = *this \/ b;\n    return *this;\n  }\n  Int operator%(Int &b) {\n    int i, j;\n    Int d = 0;\n    for (i = len - 1; i >= 0; i--) {\n      d = d * 10 + a[i];\n      for (j = 0; j < 10; j++)\n        if (d < b * (j + 1)) break;\n      d -= b * j;\n    }\n    return d;\n  }\n  Int operator%=(Int B) {\n    *this = *this % B;\n    return *this;\n  }\n  bool operator<=(Int B) {\n    if (len < B.len) return 1;\n    if (len > B.len) return 0;\n    for (int i = len - 1; i >= 0; i--) {\n      if (a[i] < B.a[i]) return 1;\n      if (a[i] > B.a[i]) return 0;\n    }\n    return 1;\n  }\n  bool operator<(Int B) {\n    if (len < B.len) return 1;\n    if (len > B.len) return 0;\n    for (int i = len - 1; i >= 0; i--) {\n      if (a[i] < B.a[i]) return 1;\n      if (a[i] > B.a[i]) return 0;\n    }\n    return 0;\n  }\n  bool operator>(Int B) { return !(*this <= B); }\n  bool operator>=(Int B) { return !(*this < B); }\n  bool operator==(Int B) { return *this <= B && *this >= B; }\n  bool operator!=(Int B) { return !(*this == B); }\n  bool zero() { return len == 1 && a[0] == 0; }\n  void printout() {\n    for (int i = len - 1; i >= 0; i--) printf(\"%d\", a[i]);\n  }\n  string str() const {\n    char s[GJMAX] = {};\n    for (int i = 0; i < len; i++) s[len - 1 - i] = a[i] + '0';\n    return s;\n  }\n};\nistream &operator>>(istream &in, Int &x) {\n  string s;\n  in >> s;\n  x = s.c_str();\n  return in;\n}\nostream &operator<<(ostream &out, const Int &x) {\n  out << x.str();\n  return out;\n}\nconst int maxn = 200005;\nint c[maxn];\nint n, m;\nint dp[maxn];\nmap<pair<int, int>, int> dis;\nint u, v, w;\nbool vis[maxn];\nvector<int> vec[maxn];\nint ans = 0;\nint INF = 0x3f3f3f3f;\nvoid work(stack<int> path) {\n  u = path.top();\n  path.pop();\n  dp[u] = INF;\n  while (path.size()) {\n    v = path.top();\n    path.pop();\n    dp[v] = min(dp[u] - c[v], dis[make_pair(v, u)]);\n    u = v;\n  }\n  ans = max(ans, dp[1]);\n}\nstack<int> path;\nvoid dfs(int idx, int step) {\n  if (step == n) {\n    work(path);\n    return;\n  }\n  vis[idx] = 1;\n  for (int i = 0; i < vec[idx].size(); i++) {\n    u = vec[idx][i];\n    if (!vis[u]) path.push(u), dfs(u, step + 1), path.pop();\n  }\n}\nvoid solve() {\n  cin >> n >> m;\n  path.push(1);\n  for (int i = 1; i <= n; i++) cin >> c[i];\n  for (int i = 1; i <= m; i++) {\n    cin >> u >> v >> w;\n    vec[u].push_back(v);\n    vec[v].push_back(u);\n    dis[make_pair(u, v)] = w - c[u];\n    dis[make_pair(v, u)] = w - c[v];\n  }\n  dfs(1, 1);\n  if (ans > 0) {\n    cout << ans;\n  } else\n    cout << -1;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int t;\n  t = 1;\n  while (t--) solve();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int a, b;\n  cin >> a >> b;\n  vector<pair<string, int>> v;\n  for (int i = 1; i <= a; i++) {\n    string s;\n    cin >> s;\n    v.push_back({s, i});\n  }\n  sort(v.begin(), v.end());\n  for (int i = 0; i < a; i++) {\n    string t = v[i].first;\n    vector<pair<string, int>> s;\n    s.push_back({t, v[i].second});\n    while (i + 1 < a) {\n      i++;\n      string q = v[i].first;\n      if (t[0] != q[0]) {\n        i--;\n        break;\n      }\n      s.push_back({q, v[i].second});\n    }\n    if (b % 2) {\n      sort(s.begin(), s.end());\n      for (auto &it : s) cout << it.second << \" \";\n    } else {\n      sort(s.rbegin(), s.rend());\n      for (auto &it : s) cout << it.second << \" \";\n    }\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nstring arr[N];\nbool cmp(string x, string y) {\n  for (int i = 0; i < x.size() - 1; ++i) {\n    if (x[i] < y[i] && i & 1) {\n      return x > y;\n    }\n    if (x[i] < y[i] && !(i & 1)) {\n      return x < y;\n    }\n    if (x[i] > y[i] && i & 1) {\n      return x > y;\n    }\n    if (x[i] > y[i] && !(i & 1)) {\n      return x < y;\n    }\n  }\n  return x < y;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; ++i) {\n    cin >> arr[i];\n    char index = (i + 1) + '0';\n    arr[i] += index;\n  }\n  sort(arr, arr + n, cmp);\n  for (int i = 0; i < n; ++i) {\n    cout << arr[i][arr[i].size() - 1] << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint p = 0;\nbool comp(string &x, string &y) { return x[p] > y[p]; }\nbool comp2(string &x, string &y) { return x[p] < y[p]; }\ntemplate <typename T>\nvoid printv(T &a) {\n  for (auto it = a.begin(); it != a.end(); ++it) cout << *it << ' ';\n  cout << '\\n';\n}\nvoid sol2() {\n  int n;\n  cin >> n;\n  int m;\n  cin >> m;\n  map<string, int> mp;\n  string s[n];\n  for (int i = 0; i < n; ++i) {\n    cin >> s[i];\n    mp[s[i]] = i + 1;\n  }\n  sort(s, s + n, comp2);\n  for (int i = 1; i < m; ++i) {\n    int last = 0;\n    for (int j = 1; j < n; ++j) {\n      if (s[j][i - 1] != s[j - 1][i - 1]) {\n        p = i;\n        if (i % 2) {\n          sort(s + last, s + j, comp);\n        } else {\n          sort(s + last, s + j, comp2);\n        }\n        last = j;\n      }\n    }\n    p = i;\n    if (i % 2) {\n      sort(s + last, s + n, comp);\n    } else {\n      sort(s + last, s + n, comp2);\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    cout << mp[s[i]] << ' ';\n  }\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  sol2();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst long double pi = 2 * acos(0.0);\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 5;\nint x = 0, y = 1;\nbool comp1(pair<string, int> a, pair<string, int> b) {\n  return a.first[x] < b.first[x];\n}\nbool comp2(pair<string, int> a, pair<string, int> b) {\n  return a.first[y] > b.first[y];\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int m, n, flag;\n  cin >> n >> m;\n  vector<pair<string, int>> v(n);\n  string s;\n  for (int i = 0; i < n; i++) {\n    cin >> s;\n    v[i].first = s;\n    v[i].second = i + 1;\n  }\n  sort(v.begin(), v.end(), comp1);\n  x += 2;\n  for (int a = 0; a < n - 1; a++) {\n    if (v[a].first[x - 2] == v[a + 1].first[x - 2]) {\n      flag = 1;\n      break;\n    }\n  }\n  if (flag == 1) {\n    for (int i = 1; i < m; i++) {\n      flag = 0;\n      int j = 0;\n      if (i % 2 == 1) {\n        for (int a = 0; a < n - 1;) {\n          while (v[a].first[x - 2] == v[a + 1].first[x - 2]) {\n            a++;\n            if (a == n - 1) {\n              break;\n            }\n          }\n          a++;\n          if (a - j > 1) sort(v.begin() + j, v.begin() + a, comp2);\n          j = a;\n        }\n        y += 2;\n        for (int a = 0; a < n - 1; a++) {\n          if (v[a].first[y - 2] == v[a + 1].first[y - 2]) {\n            flag = 1;\n            break;\n          }\n        }\n      } else {\n        for (int a = 0; a < n - 1;) {\n          while (v[a].first[y - 2] == v[a + 1].first[y - 2]) {\n            a++;\n            if (a == n - 1) {\n              break;\n            }\n          }\n          a++;\n          if (a - j > 1) sort(v.begin() + j, v.begin() + a, comp1);\n          j = a;\n        }\n        x += 2;\n        for (int a = 0; a < n - 1; a++) {\n          if (v[a].first[x - 2] == v[a + 1].first[x - 2]) {\n            flag = 1;\n            break;\n          }\n        }\n      }\n      if (flag == 0) break;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    cout << v[i].second << \" \";\n  }\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int64_t M = 1e9 + 7;\nconst int64_t INF = 1e6 + 100;\nconst int MAXN = 2e5 + 5;\nbool prime[INF];\nint64_t spf[INF];\nint64_t d[INF] = {};\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nint dx8[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nint dy8[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nstring ds = \"RLDU\";\nlong long C(int n, int m) {\n  if (m > n) return 0;\n  long long z = 1;\n  for (int i = 0; i < m; i++) z = z * (n - i) \/ (i + 1);\n  return z;\n}\nlong long int invmod(long long int i) {\n  if (i == 1) return 1;\n  return (1000000007 -\n          ((1000000007 \/ i) * invmod(1000000007 % i)) % 1000000007 +\n          1000000007) %\n         1000000007;\n}\nvoid sieve() {\n  spf[1] = 1;\n  for (int i = 2; i < INF; i++) spf[i] = i;\n  for (int i = 4; i < INF; i += 2) spf[i] = 2;\n  for (int i = 3; i * i < INF; i++) {\n    if (spf[i] == i) {\n      for (int j = i * i; j < INF; j += i)\n        if (spf[j] == j) spf[j] = i;\n    }\n  }\n}\nint64_t binpow(int64_t a, int64_t b) {\n  if (b == 0) return 1;\n  if (b == 1) return a;\n  int64_t temp = binpow(a, b \/ 2);\n  if (b % 2 == 0)\n    return (temp * temp);\n  else\n    return (((temp * temp)) * a);\n}\nint64_t tot(int64_t n) {\n  int64_t result = n;\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      while (n % i == 0) n \/= i;\n      result -= result \/ i;\n    }\n  }\n  if (n > 1) result -= result \/ n;\n  return result;\n}\nvoid phi_1_to_n(int n) {\n  vector<int> phi(n + 1);\n  phi[0] = 0;\n  phi[1] = 1;\n  for (int i = 2; i <= n; i++) phi[i] = i;\n  for (int i = 2; i <= n; i++) {\n    if (phi[i] == i) {\n      for (int j = i; j <= n; j += i) phi[j] -= phi[j] \/ i;\n    }\n  }\n}\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nbool is_prime(int64_t n) {\n  if (n == 1) return false;\n  int64_t i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      return false;\n    }\n    i += 1;\n  }\n  return true;\n}\nvoid SieveOfEratosthenes() {\n  memset(prime, 1, sizeof(prime));\n  prime[1] = 0;\n  prime[0] = 0;\n  for (int p = 2; p * p < INF; p++) {\n    if (prime[p] == true) {\n      for (int i = p * p; i < INF; i += p) {\n        prime[i] = false;\n      }\n    }\n  }\n}\nvoid div() {\n  for (int64_t i = 1; i < INF; i++) {\n    for (int64_t j = i; j < INF; j += i) {\n      d[j] += i;\n      d[j] = d[j] % M;\n    }\n  }\n}\nvector<pair<long long, long long>> factors;\nvector<pair<long long, long long>> factorize(long long N) {\n  factors.clear();\n  vector<pair<long long, long long>> res;\n  for (long long a = 2; a * a <= N; ++a) {\n    if (N % a != 0) continue;\n    long long ex = 0;\n    while (N % a == 0) {\n      ++ex;\n      N \/= a;\n    }\n    res.push_back({a, ex});\n  }\n  if (N != 1) res.push_back({N, 1});\n  factors = res;\n  return res;\n}\nvector<int64_t> divisors;\nvoid getDivisors(int64_t ind = 0, int64_t res = 1) {\n  if (ind == (int)factors.size()) {\n    divisors.push_back(res);\n    return;\n  }\n  for (int64_t i = 0; i <= factors[ind].second; i++) {\n    getDivisors(ind + 1, res);\n    res *= factors[ind].first;\n  }\n}\nbool isqr(int64_t n) {\n  int64_t val = sqrt(n);\n  return (val * val) == n;\n}\nlong long binpow(long long a, long long b, long long m) {\n  a %= m;\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a % m;\n    a = a * a % m;\n    b >>= 1;\n  }\n  return res;\n}\nbool cmp(string a, string b) {\n  int n = a.size();\n  for (int i = 0; i < n; i++) {\n    if ((i + 1) % 2 == 1) {\n      if (a[i] != b[i]) {\n        return b > a;\n      }\n    } else {\n      if (a[i] != b[i]) {\n        return a > b;\n      }\n    }\n  }\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  string s[n];\n  map<string, int> mpp;\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    mpp[s[i]] = i + 1;\n  }\n  sort(s, s + n, cmp);\n  for (int i = 0; i < n; i++) cout << mpp[s[i]] << \" \";\n  cout << endl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint p = 0;\nbool comp(string &x, string &y) { return x[p] > y[p]; }\nbool comp2(string &x, string &y) { return x[p] < y[p]; }\ntemplate <typename T>\nvoid printv(T &a) {\n  for (auto it = a.begin(); it != a.end(); ++it) cout << *it << ' ';\n  cout << '\\n';\n}\nvoid sol2() {\n  int n;\n  cin >> n;\n  int m;\n  cin >> m;\n  map<string, int> mp;\n  string s[n];\n  for (int i = 0; i < n; ++i) {\n    cin >> s[i];\n    mp[s[i]] = i + 1;\n  }\n  sort(s, s + n, comp2);\n  for (int i = 1; i < m; ++i) {\n    int last = 0;\n    for (int j = 1; j < n; ++j) {\n      if (s[j][i - 1] != s[j - 1][i - 1]) {\n        p = i;\n        if (i % 2) {\n          sort(s + last, s + j, comp);\n        } else {\n          sort(s + last, s + j, comp2);\n        }\n        last = j;\n      }\n    }\n    if (i % 2) {\n      sort(s + last, s + n, comp);\n    } else {\n      sort(s + last, s + n, comp2);\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    cout << mp[s[i]] << ' ';\n  }\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  sol2();\n  return 0;\n}\n","#include <bits\/stdc++.h>\n#include <ext\/pb_ds\/detail\/standard_policies.hpp>\n#include <ext\/pb_ds\/assoc_container.hpp>\n#include <ext\/pb_ds\/tree_policy.hpp>\n\n#define FIO                     ios::sync_with_stdio(false); cin.tie(nullptr)\n#define TC(t)                   int t; cin >> t; for(int i = 1; i <= t; i++)\n#define ll                      long long int\n#define ull                     unsigned long long int\n#define loop(i, a, b)           for(ll i = a; i <= b; i++)\n#define loop2(i, b, a)          for(ll i = b; i >= a; i--)\n#define ini(x, y)               memset(x, y, sizeof(x))\n#define all(x)                  x.begin(), x.end()\n#define all2(x)                 x.rbegin(), x.rend()\n#define sz(x)                   (ll)x.size()\n#define pb                      push_back\n#define ppb                     pop_back\n#define mp                      make_pair\n#define ff                      first\n#define ss                      second\n#define M                       1000000007\n#define endl                    '\\n'\n#define bits(x)                 __builtin_popcountll(x)\n#define zrbits(x)               __builtin_ctzll(x)\n#define vl                      vector<ll>\n#define pll                     pair<ll,ll>\n#define vpll                    vector<pll>\n#define uni(x)                  x.erase(unique(all(x)), x.end())\n#define ordered_set             tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>\n#define multi_ordered_set       tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>\n#define mxheap                  priority_queue<ll>\n#define mnheap                  priority_queue<ll, vector<ll>, greater<ll>>\n#define mxheap2                 priority_queue<pair<ll,ll>>\n#define mnheap2                 priority_queue<pair<ll,ll>, vector<pair<ll,ll>>, greater<pair<ll,ll>>>\n\nconst int N = 2e5 + 5;\nconst int L = 20;\nconst int MX = 1e9 + 10;\nconst ll INF = 1e18;\n\nconst int dx[] = {0, -1, 0, 1, -1, -1, 1, 1};\nconst int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ninline ll uceil(ll a,ll b) {return (a % b ? a \/ b + 1 : a \/ b);}\ninline ll mod(ll x) {return ( (x % M + M) % M );}\nll power(ll a, ll b) {ll res = 1; while (b) {if (b & 1) res = res * a; a = a * a; b >>= 1;} return res;}\nll modpow(ll a, ll b) {ll res = 1; while (b) {if (b & 1) res = res * a % M; a = a * a % M; b >>= 1;} return res;}\n\n#ifndef ONLINE_JUDGE\n#define deb(x)                  cerr << #x << \" = \" << x << endl;\n#define deb2(x, y)              cerr << #x << \" = \" << x << \", \" << #y << \" = \" << y << endl;\n#define deb3(x, y, z)           cerr << #x << \" = \" << x << \", \" << #y << \" = \" << y << \", \" << #z << \" = \" << z << endl;\n#define deb4()                  cerr << endl;\n#define done                    cerr << \"Line \" << __LINE__ << \" is done\" << endl;\n#else\n#define deb(x)\n#define deb2(x, y)\n#define deb3(x, y, z)\n#define deb4()\n#define done\n#endif\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {for(auto& x : v) os << x << \" \"; return os;}\ntemplate<typename T> ostream& operator<<(ostream& os, const set<T>& v) {for(auto& x : v) os << x << \" \"; return os;}\ntemplate<typename T, typename S> ostream& operator<<(ostream& os, const pair<T, S>& p) {os << p.first << ' ' << p.second; return os;}\ntemplate<typename... T> void in(T&... args) {((cin >> args), ...);}\ntemplate<typename... T> void out(T&&... args) {((cout << args << endl), ...);}\ntemplate<typename... T> void out2(T&&... args) {((cout << args << \" \"), ...);}\ntemplate<typename... T> void out3(T&&... args) {((cout << args << \" \"), ...); cout << endl;}\n\nvoid solve() {\n        ll n, m;\n        in(n, m);\n        vector<string> a(n);\n        loop(i, 0, n-1) cin >> a[i];\n        \n        map<char, char> mm1, mm2;\n        for(char ch = 'A'; ch <= 'Z'; ch++) {\n          mm1[ch] = (ch - 'A');\n        }\n\n        for(char ch = 'Z'; ch >= 'A'; ch--) {\n          mm2[ch] = ((ch - 'Z'));\n        }\n        \n        loop(j, 0, m-1) {\n          loop(i, 0, n-1) {\n            char ch;\n            if(j & 1) ch = mm2[a[i][j]];\n            else ch = mm1[a[i][j]];\n            a[i][j] = ch;\n          }\n        }\n        \n        map<string, ll> mm3;\n        loop(i, 0, n-1) mm3[a[i]] = i + 1;\n        \n        sort(all(a));\n        loop(i, 0, n-1) out2(mm3[a[i]]);\n        cout << endl;\n}\n\nsigned main () {\n        #ifndef ONLINE_JUDGE\n                freopen(\"input.txt\", \"r\", stdin);\n                freopen(\"output.txt\", \"w\", stdout);\n        #endif\n        FIO;\n        \/\/ TC(t)\n        solve();\n        return 0;\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int a, b;\n  cin >> a >> b;\n  vector<pair<string, int>> v;\n  for (int i = 1; i <= a; i++) {\n    string s;\n    cin >> s;\n    v.push_back({s, i});\n  }\n  sort(v.begin(), v.end());\n  for (int i = 0; i < a; i++) {\n    string t = v[i].first;\n    int p = i;\n    while (i + 1 < a) {\n      i++;\n      string q = v[i].first;\n      if (t[0] != q[0]) {\n        i--;\n        break;\n      }\n    }\n    for (int j = i; j >= p; j--) {\n      cout << v[j].second << \" \";\n    }\n  }\n  return 0;\n}\n","import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom heapq import heappush,heappop,heapify\nfrom bisect import bisect_right,insort,bisect_left\nfrom functools import lru_cache\nfrom itertools import permutations\n\nsys.setrecursionlimit(10**6)\n\ndef STRIN():return input()\ndef INTIN():return int(input())\ndef LINT():return list(map(int,input().split()))\ndef LSTR():return list(map(str,input().split()))\ndef MINT():return map(int,input().split())\ndef MSTR():return map(str,input().split())\n\n\n\ndef solve():\n   \n   \n    n,m=map(int,input().split())\n\n    s=[]\n    d={}\n    ans=[]\n    for i in range(n):\n        s.append(input())\n\n\n\n    s=''.join(s)\n    s=list(s)\n    for j in range(1,len(s),2):\n        if (j+1)%2==0:\n            s[j]=chr(90-(ord(s[j])+26-91))\n\n\n    for i in range(0,len(s),m):\n        ans.append(''.join(s[i:i+m]))\n\n    for i in range(len(ans)):\n        d[ans[i]]=i+1\n\n    ans.sort()\n    for i in ans:\n        print(d[i],end=\" \")\n\n    \n\n\n\n \n        \n \n \n    \n\ndef main():\n    #for _ in range(INTIN()):\n    solve()\n        \n\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int p = 1e9 + 7;\nconst int N = 2e5 + 10;\nint n, k, a[N];\nvector<pair<int, int> > g[N];\ninline void A(int &x, int y) { x = (x + y >= p ? x + y - p : x + y); }\ninline void U(int &x, int y) { x = (x > y ? x : y); }\nint del[N], si[N];\nint mnsi, mnid;\ninline void GetSi(int x, int fa) {\n  si[x] = 1;\n  for (auto e : g[x])\n    if (e.second != fa && !del[e.second]) {\n      GetSi(e.second, x);\n      si[x] += si[e.second];\n    }\n}\ninline void GetMx(int x, int fa, int al) {\n  int mx = al - si[x];\n  for (auto e : g[x])\n    if (e.second != fa && !del[e.second]) {\n      mx = max(mx, si[e.second]);\n      GetMx(e.second, x, al);\n    }\n  if (mx < mnsi) mnsi = mx, mnid = x;\n}\nint f1[N], f2[N];\nint ans;\nvoid PushIn(int x, int fa, int fe, int sm, int sw, int *f, int &mxsw) {\n  if (sw > k) return;\n  if (sw > mxsw) f[sw] = f[mxsw], mxsw = sw;\n  A(sm, a[x]);\n  A(f[sw], sm);\n  for (auto e : g[x]) {\n    int y = e.second, z = e.first;\n    if (del[y] || y == fa) continue;\n    PushIn(y, x, z, sm, sw + (fe != z), f, mxsw);\n  }\n}\nvoid Calc(int x, int fa, int fe, int sm, int sw) {\n  if (sw > k) return;\n  if (sw < k) ans = (ans + 1ll * sm * (f1[k - sw - 1] - f2[k - sw - 1])) % p;\n  ans = (ans + 1ll * sm * f2[k - sw]) % p;\n  A(sm, a[x]);\n  for (auto e : g[x]) {\n    int y = e.second, z = e.first;\n    if (del[y] || y == fa) continue;\n    Calc(y, x, z, sm, sw + (fe != z));\n  }\n}\ninline void Solve(int x) {\n  GetSi(x, 0);\n  mnsi = 1e9;\n  GetMx(x, 0, si[x]);\n  int u = mnid;\n  printf(\"Solve %d\\n\", u);\n  int sw1 = 0, sw2 = 0;\n  ++ans;\n  A(f1[0], a[u]);\n  int la = -1;\n  for (auto e : g[u]) {\n    int y = e.second, z = e.first;\n    if (z != la) {\n      for (int i = 0; i <= sw2; ++i) f2[i] = 0;\n      sw2 = 0;\n      la = z;\n    }\n    if (del[y]) continue;\n    Calc(y, x, 0, a[u], 0);\n    PushIn(y, x, z, a[u], 0, f1, sw1);\n    PushIn(y, x, z, a[u], 0, f2, sw2);\n  }\n  for (int i = 0; i <= sw1; ++i) f1[i] = 0;\n  del[u] = 1;\n  for (auto e : g[u])\n    if (!del[e.second]) Solve(e.second);\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n  for (int i = 1, x, y, z; i < n; ++i) {\n    scanf(\"%d%d%d\", &x, &y, &z);\n    g[x].push_back(pair<int, int>(z, y));\n    g[y].push_back(pair<int, int>(z, x));\n  }\n  for (int i = 1; i <= n; ++i) sort(g[i].begin(), g[i].end());\n  Solve(1);\n  if (ans < 0) ans += p;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool cmp(string a, string b) {\n  if (a[0] != b[0]) return a < b;\n  return a > b;\n}\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  string arr[n], arr2[n];\n  for (long long i = 0; i < n; i++) {\n    cin >> arr[i];\n    arr2[i] = arr[i];\n  }\n  sort(arr, arr + n, cmp);\n  for (long long i = 0; i < n; i++) {\n    long long x = 0;\n    while (arr2[x] != arr[i]) x++;\n    cout << x + 1 << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\nusing namespace std;\nbool compare(pair<string, int> A, pair<string, int> B) {\n  int k = A.first.size();\n  bool flag = true;\n  for (int i = 0; i < k; i++) {\n    if ((i + 1) % 2) {\n      if (A.first[i] > B.first[i]) {\n        flag = false;\n        break;\n      }\n    } else {\n      if (A.first[i] < B.first[i]) {\n        flag = false;\n        break;\n      }\n    }\n  }\n  return flag;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> A(n);\n  for (int i = 0; i < n; i++) {\n    cin >> A[i].first;\n    A[i].second = i + 1;\n  }\n  sort(A.begin(), A.end(), compare);\n  for (auto it : A) {\n    cout << it.second << \" \";\n  }\n  cout << \"\\n\";\n  return 0;\n}\n","\nimport string\nletras = string.ascii_uppercase\ninvertido = string.ascii_uppercase[::-1]\nn,m = map(int, input().split(' '))\n\nbooks = []\norderedBooks = []\nfor i in range (1,n+1):\n  books.append([list(input()),i])\n\nprint(books)\n\nfor i in range (len(books)): # i = par livro\/indice original\n  for j in range (m):\n    if (j%2!=0):\n      correspondente = letras.find(books[i][0][j])\n      books[i][0][j] = invertido[correspondente]\n\nbooks = sorted(books)\nsaida = []\nfor i in range(len(books)):\n  saida.append(books[i][1])\n\nprint(*saida, sep=\" \", end=\"\")\n  \t\t \t\t\t \t  \t\t \t  \t\t \t \t \t   \t","#include <bits\/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nbool cmp(string s1, string s2) {\n  int k = s1.size();\n  for (int i = 0; i < k; i++) {\n    if ((i + 1) % 2 == 1) {\n      if (s1[i] > s2[i]) {\n        return false;\n      }\n    } else {\n      if (s1[i] < s2[i]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<string> s1;\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    s1.push_back(s);\n  }\n  vector<string> s2 = {s1.begin(), s1.end()};\n  sort(s1.begin(), s1.end(), cmp);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (s1[i] == s2[j]) {\n        cout << j + 1 << \" \";\n        break;\n      }\n    }\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long int M = 1000000007;\nlong long int Boostpower(long long int x, long long int y, long long int p) {\n  long long int res = 1;\n  x = x % p;\n  if (x == 0) return 0;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nlong long int binarySearch(long long int arr[], long long int l,\n                           long long int r, long long int x) {\n  while (l <= r) {\n    long long int m = l + (r - l) \/ 2;\n    if (arr[m] == x) return m;\n    if (arr[m] < x)\n      l = m + 1;\n    else\n      r = m - 1;\n  }\n  return -1;\n}\nbool sortbysec(const pair<long long int, long long int> &a,\n               const pair<long long int, long long int> &b) {\n  return (a.second < b.second);\n}\nlong long int Stoi(string s) {\n  stringstream geek(s);\n  long long int x = 0;\n  geek >> x;\n  return x;\n}\nlong long int maxPrimeFactors(long long int n) {\n  long long int maxPrime = -1;\n  while (n % 2 == 0) {\n    maxPrime = 2;\n    n >>= 1;\n  }\n  for (long long int i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      maxPrime = i;\n      n = n \/ i;\n    }\n  }\n  if (n > 2) maxPrime = n;\n  return maxPrime;\n}\nlong long int leastdev(long long int n) {\n  for (long long int i = 1; i <= n; i++) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 0;\n}\nbool isPrime(long long int n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long long int i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nlong long int checkperfectsquare(long long int n) {\n  if (ceil((double)sqrtl(n)) == floor((double)sqrtl(n))) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\nlong long int Ceil(long long int a, long long int b) {\n  if (a < 0 || b < 0) {\n    return a \/ b;\n  }\n  if (a % b) {\n    return a \/ b + 1;\n  }\n  return a \/ b;\n}\nvoid primecount(long long int n) {\n  map<long long int, long long int> mp;\n  if (isPrime(n)) {\n    mp[n] = 1;\n  }\n  long long int count = 0;\n  while (!(n % 2)) {\n    n >>= 1;\n    count++;\n  }\n  if (count) {\n    mp[2] = count;\n  }\n  for (long long i = 3; i <= sqrt(n); i += 2) {\n    count = 0;\n    while (n % i == 0) {\n      count++;\n      n = n \/ i;\n    }\n    if (count) {\n      mp[i] = count;\n    }\n  }\n  if (n > 2) {\n    mp[n] = 1;\n  }\n}\nvoid rotate(vector<long long int> &vec, long long int d) {\n  if (d == 0) return;\n  for (long long int i = 0; i < d; i++) {\n    vec.push_back(vec[0]);\n    vec.erase(vec.begin());\n  }\n}\nlong long int binpow(long long int a, long long int b) {\n  long long int res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a;\n    a = a * a;\n    b >>= 1;\n  }\n  return res;\n}\nlong long int mx = 2e5 + 5;\nvector<long long int> fact(mx, 1), inv(mx, 1);\nvoid precompute() {\n  fact[0] = inv[0] = 1;\n  fact[1] = inv[1] = 1;\n  for (long long int i = 2; i < mx; i++) {\n    fact[i] = i * fact[i - 1];\n    fact[i] %= M;\n    long long int inverse = binpow(i, M - 2);\n    inverse %= M;\n    inv[i] = inv[i - 1] * inverse;\n    inv[i] %= M;\n  }\n}\nlong long int ncr(long long int n, long long int r) {\n  long long int ans = (fact[n] * inv[n - r]);\n  ans %= M;\n  ans *= inv[r];\n  ans %= M;\n  ans += M;\n  ans %= M;\n  return ans;\n}\nlong long int andOperator(long long int x, long long int y) {\n  for (long long int i = 0; i < (long long int)log2(y) + 1; i++) {\n    if (y <= x) {\n      return y;\n    }\n    if (y & (1 << i)) {\n      y &= ~(1UL << i);\n    }\n  }\n  return y;\n}\nlong long int ask(long long int l, long long int r) {\n  cout << \"? \";\n  cout << l;\n  cout << \" \";\n  cout << r;\n  cout << endl;\n  cout.flush();\n  long long int x;\n  cin >> x;\n  return x;\n}\nlong long int rangeSum(long long int i, long long int j, long long int pre[]) {\n  if (i == 0) return pre[j];\n  return pre[j] - pre[i - 1];\n}\nvoid output(long long int ans) {\n  cout << \"! \";\n  cout << ans;\n  cout << endl;\n  cout.flush();\n}\nbool matching(char a, char b) {\n  return ((a == '(' && b == ')') || (a == '[' && b == ']') ||\n          (a == '{' && b == '}'));\n}\nbool comparator(pair<long long int, string> p1,\n                pair<long long int, string> p2) {\n  string s1 = p1.second;\n  string s2 = p2.second;\n  for (long long int i = 0; i < s1.size(); i++) {\n    if (s1[i] != s2[i]) {\n      long long int v1 = s1[i] - '0';\n      long long int v2 = s2[i] - '0';\n      if (i % 2) {\n        if (v2 > v1) {\n          return false;\n        } else {\n          return true;\n        }\n      } else {\n        if (v1 > v2) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int t;\n  t = 1;\n  cin >> t;\n  string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n  while (t--) {\n    long long int n, k;\n    cin >> n >> k;\n    vector<pair<long long int, string>> vp;\n    for (long long int i = 0; i < n; i++) {\n      string s1;\n      cin >> s1;\n      vp.push_back({i, s1});\n    }\n    sort(vp.begin(), vp.end(), comparator);\n    for (auto x : vp) {\n      cout << x.first + 1 << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\n","\n\n\n\nn,m = list(map(int,input().split()))\narr = []\nfor i in range(n):\n    arr.append([list(input()),i+1])\nprint(arr)\nalps = list(map(chr, range(65, 91)))\nd = {}\nfor a in range(len(alps)):\n    d[alps[a]] = alps[len(alps)-1-a]\nprint(d)\nprint(arr[1][0][1])\n\nfor i in range(n):\n    for j in range(m):\n        if j%2:\n            arr[i][0][j] = d[arr[i][0][j]]\n\narr.sort()\nfor i in range(n):\n    print(arr[i][1],end = \" \")\n\n\n\n\n\n\n\n\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool comp(string s1, string s2) {\n  bool flag = true;\n  for (int i = 0; i < s1.length(); i++) {\n    if (i % 2) {\n      if (s2[i] > s1[i]) {\n        flag = false;\n        break;\n      }\n    } else {\n      if (s1[i] > s2[i]) {\n        flag = false;\n        break;\n      }\n    }\n  }\n  return flag;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  string s[n];\n  map<string, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    mp[s[i]] = i + 1;\n  }\n  sort(s, s + n, comp);\n  for (int i = 0; i < n; i++) {\n    cout << mp[s[i]] << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nstruct Book {\n  string name;\n  int index;\n  Book(string name, int index) {\n    this->name = name;\n    this->index = index;\n  }\n  bool operator<(const Book &other) const {\n    for (int i = 0; i < name.size(); i++) {\n      if (name[i] == other.name[i]) continue;\n      if (!i)\n        return name[i] < other.name[i];\n      else\n        return other.name[i] < name[i];\n    }\n    assert(false);\n  }\n};\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  string name;\n  vector<Book> v;\n  for (int i = 1; i < n + 1; i++) {\n    cin >> name;\n    v.push_back(Book(name, i));\n  }\n  sort(v.begin(), v.end());\n  for (int i = 0; i < v.size(); i++) cout << v[i].index << \" \";\n  cout << '\\n';\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint t, n, m;\npair<string, int> p[1000001];\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    string s;\n    cin >> s;\n    for (int j = 1; j < m; j += 2) s[j] = 155 - s[j];\n    p[i] = {s, i};\n  }\n  sort(p, p + n);\n  for (int i = 1; i <= n; i++) cout << p[i].second << ' ';\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool compare(string &s1, string &s2) {\n  bool ans = true;\n  int len = s1.size();\n  for (int i = 0; i < len; i++) {\n    if (i & 1) {\n      ans &= (s1[i] >= s2[i]);\n      if (ans == false) {\n        return ans;\n      }\n    } else {\n      ans &= (s1[i] <= s2[i]);\n      if (ans == false) {\n        return ans;\n      }\n    }\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  unordered_map<string, int> ch;\n  int n, m;\n  cin >> n >> m;\n  vector<string> vec(n);\n  for (int i = 0; i < n; i++) {\n    vec[i].resize(m);\n    cin >> vec[i];\n    ch[vec[i]] = i + 1;\n  }\n  sort(vec.begin(), vec.end(), compare);\n  for (int i = 0; i < n; i++) {\n    cout << ch[vec[i]] << \" \";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nlong long int mod = 1000000007;\nbool cmp(pair<string, long long int> &a, pair<string, long long int> &b) {\n  int cnt1 = 0, cnt2 = 0;\n  for (int i = 0; i < a.first.size(); i++) {\n    if (i % 2 == 0) {\n      if (a.first[i] == b.first[i]) {\n        continue;\n      } else if (a.first[i] > b.first[i]) {\n        cnt1++;\n      } else {\n        cnt2++;\n      }\n    } else {\n      if (a.first[i] == b.first[i]) {\n        continue;\n      } else if (a.first[i] > b.first[i]) {\n        cnt2++;\n      } else {\n        cnt1++;\n      }\n    }\n  }\n  return cnt2 > cnt1;\n}\nvoid solve() {\n  long long int n, m;\n  cin >> n >> m;\n  string s;\n  vector<pair<string, long long int>> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i].first;\n    v[i].second = i + 1;\n  }\n  sort(v.begin(), v.end(), cmp);\n  ;\n  for (auto it : v) {\n    cout << it.second << \" \";\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  solve();\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nlong long int mod = 1000000007;\nbool cmp(pair<string, long long int> &a, pair<string, long long int> &b) {\n  int cnt1 = 0, cnt2 = 0;\n  for (int i = 0; i < a.first.size(); i++) {\n    if (i % 2 == 0) {\n      if (a.first[i] == b.first[i]) {\n        continue;\n      } else if (a.first[i] > b.first[i]) {\n        cnt2++;\n      } else {\n        cnt1++;\n      }\n    } else {\n      if (a.first[i] == b.first[i]) {\n        continue;\n      } else if (a.first[i] > b.first[i]) {\n        cnt1++;\n      } else {\n        cnt2++;\n      }\n    }\n  }\n  if (cnt1 == cnt2) {\n    return a.second > b.second;\n  }\n  return cnt2 < cnt1;\n}\nvoid solve() {\n  long long int n, m;\n  cin >> n >> m;\n  string s;\n  vector<pair<string, long long int>> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i].first;\n    v[i].second = i + 1;\n  }\n  sort(v.begin(), v.end(), cmp);\n  ;\n  for (auto it : v) {\n    cout << it.second << \" \";\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  solve();\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint n, m;\ntypedef struct Node {\n  string element;\n  int id;\n} node;\nstruct cmp {\n  bool operator()(const node& x, const node& y) {\n    for (int i = 0; i < m; i++) return x.element > y.element;\n  }\n};\npriority_queue<node, vector<node>, cmp> mid;\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    node shu;\n    cin >> shu.element;\n    shu.id = i;\n    for (int j = 0; j < m; j++) {\n      if (j % 2 == 1) shu.element[j] = 'Z' - shu.element[j] + 'A';\n    }\n    cout << shu.element << endl;\n    mid.push(shu);\n  }\n  while (!mid.empty()) {\n    cout << mid.top().id << \" \";\n    mid.pop();\n  }\n  return 0;\n}\n","#include<bits\/stdc++.h>\n#include<ext\/pb_ds\/assoc_container.hpp>\n#include<ext\/pb_ds\/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class T> using oset = tree<T, null_type, less<T>,rb_tree_tag, tree_order_statistics_node_update>;\n#define ll long long\n#define mod 1000000007\n#define int long long\n#define endl \"\\n\"\nll power(int n,int k){\n    if(k==0)return 1;\n    ll ans;\n    ans=power(n,k\/2);\n    ans=((ans%mod)*(ans%mod))%mod;\n    if(k%2==0)return ans;\n    return ((ans%mod)*(n%mod))%mod;\n}\nint binary_search(vector<int> &v,int target){\n        int low=0,high=v.size()-1;\n        while(low<=high){\n            int mid=low+(high-low)\/2;\n            if(v[mid]==target){return mid;}\n            if(v[mid]>target){high=mid-1;}\n            else{low=mid+1;}\n        }\n        return -1;\n}\nvoid solve()\n{\n    int n,m;\n    cin>>n>>m;\n    vector<pair<string,int>> v(n);\n    for(int i=0;i<n;i++)\n    {\n        cin>>v[i].first;\n        v[i].second = i+1;\n    }\n\n    sort(v.begin(),v.end());\n\n    \/\/\/for(int i=0;i<n;i++)\n       \/\/\/ cout<<v[i].first<<\" \"<<v[i].second<<\"\\n\";\n    int idx = 0;\n    for(int i=0;i<n;i++)\n    {\n        if(v[i].first == v[n-1-i].first)\n        {\n            idx = i;\n            break;\n        }\n    }\n    vector<int> a,b;\n    for(int i=0;i<=idx;i++)\n    {\n        a.push_back(v[i].second);\n    }\n    sort(a.begin(),a.end(),greater<int>());\n    for(int i=idx+1;i<n;i++)\n    {\n        b.push_back(v[i].second);\n    }\n    sort(b.begin(),b.end());\n\n    for(int i=0;i<a.size();i++)\n        cout<<a[i]<<\" \";\n    for(int i=0;i<b.size();i++)\n        cout<<b[i]<< \" \";\n}\nint_fast32_t main() {\n    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#ifndef ONLINE_JUDGE\n   \/\/\/ freopen(\"input.txt\", \"r\", stdin);\n    \/\/\/freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    ll test=1;\n\/\/cin>>test;\n    while(test--)\n    {\n        solve();\n    }\n    return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int64_t M = 1e9 + 7;\nconst int64_t INF = 1e6 + 100;\nconst int MAXN = 2e5 + 5;\nbool prime[INF];\nint64_t spf[INF];\nint64_t d[INF] = {};\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nint dx8[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nint dy8[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nstring ds = \"RLDU\";\nlong long C(int n, int m) {\n  if (m > n) return 0;\n  long long z = 1;\n  for (int i = 0; i < m; i++) z = z * (n - i) \/ (i + 1);\n  return z;\n}\nlong long int invmod(long long int i) {\n  if (i == 1) return 1;\n  return (1000000007 -\n          ((1000000007 \/ i) * invmod(1000000007 % i)) % 1000000007 +\n          1000000007) %\n         1000000007;\n}\nvoid sieve() {\n  spf[1] = 1;\n  for (int i = 2; i < INF; i++) spf[i] = i;\n  for (int i = 4; i < INF; i += 2) spf[i] = 2;\n  for (int i = 3; i * i < INF; i++) {\n    if (spf[i] == i) {\n      for (int j = i * i; j < INF; j += i)\n        if (spf[j] == j) spf[j] = i;\n    }\n  }\n}\nint64_t binpow(int64_t a, int64_t b) {\n  if (b == 0) return 1;\n  if (b == 1) return a;\n  int64_t temp = binpow(a, b \/ 2);\n  if (b % 2 == 0)\n    return (temp * temp);\n  else\n    return (((temp * temp)) * a);\n}\nint64_t tot(int64_t n) {\n  int64_t result = n;\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      while (n % i == 0) n \/= i;\n      result -= result \/ i;\n    }\n  }\n  if (n > 1) result -= result \/ n;\n  return result;\n}\nvoid phi_1_to_n(int n) {\n  vector<int> phi(n + 1);\n  phi[0] = 0;\n  phi[1] = 1;\n  for (int i = 2; i <= n; i++) phi[i] = i;\n  for (int i = 2; i <= n; i++) {\n    if (phi[i] == i) {\n      for (int j = i; j <= n; j += i) phi[j] -= phi[j] \/ i;\n    }\n  }\n}\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nbool is_prime(int64_t n) {\n  if (n == 1) return false;\n  int64_t i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      return false;\n    }\n    i += 1;\n  }\n  return true;\n}\nvoid SieveOfEratosthenes() {\n  memset(prime, 1, sizeof(prime));\n  prime[1] = 0;\n  prime[0] = 0;\n  for (int p = 2; p * p < INF; p++) {\n    if (prime[p] == true) {\n      for (int i = p * p; i < INF; i += p) {\n        prime[i] = false;\n      }\n    }\n  }\n}\nvoid div() {\n  for (int64_t i = 1; i < INF; i++) {\n    for (int64_t j = i; j < INF; j += i) {\n      d[j] += i;\n      d[j] = d[j] % M;\n    }\n  }\n}\nvector<pair<long long, long long>> factors;\nvector<pair<long long, long long>> factorize(long long N) {\n  factors.clear();\n  vector<pair<long long, long long>> res;\n  for (long long a = 2; a * a <= N; ++a) {\n    if (N % a != 0) continue;\n    long long ex = 0;\n    while (N % a == 0) {\n      ++ex;\n      N \/= a;\n    }\n    res.push_back({a, ex});\n  }\n  if (N != 1) res.push_back({N, 1});\n  factors = res;\n  return res;\n}\nvector<int64_t> divisors;\nvoid getDivisors(int64_t ind = 0, int64_t res = 1) {\n  if (ind == (int)factors.size()) {\n    divisors.push_back(res);\n    return;\n  }\n  for (int64_t i = 0; i <= factors[ind].second; i++) {\n    getDivisors(ind + 1, res);\n    res *= factors[ind].first;\n  }\n}\nbool isqr(int64_t n) {\n  int64_t val = sqrt(n);\n  return (val * val) == n;\n}\nlong long binpow(long long a, long long b, long long m) {\n  a %= m;\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a % m;\n    a = a * a % m;\n    b >>= 1;\n  }\n  return res;\n}\nbool cmp(string a, string b) {\n  int n = a.size();\n  for (int i = 0; i < n; i++) {\n    if ((i + 1) % 2 == 1) {\n      if (a[i] != b[i]) {\n        return b > a;\n      }\n    } else {\n      if (a[i] != b[i]) {\n        return a > b;\n      }\n    }\n  }\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  string s[n];\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n  }\n  sort(s, s + n, cmp);\n  for (int i = 0; i < n; i++) cout << s[i] << \" \";\n  cout << endl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  { solve(); }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nbool cmp(string a, string b) {\n  if (a[0] != b[0]) return a < b;\n  return a > b;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  string arr[n], arr2[n];\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n    arr2[i] = arr[i];\n  }\n  sort(arr, arr + n, cmp);\n  for (int i = 0; i < n; i++) {\n    int x = 0;\n    while (arr2[x] != arr[i]) x++;\n    cout << x + 1 << \" \";\n  }\n}\n","#include <bits\/stdc++.h>\ntemplate <typename T>\nvoid swap(T &a, T &b) {\n  T tmp = a;\n  a = b;\n  b = tmp;\n}\nchar buffer[2000000];\nint n, m;\nchar *inp[1000000];\nint perm[1000000];\nint bucket[1000000];\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  char *offset = buffer;\n  std::cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    inp[i] = offset;\n    offset += m + 1;\n    std::cin >> std::ws;\n    std::cin.getline(inp[i], 2 * (m + 1));\n    perm[i] = i;\n    bucket[i] = 0;\n  }\n  for (int i = 0; i < m; i++) {\n    int c = 0;\n    while (c < n) {\n      int b = c;\n      if (i % 2 == 0) {\n        for (char ch = 'A'; ch <= 'Z'; ch++) {\n          c = b;\n          int buck = b;\n          for (; c < n && bucket[buck] == bucket[c]; c++) {\n            if (inp[perm[c]][i] == ch) {\n              swap(perm[c], perm[b]);\n              b++;\n            }\n          }\n          for (int j = buck; j < b; j++) {\n            bucket[j] = buck;\n          }\n        }\n        for (int j = b; j < c; j++) {\n          bucket[j] = b;\n        }\n      } else {\n        for (char ch = 'Z'; ch >= 'A'; ch--) {\n          c = b;\n          int buck = b;\n          for (; c < n && bucket[buck] == bucket[c]; c++) {\n            if (inp[perm[c]][i] == ch) {\n              swap(perm[c], perm[b]);\n              b++;\n            }\n          }\n          for (int j = buck; j < b; j++) {\n            bucket[j] = buck;\n          }\n        }\n        for (int j = b; j < c; j++) {\n          bucket[j] = b;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    std::cout << perm[i] + 1 << \" \";\n  }\n  std::cout << std::endl;\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nstruct sp {\n  string s1, s2;\n  int id;\n};\nint n, i, m;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  sp s[n];\n  for (int k = 0; k < n; k++) {\n    string s1 = \"\", s2 = \"\";\n    for (int j = 0; j < m; j++) {\n      char c;\n      cin >> c;\n      if (j % 2 == 0) {\n        s1 += c;\n      } else {\n        s2 += c;\n      }\n    }\n    s[k] = {s1, s2, k + 1};\n  }\n  stable_sort(s, s + n, [](sp A, sp B) { return A.s2 > B.s2; });\n  stable_sort(s, s + n, [](sp A, sp B) { return A.s1 < B.s1; });\n  for (int p = 0; p < n; p++) cout << s[p].id << \" \";\n  cout << \"\\n\";\n  return 0;\n}\n","#include<bits\/stdc++.h>\n#include<ext\/pb_ds\/assoc_container.hpp>\n#include<ext\/pb_ds\/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define fast() ios_base::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL);\n#define ll int64_t\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n#define pb push_back\n#define mp make_pair\n#define pf push_front\n#define rep(i,a,b,k) for(ll i=a;i<b;i+=k)\n#define rept(i,a,b) for(auto i=a;i!=b;++i)\n#define drep(i,a,b,k) for(ll i=a;i>=b;i-=k)\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem1(a) memset(a,0,sizeof(a))\n#define w(t) while(t--)\n#define array(arr,n) vector<ll>arr(n);for(ll i=0;i<n;i++)cin>>arr[i];\n#define ni1(t) ll t;cin>>t;\n#define ni2(a,b) ll a,b;cin>>a>>b\n#define ni3(a,b,c) ll a,b,c;cin>>a>>b>>c\n#define ni4(a,b,c,d) ll a,b,c,d;cin>>a>>b>>c>>d\n#define ni5(a,b,c,d,e) ll a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define ni6(a,b,c,d,e,f) ll a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define ns(s) string s;cin>>s\n#define print(x) for(auto ele:x)cout<<ele<<\" \";cout<<endl;\n#define printp(x)  for(auto ele:x)cout<<ele.first<<\" \"<<ele.second<<endl;\n#define printm(m) for(auto x:m)cout<<x.first<<\" \"<<x.second<<endl;\nconst ll mod=1000000007;\nconst ll siz1=200005;\nconst ll siz2=1000005;\nconst ll INF = 1e16;\nconst ll intmax = INT_MAX;\nconst ll intmin = INT_MIN;\n#define khatam return 0\n#define xt first\n#define yt second\n#define all(x) x.begin(),x.end()\ntypedef vector<ll> vl;\ntypedef vector<pair<ll,ll>> vll;\ntypedef unordered_map<ll,ll> ull;\ntypedef map<ll,ll> mll;\ntypedef pair<ll,ll>pll;\ninline ll mod_add(ll a,ll b,ll m){a = a % m;b = b % m;return (((a + b) % m) + m) % m;}\ninline ll mod_mul(ll a,ll b,ll m){a = a % m;b = b % m;return (((a * b) % m) + m) % m;}\ninline ll mod_sub(ll a,ll b,ll m){a = a % m;b = b % m;return (((a - b) % m) + m) % m;}\nll binPow(ll x,ll n,ll m){ll res=1;while(n){if(n&1) res=(res*x)%m;x=(x*x)%m;n>>=1;}return res;}\nll modInv(ll i, ll m) {return binPow(i,m-2,m);}\n\/\/vl fact(siz1);\n\/\/ll ncr(int n,int r) {return (n>=r?(fact[n]*modInv(fact[r],mod))%mod*modInv(fact[n-r],mod)%mod:0);}\n\/\/void factorial(){fact[0]=1;rep(i,1,siz1,1)fact[i]=(fact[i-1]*i)%mod;}\nll no_of_digits(ll a){ll cnt=0;while(a>0){a\/=10;cnt++;}return cnt;}\nll _log(ll a,ll b){ll cnt=0;while(a>0){a\/=b;cnt++;}return cnt;}\nvoid init(int p){cout<<fixed<<setprecision(p);}\ninline ll getmin(ll a,ll b){return min(a,b);}\ninline ll getmin(ll a,ll b,ll c){return min(min(a,b),c);}\ninline ll getmin(ll a,ll b,ll c,ll d){return min(a,min(b,min(c,d)));}\ninline ll getmax(ll a,ll b){return max(a,b);}\ninline ll getmax(ll a,ll b,ll c){return max(a,max(b,c));}\ninline ll getmax(ll a,ll b,ll c,ll d){return max(a,max(b,max(c,d)));}\nll curr=0;\nbool op(pair<string,ll> &a,pair<string,ll> &b){\n    return a.xt[curr]<b.xt[curr];\n}\nbool op1(pair<string,ll> &a,pair<string,ll> &b){\n   \n    return b.xt[curr]<a.xt[curr];\n}\n\n\nvoid solve()\n    {\n        ni2(n,d);\n        vector<pair<string,ll>>val(n);\n        rep(i,0,n,1){cin>>val[i].xt;val[i].yt=i;}\n        rep(i,0,n,1){\n           curr=i;\n           if(i%2==1){sort(all(val),op);}\n          \n        }\n        rep(i,0,n,1){\n            curr=i;\n             if(i%2==0) {sort(all(val),op1);}\n        }\n        \n        drep(i,n-1,0,1)cout<<val[i].yt+1<<\" \";cout<<endl;\n    }\n\nint main(){\n    fast();\n    \/\/ni1(t);w(t)\n    solve();\n    #ifndef ONLINE_JUDGE\n        cerr<<\"\\nTime elapsed: \"<<1000*clock()\/CLOCKS_PER_SEC<<\"ms\\n\";\n    #endif\n    khatam; \n}","#include <bits\/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\nusing namespace std;\nbool compare(pair<string, int>& A, pair<string, int>& B) {\n  int k = A.first.size();\n  bool flag = true;\n  for (int i = 0; i < k; i++) {\n    if ((i + 1) % 2) {\n      if (A.first[i] > B.first[i]) {\n        flag = false;\n        break;\n      }\n    } else {\n      if (A.first[i] < B.first[i]) {\n        flag = false;\n        break;\n      }\n    }\n  }\n  if (A.first == B.first) {\n    return A.second < B.second;\n  }\n  return flag;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<string, int>> A(n);\n  for (int i = 0; i < n; i++) {\n    cin >> A[i].first;\n    A[i].second = i + 1;\n  }\n  sort(A.begin(), A.end(), compare);\n  for (auto it : A) {\n    cout << it.second << \" \";\n  }\n  cout << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 3;\nconst int md = 1e9 + 7;\nconst int inf = 1e9 + 3;\nint n, m;\nstring a[N];\nint b[N];\nbool cmp(int x, int y) {\n  for (int i = 0; i < m; ++i) {\n    if (a[x][i] != a[y][i]) {\n      if (i & 1) {\n        return a[x][i] > a[i][i];\n      } else {\n        return a[x][i] < a[y][i];\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) cin >> a[i], b[i] = i;\n  sort(b + 1, b + n + 1, cmp);\n  for (int i = 1; i <= n; ++i) cout << b[i] << ' ';\n}\n"]}}
{"name":"1607_C. Minimum Extraction","public_tests":{"input":["8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n"],"output":["10\n0\n2\n5\n2\n2\n2\n-2\n"]},"solutions":{"language":[2,3,2,2,3,3,2,2,4,4,2,4,4,4,4,2,4,4,3,2,3,2,3,4,4,4,2,3,4,2,3,2,2,2,4,3,4,3,4,4,2,3,4,3,3,4,2,3,4,3,4,2,4,2,2,3,2,4,3,4,4,4,3,2,3,4,3,3,3,3,3,4,4,4,2,2,2,4,4,3,4,3,4,2,4,2,3,3,4,2,4,4,3,3,4,3,4,2,2,4,2,3,3,4,2,3,4,4,3,2,4,2,3,4,4,2,4,2,3,2,3,3,3,2,2,1,2,3,3,2,2,4,4,4,2,2,3,3,3,3,4,3,3,2,2,2,3,3,4,3,3,2,2,4,2,2,3,2,2,3,2,2,3,3,3,4,3,1,3,4,2,4,4,4,4,4,4,2,4,2,4,4,2,2,3,3,4,3,2,3,3,3,3,4,4,2,4,4,3,2,3,3,2,4,2,2,4,3,4,3,3,3,4,3,2,4,4,4,3,4,3,4,2,2,3,3,4,3,2,3,4,2,2,2,3,2,2,3,3,2,3,2,4,2,4,4,2,3,3,3,2,2,2,3,4,2,4,2,3,3,2,3,3,3,3,3,4,4,4,4,2,2,3,2,3,3,4,4,4,4,2,3,3,2,2,4,4,4,4,3,3,4,3,2,2,3,2,4,4,4,3,4,4,3,3,2,2,3,2,3,3,3,3,2,2,1,2,3,4,4,3,3,2,2,2,4,3,3,2,2,2,4,4,4,4,3,2,2,4,4,2,3,4,3,2,3,2,4,2,4,3,2,2,3,4,3,3,3,2,4,2,4,4,2,2,3,3,2,4,3],"solution":["#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> list;\n    int max_value = INT_MIN;\n    for (int i = 0; i < n; i++) {\n      int temp;\n      cin >> temp;\n      list.push_back(temp);\n    }\n    sort((list).begin(), (list).end());\n    int change = 0;\n    for (int i = 0; i < list.size(); i++) {\n      list[i] = list[i] - change;\n      max_value = max(list[i], max_value);\n      change += list[i];\n    }\n    cout << max_value << '\\n';\n    ;\n  }\n  return 0;\n}\n","for _ in range(int(input())):\n  n=int(input())\n  l=list(map(int,input().split()))\n  l.sort()\n  s=0\n  x=l[0]\n  mn=x\n  for i in range(n):\n    x=l[i]-s\n    s+=x\n    mn=max(x,mn)\n    \n  print(mn)\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long INF = 2 * 1e18;\nsigned main() {\n  cin.sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long N;\n    cin >> N;\n    long long i, j;\n    priority_queue<long long, vector<long long>, greater<long long> > PQ;\n    for (i = 0; i < N; i++) {\n      cin >> j;\n      PQ.push(j);\n    }\n    long long ma = PQ.top();\n    long long mi = 0;\n    while (PQ.size() >= 2) {\n      long long t = PQ.top();\n      mi += t - mi;\n      PQ.pop();\n      ma = max(ma, PQ.top() - mi);\n    }\n    cout << ma << '\\n';\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int maxn = 2 * 1e5 + 10;\nint T;\nint a[maxn], n, ans;\nint main() {\n  cin >> T;\n  for (int i = 1; i <= T; i++) {\n    memset(a, 0, sizeof(a));\n    ans = -1e9 - 10;\n    cin >> n;\n    for (int j = 1; j <= n; j++) scanf(\"%d\", &a[j]);\n    sort(a + 1, a + n + 1);\n    for (int j = 1; j <= n; j++) ans = max(a[j] - a[j - 1], ans);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n","import sys\n\nt = int(input())\nres = []\nfor j in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  a = sorted(a)\n  x = -sys.maxsize - 1\n  s = 0\n  for i in range(n):\n    x = max(x, a[i])\n    s += a[i]\n    if i < n - 1:\n      a[i + 1] -= s\n  # minA = [0] * n\n  # newA = a.copy()\n  # x = 0\n  # minA[n - 1] = min(a)\n  # x = minA[n - 1]\n  # del newA[newA.index(x)]\n  # newA = list(map(lambda y: y - x, newA))\n  # for i in range(n - 1):\n  #   if len(newA) == 0:\n  #     break\n  #   curMinA = min(newA)\n  #   val = max(minA[n - 2 - i + 1], curMinA)\n  #   if minA[n - 2 - i + 1] <= val:\n  #     minA[n - 2 - i] = val\n  #     x = minA[n - 2 - i]\n  #     if curMinA in newA:\n  #       del newA[newA.index(curMinA)]\n  #     newA = list(map(lambda y: y - curMinA, newA))\n  #   else:\n  #     break\n  res.append(x)\n\nfor index in range(t):\n  print(res[index])","for _ in range(int(input())):\n    n = int(input())\n    # n, k = map(int, input().split())\n    arr= list(map(int, input().split()))\n    # output_arr =[]\n    \n    \n    # box= \n    if len(arr)==1:\n        print(arr[0])\n        continue\n    arr.sort()\n    # print(arr)\n    sumo= arr[0]\n    # print(sumo)\n    res= arr[0]\n    for i in range(1,len(arr)):\n        if i == len(arr):\n            break\n        box= (arr[i])- sumo\n        sumo= sumo+ box\n        # print(\"sumo\", sumo)\n        # print(\"box\", box)\n        if box > res:\n            res= box\n            # print(\"res\", res)\n        \n        \n\n    print(res)","#include <bits\/stdc++.h>\nusing namespace std;\nstruct hash_pair {\n  template <class T1, class T2>\n  size_t operator()(const pair<T1, T2> &p) const {\n    auto hash1 = hash<T1>{}(p.first);\n    auto hash2 = hash<T2>{}(p.second);\n    return hash1 ^ hash2;\n  }\n};\nlong long int n, m;\nvector<long long int> adj[1];\nbool visited[1];\nlong long int start[1];\nlong long int end[1];\nlong long int parent[1];\nlong long int level[1];\nvector<long long int> dfs_order;\nvoid dfs(long long int node) {\n  visited[node] = true;\n  for (long long int next : adj[node]) {\n    if (!visited[next]) {\n      parent[next] = node;\n      level[next] = level[node] + 1;\n      dfs(next);\n    }\n  }\n}\nlong long int dist[1];\nvoid bfs(long long int start) {\n  memset(dist, -1, sizeof dist);\n  queue<long long int> q;\n  dist[start] = 0;\n  q.push(start);\n  while (!q.empty()) {\n    long long int v = q.front();\n    q.pop();\n    for (long long int e : adj[v]) {\n      if (dist[e] == -1) {\n        dist[e] = dist[v] + 1;\n        q.push(e);\n      }\n    }\n  }\n}\nlong long int lift(long long int a, long long int dist,\n                   vector<vector<long long int>> &up) {\n  for (long long int i = 0; i < 20; i++) {\n    if (dist & (1 << i)) {\n      a = up[a][i];\n    }\n  }\n  return a;\n}\nvoid preprocesslift(vector<vector<long long int>> &up) {\n  for (long long int j = 1; j < 20; j++) {\n    for (long long int i = 1; i <= n; i++) {\n      if (up[i][j - 1] != -1) {\n        up[i][j] = up[up[i][j - 1]][j - 1];\n      }\n    }\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int t;\n  cin >> t;\n  while (t > 0) {\n    long long int x;\n    cin >> n;\n    multiset<long long int> s;\n    long long int mn = numeric_limits<long long int>::max();\n    for (long long int i = 0; i < n; i++) {\n      long long int x;\n      cin >> x;\n      mn = min(mn, x);\n      s.insert(x);\n    }\n    long long int temp = 0;\n    while (s.size() > 1) {\n      long long int x = *s.begin() + temp;\n      mn = max(mn, *s.begin() + temp);\n      temp += -x;\n      s.erase(s.begin());\n    }\n    mn = max(mn, *s.begin() + temp);\n    cout << mn << \"\\n\";\n    t--;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long a[n];\n    vector<long long> p;\n    for (int i = 0; i <= n - 1; i += 1) {\n      cin >> a[i];\n    }\n    sort(a, a + n);\n    long long k = 0, x = (-1) * 1000000007;\n    for (int i = 0; i <= n - 1; i += 1) {\n      a[i] -= k;\n      x = max(x, a[i]);\n      k += a[i];\n    }\n    cout << x << \"\\n\";\n  }\n}\n","\nimport java.util.*;\nimport java.io.*;\n\npublic class cf1 {\n    static int M = 1_000_000_007;\n     static final PrintWriter out =new PrintWriter(System.out);\n     static boolean prime[];\n    \n    public static void main(String[] args) throws Exception{\n        FastIO io = new FastIO();\n        int t=io.nextInt();\n        while(t-- > 0){\n            \/\/ -----------------\n            \n            int n = io.nextInt();\n            int arr[] = new int[n];\n            PriorityQueue<Integer> pq = new PriorityQueue<>();\n            for(int i=0; i<n; i++){\n                int val = io.nextInt();\n                pq.add(val);\n            }\n            int min = pq.peek();\n            int last = 0;\n            while(pq.size() > 1){\n                int top = pq.remove();\n                top = top-last;\n                min = Math.max(top, min);\n                last += top;\n            }\n            min = Math.max(min, pq.peek()-last);\n            out.println(min);\n            \/\/ -----------------\n            out.flush();\n        }\n        \n    }\n   \n static class FastIO extends PrintWriter {\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1<<16];\n\tprivate int curChar, numChars;\n \n\t\/\/ standard input\n\tpublic FastIO() { this(System.in,System.out); }\n\tpublic FastIO(InputStream i, OutputStream o) {\n\t\tsuper(o);\n\t\tstream = i;\n\t}\n\t\/\/ file input\n\tpublic FastIO(String i, String o) throws IOException {\n\t\tsuper(new FileWriter(o));\n\t\tstream = new FileInputStream(i);\n\t}\n \n\t\/\/ throws InputMismatchException() if previously detected end of file\n\tprivate int nextByte() {\n\t\tif (numChars == -1) throw new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars == -1) return -1; \/\/ end of file\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic String nextLine() {\n\t\tint c; do { c = nextByte(); } while (c <= '\\n');\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo { res.appendCodePoint(c); c = nextByte(); } while (c > '\\n');\n\t\treturn res.toString();\n\t}\n \n\tpublic String next() {\n\t\tint c; do { c = nextByte(); } while (c <= ' ');\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo { res.appendCodePoint(c); c = nextByte(); } while (c > ' ');\n\t\treturn res.toString();\n\t}\n \n\tpublic int nextInt() { \n\t\tint c; do { c = nextByte(); } while (c <= ' ');\n\t\tint sgn = 1; if (c == '-') { sgn = -1; c = nextByte(); }\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres = 10*res+c-'0';\n\t\t\tc = nextByte();\n\t\t} while (c > ' ');\n\t\treturn res * sgn;\n\t}\n \n  public long nextLong() { \n\t\tint c; do { c = nextByte(); } while (c <= ' ');\n\t\tlong sgn = 1; if (c == '-') { sgn = -1; c = nextByte(); }\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres = 10*res+c-'0';\n\t\t\tc = nextByte();\n\t\t} while (c > ' ');\n\t\treturn res * sgn;\n\t}\n \n\tpublic double nextDouble() { return Double.parseDouble(next()); }\n}\n\n}\n","import java.io.*;\nimport java.util.*;\npublic class Main {\n   \n    public static void main(String args[]) {\n        FastReader input=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        int T=input.nextInt();\n        while (T-- > 0)\n        {\n            \/\/ long x=input.nextLong(),n=input.nextLong();\n            \/\/ long i=1;\n            \/\/ while(i<n+1)\n            \/\/ {\n            \/\/     if(x%2==0) x-=i;\n            \/\/     else x+=i;\n            \/\/     i++;\n            \/\/ }\n            \n            \/\/ out.println(x);\n            long n=input.nextLong();\n            ArrayList<Long> a= new ArrayList<>();\n            for(int i=0;i<n;i++)\n             a.add(input.nextLong()); \n             Collections.sort(a);\n             long max = a.get(0);\n\t\t\tfor(int i = 1;i<n;i++)\n\t\t\t{\n\t\t\t\tmax = Math.max(max, a.get(i)-a.get(i-1));\n\t\t\t}\n             \n         out.println(max);\n        }\n \n        out.close();\n    }\n    \n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader()\n        {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n        String nextLine()\n        {\n            String str=\"\";\n            try\n            {\n                str=br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\npriority_queue<int, vector<int>, greater<int>> p;\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int temp = 0;\n    int Min = -0x3f3f3f3f;\n    while (n--) {\n      int a;\n      cin >> a;\n      p.push(a);\n    }\n    while (!p.empty()) {\n      int now = p.top();\n      p.pop();\n      Min = max(Min, now + temp);\n      temp -= now + temp;\n    }\n    cout << Min << '\\n';\n  }\n  return 0;\n}\n","import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\n\/**\n *\n * @author Acer\n *\/\npublic class MaximumExtraction_c {\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int T = sc.nextInt();\n        while(T-- > 0){\n            int n = sc.nextInt();\n            ArrayList<Integer> arr = new ArrayList<Integer>();           \n            for (int i = 0; i < n; i++) {\n                arr.add(sc.nextInt());\n            }\n            \n            if(n == 1){\n                System.out.println(arr.get(0));\n                continue;\n            }\n            \n            Collections.sort(arr);\n            \n            long prev = arr.get(0);\n            long max = arr.get(0);\n            long ans = 0;\n            for (int i = 1; i < n; i++) {\n                ans = arr.get(i)-prev;\n                prev = prev+ans;\n                max = Math.max(max, ans);\n            }\n            System.out.println(max);\n        }\n    }\n    \n}","\/\/ Problem: C. Minimum Extraction\n\/\/ Contest: Codeforces - Codeforces Round #753 (Div. 3)\n\/\/ URL: https:\/\/codeforces.com\/contest\/1607\/problem\/C\n\/\/ Memory Limit: 256 MB\n\/\/ Time Limit: 1000 ms\n\/\/ \n\/\/ Powered by CP Editor (https:\/\/cpeditor.org)\n\nimport java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\n\n\n\npublic class Main {\n\n    private void preparation() {\n\n    }\n\n\n    private void clear() {\n\n    }\n\n    private void solve() throws Exception {\n        rf();\n        int n = ri();\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        rf();\n        for(int i = 0; i < n; i++){\n            pq.add(rl());\n        }\n\t\t\n\t\tlong ans = Long.MIN_VALUE;\n\t\tlong curInc = 0;\n\t\twhile(!pq.isEmpty())    {\n\t\t    long cur = pq.poll() - curInc;\n\t\t    ans = max(ans, cur);\n\t\t    curInc += cur;\n\t\t}\n\t\taddAns(ans);\n\t\t\n    }\n\n    private void run() throws Exception {\n\t\t\n        int T = 1;\n\t\trf();\n\t\tT = ri();\n\t\t\n\t\tpreparation();\n        while (T-- > 0) {\n            solve();\n            if (T != 0) {\n                clear();\n            }\n        }\n        printAns();\n    }\n\n    public static void main(String[] args) throws Exception {\n        new Main().run();\n    }\n\n    StringBuilder sb = new StringBuilder();\n    BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer strT;\n\n\tprivate void addAns(int a){\n\t\tsb.append(a + \"\\n\");\n\t}\n\t\n\tprivate void addAns(long a){\n\t\tsb.append(a + \"\\n\");\n\t}\n\t\n\tprivate void addAns(String s){\n\t\tsb.append(s + \"\\n\");\n\t}\n\n    private void rf() throws IOException {\n        strT = new StringTokenizer(infile.readLine());\n    }\n\n\n    private int ri() {\n        return Integer.parseInt(strT.nextToken());\n    }\n\n    private long rl() {\n        return Long.parseLong(strT.nextToken());\n    }\n\n\tprivate char [] rs2c(){\n\t\treturn strT.nextToken().toCharArray();\n\t}\n\t\n\tprivate String rs(){\n\t\treturn strT.nextToken();\n\t}\n\n    private void printAns() {\n        System.out.println(sb);\n    }\n\n    private int[] readArr(int N) throws Exception {\n        int[] arr = new int[N];\n        for (int i = 0; i < N; i++) {\n            arr[i] = Integer.parseInt(strT.nextToken());\n        }\n        return arr;\n    }\n\n\tprivate long[] readArr2(int N) throws Exception {\n        long[] arr = new long[N];\n        for (int i = 0; i < N; i++) {\n            arr[i] = Long.parseLong(strT.nextToken());\n        }\n        return arr;\n    }\n\n\tprivate void print(String format, Object ... args){\n\t\tSystem.out.println(String.format(format,args));\n\t}\n\t\n\n    private void print(int[] arr, int x) {\n        \/\/for debugging only\n        for (int i = 0;i < min(arr.length, x); i++) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n    \n    private void print(long[] arr, int x) {\n        \/\/for debugging only\n        for (int i = 0;i < min(arr.length, x); i++) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n\n    \n}\n","import java.io.*;\nimport java.util.*;\n\npublic class CodeForces{\n    \/*-------------------------------------------EDITING CODE STARTS HERE-------------------------------------------*\/\n    public static void main(String[] args) throws IOException{\n        openIO();\n        int testCase = 1;\n        testCase = sc.nextInt();\n        preCompute();\n        for (int i = 1; i <= testCase; i++) solve(i);\n        closeIO();\n    }\n\n    public static void solve(int tCase)throws IOException {\n        int n = sc.nextInt();\n        long[] arr = new long[n];\n        for(int i=0;i<n;i++)arr[i] = sc.nextInt();\n        _sort(arr,true);\n        long max = arr[0];\n        for(int i=1;i<n;i++)\n            max = Math.max(max,arr[i] - arr[i-1]);\n        out.println(max);\n    }\n\n\n    private static void  preCompute(){\n\n    }\n    \/*-------------------------------------------EDITING CODE ENDS HERE-------------------------------------------*\/\n    static FastestReader sc;\n    static PrintWriter out;\n    private static void openIO() throws IOException{\n        sc = new FastestReader();\n        out = new PrintWriter(System.out);\n    }\n\n    \/*------------------------------------------HELPER FUNCTION STARTS HERE------------------------------------------*\/\n\n    public static final int mod = (int) 1e9 +7;\n    private static final int mod2 =  998244353;\n    public static final int inf_int = (int) 2e9;\n    public static  final long inf_long = (long) 4e18;\n\n    \/\/ euclidean algorithm time O(max (loga ,logb))\n    public static long _gcd(long a, long b) {\n        if (a == 0)\n            return b;\n        return _gcd(b % a, a);\n    }\n\n    public static long _lcm(long a, long b) {\n        \/\/ lcm(a,b) * gcd(a,b) = a * b\n        return (a \/ _gcd(a, b)) * b;\n    }\n\n\n    \/\/ binary exponentiation time O(logn)\n    public static long _power(long x, long n) {\n        long ans = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ans *= x;\n                ans %= mod;\n                n--;\n            } else {\n                x *= x;\n                x %= mod;\n                n >>= 1;\n            }\n        }\n        return ans;\n    }\n    \/\/sieve\/first divisor time : O(mx * log ( log (mx) ) )\n    public static int[]  _seive(int mx){\n        int[] firstDivisor = new int[mx+1];\n        for(int i=0;i<=mx;i++)firstDivisor[i] = i;\n        for(int i=2;i*i<=mx;i++)\n            if(firstDivisor[i] == i)\n                for(int j = i*i;j<=mx;j+=i)\n                    firstDivisor[j] = i;\n        return firstDivisor;\n    }\n\n    private static boolean _isPrime(long x){\n        for(long i=2;i*i<=x;i++)\n            if(x%i==0)return false;\n        return true;\n    }\n\n    public static void _sort(int[] arr,boolean isAscending){\n        int n = arr.length;\n        List<Integer> list = new ArrayList<>();\n        for(int ele : arr)list.add(ele);\n        Collections.sort(list);\n        if(!isAscending)Collections.reverse(list);\n        for(int i=0;i<n;i++)arr[i] = list.get(i);\n    }\n    public static void _sort(long[] arr,boolean isAscending){\n        int n = arr.length;\n        List<Long> list = new ArrayList<>();\n        for(long ele : arr)list.add(ele);\n        Collections.sort(list);\n        if(!isAscending)Collections.reverse(list);\n        for(int i=0;i<n;i++)arr[i] = list.get(i);\n    }\n    \/*------------------------------------------HELPER FUNCTION ENDS HERE-------------------------------------------*\/\n\n    \/*-------------------------------------------FAST INPUT STARTS HERE---------------------------------------------*\/\n\n    public static void closeIO() throws IOException{\n        out.flush();\n        out.close();\n        sc.close();\n    }\n    private static final class FastestReader {\n        private static final int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public FastestReader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public FastestReader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\n        private int skip() throws IOException {\n            int b;\n            \/\/noinspection StatementWithEmptyBody\n            while ((b = read()) != -1 && isSpaceChar(b)) {}\n            return b;\n        }\n\n        public String next() throws IOException {\n            int b = skip();\n            final StringBuilder sb = new StringBuilder();\n            while (!isSpaceChar(b)) { \/\/ when nextLine, (isSpaceChar(b) && b != ' ')\n                sb.appendCodePoint(b);\n                b = read();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) { c = read(); }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') { c = read(); }\n            final boolean neg = c == '-';\n            if (neg) { c = read(); }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') { c = read(); }\n            final boolean neg = c == '-';\n            if (neg) { c = read(); }\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') \/ (div *= 10);\n                }\n            }\n\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) { buffer[0] = -1; }\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) { fillBuffer(); }\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            din.close();\n        }\n    }\n    \/*---------------------------------------------FAST INPUT ENDS HERE ---------------------------------------------*\/\n}","import java.util.*;\nimport java.io.*;\n\n\/\/\/\/***************************************************************************\n \/* public class E_Gardener_and_Tree implements Runnable{\n\n       public static void main(String[] args) throws Exception {\n        new Thread(null, new E_Gardener_and_Tree(), \"E_Gardener_and_Tree\", 1<<28).start();\n       }\n    public void run(){\n         WRITE YOUR CODE HERE!!!!\n         JUST WRITE EVERYTHING HERE WHICH YOU WRITE IN MAIN!!!\n       }\n\n  }\n*\/\n\/\/\/\/\/**************************************************************************\n\n\npublic class C_Minimum_Extraction{\n    public static void main(String[] args) {\n        FastScanner s= new FastScanner();\n       \/\/ PrintWriter out=new PrintWriter(System.out);\n        \/\/end of program\n        \/\/out.println(answer);\n        \/\/out.close();\n        StringBuilder res = new StringBuilder();\n        int t=s.nextInt();\n        int p=0;\n        while(p<t){\n        int n=s.nextInt();\n        ArrayList<Long> nice = new  ArrayList<Long>();\n        for(int i=0;i<n;i++){\n            long a=s.nextLong();\n            nice.add(a);\n        }\n        Collections.sort(nice);\n        long ans=Long.MIN_VALUE;\n        long yo=0;\n        for(int i=0;i<n;i++){\n            long num=nice.get(i);\n            num-=yo;\n            ans=Math.max(ans,num);\n            yo+=num;\n\n        }\n        res.append(ans+\"\\n\");\n        p++;\n    }\n    System.out.println(res);\n\n    }\n    static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n \n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n \n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n \n\t\tString nextToken() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n \n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n \n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\n\n\n}","#include <bits\/stdc++.h>\nusing namespace std;\nconst auto LAMBDA_TRUE = [](long long int) { return true; };\nconst auto LAMBDA_FALSE = [](long long int) { return false; };\nlong long int _fastXOR(const long long int &_n) {\n  if (_n % 4 == 0) return _n;\n  if (_n % 4 == 1) return 1;\n  if (_n % 4 == 2) return _n + 1;\n  return 0;\n}\nlong long int _fastSUM(const long long int &_n) { return ((1 + _n) * _n) \/ 2; }\nlong long int _ceil(const long long int &_v1, const long long int &_v2) {\n  return (_v1 + _v2 - 1) \/ _v2;\n}\ntemplate <class T>\npair<T, T> _min_v(\n    const vector<T> &_v,\n    const std::function<bool(const T &)> &_cmpv = LAMBDA_TRUE,\n    const std::function<bool(const T &)> &_cmpi = LAMBDA_TRUE) noexcept {\n  pair<T, T> r;\n  r.first = numeric_limits<long long int>::max();\n  for (size_t i = 0; i < _v.size(); i++)\n    if (_v[i] < r.first && _cmpv(_v[i]) && _cmpi(i)) {\n      r.first = _v[i];\n      r.second = i;\n    }\n  return r;\n}\ntemplate <class T>\npair<T, T> _max_v(\n    const vector<T> &_v,\n    const std::function<bool(const T &)> &_cmpv = LAMBDA_TRUE,\n    const std::function<bool(const T &)> &_cmpi = LAMBDA_TRUE) noexcept {\n  pair<T, T> r;\n  r.first = numeric_limits<long long int>::min();\n  for (size_t i = 0; i < _v.size(); i++)\n    if (_v[i] > r.first && _cmpv(_v[i]) && _cmpi(i)) {\n      r.first = _v[i];\n      r.second = i;\n    }\n  return r;\n}\nvoid solve() {\n  long long int n;\n  cin >> n;\n  vector<long long int> a(n);\n  for (long long int i = 0; i < n; i++) cin >> a[i];\n  sort(a.begin(), a.end());\n  long long int d = a[0];\n  long long int ma = a[0];\n  for (long long int i = 1; i < n; i++) {\n    a[i] -= d;\n    d += a[i];\n    ma = max(a[i], ma);\n  }\n  cout << ma << endl;\n}\nint main(int argc, char **argv) {\n  ios_base::sync_with_stdio(NULL);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n","\/*package whatever \/\/do not write package name here *\/\n\nimport java.io.*;\nimport java.util.*;\n\npublic class GFG {\n\tpublic static void main (String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tlong t=sc.nextLong();\n\t\twhile(t-->0)\n\t\t{\n\t\t   int n=sc.nextInt();\n\t\t   Long arr[]=new Long[n];\n\t\t   for(int i=0;i<n;i++)\n\t\t   {\n\t\t       arr[i]=sc.nextLong();\n\t\t   }\n\t\t   Arrays.sort(arr);\n\t\t   long ans=arr[0];\n\t\t   for(int i=0;i<n-1;i++)\n\t\t   {\n\t\t       ans=Math.max(arr[i+1]-arr[i],ans);\n\t\t   }\n\t\t   System.out.println(ans);\n\t\t}\n\t}\n}","\/\/ Working program using Reader Class\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n    static class Reader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(\n                    new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; \/\/ line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt != 0) {\n                        break;\n                    }\n                    else {\n                        continue;\n                    }\n                }\n                buf[cnt++] = (byte)c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') \/ (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0,\n                    BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n    public static void main(String[] args)\n            throws IOException\n    {\n        Reader sc = new Reader();\n        int t = sc.nextInt();\n        while(t-- >0)\n        {\n            int n = sc.nextInt();\n            ArrayList<Integer> list = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                list.add(sc.nextInt());\n            }\n            Collections.sort(list);\n            int ans = list.get(0);\n            for (int i = 1; i < n; i++) {\n                ans = Math.max(ans, list.get(i) - list.get(i-1));\n            }\n            System.out.println(ans);\n        }\n    }\n}\n","for s in[*open(0)][2::2]:a=sorted(map(int,s.split()));print(max(y-x\nfor x,y in zip([0]+a,a)))","#include <bits\/stdc++.h>\nusing namespace std;\nint t;\nint n;\nlong long a[200010], b[200010];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    if (n == 1) {\n      cout << a[1] << \"\\n\";\n      continue;\n    }\n    sort(a + 1, a + n + 1);\n    long long ans = 0;\n    for (int i = 1; i <= n; i++) {\n      ans = max(ans, a[i] - a[i - 1]);\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n","t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input().split()\n    for j in range(n):\n        s[j] = int(s[j])\n    s.sort()\n    hieu = 0\n    res = s[0]\n    for i in range(1,n):\n        s[i] = s[i] - hieu -s[i-1]\n        hieu+=s[i-1]\n        res =  max(res,s[i])\n    print(res)","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint a[N];\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n      scanf(\"%d\", &a[i]);\n    }\n    sort(a + 1, a + n + 1);\n    int ans = a[1];\n    for (int i = 1; i < n; ++i) {\n      ans = max(a[i + 1] - a[i], ans);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n","import sys\ninput = sys.stdin.readline\n\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(num) for num in input().split()]\n\n    if n == 1:\n        print(*a)\n    else:\n        m = min(a)\n\n        if m < 0:\n            del a[a.index(m)]\n\n            a = [ai - m for ai in a]\n\n            b = []\n            c = []\n            for ai in a:\n                if ai < 0:\n                    b.append(abs(ai))\n                else:\n                    c.append(ai)\n\n            b = sum(b)\n            a = [ci + b for ci in c]\n\n        a.sort()\n        max_min = a[0]\n        minus = a[0]\n\n        for ind in range(1, len(a)):\n            max_min = max(max_min, a[ind] - minus)\n            minus += a[ind] - minus\n\n        print(max_min)","\n\n\nimport java.lang.reflect.Array;\nimport  java.util.*;\npublic class sampleEditor_codeforces {\n    static class Pair implements Comparable<Pair>{\n        int x;\n        int y;\n\n        public Pair(int px , int py){\n            x = px;\n            y = py;\n        }\n\n        @Override\n        public int compareTo(Pair pair){\n            if (x > pair.x)\n                return 1;\n            else if (x == pair.x)\n                return 0;\n            else\n                return -1;\n        }\n\n    }\n\n\n    public static boolean isSorted(int[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n - 1; i++) {\n            if (arr[i] > arr[i + 1]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void reverse(int[] arr) {\n        int l = 0;\n        int r = arr.length - 1;\n        while (l < r) {\n            int temp = arr[l];\n            arr[l] = arr[r];\n            arr[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void solve(int n,int [] arr) {\n\n\n    }\n\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while (t-- > 0) {\n           int n=sc.nextInt();\n          ArrayList<Integer> al=new ArrayList<>();\n          for(int i=0;i<n;i++){\n              al.add(sc.nextInt());\n          }\n          Collections.sort(al);\n          int max=al.get(0);\n          for(int i=0;i<n-1;i++){\n              int temp=al.get(i+1)-al.get(i);\n              max=Math.max(temp,max);\n          }\n            System.out.println(max);\n\/\/           solve(n,arr);\n        }\n    }\n}\n","import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\npublic class Main\n{\n\tstatic String shengxiao[] =\n\t{ \"ox\", \"tiger\", \"rabbit\", \"dragon\", \"snake\", \"horse\", \"goat\", \"monkey\", \"rooster\", \"dog\", \"pig\", \"rat\" };\n\tstatic String shengxiaoo[] =\n\t{ \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Goat\", \"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\" };\n\tstatic int zhong[] =\n\t{ -1, 1, 0, 0, -1, -1, 1, 1 };\n\tstatic int heng[] =\n\t{ 0, 0, -1, 1, -1, 1, -1, 1 };\n\tstatic int zhongg[] =\n\t{ -1, -1, 0, 1, 1, 1, 0, -1 };\n\tstatic int hengg[] =\n\t{ 0, 1, 1, 1, 0, -1, -1, -1 };\n\tstatic int month[] =\n\t{ 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\tstatic int inf = Integer.MAX_VALUE;\n\tstatic long inff = Long.MAX_VALUE;\n\n\tstatic int N = (int) 5e1;\n\tstatic int M = (int) 1e5;\n\tstatic int mod = 19990920;\n\n\/\/\t \u63d0\u4ea4\u65f6\u6ce8\u610f\u9700\u8981\u6ce8\u91ca\u6389\u9996\u884cpackage\n\/\/\t \u57fa\u7840\u7c7b\u578b\u6570\u7ec4\u4f8b\u5982long[]\u4f7f\u7528Arrays\u6392\u5e8f\u5bb9\u6613TLE,\u53ef\u4ee5\u66ff\u6362\u6210Long[]\n\/\/\t int \u6700\u5927\u503c 2^31 - 1 , 2147483647;\n\/\/\t \u5c3d\u91cf\u4f7f\u7528long\u7c7b\u578b,\u907f\u514dint\u8ba1\u7b97\u7684\u6570\u636e\u6ea2\u51fa\n\n\tstatic void init()\n\t{\n\n\t}\n\n\/\/\tstatic void solve(String s)\n\/\/\tstatic void solve(int n)\n\/\/\tstatic void solve(long n)\n\tstatic void solve() throws FileNotFoundException\n\t{\n\t\tint n = sc.readInt();\n\t\tInteger shu[] = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tshu[i] = sc.readInt();\n\n\t\tif (n == 1)\n\t\t\tout.printLine(shu[0]);\n\t\telse\n\t\t{\n\t\t\tArrays.sort(shu);\n\t\t\tint max = shu[0];\n\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t{\n\t\t\t\tif (shu[i] - shu[i - 1] > max)\n\t\t\t\t\tmax = shu[i] - shu[i - 1];\n\t\t\t}\n\t\t\tout.printLine(max);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException\n\t{\n\/\/\t\tinit();\n\/\/\n\/\/\t\tint t = 1;\n\t\tint t = sc.readInt();\n\t\tfor (int i = 1; i <= t; i++)\n\t\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tstatic InputStream inputStream = System.in;\n\tstatic OutputStream outputStream = System.out;\n\tstatic InputReader sc = new InputReader(inputStream);\n\tstatic OutputWriter out = new OutputWriter(outputStream);\n\n\/\/\tSystem.setIn(new FileInputStream(\"copycat.in\"));\/\/ \u8bfb\u5165\u6587\u4ef6\n\/\/\tSystem.setOut(new PrintStream(new FileOutputStream(\"copycat.out\")));\/\/ \u8f93\u51fa\u5230\u6587\u4ef6\n\/\/\tlong startTime = System.currentTimeMillis(); \/\/ \u83b7\u53d6\u5f00\u59cb\u65f6\u95f4\n\/\/\tlong endTime = System.currentTimeMillis(); \/\/ \u83b7\u53d6\u7ed3\u675f\u65f6\u95f4\n\/\/\tSystem.out.println(\"\u7a0b\u5e8f\u8fd0\u884c\u65f6\u95f4\uff1a\" + (endTime - startTime) + \"ms\"); \/\/ \u8f93\u51fa\u7a0b\u5e8f\u8fd0\u884c\u65f6\u95f4\n\n\/\/\tint a = sc.readInt();\/\/ \u6574\u578b\n\/\/\tlong b = sc.readLong();\/\/ \u957f\u6574\u578b\n\/\/\tdouble c = sc.readDouble();\/\/ \u53cc\u7cbe\u5ea6\n\/\/\tString d = sc.readString(); \/\/ \u4e00\u4e2a\u5b57\u7b26\u4e32\n\/\/\tString e = sc.readStringLine();\/\/ \u4e00\u884c\u5b57\u7b26\u4e32\n\/\/\tchar f = sc.readCharacter();\/\/ \u5355\u4e2a\u5b57\u7b26\n\/\/\tout.print();\n\/\/\tout.printLine();\n\/\/\tout.close();\n\n\t\/\/ \u5c01\u88c5\u57fa\u4e8e\u5b57\u8282\u6d41\u8bfb\u53d6\u7684\u9ad8\u6548\u8f93\u5165\u7c7bInputReader\uff0c\u907f\u514dScanner\u7684\u4f4e\u6548\u7387\uff0c\u6bd4streamTokenizer\u5feb\u8bfb\u8fd8\u5feb\uff1b\n\tstatic class InputReader\n\t{\n\t\t\/\/ java.io.InputStream \u6240\u6709\u5b57\u8282\u8f93\u5165\u6d41\u7684\u7236\u7c7b\n\t\tprivate InputStream stream;\n\t\t\/\/ \u8f93\u5165\u7f13\u5b58byte\u6570\u7ec4\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\/\/ \u5f53\u524d\u5b57\u7b26\n\t\tprivate int numChars;\/\/ \u603b\u8f93\u5165\u5b57\u7b26\n\t\t\/\/ \u81ea\u5b9a\u4e49\u63a5\u53e3\n\t\tprivate SpaceCharFilter filter;\n\n\t\t\/\/ \u6784\u9020\u51fd\u6570\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\t\/\/ \u5c1d\u8bd5\u81f3\u5c11\u8bfb\u53d6\u4e00\u4e2a\u5b57\u8282\u5e76\u5b58\u50a8\u5230\u7f13\u51b2\u6570\u7ec4buf\u4e2d\n\t\tpublic int read()\n\t\t{\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t\/\/ \u65e2\u7136\u662f\u7f13\u51b2\u8bfb\u53d6\uff0c\u5982\u679c1\u6b21\u8bfb\u53d61024\u4e2a\uff0c\u90a3\u4e48\u6bcf\u6b21\u76f4\u63a5\u7f13\u51b2\u533a\u8bfb\u53d6 \u5982\u679ccurChar<numChar \u90a3\u4e48\u8bc1\u660e\u7f13\u51b2\u533a\u7684\u8fd8\u6ca1\u6709\u7528\u5b8c\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\/\/ \u7f13\u51b2\u533a\u7684\u6570\u636e\u7528\u5b8c\u4e86\uff0c\u90a3\u4e48\u4ece0\u5f00\u59cb\uff0c\u518d\u53bb\u4e00\u6b21\u6027\u8bfb\u53d6\u82e5\u5e72\u4e2a\u653e\u5230\u7f13\u51b2\u6570\u7ec4\u91cc\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t\/\/ \u4ece\u8f93\u5165\u6d41\u4e2d\u8bfb\u53d6\u4e00\u5b9a\u6570\u91cf\u7684\u5b57\u8282\uff0c\u5e76\u5c06\u5176\u5b58\u50a8\u5728\u7f13\u51b2\u533a\u6570\u7ec4buf\u4e2d\uff0cnumChar\u7b49\u4e8e\u5b9e\u9645\u8bfb\u53d6\u7684\u5b57\u8282\u6570\u91cf\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\/\/ \u5982\u679c\u8bfb\u53d6\u7684\u6709\u6548\u6570\u91cf\u4e3a0\uff0c\u90a3\u4e48\u8fd4\u56de-1\uff0c\u5de7\u5999\u7684\u907f\u5f00\u4e86\u5408\u6cd5\u7684ASCII\u7801\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\/\/ \u7b49\u4ef7\u4e8eelse (curChar<numChar),\u5982\u679c\u7f13\u51b2\u533a\u6ca1\u6709\u7528\u5b8c\uff0c\u76f4\u63a5\u8fd4\u56de\u7f13\u51b2\u533a\u5f53\u524d\u7b2ccurChar\u5b57\u7b26\uff0c\u6307\u9488\u540e\u79fb\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\t\/\/ \u8bfb\u5165\u4e00\u4e2a\u4e00\u4e2a\u5b57\u8282\uff0c\u624b\u5de5\u6784\u9020int\n\t\tpublic int readInt()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\/\/ \u5ffd\u7565>=1\u7684\u6240\u6709\u7a7a\u683c\u7b26\u6216\u8005\u81ea\u5df1\u5b9a\u4e49\u7684\u4e0d\u80fd\u6784\u6210\u6574\u6570\u7684\u65e0\u610f\u4e49\u7b26\u53f7\u5165\\n\\r\\t\u7b49\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\/\/ \u8bc6\u522b\u7b2c\u4e00\u7b26\u53f7\u4f4d\uff0c\u5224\u5b9a\u662f\u6b63\u6570\u8fd8\u662f\u8d1f\u6570\n\t\t\tif (c == '-')\n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t\/\/ \u4e0d\u65ad\u7684*10+\u5f53\u524d\u6570\u6784\u6210int\u7684\u5224\u65ad\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\t\/\/ \u8bfb\u5165\u4e00\u4e2a\u4e00\u4e2a\u5b57\u8282\uff0c\u624b\u5de5\u6784\u9020long\n\t\tpublic long readLong()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-')\n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\t\/\/ \u9ad8\u6548\u7684\u8bfb\u53d6\u5b57\u7b26\u4e32\n\t\tpublic String readString()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo\n\t\t\t{\n\t\t\t\t\/\/ \u786e\u5b9a\u6307\u5b9a\u7684\u4ee3\u7801\u70b9\u662f\u5426\u662f\u4e00\u4e2a\u6709\u6548\u7684Unicode\u4ee3\u7801\u70b9\u503c\n\t\t\t\tif (Character.isValidCodePoint(c))\n\t\t\t\t\tres.appendCodePoint(c);\/\/ \u8ffd\u52a0Unicode\u4ee3\u7801\u70b9\u503c\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\t\/\/ \u7edf\u4e00Scanner\u7684\u8bed\u6cd5\u4e60\u60ef\n\t\tpublic String next()\n\t\t{\n\t\t\treturn readString();\n\t\t}\n\n\t\t\/\/ \u8bfb\u5165\u4e00\u884c\u5b57\u7b26\u4e32\u6570\u7ec4\n\t\tpublic static String[] readStringArray(InputReader in, int size)\n\t\t{\n\t\t\tString[] array = new String[size];\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tarray[i] = in.readString();\n\t\t\treturn array;\n\t\t}\n\n\t\t\/\/ \u8bfb\u5165\u4e8c\u7ef4\u5b57\u7b26\u6570\u7ec4\n\t\tpublic static String[][] readStringTable(InputReader in, int rowCount, int columnCount)\n\t\t{\n\t\t\tString[][] table = new String[rowCount][];\n\t\t\tfor (int i = 0; i < rowCount; i++)\n\t\t\t\ttable[i] = readStringArray(in, columnCount);\n\t\t\treturn table;\n\t\t}\n\n\t\t\/\/ \u8bfb\u5165char\n\t\tpublic char readCharacter()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\treturn (char) c;\n\t\t}\n\n\t\t\/\/ \u8bfb\u5165\u4e00\u884c\u5b57\u7b26\u4e32\n\t\tpublic String readStringLine()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar2(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo\n\t\t\t{\n\t\t\t\t\/\/ \u786e\u5b9a\u6307\u5b9a\u7684\u4ee3\u7801\u70b9\u662f\u5426\u662f\u4e00\u4e2a\u6709\u6548\u7684Unicode\u4ee3\u7801\u70b9\u503c\n\t\t\t\tif (Character.isValidCodePoint(c))\n\t\t\t\t\tres.appendCodePoint(c);\/\/ \u8ffd\u52a0Unicode\u4ee3\u7801\u70b9\u503c\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar2(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\t\/\/ \u8bfb\u5165double\n\t\tpublic double readDouble()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-')\n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.')\n\t\t\t{\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.')\n\t\t\t{\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c))\n\t\t\t\t{\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm \/= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c)\n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn isWhitespace(c);\n\t\t}\n\n\t\tpublic boolean isSpaceChar2(int c)\n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar2(c);\n\t\t\treturn isWhitespace2(c);\n\t\t}\n\n\t\t\/\/ \u53ef\u4ee5\u8f93\u5165\u7a7a\u683c\u7684\u4e00\u884c\n\t\tpublic static boolean isWhitespace2(int c)\n\t\t{\n\t\t\treturn c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic static boolean isWhitespace(int c)\n\t\t{\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\t\/\/ \u81ea\u5b9a\u4e49\u63a5\u53e3\uff0c\u5b9a\u4e86\u4e00\u4e2a\u62bd\u8c61\u65b9\u6cd5\u5224\u65ad\u662f\u5426\u662f\u7a7a\u683c\u7b26\n\t\tpublic interface SpaceCharFilter\n\t\t{\n\t\t\tpublic boolean isSpaceChar(int ch);\n\n\t\t\tpublic boolean isSpaceChar2(int ch);\n\t\t}\n\t}\n\n\tstatic class OutputWriter\n\t{\n\t\t\/\/ \u5411\u6587\u672c\u8f93\u51fa\u6d41\u6253\u5370\u5bf9\u8c61\u7684\u683c\u5f0f\u5316\u8868\u73b0\u5f62\u5f0f extends java.io.Writer\n\t\tprivate final PrintWriter writer;\n\n\t\tpublic OutputWriter(OutputStream outputStream)\n\t\t{\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t\t}\n\n\t\t\/\/ \u6253\u5370\u6570\u7ec4\u7528\u7a7a\u683c\u5206\u9694\n\t\tpublic void print(int[] array)\n\t\t{\n\t\t\tfor (int i = 0; i < array.length; i++)\n\t\t\t{\n\t\t\t\tif (i != 0)\n\t\t\t\t\twriter.print(' ');\n\t\t\t\twriter.print(array[i]);\n\t\t\t}\n\t\t}\n\n\t\t\/\/ \u5e26\u6362\u884c\u7684\u6570\u7ec4\u6253\u5370\n\t\tpublic void printLine(int[] array)\n\t\t{\n\t\t\tprint(array);\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void print(Object... objects)\n\t\t{\n\t\t\tfor (int i = 0; i < objects.length; i++)\n\t\t\t{\n\t\t\t\tif (i != 0)\n\t\t\t\t\twriter.print(' ');\n\t\t\t\twriter.print(objects[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void printLine(Object... objects)\n\t\t{\n\t\t\tprint(objects);\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void close()\n\t\t{\n\t\t\twriter.close();\n\t\t}\n\n\t\tpublic void print(int i)\n\t\t{\n\t\t\twriter.print(i);\n\t\t}\n\n\t\tpublic void print(String i)\n\t\t{\n\t\t\twriter.print(i);\n\t\t}\n\n\t\tpublic void print(long i)\n\t\t{\n\t\t\twriter.print(i);\n\t\t}\n\n\t\tpublic void print(char i)\n\t\t{\n\t\t\twriter.print(i);\n\t\t}\n\n\t\tpublic void printf(String format, Object... x)\n\t\t{\n\t\t\twriter.printf(format, x);\n\t\t}\n\n\t\t\/\/ \u6253\u5370\u5e26\u6362\u884c\u7684\u6574\u6570i\n\t\tpublic void printLine(int i)\n\t\t{\n\t\t\twriter.println(i);\n\t\t}\n\n\t\tpublic void printLine(long i)\n\t\t{\n\t\t\twriter.println(i);\n\t\t}\n\t}\n\n\tstatic class IOUtils\n\t{\n\t\t\/\/ \u9ad8\u6548\u8bfb\u5165\u6574\u578b\u4e00\u7ef4\u6570\u7ec4\n\t\tpublic static int[] readIntArray(InputReader in, int size)\n\t\t{\n\t\t\tint[] array = new int[size];\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tarray[i] = in.readInt();\n\t\t\treturn array;\n\t\t}\n\n\t\t\/\/ \u8c03\u7528\u4e0a\u9762\u7684\u8bfb\u5165\u4e00\u7ef4\u6570\u7ec4\u7684\u5feb\u901f\u8bfb\u53d6\u4e8c\u7ef4\u6570\u7ec4\n\t\tpublic static int[][] readIntTable(InputReader in, int rowCount, int columnCount)\n\t\t{\n\t\t\tint[][] table = new int[rowCount][];\n\t\t\tfor (int i = 0; i < rowCount; i++)\n\t\t\t\ttable[i] = readIntArray(in, columnCount);\n\t\t\treturn table;\n\t\t}\n\n\t\t\/\/ \u76f8\u5f53\u4e8e\u4e8c\u7ef4\u6570\u7ec4\uff08\u591a\u5173\u952e\u5b57\u53c2\u6570\u7684\u53e6\u5916\u4e00\u79cd\u5199\u6cd5\uff09\n\t\tpublic static void readIntArrays(InputReader in, int[]... arrays)\n\t\t{\n\t\t\tfor (int i = 0; i < arrays[0].length; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < arrays.length; j++)\n\t\t\t\t\tarrays[j][i] = in.readInt();\n\t\t\t}\n\t\t}\n\n\t\tpublic static char[] readCharArray(InputReader in, int size)\n\t\t{\n\t\t\tchar[] array = new char[size];\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tarray[i] = in.readCharacter();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic static char[][] readTable(InputReader in, int rowCount, int columnCount)\n\t\t{\n\t\t\tchar[][] table = new char[rowCount][];\n\t\t\tfor (int i = 0; i < rowCount; i++)\n\t\t\t\ttable[i] = readCharArray(in, columnCount);\n\t\t\treturn table;\n\t\t}\n\n\t}\n\n\tstatic class MiscUtils\n\t{\n\t\tpublic static void decreaseByOne(int[]... arrays)\n\t\t{\n\t\t\tfor (int[] array : arrays)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < array.length; i++)\n\t\t\t\t\tarray[i]--;\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n","import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n\/*\nI can't live without doing CP!\nNever Give UP!\nConsistency is the key!\n*\/\npublic class Coder {\n\n  static StringBuffer str=new StringBuffer();\n  static int n;\n  static List<Long> l;\n\n  static void solve(){\n    Collections.sort(l);\n    long sum=l.get(0);\n    long max=sum;\n    for(int i=1;i<n;i++){\n      long val=l.get(i)-sum;\n      max=Math.max(max, val);\n      sum+=val;\n      \/\/ str.append(val+\" \"+sum).append(\"\\n\");\n    }\n    str.append(max).append(\"\\n\");\n  }\n\n  public static void main(String[] args) throws java.lang.Exception {\n    BufferedReader bf;\n    PrintWriter pw;\n    boolean lenv=false;\n    if(lenv){\n      bf = new BufferedReader(\n                          new FileReader(\"input.txt\"));\n      pw=new PrintWriter(new\n            BufferedWriter(new FileWriter(\"output.txt\")));\n    }else{\n      bf = new BufferedReader(new InputStreamReader(System.in));\n      pw = new PrintWriter(new OutputStreamWriter(System.out));\n    }\n    int q = Integer.parseInt(bf.readLine().trim());\n    while (q-- > 0) {\n      n=Integer.parseInt(bf.readLine().trim());\n      l=new ArrayList<>();\n      String s[]=bf.readLine().trim().split(\"\\\\s+\");\n      for(int i=0;i<n;i++) l.add(Long.parseLong(s[i]));\n      solve();\n    }\n    pw.print(str);\n    pw.flush();\n    \/\/ System.out.print(str);\n  }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    long long int n;\n    cin >> n;\n    long long int sum = 0, mx = INT_MIN, s = 0, mn;\n    priority_queue<long long int, vector<long long int>, greater<long long int>>\n        pqm;\n    for (long long int i = 0; i < n; i++) {\n      int ele;\n      cin >> ele;\n      s += ele;\n      pqm.push(ele);\n    }\n    for (long long int i = n; i > 1; i--) {\n      mn = pqm.top();\n      pqm.pop();\n      mn = mn - sum;\n      if (mn > mx) {\n        mx = mn;\n      }\n      sum = sum + mn;\n      s = s - i * (mn);\n    }\n    if (s > mx) {\n      mx = s;\n    }\n    cout << mx << \"\\n\";\n  }\n  return 0;\n}\n","import math;from heapq import heappush,heappop,heapify;import random;import string;from collections import deque;from bisect import bisect,bisect_left,bisect_right,insort;import sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());H=1000000000+7\nfor _ in range(I()):\n\tn=I()\n\tl=L()\n\tif len(l)==1:\n\t\tprint(l[0]);continue\n\tp=min(l)\n\tif p<0:\n\t\tl.pop(l.index(p))\n\t\tfor i in range(n-1):\n\t\t\tl[i]-=p\n\tl.sort();m=min(l)\n\tfor i in range(len(l)-1):\n\t\tm=max(l[i+1]-l[i],m)\n\tprint(m)","\/\/ Kaustav Vats\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n\n\npublic class C {\n\n    public static long solve(int N, long[] Arr) {\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (int i=0; i<N; i++) {\n            pq.add(Arr[i]);\n        }\n        long max = N == 1 ? Arr[0] : Long.MIN_VALUE;\n        long prev = 0;\n        while(pq.size() > 1) {\n            long x = pq.poll();\n            \/\/ System.out.println(\"[before] x : \" + x );\n            x -= prev;\n            prev += x;\n            \/\/ System.out.println(\"x : \" + x + \" prev:\/ \" + prev);\n            if (x > max) {\n                max = x;\n            }\n        }\n        long x = pq.poll();\n        x -= prev;\n        if (x > max) {\n            max = x;\n        }\n        return max;\n    }\n\n    public static void main(String[] args) throws IOException{\n        Reader.init(System.in);\n        int T = Reader.nextInt();\n        while(T--> 0) {\n            int N = Reader.nextInt();\n            long[] Arr = new long[N];\n            for (int i = 0; i < N; i++) {\n                Arr[i] = Reader.nextLong();\n            }\n            System.out.println(solve(N, Arr));\n        }\n    }\n}\n\n\n\/** Class for buffered reading int and double values *\/\nclass Reader {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    \/** call this method to initialize reader for InputStream *\/\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                     new InputStreamReader(input) );\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    \/** get next word *\/\n    static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            \/\/TODO add check for eof if necessary\n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong( next() );\n    }\n\t\n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nlong long casenum = 1;\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\nvoid rf() {}\nvoid fast() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n}\nint pos[1005];\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  sort(a.begin(), a.end());\n  int ret = a[0];\n  for (int i = 0; i < n - 1; ++i) {\n    ret = max(ret, a[i + 1] - a[i]);\n  }\n  cout << ret << endl;\n}\nint main() {\n  fast();\n  rf();\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","import sys\nimport time\nimport os\nfrom io import BytesIO, IOBase\nimport math\nfrom random import randint\n\nM=10**9+7\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \ndef inputf(): \n    return sys.stdin.readline().rstrip(\"\\r\\n\")   \n \ndef get_ints(): \n    return list(map(int, inputf().split()))\n \n \ndef get_string(): \n    return list(map(str, inputf().split()))\n\n\n\n\n\nglobal maximum\n \n \ndef _lis(arr, n):\n \n    global maximum\n \n    if n == 1:\n        return 1\n \n    maxEndingHere = 1\n    for i in range(1, n):\n        res = _lis(arr, i)\n        if arr[i-1] < arr[n-1] and res+1 > maxEndingHere:\n            maxEndingHere = res + 1\n \n    maximum = max(maximum, maxEndingHere)\n \n    return maxEndingHere\n \n \ndef LIS(arr):\n \n    global maximum\n \n    n = len(arr)\n \n    maximum = 1\n \n    _lis(arr, n)\n \n    return maximum\n \n\ndef binary_search(data, elem):\n    \n    low = 0\n    high = len(data) - 1\n    while low <= high:\n      \n        middle = (low + high)\/\/2\n        if data[middle] == elem:\n            return middle\n            \n        elif data[middle] > elem:\n\n            high = middle - 1\n        else:\n            low = middle + 1\n\n    return middle   \n\ndef upper_bound(my_list, key):\n    large = len(my_list) -1\n    small = 0\n\n    while (small <= large):\n        mid = (small + large) \/\/ 2\n        if my_list[mid] < key:\n            small = mid + 1\n        elif my_list[mid] > key:\n            large = mid - 1\n        else:\n            return mid\n    if my_list[mid]>key:\n        return mid\n    else:\n        return mid+1\n\n\ndef lower_bound(my_list, key):\n    large = len(my_list) -1\n    small = 0\n\n    while (small <= large):\n        mid = (small + large) \/\/ 2\n        if my_list[mid] < key:\n            small = mid + 1\n        elif my_list[mid] > key:\n            large = mid - 1\n        else:\n            return mid\n    if my_list[mid]<key:\n        return mid\n    else:\n        return mid-1\n\n\na=[]\ndef SieveOfEratosthenes(n):\n    \n\tprime = [True for i in range(n+1)]\n\tp = 2\n\twhile (p * p <= n):\n\n\t\tif (prime[p] == True):\n\n\t\t\tfor i in range(p * p, n+1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\n\tfor p in range(2, n+1):\n\t\tif prime[p]:\n\t\t\ta.append(p)\n\ndef roman_number(x):\n    if x > 15999:\n        return\n    value = [5000, 4000, 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbol = [\"F\", \"MF\", \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman = \"\"\n    i = 0\n    while x > 0:\n        div = x \/\/ value[i]\n        x = x % value[i]\n        while div:\n            roman += symbol[i]\n            div -= 1\n        i += 1\n    return roman\n\ndef maxSubArraySum(a,size):\n     \n    max_so_far = a[0]   \n    max_ending_here = 0\n     \n    for i in range(0, size):\n        max_ending_here = max_ending_here + a[i]\n        if max_ending_here < 0:\n            max_ending_here = 0\n         \n        elif (max_so_far < max_ending_here):   \n            max_so_far = max_ending_here\n             \n    return max_so_far\n\n    \ndef prefixSum(test_list):\n    res = [sum(test_list[ : i + 1]) for i in range(len(test_list))]\n    return res\n\n# Python Program to find the L.C.M. of two input number\n\ndef lcm(x, y):\n\n   # choose the greater number\n   if x > y:\n       greater = x\n   else:\n       greater = y\n\n   while(True):\n       if((greater % x == 0) and (greater % y == 0)):\n           lcm = greater\n           break\n       greater += 1\n\n   return lcm\n\"\"\"\ndef find_shortest_path(graph, start, end, path):\n    path = path + [start]\n    if start == end:\n        return path\n    if start not in graph:\n        return None\n    shortest = None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_shortest_path(graph, node, end, path)\n            if newpath:\n                if not shortest or len(newpath) < len(shortest):\n                    shortest = newpath\n    return shortest\n\"\"\" \n\n\"\"\"\ndef dfs(root,nodeVal,nodeConnection,visited):\n    leftVal = nodeVal[root][0]\n    rightVal = nodeVal[root][1]\n    solution = []\n    if nodeConnection[root]:\n        visited.add(root)\n        for i in nodeConnection[root]:\n            if i not in visited:\n                solution.append(dfs(i,nodeVal,nodeConnection,visited))\n        leftMax = 0\n        rightMax = 0\n        for i in solution:\n            l, r = i\n            leftMax += max(abs(leftVal - l[0]) + l[1], abs(leftVal - r[0]) + r[1])\n            rightMax += max(abs(rightVal - l[0]) + l[1], abs(rightVal - r[0]) + r[1])\n        return ((leftVal, leftMax), (rightVal, rightMax))\n    else:\n        return ((leftVal, 0), (rightVal, 0))\n \n\"\"\"\n \n\"\"\"\ndef BFS(adj,src,dist,paths,n):\n    visited=[False]*n\n    dist[src]=0\n    paths[0]=1\n    q=[src]\n    visited[src]=True\n    while(q):\n        p=q.pop(0)\n        for j in adj[p]:\n            if not visited[j]:\n                q.append(j)\n                visited[j]=True\n            if dist[j]>dist[p]+1:\n                dist[j] = dist[p]+1\n                paths[j] = paths[p]\n            elif dist[j]==dist[p]+1:\n                paths[j] +=paths[p]\n    return paths\n \n\"\"\"\n\n\ntestcase=int(inputf())\n\nfor test in range(testcase):\n    n=int(inputf())\n    a=get_ints()\n    a.sort()\n    res=a[0]\n    for i in range(1,n):\n        res=max(res,a[i]-a[i-1])\n    print(res)\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> a(n);\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  sort(a.begin(), a.end());\n  long long ans = a[0];\n  long long change = a[0];\n  for (int i = 1; i < n; ++i) {\n    ans = max(ans, a[i] - change);\n    change += a[i] - change;\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; ++i) solve();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long SET(long long n, long long pos) { return n = n | (1 << pos); }\nlong long RESET(long long n, long long pos) { return n = n & ~(1 << pos); }\nbool CHECK(long long n, long long pos) { return (bool)(n & (1 << pos)); }\nvector<long long> v;\nlong long x, y, z, a, b, c, sum, ans, total, t, cnt, n, m, k, p, q, r, l, w,\n    right, left, row, col, kase;\nstring s1, s2;\nmap<long long, long long> mp;\nset<long long> s;\nmap<long long, long long>::iterator itr1, ptr1;\nset<long long>::iterator itr, ptr;\nlong long arr[3000009], arr1[3000009], ind[3000009];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    ans = INT_MIN;\n    for (long long i = 0; i < n; i++) cin >> arr[i];\n    sort(arr, arr + n);\n    ans = arr[0];\n    p = arr[0];\n    for (long long i = 1; i < n; i++) {\n      arr[i] -= p;\n      ans = max(ans, arr[i]);\n      p += arr[i];\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long CPU_TIME = 3;\nconst long long MAX_FILE_SIZE = 1024 * 1024;\ntemplate <typename Arg1>\nvoid ZZ(const char* name, Arg1&& arg1) {\n  std::cerr << name << \" = \" << arg1 << '\\n';\n}\ntemplate <typename Arg1, typename... Args>\nvoid ZZ(const char* names, Arg1&& arg1, Args&&... args) {\n  const char* comma = strchr(names + 1, ',');\n  std::cerr.write(names, comma - names) << \" = \" << arg1;\n  ZZ(comma, args...);\n}\nconst long long MOD = 1000000007LL;\nconst long long MAX = 100010LL;\ntemplate <class T>\nT abs(T x) {\n  return x > 0 ? x : -x;\n}\ntemplate <typename T>\nT gcd(T a, T b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\ntemplate <typename T>\nT power(T x, T y, long long m = MOD) {\n  T ans = 1;\n  x %= m;\n  while (y > 0) {\n    if (y & 1LL) ans = (ans * x) % m;\n    y >>= 1LL;\n    x = (x * x) % m;\n  }\n  return ans % m;\n}\ntemplate <typename T>\nT ceiling(T numerator, T denominator) {\n  return (numerator + denominator - 1) \/ denominator;\n}\ntemplate <typename T>\nT inverse(T num, long long m = MOD) {\n  return ((num == 1)\n              ? 1\n              : (MOD - ((MOD \/ num) * inverse(MOD % num)) % MOD + MOD) % MOD);\n}\ntemplate <typename T>\nistream& operator>>(istream& cin, vector<T>& a) {\n  for (auto& i : a) cin >> i;\n  return cin;\n}\ntemplate <typename T>\nostream& operator<<(ostream& cout, vector<T>& a) {\n  for (auto& i : a) cout << i << \" \";\n  return cout;\n}\ntemplate <typename T, typename A>\nostream& operator<<(ostream& cout, pair<T, A>& a) {\n  cout << \"(\" << a.first << \",\" << a.second << \")\";\n  return cout;\n}\ntemplate <typename T>\nostream& operator<<(ostream& cout, set<T>& a) {\n  for (auto& i : a) cout << i << \" \";\n  return cout;\n}\ntemplate <typename T, typename A>\nostream& operator<<(ostream& cout, map<T, A>& a) {\n  for (auto& i : a) cout << \"(\" << i.first << \",\" << i.second << \") \";\n  return cout;\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  cin >> a;\n  if (n == 1) {\n    cout << a[0] << '\\n';\n    return;\n  }\n  sort((a).begin(), (a).end());\n  int ans = a[0];\n  for (int i(1); i <= ((n - 1)); i++) ans = max(ans, a[i] - a[i - 1]);\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","import java.util.*;\npublic class MyClass {\n      private static void shuffleArray(long[] arr)\n    {\n        int n = arr.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i)\n        {\n            long tmp = arr[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            arr[i] = arr[randomPos];\n            arr[randomPos] = tmp;\n        }\n    }\n    public static void main(String args[]) {\n    Scanner sc=new Scanner(System.in);\n    int t=sc.nextInt();\n    while(t-->0)\n        {\n            int n=sc.nextInt();\n            long a[]=new long[n];\n            for(int i=0;i<n;i++)\n                {\n                    a[i]=sc.nextLong();\n                }\n                shuffleArray(a);\n                Arrays.sort(a);\n             long max=a[0], sum=a[0];\n            for(int i=1;i<n;i++)\n            {\n                max=Math.max(max,a[i]-sum);\n                if(a[i]!=a[i-1]) sum+=(a[i]-sum);\n            }\n                System.out.println(max);\n        }\n    }\n}","from os import path, truncate\nfrom sys import int_info, stdin, stdout\nif path.exists('tc.txt'):\n    stdin = open('tc.txt', 'r')\ndef gmi(): return map(int, stdin.readline().strip().split())\ndef gms(): return map(str, stdin.readline().strip().split())\ndef gari(): return list(map(int, stdin.readline().strip().split()))\ndef gart(): return tuple(map(int, stdin.readline().strip().split()))\ndef gars(): return list(map(str, stdin.readline().strip().split()))\ndef gs(): return stdin.readline().strip()\ndef gls(): return list(stdin.readline().strip())\ndef gi(): return int(stdin.readline())\n\nfor _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    if n==1:\n        print(a[0])\n        continue\n    else:\n        cnt=min(a)\n        a.sort()\n        n=len(a)\n        for i in range(1,n):\n            cnt=max(cnt,a[i]-a[i-1])\n        print(cnt)\n\n\n\n\n\n\n    \n\n   \n\n    \n\n   \n\n# def maxsum(arr):\n#     n=len(arr)\n#     su=0\n#     leftdp=[0]*n\n#     rightdp=[0]*n\n#     c=0\n#     for i in range(0,n,2):\n#         su+=arr[i]\n#     for i in range(1, n, 2):\n#         leftdiff = arr[i]-arr[i-1]\n#         if c-1<0:\n#             leftdp[i]=leftdiff\n#         else:\n#             if leftdp[i-2]>0:\n#                 leftdp[i]=leftdiff+leftdp[i-2]\n#             else:\n#                 leftdp[i]=leftdiff\n#         rightdiff=0\n#         if i+1>=n:\n#             rightdiff=0\n#         else:\n#             rightdiff=arr[i]-arr[i+1]\n#         if c-1<0:\n#             rightdp[i]=rightdiff\n#         else:\n#             if rightdp[i-2]>0:\n#                 rightdp[i]=rightdiff+rightdp[i-2]\n#             else:\n#                 rightdp[i]=rightdiff\n#         c+=1\n#     maxm=0\n#     for i  in range(1,n,2):\n#          maxm=max(maxm,max(leftdp[i],rightdp[i]))\n#     return maxm + su\n        \n        \n\n# arr =list(map(int,input().split()))\n# re=maxsum(arr)\n# print(re)\n\n# x = math.floor(math.log(b)\/math.log(2))\n# y = math.floor(math.log(a)\/math.log(5))\n","import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.PriorityQueue;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Anubhav\n *\/\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        CMinimumExtraction solver = new CMinimumExtraction();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMinimumExtraction {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int t = in.nextInt();\n            while (t-- > 0) {\n                int n = in.nextInt();\n                PriorityQueue<Long> pq = new PriorityQueue<>();\n                for (int i = 0; i < n; i++)\n                    pq.add(in.nextLong());\n                long sum = 0;\n                long ans = pq.peek();\n                long prev = 0;\n                while (pq.size() > 1) {\n                    prev = pq.poll() - sum;\n                    sum += prev;\n                    ans = Math.max(ans, pq.peek() - sum);\n                }\n                out.println(ans);\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n","from collections import defaultdict as d\ndef solve():\n  n = int(input())\n  ll = list(map(int, input().split()))\n  if n == 1:\n    return ll[0]\n  ans = -9999999999\n  temp_sum = 0\n  ll.sort()\n  for i in range(n-1):\n    x = ll[i] - temp_sum\n    temp_sum += x\n    ans = max(ans, x)\n  ans = max(ans, ll[-1] - temp_sum)\n  return ans\n\n\nt = int(input())\nwhile t != 0:\n  res = solve()\n  print(res)\n  t -=1\n","\/*package whatever \/\/do not write package name here *\/\n\nimport java.io.*;\nimport java.util.*;\n\npublic class GFG {\n\tpublic static void main (String[] args) {\n\t    Scanner sc=new Scanner(System.in);\n\t    int t=sc.nextInt();\n\t    while(t-->0)\n\t    {\n\t        int n=sc.nextInt();\n\t    PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\n\t    for(int i=0;i<n;i++)\n\t    {\n\t        pq.add(sc.nextInt());\n\t    }\n\t    int max=pq.poll();\n\t    int temp1=max;\n\t    while(!pq.isEmpty())\n\t    {\n\t       \n\t        int temp2=pq.poll();\n\t        if( temp2-temp1>max)\n\t        {\n\t            max=temp2-temp1;\n\t        }\n\t        temp1=temp2;\n\t    }\n\t    System.out.println(max);\n\t    }\n\t}\n}","import java.util.*;\nimport java.io.*;\n\npublic class Main{\n    public static void main(String[] args) throws Exception{\n        InputStreamReader isr = new InputStreamReader(System.in);\n        BufferedReader br = new BufferedReader(isr);\n        String s = br.readLine();\n        String[] vals = s.split(\" \");\n        int tests = Integer.parseInt(vals[0]);\n        for(int i = 0; i < tests; i++){\n            s = br.readLine();\n            vals = s.split(\" \");\n            int arraySize = Integer.parseInt(vals[0]);\n            s = br.readLine();\n            vals = s.split(\" \");\n            PriorityQueue<Integer> order = new PriorityQueue<Integer>();\n            long diff = 0;\n            for(int j = 0; j < arraySize; j++){\n                order.add(Integer.parseInt(vals[j]));\n            }\n            long result = order.peek();\n            for(int j = 0; j < arraySize; j++){\n                result = Math.max(result, order.peek() - diff);\n                diff += order.poll() - diff;\n            }\n            System.out.println(result);\n        }\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long log_a_to_base_b(long long a, long long b) { return log(a) \/ log(b); }\nbool isPrime(long long n) {\n  if (n == 1) {\n    return false;\n  }\n  long long i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      return false;\n    }\n    i += 1;\n  }\n  return true;\n}\nvector<long long> prime_fact(long long n) {\n  vector<long long> v;\n  for (long long i = 2; i * i <= n; i++)\n    if (n % i == 0) {\n      while (n % i == 0) n \/= i;\n      v.push_back(i);\n    }\n  if (n > 1) v.push_back(n);\n  return v;\n}\nlong long power(long long a, long long n) {\n  long long res = 1;\n  while (n) {\n    if (n % 2)\n      res *= a, n--;\n    else\n      a *= a, n \/= 2;\n  }\n  return res;\n}\nlong long euler_totient(long long n) {\n  long long res = n;\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      res \/= i;\n      res *= (i - 1);\n      while (n % i == 0) n \/= i;\n    }\n  }\n  if (n > 1) res \/= n, res *= (n - 1);\n  return res;\n}\nbool isKthBitSet(long long n, long long k) {\n  if (n & (1 << k))\n    return true;\n  else\n    return false;\n}\nlong long no_of_set_bits(long long n) {\n  long long cnt = 0;\n  while (n > 0) {\n    cnt++;\n    n = n & (n - 1);\n  }\n  return cnt;\n}\nvoid init() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nsigned main() {\n  init();\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> v(n);\n    for (auto &i : v) cin >> i;\n    sort(v.begin(), v.end());\n    if (n == 1) {\n      cout << v[0] << \"\\n\";\n      continue;\n    }\n    if (n == 2) {\n      cout << max(v[0], (v[1] - v[0])) << \"\\n\";\n      continue;\n    }\n    long long ans = v[0];\n    long long i = 0ll;\n    for (; i < n - 1ll; i++) ans = max(ans, (long long)(v[i + 1] - v[i]));\n    cout << (long long)ans << \"\\n\";\n  }\n  return 0;\n}\n","for _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    a.sort()\n    mx = min(a)\n    k = 0\n    for i in range(len(a)-1):\n        mx = max(mx,a[i + 1] - a[i] + k)\n        a[i + 1] = a[i + 1] - a[i] + k\n        k -= a[i]\n    print(mx)","import java.util.*;\nimport java.io.*;\npublic class Main {\n\t\tstatic long mod = 1000000007;\n\t\tstatic long max ;\n\t\tstatic PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\t\tpublic static void main(String[] args) throws IOException  {\n\t\t\tFastReader sc = new FastReader();\n\t\t\tint t = sc.nextInt();\n\t\t\twhile( t-- > 0) {\n\t\t\t\tint n = sc.nextInt();\n\/\/\t\t\t\tlong start = System.currentTimeMillis();\n\t\t\t\tArrayList<Integer> arr = new ArrayList<>();\n\t\t\t\tfor( int i = 0 ;i< n; i++) {\n\t\t\t\t\tarr.add(sc.nextInt());\n\t\t\t\t}\n\t\t\t\tCollections.sort(arr);\n\t\t\t\tlong ans = arr.get(0);\n\t\t\t\tfor( int i = 1 ;i < n; i++) {\n\t\t\t\t\tans = Math.max(ans, arr.get(i) - arr.get(i-1));\n\t\t\t\t}\n\/\/\t\t\t\tlong end = System.currentTimeMillis();\n\t\t\t\tout.println(ans);\n\/\/\t\t\t\tout.println((end- start));\n\t\t\t}\n\t\t\tout.flush();\n\t\t}\n\t\n\t\tpublic static boolean ifpowof2(long n ) {\n\t\t\treturn ((n&(n-1)) == 0);\n\t\t}\n\t\t\n\t\tpublic static int[] nextLargerElement(int[] arr, int n)\t{ \n\t\t\tStack<Integer> stack = new Stack<>();\n\t\t\tint rtrn[] = new int[n];\n\t\t\trtrn[n-1] = -1;\n\t        stack.push( n-1);\n\t        for( int i = n-2 ;i >= 0 ; i--){\n\t            int temp = arr[i];\n\t            int lol = -1;\n\t            while( !stack.isEmpty() && arr[stack.peek()] <= temp){\n\t            \tif(arr[stack.peek()] == temp ) {\n\t            \t\tlol = stack.peek();\n\t            \t}\n\t                stack.pop();\n\t            }\n\t            if( stack.isEmpty()){\n\t            \tif( lol != -1) {\n\t            \t\trtrn[i] = lol;\n\t            \t}\n\t            \telse {\n\t            \t\trtrn[i] = -1;\n\t            \t}\n\t            }\n\t            else{\n\t            \trtrn[i] = stack.peek();\n\t            }\n\t            stack.push( i);\n\t        }\n\t        return rtrn;\n\t\t}\n\t\t\n\t\t@SuppressWarnings(\"unused\")\n\t\tprivate static void mySort(int[] arr) {\n\t        for(int i=0;i<arr.length;i++) {\n\t            int rand = (int) (Math.random() * arr.length);\n\t            int loc = arr[rand];\n\t            arr[rand] = arr[i];\n\t            arr[i] = loc;\n\t        }\n\t        Arrays.sort(arr);\n\t    }\n\t\t\n\t\tstatic long gcd(long a, long b)\n\t\t{\n\t\t\tif (a == 0)\n\t\t\t\treturn b;\n\t\t\treturn gcd(b % a, a);\n\t\t}\n\t\t\n\t\t\t   \n\t\t static long lcm(long a, long b)\n\t\t {\n\t\t\t return (a \/ gcd(a, b)) * b;\n\t\t }\n\t\t \n\n\t\t static long rightmostsetbit(long n) {\n\t\t\t return n&-n;\n\t\t }\n\t\t \n\t\t static long leftmostsetbit(long n)\n\t\t    {\n\t\t        long k = (long)(Math.log(n) \/ Math.log(2));\n\t\t        return 1 << k;\n\t\t    }\n\t \n\t\t static HashMap<Long,Long> primefactor( long n){\n\t\t\t HashMap<Long ,Long> hm = new HashMap<>();\n\t\t\t long temp = 0;\n\t\t\t while( n%2 == 0) {\n\t\t\t\t temp++;\n\t\t\t\t n\/=2;\n\t\t\t }\t\n\t\t\t if( temp!= 0) {\n\t\t\t\t hm.put( 2L, temp);\n\t\t\t }\n\t\t\t long c = (long)Math.sqrt(n);\n\t\t\t for( long i = 3 ; i <= c ; i+=2) {\n\t\t\t\t temp = 0;\n\t\t\t\t while( n% i == 0) {\n\t\t\t\t\t temp++;\n\t\t\t\t\t n\/=i;\n\t\t\t\t }\n\t\t\t\t if( temp!= 0) {\n\t\t\t\t\t hm.put( i, temp);\n\t\t\t\t }\n\t \t\t }\n\t \t\t if( n!= 1) {\n\t \t\t\t hm.put( n , 1L);\n\t \t\t }\n\t \t\t return hm;\t\n\t\t }\n\t\t \n\t\t @SuppressWarnings(\"unused\")\n\t\tprivate static ArrayList<Integer> allfactors(int abs) {\n\t\t\t HashMap<Integer,Integer> hm = new HashMap<>();\n\t\t\t ArrayList<Integer> rtrn = new ArrayList<>();\n\t\t\t for( int i = 2 ;i*i <= abs; i++) {\n\t\t\t\t if( abs% i == 0) {\n\t\t\t\t\t hm.put( i , 0);\n\t\t\t\t\t hm.put(abs\/i, 0);\n\t\t\t\t }\n\t\t\t }\n\t\t\t for( int x : hm.keySet()) {\n\t\t\t\t rtrn.add(x);\n\t\t\t }\n\t\t\t \n\t\t\t if( abs != 0) {\n\t\t\t\t rtrn.add(abs);\n\t\t\t }\n\t\t\t \n\t\t\t return rtrn;\n\t\t }\n\t\t\t\n\t \n\t\t static class FastReader {\n\t\t\t BufferedReader br;\n\t\t\t StringTokenizer st;\n\t\t \n\t\t\t public FastReader()\n\t\t\t {\n\t\t\t\t br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t }\n\t\t        \n\t\t\t String next()\n\t\t\t {\n\t\t\t\t while (st == null || !st.hasMoreElements()) {\n\t\t\t\t\t try {\n\t\t\t\t\t\t st = new StringTokenizer(br.readLine());\n\t\t\t\t\t }\n\t\t\t\t\t catch (IOException e) {\n\t\t\t\t\t\t e.printStackTrace();\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t return st.nextToken();\n\t\t\t }\n\t\t \n\t\t\t int nextInt() { return Integer.parseInt(next()); }\n\t\t\t \n\t\t\t long nextLong() { return Long.parseLong(next()); }\n\t\t\t \n\t\t\t double nextDouble()\n\t\t\t {\n\t\t\t\t return Double.parseDouble(next());\n\t\t\t }\t\n\t\t \n\t\t\t String nextLine()\n\t\t\t {\n\t\t\t\t String str = \"\";\n\t\t\t\t try {\n\t\t\t\t\t str = br.readLine();\n\t\t\t\t }\n\t\t\t\t catch (IOException e) {\n\t\t\t\t\t e.printStackTrace();\n\t\t\t\t }\n\t\t\t\t return str;\n\t\t\t }\n\t\t }\t\n}","for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort(reverse=True)\n    maxes = []\n    m = 0\n    while len(arr) != 1:\n        maxes.append(arr[-1] - m)\n        m += (arr[-1] - m)\n        del arr[-1]\n    maxes.append(arr[0] - m)\n    print(max(maxes))\n\n","def f():\n    n=int(input())\n    l=sorted(map(int,input().split()))\n    if n==1:\n        return l[0]\n    t=l[0]\n    for i in range(1,n):\n        t=max(t,l[i]-l[i-1])\n    return t\nfor _ in range(int(input())):\n    print(f())","import java.util.*;\nimport java.io.*;\n\npublic class C {\n    static StringBuilder sb;\n    static long fact[];\n    static long mod = (long) (1e9 + 7);\n    static int[] arr = { 0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111 };\n\n    static void solve(int[] arr) {\n        if (arr.length == 1) {\n            sb.append(arr[0] + \"\\n\");\n            return;\n        }\n\n        HashSet<Integer> visited = new HashSet<>();\n        ArrayList<Integer> uniqueElements = new ArrayList<>();\n        for (int ele : arr) {\n            if (!visited.contains(ele)) {\n                uniqueElements.add(ele);\n                visited.add(ele);\n            }\n        }\n\n        Collections.sort(uniqueElements);\n\n        if (uniqueElements.size() == 1 && uniqueElements.get(0) < 0) {\n            sb.append(\"0\\n\");\n            return;\n            \n        }\n\n        long ans = uniqueElements.get(0);\n        for (int i = 0; i < uniqueElements.size() - 1; i++) {\n            long diff = uniqueElements.get(i + 1) - uniqueElements.get(i);\n            ans = Math.max(ans, diff);\n        }\n        sb.append(ans + \"\\n\");\n    }\n\n    public static void main(String[] args) {\n        sb = new StringBuilder();\n        int test = i();\n        while (test-- > 0) {\n            int n = i();\n            int[] arr = readArray(n);\n            solve(arr);\n        }\n        out.printLine(sb);\n        out.flush();\n        out.close();\n\n    }\n\n    \/*\n     * fact=new long[(int)1e6+10]; fact[0]=fact[1]=1; for(int i=2;i<fact.length;i++)\n     * { fact[i]=((long)(i%mod)1L(long)(fact[i-1]%mod))%mod; }\n     *\/\n    \/\/ **************NCR%P******************\n\n    static long p(long x, long y)\/\/ POWER FXN \/\/\n    {\n        if (y == 0)\n            return 1;\n\n        long res = 1;\n        while (y > 0) {\n            if (y % 2 == 1) {\n                res = (res * x) % mod;\n                y--;\n            }\n\n            x = (x * x) % mod;\n            y = y \/ 2;\n\n        }\n        return res;\n    }\n\n    static long ncr(int n, int r) {\n        if (r > n)\n            return (long) 0;\n\n        long res = fact[n] % mod;\n        \/\/ System.out.println(res);\n        res = ((long) (res % mod) * (long) (p(fact[r], mod - 2) % mod)) % mod;\n        res = ((long) (res % mod) * (long) (p(fact[n - r], mod - 2) % mod)) % mod;\n        \/\/ System.out.println(res);\n        return res;\n\n    }\n\n    \/\/ **************END******************\n\n    \/\/ *************Disjoint set\n    \/\/ union*********\/\/\n\n    \/\/ ***************PRIME FACTORIZE\n    \/\/ ***********************************\/\/\n    static TreeMap<Integer, Integer> prime(long n) {\n        TreeMap<Integer, Integer> h = new TreeMap<>();\n        long num = n;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (n % i == 0) {\n                int nt = 0;\n                while (n % i == 0) {\n                    n = n \/ i;\n                    nt++;\n                }\n                h.put(i, nt);\n            }\n        }\n        if (n != 1)\n            h.put((int) n, 1);\n        return h;\n\n    }\n\n    \/\/ *****CLASS PAIR\n    \/\/ *************************************************\n    static class Pair implements Comparable<Pair> {\n        int x;\n        long y;\n\n        Pair(int x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Pair o) {\n            return (int) (this.y - o.y);\n\n        }\n\n    }\n    \/\/ *****CLASS PAIR\n    \/\/ ***************************************************\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int Int() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String String() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return String();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void flush() {\n            writer.flush();\n        }\n    }\n\n    static InputReader in = new InputReader(System.in);\n    static OutputWriter out = new OutputWriter(System.out);\n\n    public static long[] sortlong(long[] a2) {\n        int n = a2.length;\n        ArrayList<Long> l = new ArrayList<>();\n        for (long i : a2)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < l.size(); i++)\n            a2[i] = l.get(i);\n        return a2;\n    }\n\n    public static int[] sortint(int[] a2) {\n        int n = a2.length;\n        ArrayList<Integer> l = new ArrayList<>();\n        for (int i : a2)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < l.size(); i++)\n            a2[i] = l.get(i);\n        return a2;\n    }\n\n    public static long pow(long x, long y) {\n        long res = 1;\n        while (y > 0) {\n            if (y % 2 != 0) {\n                res = (res * x);\/\/ % modulus;\n                y--;\n\n            }\n            x = (x * x);\/\/ % modulus;\n            y = y \/ 2;\n        }\n        return res;\n    }\n\n    \/\/ GCD___+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n    public static long gcd(long x, long y) {\n        if (x == 0)\n            return y;\n        else\n            return gcd(y % x, x);\n    }\n    \/\/ ******LOWEST COMMON MULTIPLE\n    \/\/ *********************************************\n\n    public static long lcm(long x, long y) {\n        return (x * (y \/ gcd(x, y)));\n    }\n\n    \/\/ INPUT\n    \/\/ PATTERN********************************************************\n    public static int i() {\n        return in.Int();\n    }\n\n    public static long l() {\n        String s = in.String();\n        return Long.parseLong(s);\n    }\n\n    public static String s() {\n        return in.String();\n    }\n\n    public static int[] readArray(int n) {\n        int A[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            A[i] = i();\n        }\n        return A;\n    }\n\n    public static long[] readArray(long n) {\n        long A[] = new long[(int) n];\n        for (int i = 0; i < n; i++) {\n            A[i] = l();\n        }\n        return A;\n    }\n\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<int> a;\n    for (int i = 0; i < n; i++) {\n      long long b;\n      cin >> b;\n      a.push_back(b);\n    }\n    sort(a.begin(), a.end());\n    long long min = a[0], b[n];\n    for (int i = 1; i < n; i++) {\n      b[i] = abs(a[i] - a[i - 1]);\n      if (b[i] > min) {\n        min = b[i];\n      }\n    }\n    cout << min << endl;\n  }\n}\n","n = int(input())\n\nfor _ in range(0, n):\n    input()\n    line = [int(i) for i in input().split()]\n    line.sort()\n    res = line[0]\n    for i in range(0, len(line)-1):\n        diff = line[i+1] - line[i]\n        res = max(res, diff)\n\n    print(res)","import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class MinimumExtraction {\n\t\n\tstatic class FastReader {\n\t\t\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(\n                new InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() { return Integer.parseInt(next()); }\n \n        long nextLong() { return Long.parseLong(next()); }\n        \n        double nextFloat() { return Float.parseFloat(next()); }\n \n        double nextDouble() { return Double.parseDouble(next()); }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] nextArray(int n)\n        {\n        \tint[] a = new int[n];\n        \tfor (int i=0; i<n; i++) {\n        \t\ta[i] = this.nextInt();\n        \t}\n        \treturn a;\n        }\n        \n        long[] nextArrayLong(int n)\n        {\n        \tlong[] a = new long[n];\n        \tfor (int i=0; i<n; i++) {\n        \t\ta[i] = this.nextInt();\n        \t}\n        \treturn a;\n        }\n        \n    }\n\t\n\tstatic final Random random=new Random();\n\tpublic static void ruffleSort(int[] a)\n\t{\n        int n=a.length;\n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n), temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\t\n\tpublic static void solve(int n, int[] a) {\n\t\t\n\t\truffleSort(a);\n\t\tint min = a[0];\n\t\tint change = 0;\n\t\tfor (int i=1; i<n; i++) {\n\t\t\tchange -= (a[i-1]+change);\n\t\t\tmin = Math.max(a[i]+change, min);\n\t\t}\n\t\tSystem.out.println(min);\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tFastReader in = new FastReader();\n\t\tint t = in.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tint n = in.nextInt();\n\t\t\tint[] a = in.nextArray(n);\n\t\t\tsolve(n, a);\n\t\t}\n\n\t}\n\n}\n","for _ in range(int(input())):\n    n = int(input())\n    arr = sorted(list(map(int, input().split()))) + [-1000000000]\n    m = 0\n    if n == 1:\n        print(arr[0])\n        continue\n    s = 0\n    c = 0\n    m = arr[0]\n    for i in range(n):\n        c += arr[i] - c\n        if arr[i + 1] - c > m:\n            m = arr[i + 1] - arr[i]\n    print(m)\n","import java.io.BufferedReader; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \nimport java.util.Scanner; \nimport java.util.StringTokenizer;\nimport java.util.*;\npublic class codeforcesB{\n public static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n   } \n public static void main(String args[]){\n    FastReader sc=new FastReader();\n    StringBuilder sb=new StringBuilder();\n    int t=sc.nextInt();\n    while(t-->0){\n      int n=sc.nextInt();\n      Integer ar[]=new Integer[n];\n      for(int i=0;i<n;i++){ar[i]=sc.nextInt();}\n      Arrays.sort(ar);\n      long x=ar[0];\n      long min=ar[0];\n      for(int i=1;i<n;i++){\n          min=Math.max(min,(long)ar[i]-x);\n          x+=(long)((long)ar[i]-x);\n        }\n        System.out.println(min);\n    }\n   }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    if (n == 1) {\n      int x;\n      cin >> x;\n      cout << x << '\\n';\n    } else {\n      int mas[n];\n      for (int i = 0; i < n; i++) {\n        cin >> mas[i];\n      }\n      sort(mas, mas + n);\n      int sum = mas[0], y = -1000000001;\n      for (int i = 1; i < n; i++) {\n        mas[i] -= sum;\n        y = max({y, mas[i - 1], mas[i]});\n        sum += mas[i];\n      }\n      cout << y << '\\n';\n    }\n  }\n}\n","\/\/package Codeforces;\nimport java.util.*;\n\nimport java.io.*;\npublic  class template{\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\tString next () {\n\t\t\twhile(!st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t}catch(IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tint[] readArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\t\n\tstatic class helper{\n\t\t\n\t\t\/\/reverse 1-d Array\n\t\tpublic static void reverse(int arr[]) {\n\t\t\tint i = 0;\n\t\t\tint j = arr.length - 1;\n\t\t\twhile(i<j) {\n\t\t\t\tint temp = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/gcd of two numbers\n\t\tpublic static int gcd(int a,int b) {\n\t\t\tif(b == 0) {\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\treturn gcd(b,a%b);\n\t\t}\n\t\t\n\t\t\/\/calculate ncr\n\t\tpublic static int ncr(int n,int r) {\n\t\t\tint num = n;\n\t\t\tint deno = r;\n\t\t\tint a1 = 1;\n\t\t\tint a2 = 1;\n\t\t\tfor(int i=0;i<r;i++) {\n\t\t\t\ta1 *= num;\n\t\t\t\ta2 *= deno;\n\t\t\t\tnum--;\n\t\t\t\tdeno--;\n\t\t\t}\n\t\t\tint ans = a1\/a2;\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t\/\/isPalindrome\n\t\tpublic static boolean isPalindrome(String substring){\n\t\t    char ch[] = substring.toCharArray();\n\t\t    int i = 0;\n\t\t    int j = ch.length-1;\n\t\t    while(i<j){\n\t\t        char temp = ch[i];\n\t\t        ch[i] = ch[j];\n\t\t        ch[j] = temp;\n\t\t        i++;\n\t\t        j--;\n\t\t    }\n\t\t    String rev = String.valueOf(ch);\n\t\t    if(rev.equals(substring)){\n\t\t        return true;\n\t\t    }\n\t\t    else{\n\t\t        return false;\n\t\t    }\n\t\t}\n\t\t\n\t\t\/\/isPowerOfTwo\n\t\tpublic static boolean isPowerOfTwo(long x)\n\t    {\n\t        \/* First x in the below expression is\n\t        for the case when x is 0 *\/\n\t        return x != 0 && ((x & (x - 1)) == 0);\n\t    }\n\t\t\n\t\t\/\/nextPowerOfTwo\n\t\tpublic static long nextPowerOfTwo(long n)\n\t    {\n\t        n--;\n\t        n |= n >> 1;\n\t        n |= n >> 2;\n\t        n |= n >> 4;\n\t        n |= n >> 8;\n\t        n |= n >> 16;\n\t        n++;\n\t         \n\t        return n;\n\t    }\n\t}\n\t\n\t public static void ruffleSort(long[] arr) {\n\t        int n = arr.length;\n\t        Random rnd = new Random();\n\t        for (int i = 0; i < n; ++i) {\n\t            long tmp = arr[i];\n\t            int randomPos = i + rnd.nextInt(n - i);\n\t            arr[i] = arr[randomPos];\n\t            arr[randomPos] = tmp;\n\t        }\n\t        Arrays.sort(arr);\n\t    }\n\t\n\tpublic static void main(String[] args) {\n\t\t FastScanner sc = new FastScanner();\n\t\t\tint test = sc.nextInt();\n\t\t\tPrintWriter o = new PrintWriter(System.out);\n\t\t\n\t\t\t\n\t\t\twhile(test-->0) {\n\t\t\t\t\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tlong a[] = new long[n];\n\t\t\t\tfor(int i = 0;i<n;i++)\n\t\t\t\t{\n\t\t\t\t\ta[i] = sc.nextLong();\n\t\t\t\t}\n\t\t\t\tif(n==1)\n\t\t\t\t{\n\t\t\t\t\to.println(a[0]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\truffleSort(a);\n\t\t\t\tlong max =a[0];\n\t\t\t\t\n\t\t\t\tfor(int i = 1;i<n;i++)\n\t\t\t\t{\n\t\t\t\t\tlong c = a[i] - a[i-1];\n\t\t\t\t\tif(c>max)\n\t\t\t\t\t{\n\t\t\t\t\t\tmax = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\to.println(max);\n\t\t\t\t\n\t\t\t}\n\t\t\to.close();\n\n\t}\n\t\n}\nclass lavesh {\n\tint value;\n\tString color;\n\tlavesh(int value,String color){\n\t\tthis.value = value;\n\t\tthis.color = color;\n\t}\n\tpublic int getValue() {\n\t\treturn value;\n\t}\n\tpublic void setValue(int value) {\n\t\tthis.value = value;\n\t}\n\tpublic String getColor() {\n\t\treturn color;\n\t}\n\tpublic void setColor(String color) {\n\t\tthis.color = color;\n\t}\n}\nclass pair {\n\tint value;\n\tint index;\n\tpair(int value,int index){\n\t\tthis.value = value;\n\t\tthis.index = index;\n\t}\n\tpublic int getValue() {\n\t\treturn value;\n\t}\n\tpublic void setValue(int value) {\n\t\tthis.value = value;\n\t}\n\tpublic int getIndex() {\n\t\treturn index;\n\t}\n\tpublic void setIndex(int index) {\n\t\tthis.index = index;\n\t}\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long extr(long long arr[], int n) {\n  if (n == 1) return arr[0];\n  long long ans = arr[0];\n  for (int i = 1; i < n; i++) {\n    ans = max(ans, arr[i] - arr[i - 1]);\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long arr[n];\n    for (int i = 0; i < n; i++) cin >> arr[i];\n    sort(arr, arr + n);\n    cout << extr(arr, n) << '\\n';\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint p[N];\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> p[i];\n    sort(p + 1, p + n + 1);\n    int ans = p[1];\n    for (int i = 2; i <= n; i++) ans = max(p[i] - p[i - 1], ans);\n    cout << ans << endl;\n  }\n  return 0;\n}\n","t=int(input())\nfor i in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    a=sorted(a)\n    res=a[0]\n    for i in range(n-1):\n        res=max(res,a[i+1]-a[i])\n    print(res)\n        ","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long MOD = 1000000007;\nint main(void) {\n  cin.tie(0);\n  cout.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout.precision(15);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a.begin(), a.end());\n    long long ans = a[0];\n    for (int i = 0; i < n - 1; i++) {\n      ans = max(ans, a[i + 1] - a[i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n","import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class C{\n\tpublic static void main(String[] args){\n\t\tFastReader sc = new FastReader();\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0){\n\t\t\tint n=sc.nextInt();\n\t\t\tArrayList<Integer> a= new ArrayList<>();\n\t\t\tfor(int i=0;i<n;i++)a.add(sc.nextInt());\n\t\t\tCollections.sort(a);\n\t\t\tif(n==1) {\n\t\t\t\tSystem.out.println(a.get(0));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ans=a.get(0);\n\t\t\tfor(int i=1;i<n;i++) {\n\t\t\t\tans=Math.max(ans, a.get(i)-a.get(i-1));\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\t\t \n    }\n\n\tstatic class pair {\n\t\tint x;int y;\n\t\t pair(int x,int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t\n\t}\n\tstatic ArrayList<Integer> primeFac(int n){\n\t\tArrayList<Integer>ans = new ArrayList<Integer>();\n\t\tint lp[]=new int [n+1];\n\t\tArrays.fill(lp, 0);  \t\/\/0-prime\n\t\tfor(int i=2;i<=n;i++) {\n\t\t\tif(lp[i]==0) {\n\t\t\t\tfor(int j=i;j<=n;j+=i) {\n\t\t\t\t\tif(lp[j]==0) lp[j]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint fac=n;\n\t\twhile(fac>1) {\n\t\t\tans.add(lp[fac]);\n\t\t\tfac=fac\/lp[fac];\n\t\t}\n\t\tprint(ans);\n\t\treturn ans;\n\t}\n\tstatic ArrayList<Long> prime_in_given_range(long l,long r){\n\t\tArrayList<Long> ans= new ArrayList<>();\n\t\tint n=(int)Math.sqrt(r)+1;\n\t\tint prime[]=sieve_of_Eratosthenes(n);\n\t\tlong res[]=new long [(int)(r-l)+1];\n\t\tfor(int i=0;i<=r-l;i++) {\n\t\t\tres[i]=i+l;\n\t\t}\n\t\tfor(int i=0;i<prime.length;i++) {\n\t\t\tif(prime[i]==1) {\n\t\t\t\tSystem.out.println(2);\n\t\t\t\tfor(int j=Math.max((int)i*i, (int)(l+i-1)\/i*i);j<=r;j+=i) {\n\t\t\t\t\tres[j-(int)l]=0; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(long i:res) if(i!=0)ans.add(i);\n\t\treturn ans;\n\t}\n\tstatic int [] sieve_of_Eratosthenes(int n) {\n\t\tint prime[]=new int [n];\n\t\tArrays.fill(prime, 1);  \/\/ 1-prime | 0-not prime\n\t\tprime[0]=prime[1]=0;\n\t\tfor(int i=2;i<n;i++) {\n\t\t\tif(prime[i]==1) {\n\t\t\t\tfor(int j=i*i;j<n;j+=i) {\n\t\t\t\t\tprime[j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prime;\n\t}\n\tstatic long binpow(long a,long b) {\n\t\tlong res=1;\n\t\tif(b==0)return a;\n\t\tif(a==0)return 1;\n\t\twhile(b>0) {\n\t\t\tif((b&1)==1) {\n\t\t\t\tres*=a;\n\t\t\t}\n\t\t\ta*=a;\n\t\t\tb>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tstatic void print(int a[]) {\n\t\tSystem.out.println(a.length);\n\t\tfor(int i:a) {\n\t\t\tSystem.out.print(i+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tstatic void print(long a[]) {\n\t\tSystem.out.println(a.length);\n\t\tfor(long i:a) {\n\t\t\tSystem.out.print(i+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tstatic long rolling_hashcode(String s ,int st,int end,long Hashcode,int n) {\n\t\tif(end>=s.length()) return -1;\n\t\tint mod=1000000007;\n\t\t\n\t\tHashcode=Hashcode-(s.charAt(st-1)*(long)Math.pow(27,n-1));\n\t\tHashcode*=10;\n\t\t\n\t\tHashcode=(Hashcode+(long)s.charAt(end))%mod;\n\t\treturn Hashcode;\n\t\t\n\t}\n\tstatic long  hashcode(String s,int n) {\n\t\tlong code=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tcode+=((long)s.charAt(i)*(long)Math.pow(27, n-i-1)%1000000007);\n\t\t}\n\t\treturn code;\n\t}\n\tstatic void print(ArrayList<Integer> a) {\n\t\tSystem.out.println(a.size());\n\t\tfor(long i:a) {\n\t\t\tSystem.out.print(i+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader()\n\t\t{\n\t\t\tbr = new BufferedReader(\n\t\t\t\tnew InputStreamReader(System.in));\n\t\t}\n\t\tint [] fastArray(int n) {\n\t\t\tint a[]=new int [n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i]=nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tString next()\n\t\t{\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() { return Integer.parseInt(next()); }\n\n\t\tlong nextLong() { return Long.parseLong(next()); }\n\n\t\tdouble nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine()\n\t\t{\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n}","for _ in range(int(input())):\n    n = int(input())\n    line = sorted(list(map(int, input().split())))\n    k = line[0]\n    for i in range(1, n):\n        k = max(k, line[i] - line[i - 1])\n    print(k)","import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic int mod=1000000007;\n\tstatic MyScanner sc = new MyScanner();\n\tstatic Output out = new Output();\n\tpublic static void main(String[] args) {\n\t\tint t=sc.nextInt();\n\t\tfor (int i=0;i<t;i++) {\n\t\t\tsolve();\n\t\t}\n\t\tout.flush();\n\t}\n\n\tpublic static void solve() {\n\t\tint n=sc.nextInt();\n\t\tlong a[]=sc.nextLongArr(n);\n\t\tArray.sort(a);\n\t\tlong ans=a[n-1];\n\t\tlong sum=0;\n\t\tlong max=a[0];\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\ta[i]-=sum;\n\t\t\tsum+=a[i];\n\t\t\tans-=a[i];\n\t\t\tmax=Math.max(max, a[i]);\n\t\t}\n\t\tmax=Math.max(ans, max);\n\t\tout.println(max);\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Array{\n\tstatic void sort(long[] arr){\n\t\tmergesort(arr,0,arr.length-1);\n\t}\n\tstatic void sort(long[] arr,int startIndex,int endIndex){\n\t\tmergesort(arr,startIndex,endIndex);\n\t}\n\n\tstatic void mergesort(long[] arr,int b,int e) {\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tmergesort(arr,b,m);\n\t\t\tmergesort(arr,m+1,e);\n\t\t\tmerge(arr,b,m,e);\n\t\t}\n\t\treturn;\t\n\t}\n\tstatic void merge(long[] arr,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tlong[] l=new long[len1];\n\t\tlong[] r=new long[len2];\n\t\tfor(int i=0;i<len1;i++)l[i]=arr[b+i];\n\t\tfor(int i=0;i<len2;i++)r[i]=arr[m+1+i];\n\t\tint i=0,j=0,k=b;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<r[j])arr[k++]=l[i++];\n\t\t\telse arr[k++]=r[j++];\n\t\t}\n\t\twhile(i<len1)arr[k++]=l[i++];\n\t\twhile(j<len2)arr[k++]=r[j++];\n\t\treturn;\n\t}\n\t\n\tpublic static  void SortColoumn (int[][] array, final int columnIndex){\n        Arrays.sort(array, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] first, int[] second) {\n               if(first[columnIndex] > second[columnIndex]) return 1;\n               else return -1;\n            }\n        });\n\t}\n\t\n\t\/\/2d sort\n\/\/\tstatic void sort(int[][] arr){\n\/\/\t\tmergesort(arr,0,arr.length-1);\n\/\/\t}\n\/\/\tstatic void sort(int[][] arr,int startIndex,int endIndex){\n\/\/\t\tmergesort(arr,startIndex,endIndex);\n\/\/\t}\n\/\/\n\/\/\tstatic void mergesort(int[][] arr,int b,int e) {\n\/\/\t\tif(b<e) {\n\/\/\t\t\tint m=b+(e-b)\/2;\n\/\/\t\t\tmergesort(arr,b,m);\n\/\/\t\t\tmergesort(arr,m+1,e);\n\/\/\t\t\tmerge(arr,b,m,e);\n\/\/\t\t}\n\/\/\t\treturn;\t\n\/\/\t}\n\/\/\tstatic void merge(int[][] arr,int b,int m,int e) {\n\/\/\t\tint len1=m-b+1,len2=e-m;\n\/\/\t\tint[][] l=new int[len1][2];\n\/\/\t\tint[][] r=new int[len2][2];\n\/\/\t\tfor(int i=0;i<len1;i++) {\n\/\/\t\t\tl[i][0]=arr[b+i][0];\n\/\/\t\t\tl[i][1]=arr[b+i][1];\n\/\/\t\t}\n\/\/\t\tfor(int i=0;i<len2;i++) {\n\/\/\t\t\tr[i][0]=arr[m+1+i][0];\n\/\/\t\t\tr[i][1]=arr[m+1+i][1];\n\/\/\t\t}\n\/\/\t\tint i=0,j=0,k=b;\n\/\/\t\twhile(i<len1 && j<len2) {\n\/\/\t\t\tif(l[i][0]<r[j][0]) {\n\/\/\t\t\t\tarr[k++][0]=l[i++][0];\n\/\/\t\t\t\tarr[k-1][1]=l[i-1][1];\n\/\/\t\t\t}\n\/\/\t\t\telse {\n\/\/\t\t\t\tarr[k++][0]=r[j++][0];\n\/\/\t\t\t\tarr[k-1][1]=r[j-1][1];\n\/\/\t\t\t}\n\/\/\t\t}\n\/\/\t\twhile(i<len1) {\n\/\/\t\t\tarr[k++][0]=l[i++][0];\n\/\/\t\t\tarr[k-1][1]=l[i-1][1];\n\/\/\t\t}\n\/\/\t\twhile(j<len2) {\n\/\/\t\t\tarr[k++][0]=r[j++][0];\n\/\/\t\t\tarr[k-1][1]=r[j-1][1];\n\/\/\t\t}\n\/\/\t\treturn;\n\/\/\t}\n\t\n}\nclass MyScanner {\n\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tpublic MyScanner() {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tString next() {\n\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tString nextLine() {\n\t\tString str = \"\";\n\t\ttry {\n\t\t\tstr = br.readLine();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn str;\n\t}\n\n\tpublic int[] nextIntArr(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic long[] nextLongArr(int n) {\n\t\tlong a[] = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n\n\tpublic double[] nextDoubleArr(int n) {\n\t\tdouble a[] = new double[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextDouble();\n\t\treturn a;\n\t}\n\n\tpublic String[] nextArr(int n) {\n\t\tString a[] = new String[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = next();\n\t\treturn a;\n\t}\n\n\tpublic String[] nextLineArr(int n) {\n\t\tString a[] = new String[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLine();\n\t\treturn a;\n\t}\n}\n\nclass Output {\n\tBufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n\tpublic void print() {}\n\tpublic void println() {\n\t\ttry {\n\t\t\tout.write(\"\\n\");\n\t\t} catch (Exception e) {}\n\t}\n\tpublic void print(Object s) {\n\t\ttry {\n\t\t\tout.write(s + \"\");\n\t\t} catch (Exception e) {}\n\t}\n\tpublic void println(Object s) {\n\t\ttry {\n\t\t\tout.write(s + \"\\n\");\n\t\t} catch (Exception e) {}\n\t}\n\tpublic void flush() {\n\t\ttry {\n\t\t\tout.flush();\n\t\t} catch (Exception e) {}\n\t}\n}","import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    static int M = 998244353;\n    static Random rng = new Random();\n\n    private static int testCase(int n, int[] a) {\n        int ans = Integer.MIN_VALUE, change = 0;\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n\n        for (int ai : a) {\n            pq.offer(ai);\n        }\n\n        while (!pq.isEmpty()) {\n            int next = pq.poll() - change;\n            ans = Math.max(ans, next);\n            change += next;\n        }\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        FastScanner in = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int t = in.nextInt();  \/\/ Scanner has functions to read ints, longs, strings, chars, etc.\n        \/\/in.nextLine();\n        for (int tt = 1; tt <= t; ++tt) {\n            int n = in.nextInt();\n            int[] a = in.readArray(n);\n\n            out.println(testCase(n, a));\n        }\n\n        out.close();\n    }\n\n    private static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        boolean hasNext() {\n            return st.hasMoreTokens();\n        }\n\n        char[] readCharArray(int n) {\n            char[] arr = new char[n];\n            try {\n                br.read(arr);\n                br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return arr;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long[] readLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n    private static void sort(int[] arr) {\n        int temp, idx;\n\n        for (int i = arr.length - 1; i > 0; i--) {\n            idx = rng.nextInt(i + 1);\n\n            temp = arr[i];\n            arr[i] = arr[idx];\n            arr[idx] = temp;\n        }\n\n        Arrays.sort(arr);\n    }\n\n    private static void sort(long[] arr) {\n        long temp;\n        int idx;\n\n        for (int i = arr.length - 1; i > 0; i--) {\n            idx = rng.nextInt(i + 1);\n\n            temp = arr[i];\n            arr[i] = arr[idx];\n            arr[idx] = temp;\n        }\n\n        Arrays.sort(arr);\n    }\n\n    private static <T> void sort(T[] arr) {\n        T temp;\n        int idx;\n\n        for (int i = arr.length - 1; i > 0; i--) {\n            idx = rng.nextInt(i + 1);\n\n            temp = arr[i];\n            arr[i] = arr[idx];\n            arr[idx] = temp;\n        }\n\n        Arrays.sort(arr);\n    }\n\n    private static <T> void sort(T[] arr, Comparator<? super T> cmp) {\n        T temp;\n        int idx;\n\n        for (int i = arr.length - 1; i > 0; i--) {\n            idx = rng.nextInt(i + 1);\n\n            temp = arr[i];\n            arr[i] = arr[idx];\n            arr[idx] = temp;\n        }\n\n        Arrays.sort(arr, cmp);\n    }\n\n    private static <T extends Comparable<? super T>> void sort(ArrayList<T> list) {\n        T temp;\n        int idx;\n\n        for (int i = list.size() - 1; i > 0; i--) {\n            idx = rng.nextInt(i + 1);\n\n            temp = list.get(i);\n            list.set(i, list.get(idx));\n            list.set(idx, temp);\n        }\n\n        Collections.sort(list);\n    }\n\n    private static <T> void sort(ArrayList<T> list, Comparator<? super T> cmp) {\n        T temp;\n        int idx;\n\n        for (int i = list.size() - 1; i > 0; i--) {\n            idx = rng.nextInt(i + 1);\n\n            temp = list.get(i);\n            list.set(i, list.get(idx));\n            list.set(idx, temp);\n        }\n\n        Collections.sort(list, cmp);\n    }\n}\n","\nimport java.util.*;\nimport java.io.*;\n\n\n\npublic class Main {\n\tstatic StringBuilder sb;\n\tstatic dsu dsu;\n\tstatic long fact[];\n\tstatic int mod = (int) (1e9 + 7);\n\n\tstatic void solve() {\n\t\tint n=i();\n\t\tlong[]arr=new long[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t    arr[i]=l();\n\t\t}\n\t\tPriorityQueue<Long> pq=new PriorityQueue<>();\n\t\tfor(int i=0;i<n;i++)pq.add(arr[i]);\n\t\tlong ans=Long.MIN_VALUE;\n\t\tlong m=0;\n\t\twhile(pq.size()>0){\n\t\t    long x=pq.remove();\n\t\t    ans=Math.max(ans,x-m);\n\t\t    m+=x-m;\n\t\t    \n\t\t}\n\t\tsb.append(ans+\"\\n\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tsb = new StringBuilder();\n\t\tint test = i();\n\t\twhile (test-- > 0) {\n\t\t\tsolve();\n\t\t}\n\t\tSystem.out.println(sb);\n\n\t}\n\n\t\/*\n\t * fact=new long[(int)1e6+10]; fact[0]=fact[1]=1; for(int i=2;i<fact.length;i++)\n\t * { fact[i]=((long)(i%mod)1L(long)(fact[i-1]%mod))%mod; }\n\t *\/\n\/\/**************NCR%P******************\t \n\tstatic long ncr(int n, int r) {\n\t\tif (r > n)\n\t\t\treturn (long) 0;\n\n\t\tlong res = fact[n] % mod;\n\t\t\/\/ System.out.println(res);\n\t\tres = ((long) (res % mod) * (long) (p(fact[r], mod - 2) % mod)) % mod;\n\t\tres = ((long) (res % mod) * (long) (p(fact[n - r], mod - 2) % mod)) % mod;\n\t\t\/\/ System.out.println(res);\n\t\treturn res;\n\n\t}\n\n\tstatic long p(long x, long y)\/\/ POWER FXN \/\/\n\t{\n\t\tif (y == 0)\n\t\t\treturn 1;\n\n\t\tlong res = 1;\n\t\twhile (y > 0) {\n\t\t\tif (y % 2 == 1) {\n\t\t\t\tres = (res * x) % mod;\n\t\t\t\ty--;\n\t\t\t}\n\n\t\t\tx = (x * x) % mod;\n\t\t\ty = y \/ 2;\n\n\t\t}\n\t\treturn res;\n\t}\n\n\/\/**************END******************\n\n\t\/\/ *************Disjoint set\n\t\/\/ union*********\/\/\n\tstatic class dsu {\n\t\tint parent[];\n\n\t\tdsu(int n) {\n\t\t\tparent = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tparent[i] = -1;\n\t\t}\n\n\t\tint find(int a) {\n\t\t\tif (parent[a] < 0)\n\t\t\t\treturn a;\n\t\t\telse {\n\t\t\t\tint x = find(parent[a]);\n\t\t\t\tparent[a] = x;\n\t\t\t\treturn x;\n\t\t\t}\n\t\t}\n\n\t\tvoid merge(int a, int b) {\n\t\t\ta = find(a);\n\t\t\tb = find(b);\n\t\t\tif (a == b)\n\t\t\t\treturn;\n\t\t\tparent[b] = a;\n\t\t}\n\t}\n\n\/\/**************PRIME FACTORIZE **********************************\/\/\n\tstatic TreeMap<Integer, Integer> prime(long n) {\n\t\tTreeMap<Integer, Integer> h = new TreeMap<>();\n\t\tlong num = n;\n\t\tfor (int i = 2; i <= Math.sqrt(num); i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tint nt = 0;\n\t\t\t\twhile (n % i == 0) {\n\t\t\t\t\tn = n \/ i;\n\t\t\t\t\tnt++;\n\t\t\t\t}\n\t\t\t\th.put(i, nt);\n\t\t\t}\n\t\t}\n\t\tif (n != 1)\n\t\t\th.put((int) n, 1);\n\t\treturn h;\n\n\t}\n\n\/\/****CLASS PAIR ************************************************\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint x;\n\t\tlong y;\n\n\t\tPair(int x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn (int) (this.y - o.y);\n\n\t\t}\n\n\t}\n\/\/****CLASS PAIR **************************************************\n\n\tstatic class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int Int() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String String() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\treturn String();\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n\n\tstatic class OutputWriter {\n\t\tprivate final PrintWriter writer;\n\n\t\tpublic OutputWriter(OutputStream outputStream) {\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t\t}\n\n\t\tpublic OutputWriter(Writer writer) {\n\t\t\tthis.writer = new PrintWriter(writer);\n\t\t}\n\n\t\tpublic void print(Object... objects) {\n\t\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\twriter.print(' ');\n\t\t\t\twriter.print(objects[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void printLine(Object... objects) {\n\t\t\tprint(objects);\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void close() {\n\t\t\twriter.close();\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\twriter.flush();\n\t\t}\n\t}\n\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic OutputWriter out = new OutputWriter(System.out);\n\n\tpublic static long[] sort(long[] a2) {\n\t\tint n = a2.length;\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a2)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < l.size(); i++)\n\t\t\ta2[i] = l.get(i);\n\t\treturn a2;\n\t}\n\n\tpublic static char[] sort(char[] a2) {\n\t\tint n = a2.length;\n\t\tArrayList<Character> l = new ArrayList<>();\n\t\tfor (char i : a2)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < l.size(); i++)\n\t\t\ta2[i] = l.get(i);\n\t\treturn a2;\n\t}\n\n\tpublic static long pow(long x, long y) {\n\t\tlong res = 1;\n\t\twhile (y > 0) {\n\t\t\tif (y % 2 != 0) {\n\t\t\t\tres = (res * x);\/\/ % modulus;\n\t\t\t\ty--;\n\n\t\t\t}\n\t\t\tx = (x * x);\/\/ % modulus;\n\t\t\ty = y \/ 2;\n\t\t}\n\t\treturn res;\n\t}\n\n\/\/GCD___+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\tpublic static long gcd(long x, long y) {\n\t\tif (x == 0)\n\t\t\treturn y;\n\t\telse\n\t\t\treturn gcd(y % x, x);\n\t}\n\t\/\/ ******LOWEST COMMON MULTIPLE\n\t\/\/ *********************************************\n\n\tpublic static long lcm(long x, long y) {\n\t\treturn (x * (y \/ gcd(x, y)));\n\t}\n\n\/\/INPUT PATTERN********************************************************\n\tpublic static int i() {\n\t\treturn in.Int();\n\t}\n\n\tpublic static long l() {\n\t\tString s = in.String();\n\t\treturn Long.parseLong(s);\n\t}\n\n\tpublic static String s() {\n\t\treturn in.String();\n\t}\n\n\tpublic static int[] readArrayi(int n) {\n\t\tint A[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tA[i] = i();\n\t\t}\n\t\treturn A;\n\t}\n\n\tpublic static long[] readArray(long n) {\n\t\tlong A[] = new long[(int) n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tA[i] = l();\n\t\t}\n\t\treturn A;\n\t}\n\n}","for _ in range(int(input())):\n    n = int(input())\n    x = list(map(int, input().split()))\n    if n == 1: ans = x[0]\n    else:\n        x = sorted(x)\n        ans = x[0]\n        for i in range(1, n):\n            xd = x[i] - x[i-1]\n            if xd > ans : ans = xd\n    print(ans)","#include <bits\/stdc++.h>\nusing namespace std;\nsigned main() {\n  long long test;\n  cin >> test;\n  while (test--) {\n    long long n;\n    cin >> n;\n    vector<long long> a(n);\n    for (long long &x : a) {\n      cin >> x;\n    }\n    sort(a.begin(), a.end());\n    long long ans = a[0];\n    for (long long i = 1; i < n; i++) {\n      ans = max(ans, a[i] - a[i - 1]);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n","for t in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    if n==1:\n        print(*l)\n        continue\n    l.sort()\n    mx=l[0]\n    for i in range(1,n):\n        if (l[i]-l[i-1])>mx:\n            mx=l[i]-l[i-1]\n       \n    print(mx) ","import java.io.*;\nimport java.util.*;\n\n\/**\n * -----------------|___________|---------------------\n * CCCCCCCCC   OOOOOOOOOO   DDDDDDDD      EEEEEEEEE\n * CCCC        OOO    OOO   DD    DDD     EEEE\n * CCCC        OOO    OOO   DD     DDD    EEEEEEEEEE\n * CCCC        OOO    OOO   DD     DDDD   EEEE\n * CCCCCCCCC   OOOOOOOOOO   DDDDDDDDDDDD  EEEEEEEEEE\n * -----------------|___________|---------------------\n *\/\n\npublic class Main {\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter sout = new PrintWriter(outputStream);\n\n        int t = in.nextInt();\n        while (t-- > 0) {\n            int n = in.nextInt();\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = in.nextLong();\n            }\n            sortLong(arr);\n            long max = arr[0];\n            if (arr.length > 1) {\n                for (int i = 0; i < n - 1; i++) {\n                    long var = arr[i + 1] - arr[i];\n                    if (max < var) {\n                        max = var;\n                    }\n                }\n            }\n            sout.println(max);\n        }\n        sout.close();\n    }\n\n    private static boolean checkPrime(long n) {\n        for (long i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return n >= 2;\n    }\n\n    public static List<Integer> getPrimesList(int N) {\n        boolean[] isComposite = new boolean[N + 1];\n        for (int i = 2; i <= N; i++) {\n            if (isComposite[i])\n                continue;\n            for (int j = i * 2; j <= N; j += i)\n                isComposite[j] = true;\n        }\n        List<Integer> numbers = new ArrayList<>();\n        for (int i = 2; i <= N; i++)\n            if (!isComposite[i])\n                numbers.add(i);\n        return numbers;\n    }\n\n    static class Node {\n        int value;\n        \/\/List<Town> edges = new ArrayList<>();\n\n        public Node(int value) {\n            this.value = value;\n        }\n    }\n\n    public static int binarySearch(long[] array, long value) {\n        int left = 0, right = array.length - 1;\n        while (left <= right) {\n            int m = (left + right) \/ 2;\n            if (array[m] == value)\n                return m;\n            else if (array[m] < value)\n                left = m + 1;\n            else\n                right = m - 1;\n        }\n        return -1;\n    }\n\n    public static int gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static void sortInt(int[] a) {\n        ArrayList<Integer> l = new ArrayList<>();\n        for (int i : a)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n\n    public static void sortLong(long[] a) {\n        ArrayList<Long> l = new ArrayList<>();\n        for (long i : a)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n\n    private static int upperBound(int[] a, int low, int high, int element) {\n        while (low < high) {\n            int middle = low + (high - low) \/ 2;\n            if (a[middle] > element)\n                high = middle;\n            else\n                low = middle + 1;\n        }\n        return low;\n    }\n\n    public static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String nextToken() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}","import math\nT=int(input())\nfor _ in range(T):\n    n=int(input())\n    a=list(map(int,input().split()))\n    if n==1:\n        print(a[0])\n        continue\n    a.sort()\n    neg=0\n    i=0\n    rem=0\n    pos=0\n    ans=-999999999\n    while i<n:\n        ans=max(ans,a[i]+abs(neg)-pos)\n        if a[i]+abs(neg)-pos<0:\n            neg+=(a[i]+neg)\n        else:\n            pos+=(a[i]+abs(neg)-pos)\n\n        i+=1\n    print(ans)\n    \n\n    \n    ","def minimal(a):\n    if len(a) == 1:\n        return a[0]\n    a.sort()\n    f = [0] * len(a)\n    f[0] = a[0]\n    s = f[0]\n    for i in range(1, len(a)):\n        f[i] = a[i] - s\n        s += f[i]\n    return max(f)\n\n\nt = int(input())\n# 0 -1 1 4 0 -5 1 8 0 -9 1  12 0\n# 0  1 2 3 4  5 6 7 8  9 10 11 12\nfor qwer in range(t):\n    n = int(input())\n    stro = list(map(int, input().split()))\n    print(minimal(stro))","t = int(input())\nDIC = {}\nfor _ in range(t):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    lst.sort()\n    i = 0\n    tot = 0\n    mx = lst[0]\n    while i < n:\n        mx = max(mx, lst[i] - tot)\n        tot += lst[i] - tot\n        i += 1\n    print(mx)\n\n","t = int(input())\nfor i in range(t):\n    n = int(input())\n    K = list(map(int, input().split()))\n    K.sort()\n    count = K[0]\n    for i in range(n-1):\n        count = max(count,K[i+1]-K[i])\n    print(count)\n","def main():\n    n = int(input())\n    array = sorted([int(x) for x in input().split()])\n    mx, sm = array[0], array[0]\n    for i in range(1, n):\n        cnt = array[i] - sm\n        sm += cnt\n        mx = max(mx, cnt)\n    print(mx)\n\n\nif __name__ == '__main__':\n    # tests = 1\n    tests = int(input())\n    while tests > 0:\n        tests -= 1\n        main()\n","import java.io.*;\nimport java.util.*;\n\npublic class C_Minimum_Extraction {\n\n    static final int MOD = (int) 1e9 + 7;\n    static final int INT_POSITIVE_INFINITY = Integer.MAX_VALUE;\n    static final long LONG_POSITIVE_INFINITY = Long.MAX_VALUE;\n    static final int INT_NEGATIVE_INFINITY = Integer.MIN_VALUE;\n    static final long LONG_NEGATIVE_INFINITY = Long.MIN_VALUE;\n    static StringBuilder result = new StringBuilder();\n\n    static class Pair {\n        int a;\n        int b;\n\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    public static void main(String args[]) throws IOException {\n        FastReader fr = new FastReader();\n\n        int tc = fr.nextInt();\n        while (tc-- > 0) {\n            int n = fr.nextInt();\n            ArrayList<Integer> arr = new ArrayList<Integer>();\n            for (int i = 0; i < n; i++) {\n                arr.add(fr.nextInt());\n            }\n            Collections.sort(arr);\n            int max = arr.get(0);\n            int temp = max;\n            for (int i = 1; i < n; i++) {\n                max = Math.max(max, arr.get(i) - temp);\n                temp += (arr.get(i) - temp);\n            }\n            result.append(max + \"\\n\");\n        }\n\n        System.out.print(result);\n    }\n\n    static class FastReader {\n        InputStreamReader ir;\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            ir = new InputStreamReader(System.in);\n            br = new BufferedReader(ir);\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static int fastPow(long b, long e) {\n        long curr = b;\n        long res = 1;\n\n        while (e != 0) {\n            if ((e & 1) != 0) {\n                res = (res * curr) % MOD;\n            }\n            curr = (curr * curr) % MOD;\n            e >>= 1;\n        }\n\n        return (int) res;\n    }\n\n    static int gcd(int a, int b) {\n        if (b > a) {\n            return gcd(b, a);\n        }\n\n        if (b == 0) {\n            return a;\n        }\n\n        return gcd(b, a % b);\n    }\n}","\/**\n * 11\/02\/21 morning\n * https:\/\/codeforces.com\/contest\/1607\/problem\/C\n *\/\n\n\/\/ package codeforce.cf.div3.r753;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class C {\n\n    static PrintWriter pw;\n\n    \/*\n       [1, 2, 7, 10]\n           [1, 6, 9]\n              [5, 8]\n                 [3]\n     *\/\n    void solve(int n, int[] a) {\n        shuffleArray(a);\n        Arrays.sort(a);\n        int max = a[0];\n        for (int i = 1; i < n; i++) {\n            max = Math.max(max, a[i] - a[i - 1]);\n        }\n        pr(max);\n    }\n\n    void shuffleArray(int[] a) {\n        int n = a.length;\n        Random rnd = new Random();\n        for (int i = 0; i < n; i++) {\n            int tmp = a[i];\n            int randomPos = i + rnd.nextInt(n - i);\n            a[i] = a[randomPos];\n            a[randomPos] = tmp;\n        }\n    }\n\n    private void run() {\n        \/\/ read_write_file(); \/\/ comment this before submission\n        FastScanner fs = new FastScanner();\n        int t = fs.nextInt();\n        while (t-- > 0) {\n            int n = fs.nextInt();\n            int[] a = fs.readArray(n);\n            solve(n, a);\n        }\n    }\n\n    private final String INPUT = \"input.txt\";\n    private final String OUTPUT = \"output.txt\";\n\n    void read_write_file() {\n        FileInputStream instream = null;\n        PrintStream outstream = null;\n        try {\n            instream = new FileInputStream(INPUT);\n            outstream = new PrintStream(new FileOutputStream(OUTPUT));\n            System.setIn(instream);\n            System.setOut(outstream);\n        } catch (Exception e) {\n        }\n    }\n\n    public static void main(String[] args) {\n        pw = new PrintWriter(System.out);\n        new C().run();\n        pw.close();\n    }\n\n    void pr(int num) {\n        pw.println(num);\n    }\n\n    void pr(long num) {\n        pw.println(num);\n    }\n\n    void pr(double num) {\n        pw.println(num);\n    }\n\n    void pr(String s) {\n        pw.println(s);\n    }\n\n    void pr(char c) {\n        pw.println(c);\n    }\n\n    class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        List<Integer> readList(int n) {\n            List<Integer> l = new ArrayList<>();\n            for (int i = 0; i < n; i++) l.add(nextInt());\n            return l;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    void tr(Object... o) {\n        pw.println(Arrays.deepToString(o));\n    }\n}","\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\n\npublic class Main {\n\n    static class Pair {\n        int x,y;\n\n        public Pair(int x,int y) {\n            this.x=x;\n            this.y=y;\n        }\n    }\n\n    static int mod=1000000007;\n\n    public static void main(String[] args) throws IOException\n    {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC\n    {\n        public static void solve(int testNumber, InputReader in, OutputWriter out)\n        {\n            int t=in.readInt();\n            while(t-->0)\n            {\n                int n=in.readInt();\n                int arr[]=in.nextIntArray(n);\n                if(n==1)\n                {\n                    out.printLine(arr[0]);\n                    continue;\n                }\n                CP.sort(arr);\n                long prev=0,ele=0;\n                int min=Integer.MIN_VALUE;\n                for(int i=0;i<n;i++)\n                {\n                    min=Math.max(min,(int)(arr[i]-prev));\n                    prev=prev+arr[i]-prev;\n                }\n                out.printLine(min);\n            }\n        }\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int arraySize) {\n            int[] array = new int[arraySize];\n\n            for (int i = 0; i < arraySize; i++) {\n                array[i] = readInt();\n            }\n\n            return array;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isNewLine(int c) {\n            return c == '\\n';\n        }\n\n        public String nextLine() {\n            int c = read();\n\n            StringBuilder result = new StringBuilder();\n\n            do {\n                result.appendCodePoint(c);\n\n                c = read();\n            } while (!isNewLine(c));\n\n            return result.toString();\n        }\n\n        public long nextLong() {\n            int c = read();\n\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n\n            int sign = 1;\n\n            if (c == '-') {\n                sign = -1;\n\n                c = read();\n            }\n\n            long result = 0;\n\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n\n                result *= 10;\n                result += c & 15;\n\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return result * sign;\n        }\n\n        public long[] nextLongArray(int arraySize) {\n            long array[] = new long[arraySize];\n\n            for (int i = 0; i < arraySize; i++) {\n                array[i] = nextLong();\n            }\n\n            return array;\n        }\n\n        public double nextDouble() {\n            double ret = 0, div = 1;\n            byte c = (byte) read();\n\n            while (c <= ' ') {\n                c = (byte) read();\n            }\n\n            boolean neg = (c == '-');\n\n            if (neg) {\n                c = (byte) read();\n            }\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = (byte) read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = (byte) read()) >= '0' && c <= '9') {\n                    ret += (c - '0') \/ (div *= 10);\n                }\n            }\n\n            if (neg) {\n                return -ret;\n            }\n\n            return ret;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n    }\n\n    static class CP {\n\n        static boolean isPrime(long n) {\n            if (n <= 1)\n                return false;\n            if (n == 2 || n == 3)\n                return true;\n            if (n % 2 == 0 || n % 3 == 0)\n                return false;\n            for (int i = 5; (long) i * i <= n; i += 6) {\n                if (n % i == 0 || n % (i + 2) == 0)\n                    return false;\n            }\n            return true;\n        }\n\n        static String addChar(String s, int n, String ch) {\n            String res =s+String.join(\"\", Collections.nCopies(n, ch));\n            return res;\n        }\n\n        static int ifnotPrime(int[] prime, int x) {\n\n            return (prime[x \/ 64] & (1 << ((x >> 1) & 31)));\n        }\n\n        static void makeComposite(int[] prime, int x) {\n\n            prime[x \/ 64] |= (1 << ((x >> 1) & 31));\n        }\n\n        static ArrayList<Integer> bitWiseSieve(int n) {\n            ArrayList<Integer> al = new ArrayList<>();\n            int prime[] = new int[n \/ 64 + 1];\n\n\n            for (int i = 3; i * i <= n; i += 2) {\n\n                if (ifnotPrime(prime, i) == 0)\n                    for (int j = i * i, k = i << 1;\n                         j < n; j += k)\n                        makeComposite(prime, j);\n            }\n\n            al.add(2);\n\n            for (int i = 3; i <= n; i += 2)\n                if (ifnotPrime(prime, i) == 0)\n                    al.add(i);\n\n            return al;\n        }\n\n        public static long[] sort(long arr[]){\n            List<Long> list = new ArrayList<>();\n            for(long n : arr){list.add(n);}\n            Collections.sort(list);\n            for(int i=0;i<arr.length;i++){\n                arr[i] = list.get(i);\n            }\n            return arr;\n        }\n\n\n        static List<Integer> sieve(long size) {\n\n            ArrayList<Integer> pr = new ArrayList<Integer>();\n            boolean prime[] = new boolean[(int) size];\n            for (int i = 2; i < prime.length; i++) prime[i] = true;\n            for (int i = 2; i * i < prime.length; i++) {\n                if (prime[i]) {\n                    for (int j = i * i; j < prime.length; j += i) {\n                        prime[j] = false;\n                    }\n                }\n            }\n            for (int i = 2; i < prime.length; i++) if (prime[i]) pr.add(i);\n            return pr;\n        }\n\n        static void segmented_sieve(int l, int r, ArrayList<Integer> primes) {\n            if (l == 1) ++l;\n            int max = r - l + 1;\n            int arr[] = new int[max];\n            for (int p : primes) {\n                if (p * p <= r) {\n                    int i = (l \/ p) * p;\n                    if (i < l) i += p;\n                    for (; i <= r; i += p) {\n                        if (i != p) {\n                            arr[i - l] = 1;\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < max; ++i) {\n                if (arr[i] == 0) {\n                    System.out.println(l + i);\n                }\n            }\n        }\n\n        static boolean isfPrime(long n, int iteration) {\n\n            if (n == 0 || n == 1)\n                return false;\n\n            if (n == 2)\n                return true;\n\n            if (n % 2 == 0)\n                return false;\n\n            Random rand = new Random();\n            for (int i = 0; i < iteration; i++) {\n                long r = Math.abs(rand.nextLong());\n                long a = r % (n - 1) + 1;\n                if (modPow(a, n - 1, n) != 1)\n                    return false;\n            }\n            return true;\n        }\n\n        static long modPow(long a, long b, long c) {\n            long res = 1;\n            for (int i = 0; i < b; i++) {\n                res *= a;\n                res %= c;\n            }\n            return res % c;\n        }\n\n        private static long binPower(long a, long l, long mod) {\n\n            long res = 0;\n\n            while (l > 0) {\n                if ((l & 1) == 1) {\n                    res = mulmod(res, a, mod);\n                    ;\n                    l >>= 1;\n                }\n                a = mulmod(a, a, mod);\n            }\n            return res;\n        }\n\n        private static long mulmod(long a, long b, long c) {\n\n            long x = 0, y = a % c;\n            while (b > 0) {\n                if (b % 2 == 1) {\n                    x = (x + y) % c;\n                }\n                y = (y * 2L) % c;\n                b \/= 2;\n            }\n            return x % c;\n\n        }\n\n        static long binary_Expo(long a, long b) {\n            long res = 1;\n            while (b != 0) {\n                if ((b & 1) == 1) {\n                    res *= a;\n                    --b;\n                }\n                a *= a;\n                b \/= 2;\n            }\n            return res;\n        }\n\n        static long Modular_Expo(long a, long b) {\n            long res = 1;\n            while (b != 0) {\n                if ((b & 1) == 1) {\n                    res = (res * a) % 1000000007;\n                    --b;\n                }\n                a = (a * a) % 1000000007;\n                b \/= 2;\n            }\n            return res;\n        }\n\n        static int i_gcd(int a, int b) {\n            while (true) {\n                if (b == 0)\n                    return a;\n                int c = a;\n                a = b;\n                b = c % b;\n            }\n        }\n\n        static long gcd(long a, long b) {\n            if (b == 0)\n                return a;\n            return gcd(b, a % b);\n        }\n\n        static long ceil_div(long a, long b) {\n            return (a + b - 1) \/ b;\n        }\n\n        static int getIthBitFromInt(int bits, int i) {\n            return (bits >> (i - 1)) & 1;\n        }\n\n        private static TreeMap<Long, Long> primeFactorize(long n) {\n            TreeMap<Long, Long> pf = new TreeMap<>(Collections.reverseOrder());\n            long cnt = 0;\n            long total = 1;\n            for (long i = 2; (long) i * i <= n; ++i) {\n                if (n % i == 0) {\n                    cnt = 0;\n                    while (n % i == 0) {\n                        ++cnt;\n                        n \/= i;\n                    }\n                    pf.put(cnt, i);\n                    \/\/total*=(cnt+1);\n                }\n            }\n            if (n > 1) {\n                pf.put(1L, n);\n                \/\/total*=2;\n            }\n            return pf;\n        }\n\n        static long upper_Bound(long a[], long x) {\n            long l = -1, r = a.length;\n            while (l + 1 < r) {\n                long m = (l + r) >>> 1;\n                if (a[(int) m] <= x)\n                    l = m;\n                else\n                    r = m;\n            }\n            return l + 1;\n        }\n\n        static int upper_Bound(List<Integer> a, int x) {\n            int l = -1, r = a.size();\n            while (l + 1 < r) {\n                int m = (l + r) >>> 1;\n                if (a.get(m) <= x)\n                    l = m;\n                else\n                    r = m;\n            }\n            return l + 1;\n        }\n\n        static int lower_Bound(int a[],int x) {\n            int l = -1, r = a.length;\n            while (l + 1 < r) {\n                int m = (l + r) >>> 1;\n                if (a[(int) m] >= x)\n                    r = m;\n                else\n                    l = m;\n            }\n            return r;\n        }\n\n        static long bsh(int  a[],int t) {\n            int ans = -1;\n            int i = 0, j = a.length - 1;\n            while (i <= j) {\n                int mid = i + (j - i) \/ 2;\n                if (a[mid] == t) {\n                    ans = mid;\n                    break;\n                } else if (a[mid] > t) {\n                    ans = mid;\n                    j = mid - 1;\n                } else {\n                    i = mid + 1;\n                }\n            }\n            return ans;\n        }\n\n        static int bsl(int a[],int t) {\n            int ans = -1;\n            int i = 0, j = a.length - 1;\n            while (i <= j) {\n                int mid = i + (j - i) \/ 2;\n                if (a[mid] == t) {\n                    ans = mid;\n                    break;\n                } else if (a[mid] > t) {\n                    j = mid - 1;\n                } else {\n                    ans=mid;\n                    i = mid + 1;\n                }\n            }\n            return ans;\n        }\n\n        static int lower_Bound(List<Integer> a, int x)  \/\/closest to the right\n        {\n            int l = -1, r = a.size();\n            while (l + 1 < r) {\n                int m = (l + r) >>> 1;\n                if (a.get(m) >= x)\n                    r = m;\n                else\n                    l = m;\n            }\n            return r;\n        }\n\n        static boolean isSquarefactor(int x, int factor, int target) {\n            int s = (int) Math.round(Math.sqrt(x));\n            return factor * s * s == target;\n        }\n\n        static boolean isSquare(int x) {\n            int s = (int) Math.round(Math.sqrt(x));\n            return x * x == s;\n        }\n\n        static void sort(int a[]) \/\/ heap sort\n        {\n            PriorityQueue<Integer> q = new PriorityQueue<>();\n            for (int i = 0; i < a.length; i++)\n                q.add(a[i]);\n            for (int i = 0; i < a.length; i++)\n                a[i] = q.poll();\n        }\n\n        static void shuffle(int[] in) {\n            for (int i = 0; i < in.length; i++) {\n                int idx = (int) (Math.random() * in.length);\n                fast_swap(in, idx, i);\n            }\n        }\n\n        static int[] computeLps(String pat) {\n            int len = 0, i = 1, m = pat.length();\n            int lps[] = new int[m];\n            lps[0] = 0;\n            while (i < m) {\n                if (pat.charAt(i) == pat.charAt(len)) {\n                    ++len;\n                    lps[i] = len;\n                    ++i;\n                } else {\n                    if (len != 0) {\n                        len = lps[len - 1];\n                    } else {\n                        lps[i] = len;\n                        ++i;\n                    }\n                }\n            }\n            return lps;\n        }\n\n        static void kmp(String s, String pat) {\n            int n = s.length(), m = pat.length();\n            int lps[] = computeLps(pat);\n            int i = 0, j = 0;\n            while (i < n) {\n                if (s.charAt(i) == pat.charAt(j)) {\n                    i++;\n                    j++;\n\n                } else {\n                    if (j != 0) {\n                        j = lps[j - 1];\n                    } else {\n                        i++;\n                    }\n                }\n            }\n        }\n\n        static void reverse_ruffle_sort(int a[]) {\n            shuffle(a);\n            Arrays.sort(a);\n            for (int l = 0, r = a.length - 1; l < r; ++l, --r)\n                fast_swap(a, l, r);\n\n        }\n\n        static void ruffle_sort(int a[]) {\n            shuffle(a);\n            Arrays.sort(a);\n        }\n\n        static int getMax(int arr[], int n) {\n            int mx = arr[0];\n            for (int i = 1; i < n; i++)\n                if (arr[i] > mx)\n                    mx = arr[i];\n            return mx;\n        }\n\n        static ArrayList<Long> primeFactors(long n) {\n            ArrayList<Long> al = new ArrayList<>();\n            al.add(1L);\n            while (n % 2 == 0) {\n                if(!al.contains(2L))\n                {\n                    al.add(2L);\n                }\n                n \/= 2L;\n            }\n\n            for (int i = 3; (long) i * i <= n; i += 2) {\n                while ((n % i == 0)) {\n                    if(!al.contains((long)i))\n                    {\n                        al.add((long) i);\n                    }\n                    n \/= i;\n                }\n            }\n\n            if (n > 2) {\n                if(!al.contains(n))\n                {\n                    al.add(n);\n                }\n            }\n            return al;\n        }\n\n        static int[] z_function(String s) {\n            int n = s.length(), z[] = new int[n];\n\n            for (int i = 1, l = 0, r = 0; i < n; ++i) {\n                if (i <= r)\n                    z[i] = Math.min(z[i - l], r - i + 1);\n\n                while (i + z[i] < n && s.charAt(z[i]) == s.charAt(i + z[i]))\n                    ++z[i];\n\n                if (i + z[i] - 1 > r) {\n                    l = i;\n                    r = i + z[i] - 1;\n                }\n            }\n            return z;\n        }\n\n        static void swap(int a[], int idx1, int idx2) {\n            a[idx1] += a[idx2];\n            a[idx2] = a[idx1] - a[idx2];\n            a[idx1] -= a[idx2];\n        }\n\n        static void fast_swap(int[] a, int idx1, int idx2) {\n            if (a[idx1] == a[idx2])\n                return;\n\n            a[idx1] ^= a[idx2];\n            a[idx2] ^= a[idx1];\n            a[idx1] ^= a[idx2];\n        }\n\n        public static void fast_sort(long[] array) {\n            ArrayList<Long> copy = new ArrayList<>();\n            for (long i : array)\n                copy.add(i);\n            Collections.sort(copy);\n            for (int i = 0; i < array.length; i++)\n                array[i] = copy.get(i);\n        }\n\n        static int divCount(int n) {\n            boolean hash[] = new boolean[n + 1];\n            Arrays.fill(hash, true);\n            for (int p = 2; p * p < n; p++)\n                if (hash[p] == true)\n                    for (int i = p * 2; i < n; i += p)\n                        hash[i] = false;\n\n            int total = 1;\n            for (int p = 2; p <= n; p++) {\n                if (hash[p]) {\n                    int count = 0;\n                    if (n % p == 0) {\n                        while (n % p == 0) {\n                            n = n \/ p;\n                            count++;\n                        }\n                        total = total * (count + 1);\n                    }\n                }\n            }\n            return total;\n        }\n\n        static long binomialCoeff(int n,int k)\n        {\n            long res = 1;\n\n            \/\/ Since C(n, k) = C(n, n-k)\n            if (k > n - k)\n                k = n - k;\n\n            \/\/ Calculate value of\n            \/\/ [n * (n-1) *---* (n-k+1)] \/ [k * (k-1) *----* 1]\n            for (int i = 0; i < k; ++i) {\n                res = (res%mod*(n - i)%mod)%mod;\n                res \/= (i + 1);\n            }\n            return res%mod;\n        }\n\n        static long c(long fact[],int n,int k)\n        {\n            if(k>n) return 0;\n            long res=fact[n];\n            res= (int) ((res * Modular_Expo(fact[k], mod - 2))%mod);\n            res= (int) ((res * Modular_Expo(fact[n - k], mod - 2))%mod);\n            return res%mod;\n        }\n\n        public static ArrayList<Long> getFactors(long x) {\n\n            ArrayList<Long> facts=new ArrayList<>();\n            for(long i=2;i*i<=x;++i)\n            {\n                if(x%i==0)\n                {\n                    facts.add(i);\n                    if(i!=x\/i)\n                    {\n                        facts.add(x\/i);\n                    }\n                }\n            }\n            return facts;\n        }\n    }\n\n    static void py() {\n        System.out.println(\"YES\");\n    }\n\n    static void pn() {\n        System.out.println(\"NO\");\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(int[] array) {\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(array[i]);\n            }\n        }\n\n        public void printLine(int[] array) {\n            print(array);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n        public void printLine(char c)\n        {\n            writer.println(c);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n    }\n}\n\n\n\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid fastio() {\n  ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n  ;\n}\nint main() {\n  fastio();\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<long long int> v1(n), v2;\n    priority_queue<long long int> pq;\n    for (auto &i : (v1)) cin >> i;\n    ;\n    sort(v1.begin(), v1.end());\n    long long int sum = 0, ans = INT_MIN;\n    for (int i = 0; i < n; i++) {\n      ans = max(ans, v1[i] - sum);\n      sum += (v1[i] - sum);\n    }\n    cout << ans;\n    cout << \"\\n\";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid _print(long long t) { cerr << t; }\nvoid _print(string t) { cerr << t; }\nvoid _print(char t) { cerr << t; }\nvoid _print(long double t) { cerr << t; }\nvoid _print(double t) { cerr << t; }\nvoid _print(unsigned long long t) { cerr << t; }\ntemplate <class T, class V>\nvoid _print(pair<T, V> p);\ntemplate <class T>\nvoid _print(vector<T> v);\ntemplate <class T>\nvoid _print(set<T> v);\ntemplate <class T, class V>\nvoid _print(map<T, V> v);\ntemplate <class T>\nvoid _print(multiset<T> v);\ntemplate <class T, class V>\nvoid _print(pair<T, V> p) {\n  cerr << \"{\";\n  _print(p.first);\n  cerr << \",\";\n  _print(p.second);\n  cerr << \"}\";\n}\ntemplate <class T>\nvoid _print(vector<T> v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T>\nvoid _print(set<T> v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T>\nvoid _print(multiset<T> v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T, class V>\nvoid _print(map<T, V> v) {\n  cerr << \"[ \";\n  for (auto i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\nvoid solve(long long tc) {\n  long long n;\n  cin >> n;\n  vector<long long> a(n);\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sort((a).begin(), (a).end());\n  long long ans = a[0];\n  long long cur = a[0], sum = a[0];\n  for (long long i = 1; i < n; i++) {\n    a[i] = a[i] - sum;\n    cur = a[i];\n    sum += cur;\n    if (cur > ans) {\n      ans = cur;\n    }\n  }\n  cout << ans;\n  cout << \"\\n\";\n  ;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long t = 1;\n  cin >> t;\n  for (long long tc = 1; tc <= t; tc++) {\n    solve(tc);\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    long long int n, m, ans = 0, c;\n    cin >> n;\n    long long int a[n];\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a, a + n);\n    for (int i = 0; i < n; i++) {\n      if (i == 0) {\n        ans = a[i];\n        c = a[i];\n      } else {\n        ans = max(ans, a[i] - c);\n        c += a[i] - c;\n      }\n    }\n    cout << ans << endl;\n  }\n}\n","import java.util.*;\npublic class test {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int t = in.nextInt();\n        while(t-->0) {\n            int n = in.nextInt();\n            PriorityQueue<Integer>queue = new PriorityQueue<>();\n            for (int i = 0; i < n; i++) {\n                int a = in.nextInt();\n                queue.offer(a);\n            }\n            int max = queue.peek();\n            int a = queue.poll();\n            if(n>1) {\n                int b = queue.poll();\n                while (!queue.isEmpty()) {\n                    if ((b - a) > max) {\n                        max = b - a;\n                    }\n                    a = b;\n                    b = queue.poll();\n                }\n                if ((b - a) > max) {\n                    max = b - a;\n                }\n            }\n\n\n            System.out.println(max);\n\n\n        }\n    }\n}","\/\/ HOPE\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/----------------------------------------------------------------------------------------------------------------------\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/----------------------------------------------------------------------------------------------------------------------\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/                                                                                                       \/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/                                                                                                       \/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/            RRRRRRRRRRRRR     YY          YY         AA               NN         NN                    \/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/            RR         RR      YY        YY        AA  AA             NN NN      NN                    \/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/            RR        RR         YY     YY        AA    AA            NN  NN     NN                    \/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/            RRRRRRRRRR            YY   YY       AAAAAAAAAAAA          NN    NN   NN                    \/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/            RR RR                   YY         AAAAAAAAAAAAAA         NN      NN NN                    \/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/            RR   RR                 YY        AA            AA        NN       NNNN                    \/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/            RR     RR               YY       AA              AA       NN         NN                    \/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/            RR       RR_____________________________________________________________________________   \/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/                                                                                                      \/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/----------------------------------------------------------------------------------------------------------------------\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/----------------------------------------------------------------------------------------------------------------------\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Codeforces2 {\n    static PrintWriter out = new PrintWriter(System.out);\n    static final int mod=1_000_000_007;\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readIntArray(int n){\n            int[] a = new int[n];\n            for(int i=0;i<n;i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        long[] readLongArray(int n){\n            long[] a = new long[n];\n            for(int i=0;i<n;i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    \/\/Try seeing general case\n    public static void main(String[] args) {\n        FastReader s = new FastReader();\n        int t = s.nextInt();\n        while(t-->0)\n        {\n            int n = s.nextInt();\n            ArrayList<Long> ls = new ArrayList<>();\n            for(int i=0;i<n;i++)\n            {\n                ls.add(s.nextLong());\n            }\n            out.println(find(n, ls));\n        }\n\n        out.close();\n    }\n\n    public static long find(int n, ArrayList<Long> ls)\n    {\n        Collections.sort(ls);\n        if(n==1)\n            return ls.get(0);\n\n        long sum = ls.get(0);\n        long val = 0;\n        long max = ls.get(0);\n        for(int i=1;i<n;i++)\n        {\n            val = ls.get(i) - sum;\n            max = Math.max(max, val);\n            sum += val;\n        }\n        return max;\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/THE END\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    public static int gcd(int x,int y)\n    {\n        return y==0?x:gcd(y,x%y);\n    }\n    public static long gcd(long x,long y)\n    {\n        return y==0L?x:gcd(y,x%y);\n    }\n\n    public static int lcm(int a, int b) {\n        return (a * b) \/ gcd(a, b);\n    }\n    public static long lcm(long a, long b) {\n        return (a * b) \/ gcd(a, b);\n    }\n\n    public static long pow(long a,long b)\n    {\n        if(b==0L)\n            return 1L;\n        long tmp=1;\n        while(b>1L)\n        {\n            if((b&1L)==1)\n                tmp*=a;\n            a*=a;\n            b>>=1;\n        }\n        return (tmp*a);\n    }\n\n    public static long modPow(long a,long b,long mod)\n    {\n        if(b==0L)\n            return 1L;\n        long tmp=1;\n        while(b>1L)\n        {\n            if((b&1L)==1L)\n                tmp*=a;\n\n            a*=a;\n            a%=mod;\n            tmp%=mod;\n            b>>=1;\n        }\n        return (tmp*a)%mod;\n    }\n\n    static long mul(long a, long b) {\n        return a*b%mod;\n    }\n\n    static long fact(int n) {\n        long ans=1;\n        for (int i=2; i<=n; i++) ans=mul(ans, i);\n        return ans;\n    }\n\n    static long fastPow(long base, long exp) {\n        if (exp==0) return 1;\n        long half=fastPow(base, exp\/2);\n        if (exp%2==0) return mul(half, half);\n        return mul(half, mul(half, base));\n    }\n\n    static void debug(int ...a)\n    {\n        for(int x: a)\n            out.print(x+\" \");\n        out.println();\n    }\n\n    static void debug(long ...a)\n    {\n        for(long x: a)\n            out.print(x+\" \");\n        out.println();\n    }\n\n    static void debugMatrix(int[][] a)\n    {\n        for(int[] x:a)\n            out.println(Arrays.toString(x));\n    }\n    static void debugMatrix(long[][] a)\n    {\n        for(long[] x:a)\n            out.println(Arrays.toString(x));\n    }\n\n    static void reverseArray(int[] a) {\n        int n = a.length;\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = a[n - i - 1];\n        for (int i = 0; i < n; i++)\n            a[i] = arr[i];\n    }\n\n    static void reverseArray(long[] a) {\n        int n = a.length;\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = a[n - i - 1];\n        for (int i = 0; i < n; i++)\n            a[i] = arr[i];\n    }\n\n    static void sort(int[] a)\n    {\n        ArrayList<Integer> ls = new ArrayList<>();\n        for(int x: a) ls.add(x);\n        Collections.sort(ls);\n        for(int i=0;i<a.length;i++)\n            a[i] = ls.get(i);\n    }\n\n    static class Pair{\n        int x, y;\n        Pair(int x, int y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return \"Pair{\" +\n                    \"x=\" + x +\n                    \", y=\" + y +\n                    '}';\n        }\n    }\n    static class MyCmp implements Comparator<Pair>\n    {\n        public int compare(Pair p1, Pair p2)\n        {\n            return p1.x-p2.x;\n        }\n    }\n}\n","# cook your dish here\nimport sys\nimport math\nimport random\nimport heapq\n#sys.setrecursionlimit(10**6)\ninput=sys.stdin.readline\ndef pow(a,n):\n    if n==0:\n        return 1 \n    x=pow(a,n\/\/2)\n    if n%2==0 :\n        return (x*x)\n    else:\n        return (x*x*a)\n \ndef gcd(a,b):\n    while b!=0:\n        a,b=b,a%b\n    return a \n    \ndef bs(arr,le,ri):\n    l=0\n    arr.sort()\n    r=len(arr)-1\n    ans=10000000\n    while l<=r:\n        m=(l+r)\/\/2\n        if arr[m]>=le and arr[m]<=ri:\n            ans=arr[m]\n            r=m-1\n        elif arr[m]<le:\n            l=m+1 \n        else:\n            r=m-1\n    return ans\n \nt=int(input())\n# t=1\nwhile t>0:\n    n=int(input())\n    l=list(map(int,input().split()))\n    l.sort()\n    ans=l[0]\n    s=l[0]\n    for i in l[1:]:\n        ans=max(ans,i-s)\n        s=i\n    print(ans)\n    t-=1\n","import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n    public class Main {\n\n        \/\/ -- static variables --- \/\/\n        static FastReader sc = new FastReader();\n        static PrintWriter out = new PrintWriter(System.out);\n        static int mod = (int) 1000000007;\n        public static void main(String[] args) throws Exception {\n         \n            int t=sc.nextInt();\n            while(t-->0)\n            Main.go();\n            \/\/ out.println();\n            out.flush();\n        }\n\n        \/\/ >>>>>>>>>>>>>>>>>>> Code Starts <<<<<<<<<<<<<<<<<<<< \/\/\n        static class pair{\n            int x,y;\n            pair(int x,int y){\n                this.x=x;\n                this.y=y;\n            }\n        }\n\n\n        static void go() throws Exception {\n        \tint n=sc.nextInt();\n        \tlong a[]=sc.longArray(n);\n        \tif(n==1) {\n        \t\tout.println(a[0]);\n        \t}else {\n        \t\tsort(a);\n        \t\tlong sum=a[0];\n        \t\tlong max=a[0];\n        \t\tfor(int i=1;i<n;i++) {\n        \t\t\ta[i]-=sum;\n        \t\t\tmax=Math.max(max,a[i]);\n        \t\t\tsum+=a[i];\n        \t\t}\n        \t\tout.println(max);\n        \t}\n        }\n        \n        static long lcm(long a,long b) {\n        \treturn a*b\/gcd(a,b);\n        }\n     \n    \n        \/\/ >>>>>>>>>>> Code Ends <<<<<<<<< \/\/\n\n        \/\/ --For Rounding--\/\/\n        static double round(double value, int places) {\n\n            if (places < 0)\n                throw new IllegalArgumentException();\n            BigDecimal bd = new BigDecimal(Double.toString(value));\n            bd = bd.setScale(places, RoundingMode.HALF_UP);\n            return bd.doubleValue();\n        }\n\n        \/\/ ----Greatest Common Divisor-----\/\/\n        static long gcd(long a, long b) {\n            if (b == 0) {\n                return a;\n            }\n            return gcd(b, a % b);\n        }\n\n        \/\/ --- permutations and Combinations ---\/\/\n        static long fact[];\n        static long invfact[];\n\n        static long ncr(int n, int k) {\n            if (k < 0 || k > n) {\n                return 0;\n            }\n            long x = fact[n];\n            long y = fact[k];\n            long yy = fact[n - k];\n            long ans = (x \/ y);\n            ans = (ans \/ yy);\n            return ans;\n        }\n\n        \/\/ ---sieve---\/\/\n        static int prime[] = new int[1000006];\n\n        \/\/ static void sieve() {\n        \/\/     Arrays.fill(prime, 1);\n        \/\/     prime[0] = 0;\n        \/\/     prime[1] = 0;\n        \/\/     for (int i = 2; i * i <= 1000005; i++) {\n        \/\/         if (prime[i] == 1)\n        \/\/             for (int j = i * i; j <= 1000005; j += i) {\n        \/\/                 prime[j] = 0;\n        \/\/             }\n        \/\/     }\n        \/\/ }\n\n        \/\/ ---- Manual sort ------\/\/\n        static void sort(long[] a) {\n            ArrayList<Long> aa = new ArrayList<>();\n            for (long i : a) {\n                aa.add(i);\n            }\n            Collections.sort(aa);\n            for (int i = 0; i < a.length; i++)\n                a[i] = aa.get(i);\n        }\n\n        static void sort(int[] a) {\n            ArrayList<Integer> aa = new ArrayList<>();\n            for (int i : a) {\n                aa.add(i);\n            }\n            Collections.sort(aa);\n            for (int i = 0; i < a.length; i++)\n                a[i] = aa.get(i);\n        }\n\n        \/\/ --- Fast exponentiation ---\/\/\n        static long pow(long x, long y) {\n            long res = 1l;\n            while (y != 0) {\n                if (y % 2 == 1) {\n                    res = (x * res);\n                }\n                y \/= 2;\n                x = (x * x);\n            }\n            return res;\n        }\n\n        \/\/ >>>>>>>>>>>>>>> Fast IO <<<<<<<<<<<<<< \/\/\n        static class FastReader {\n            BufferedReader br;\n            StringTokenizer st;\n\n            public FastReader() {\n                br = new BufferedReader(new InputStreamReader(System.in));\n            }\n\n            String next() {\n                while (st == null || !st.hasMoreElements()) {\n                    try {\n                        st = new StringTokenizer(br.readLine());\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                return st.nextToken();\n            }\n\n            int nextInt() {\n                return Integer.parseInt(next());\n            }\n\n            long nextLong() {\n                return Long.parseLong(next());\n            }\n\n            double nextDouble() {\n                return Double.parseDouble(next());\n            }\n\n            int[] intArray(int n) {\n                int a[] = new int[n];\n                for (int i = 0; i < n; i++)\n                    a[i] = sc.nextInt();\n                return a;\n            }\n\n            long[] longArray(int n) {\n                long a[] = new long[n];\n                for (int i = 0; i < n; i++)\n                    a[i] = sc.nextLong();\n                return a;\n            }\n\n            String nextLine() {\n                String str = \"\";\n                try {\n                    str = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                return str;\n            }\n        }\n    }","import sys\n# import pdb\n# inp = open(\"input.txt\")\ninp = sys.stdin\ncount = int(inp.readline())\narr_length = []\nlines = []\n\nfor i in range(count):\n    arr_length.append(int(inp.readline()))\n    lines.append(inp.readline().split())\ninp.close()\n# outp = open(\"output.txt\", \"w\")\noutp = sys.stdout\n# pdb.set_trace()\nfor j in range(count):\n    line = lines[j]\n    al, arr = arr_length[j], lines[j]\n    arr = [int(el) for el in arr]\n    arr.sort()\n    cur_add = 0\n    max_i = 0\n    max_val = arr[0]\n    if al > 1:\n        for i in range(al-1):\n            cur_range = -arr[i]\n            cur_add += cur_range\n            if (arr[i+1] + cur_range > max_val):\n                max_val = arr[i+1] + cur_range\n                max_i += 1\n    outp.write(str(max_val))\n    if (j != count - 1):\n        outp.write('\\n')\noutp.close()","import java.util.*;\n \nimport java.io.BufferedWriter;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\n \npublic class C {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter writer = new PrintWriter(System.out);\n\n\t\tint t = sc.nextInt();\n\t\tfor (; t > 0; t--) {\n\t\t\tint n = sc.nextInt();\n\t\t\tList<Integer> a = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta.add(sc.nextInt());\n\t\t\t}\n\n\t\t\tCollections.sort(a);\n\t\t\tint sum = 0;\n\n\t\t\tint maxMin = a.get(0);\n\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tint d = a.get(i) - sum;\n\t\t\t\tmaxMin = Math.max(maxMin, d);\n\t\t\t\tsum += d;\n\t\t\t}\n\n\t\t\twriter.println(Math.max(a.get(n-1) - sum, maxMin));\n\t\t}\n\n\t\twriter.close();\n\t\tsc.close();\n\t}\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a, a + n);\n    int r = a[0], h = a[0];\n    for (int i = 1; i < n; i++) {\n      h = max(h, a[i] - r);\n      r += a[i] - r;\n    }\n    cout << h << endl;\n  }\n}\n","import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\/\/\tstatic boolean[] prime = new boolean[10000000];\n\tfinal static long mod = 1000000007;\n\n\tpublic static void main(String[] args) {\n\/\/\t\tsieve();\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint t = in.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tint n = in.nextInt();\n\t\t\tInteger[] a = intInput(n, in);\n\t\t\tif(n == 1) {\n\t\t\t\tout.println(a[0]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\tint ans = a[0];\n\t\t\tfor(int i = 1; i < n; i++) {\n\t\t\t\tans = Math.max(a[i] - a[i-1], ans);\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tout.flush();\n\t}\n\t\n\tstatic long gcd(long a, long b) {\n\t\tif (a % b == 0) {\n\t\t\treturn b;\n\t\t} else {\n\t\t\treturn gcd(b, a % b);\n\t\t}\n\t}\n\n\tstatic void reverseArray(int[] a) {\n\t\tfor (int i = 0; i < (a.length >> 1); i++) {\n\t\t\tint temp = a[i];\n\t\t\ta[i] = a[a.length - 1 - i];\n\t\t\ta[a.length - 1 - i] = temp;\n\t\t}\n\t}\n\n\tstatic Integer[] intInput(int n, InputReader in) {\n\t\tInteger[] a = new Integer[n];\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = in.nextInt();\n\t\treturn a;\n\t}\n\n\tstatic Long[] longInput(int n, InputReader in) {\n\t\tLong[] a = new Long[n];\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = in.nextLong();\n\t\treturn a;\n\t}\n\n\tstatic String[] strInput(int n, InputReader in) {\n\t\tString[] a = new String[n];\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = in.next();\n\t\treturn a;\n\t}\n\n\/\/\tstatic void sieve() {\n\/\/\t\tfor (int i = 2; i * i < prime.length; i++) {\n\/\/\t\t\tif (prime[i])\n\/\/\t\t\t\tcontinue;\t\n\/\/\t\t\tfor (int j = i * i; j < prime.length; j += i) {\n\/\/\t\t\t\tprime[j] = true;\n\/\/\t\t\t}\n\/\/\t\t}\n\/\/\t}\n\n}\n\nclass Data {\n\tint val;\n\tint ind;\n\tint i;\n\n\tData(int val, int ind, int i) {\n\t\tthis.val = Math.abs(val);\n\t\tthis.ind = ind;\n\t\tthis.i = i;\n\t}\n}\n\nclass compareVal implements Comparator<Data> {\n\n\t@Override\n\tpublic int compare(Data o1, Data o2) {\n\/\/\t\treturn (o1.val - o2.val == 0 ? o1.ind - o2.ind : o1.val - o2.val);\n\t\treturn (o1.i - o2.i);\n\t}\n\n}\n\nclass compareInd implements Comparator<Data> {\n\n\t@Override\n\tpublic int compare(Data o1, Data o2) {\n\t\treturn o1.ind - o2.ind == 0 ? o1.val - o2.val : o1.ind - o2.ind;\n\t}\n\n}\n\nclass InputReader {\n\tpublic BufferedReader reader;\n\tpublic StringTokenizer tokenizer;\n\n\tpublic InputReader(InputStream stream) {\n\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\ttokenizer = null;\n\t}\n\n\tpublic String next() {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tString nextLine() {\n\t\tString str = \"\";\n\t\ttry {\n\t\t\tstr = reader.readLine();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn str;\n\t}\n\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int tc;\n  cin >> tc;\n  while (tc--) {\n    int n;\n    cin >> n;\n    long long arr[n];\n    for (long long &x : arr) cin >> x;\n    sort(arr, arr + n);\n    long long maximal_min = arr[0], decr = arr[0];\n    for (int i = 1; i < n; i++) {\n      arr[i] -= decr;\n      maximal_min = max(maximal_min, max({arr[i - 1], arr[i]}));\n      decr += arr[i];\n    }\n    cout << maximal_min << '\\n';\n  }\n}\n","import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\ndef main(t):\n\n\n    n = int(input())\n    arr = list(map(int,input().split()))\n    arr.sort()\n\n    ans = arr[0]\n\n   \n    if n>1:  ans = max(ans,  max([arr[i+1]-arr[i] for i in range(n-1)]))\n    print(ans)\n\n\n        \n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT = int(input())\nt = 1\nwhile t<=T:\n    main(t)\n    t += 1\n","import heapq\nfor step in range(int(input())):\n  n = int(input())\n  heap = list(map(int,input().split()))\n  heapq.heapify(heap)\n  ans = -1e9-1\n  res = 0\n  for i in range(n):\n    m = heapq.heappop(heap)\n    ans = max(m-res,ans)\n    res = m\n  print(ans)","import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static PrintWriter pw;\n    static Scanner sc;\n    static long ceildiv(long x, long y) { return (x+y-1) \/ y; }\n    static int mod(long x, int m) { return (int) ((x%m + m) % m); }\n    static void put(Map<Integer, Integer> map, Integer p){if(map.containsKey(p)) map.replace(p, map.get(p)+1); else map.put(p, 1); }\n    static void rem(Map<Integer, Integer> map, Integer p){ if(map.get(p)==1) map.remove(p); else map.replace(p, map.get(p)-1); }\n    static int Int(boolean x){ return x ? 1 : 0; }\n    static final int inf=(int)1e9, mod= inf + 7;\n    static final long infL=inf*1l*inf;\n    static final double eps=1e-9;\n    public static long gcd(long x, long y) { return y==0? x: gcd(y, x%y); }\n    public static void main(String[] args) throws Exception {\n        sc = new Scanner(System.in);\n        pw = new PrintWriter(System.out);\n        int t = sc.nextInt();\n        while (t-- > 0)\n            testCase();\n        pw.close();\n    }\n\n    static void testCase() throws Exception{\n        int n = sc.nextInt();\n        Integer[] arr = sc.nextsort(n);\n        Arrays.sort(arr);\n        int max = Integer.MIN_VALUE;\n        int prev = 0;\n        for (int i = 0; i < n; i++) {\n            max = Math.max(max, arr[i] - prev);\n            prev = arr[i];\n        }\n        pw.println(max);\n    }\n\n\n    static void printArr(int[] arr) {\n        for (int i = 0; i < arr.length; i++)\n            pw.print(arr[i] + \" \");\n        pw.println();\n    }\n\n    static void printArr(long[] arr) {\n        for (int i = 0; i < arr.length; i++)\n            pw.print(arr[i] + \" \");\n        pw.println();\n    }\n\n    static void printArr(double[] arr) {\n        for (int i = 0; i < arr.length; i++)\n            pw.print(arr[i] + \" \");\n        pw.println();\n    }\n\n    static void printArr(Integer[] arr) {\n        for (int i = 0; i < arr.length; i++)\n            pw.print(arr[i] + \" \");\n        pw.println();\n    }\n\n    static void printIter(Iterable list) {\n        for (Object o : list)\n            pw.print(o + \" \");\n        pw.println();\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextDigits() throws IOException {\n            String s = nextLine();\n            int[] arr = new int[s.length()];\n            for (int i = 0; i < arr.length; i++)\n                arr[i] = s.charAt(i) - '0';\n            return arr;\n        }\n\n        public int[] nextArr(int n) throws IOException {\n            int[] arr = new int[n];\n            for (int i = 0; i < arr.length; i++)\n                arr[i] = nextInt();\n            return arr;\n        }\n\n        public Integer[] nextsort(int n) throws IOException {\n            Integer[] arr = new Integer[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextInt();\n            return arr;\n        }\n\n        public Pair nextPair() throws IOException {\n            return new Pair(nextInt(), nextInt());\n        }\n\n        public long[] nextLongArr(int n) throws IOException {\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextLong();\n            return arr;\n        }\n\n        public Pair[] nextPairArr(int n) throws IOException {\n            Pair[] arr = new Pair[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextPair();\n            return arr;\n        }\n\n        public boolean hasNext() throws IOException {\n            return (st != null && st.hasMoreTokens()) || br.ready();\n        }\n    }\n\n    static class Pair implements Comparable<Pair> {\n        int x;\n        int y;\n\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public Pair(Map.Entry<Integer, Integer> a) {\n            x = a.getKey();\n            y = a.getValue();\n        }\n\n        public int hashCode() {\n            return (int) ((this.x*1l*100003 + this.y) % mod);\n        }\n\n        public int compareTo(Pair p) {\n            if(x != p.x)\n                return x - p.x;\n            return y - p.y;\n        }\n\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (this.getClass() != obj.getClass()) {\n                return false;\n            }\n            Pair p = (Pair) obj;\n            return this.x == p.x && this.y == p.y;\n        }\n\n        public Pair clone() {\n            return new Pair(x, y);\n        }\n\n        public String toString() {\n            return this.x + \" \" + this.y;\n        }\n\n        public void subtract(Pair p) {\n            x -= p.x;\n            y -= p.y;\n        }\n\n        public void add(Pair p) {\n            x += p.x;\n            y += p.y;\n        }\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> a(n, 0);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    long long ans = a[0];\n    long long b = 0;\n    long long bans = ans;\n    for (int i = 0; i < n - 1; i++) {\n      a[i + 1] -= b;\n      b += a[i];\n      a[i + 1] -= a[i];\n      ans = a[i + 1];\n      bans = max(bans, ans);\n    }\n    cout << bans << endl;\n  }\n}\n","import java.io.*;\nimport java.util.*;\n\npublic class PROBC {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\/\/BufferedReader br = new BufferedReader(new FileReader(\"src\/input.txt\"));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\n\t\tint t = Integer.parseInt(st.nextToken());\n\t\tfor (int i = 0; i < t; i++)\n\t\t{\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint n = Integer.parseInt(st.nextToken());\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tArrayList<Integer> l = new ArrayList<Integer>();\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tl.add(Integer.parseInt(st.nextToken()));\n\t\t\t}\n\t\t\tl.sort(null);\n\t\t\tint best = l.get(0);\n\t\t\tfor (int j = 1; j < l.size(); j++)\n\t\t\t{\n\t\t\t\tbest = Math.max(best, l.get(j)-l.get(j-1));\n\t\t\t}\n\t\t\tSystem.out.println(best);\n\t\t}\n\t}\n}","import java.util.*;\nimport java.io.*;\npublic class Main{\n   public static void main(String[] args) throws IOException{\n      BufferedReader f= new BufferedReader(new InputStreamReader(System.in));\n      StringTokenizer s=new StringTokenizer(f.readLine());\n      int t=Integer.parseInt(s.nextToken());\n      for(int i=0;i<2*t;i+=2){\n         ArrayList<Integer> arr=new ArrayList<Integer>();\n         s=new StringTokenizer(f.readLine());\n         int n=Integer.parseInt(s.nextToken());\n         s=new StringTokenizer(f.readLine());\n         for(int k=0;k<n;k++){\n            arr.add(Integer.parseInt(s.nextToken()));\n         }\n         Collections.sort(arr);\n         int max=arr.get(0);\n         for(int k=1;k<arr.size();k++){\n            max=Math.max(max,arr.get(k)-arr.get(k-1));\n         }\n         System.out.println(max);\n      }\n   }\n}","import sys\ninput = sys.stdin.readline\n\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(map(int,input().split()))\n\ndef minimumExtraction():\n    n = inp()\n    a = sorted(inlt())\n    diff = 0\n    ret = a[0]\n    for i in range(len(a)):\n        ret = max(ret, a[i] - diff)\n        diff += a[i] - diff\n    print(ret)\n    return\n\n\nif __name__ == '__main__':\n    t = inp()\n    for i in range(t):\n        minimumExtraction()\n","import sys\ninput = lambda: sys.stdin.readline().rstrip()\nsys.setrecursionlimit(10**5)\nINF = 10**18\n\nimport heapq  # heapq\u30e9\u30a4\u30d6\u30e9\u30ea\u306eimport\ndef solve():\n    N = int(input())\n    A = list(map(int,input().split()))\n    if N == 1:\n        print(A[0])\n        return\n\n    heapq.heapify(A)\n    cnt = 1\n    ans = heapq.heappop(A)\n    add = ans\n    while cnt < N:\n        n = heapq.heappop(A)\n        cnt += 1\n        ans = max(ans, n-add)\n        add += n-add\n        # print(n,add,ans)\n    \n    print(ans)\n\nQ = int(input())\nfor _ in range(Q):\n    solve()\n\n","import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n    static long mod = (int)1e9+7;\n    public static void main (String[] args) throws java.lang.Exception\n    {\n        FastReader sc =new FastReader();\n\n        int t=sc.nextInt();\n   \n    \/\/   int t=1;\n   \n        while(t-->0)\n        {\n            int n=sc.nextInt();\n            int a[]=sc.readArray(n);\n            if(n==1)\n            {\n                System.out.println(a[0]);\n                continue;\n            }\n            radixSort2(a);\n            int sub=a[0];\n            int max=a[0];\n            for(int i=1;i<n;i++)\n            {\n                max=Math.max(max,a[i]-sub);\n                sub+=(a[i]-sub);\n            }\n            System.out.println(max);\n        }\n    }\n\nstatic int findfrequencies(int a[],int n)\n{\n    int count=0;\n    for(int i=0;i<a.length;i++)\n    {\n        if(a[i]==n)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nstatic class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(\n                new InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() { return Integer.parseInt(next()); }\n \n        long nextLong() { return Long.parseLong(next()); }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n       \n        float nextFloat()\n        {\n            return Float.parseFloat(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n       \n        int[] readArray(int n) {\nint[] a=new int[n];\nfor (int i=0; i<n; i++) a[i]=nextInt();\nreturn a;\n}\n\nlong[] readArrayLong(int n) {\nlong[] a=new long[n];\nfor (int i=0; i<n; i++) a[i]=nextLong();\nreturn a;\n}\n\n    }\n   \n    public static int[] radixSort2(int[] a)\n{\nint n = a.length;\nint[] c0 = new int[0x101];\nint[] c1 = new int[0x101];\nint[] c2 = new int[0x101];\nint[] c3 = new int[0x101];\nfor(int v : a) {\nc0[(v&0xff)+1]++;\nc1[(v>>>8&0xff)+1]++;\nc2[(v>>>16&0xff)+1]++;\nc3[(v>>>24^0x80)+1]++;\n}\nfor(int i = 0;i < 0xff;i++) {\nc0[i+1] += c0[i];\nc1[i+1] += c1[i];\nc2[i+1] += c2[i];\nc3[i+1] += c3[i];\n}\nint[] t = new int[n];\nfor(int v : a)t[c0[v&0xff]++] = v;\nfor(int v : t)a[c1[v>>>8&0xff]++] = v;\nfor(int v : a)t[c2[v>>>16&0xff]++] = v;\nfor(int v : t)a[c3[v>>>24^0x80]++] = v;\nreturn a;\n}\n\nstatic int[] EvenOddArragement(int a[])\n{\n    ArrayList<Integer> list=new ArrayList<>();\n    for(int i=0;i<a.length;i++)\n    {\n        if(a[i]%2==0)\n        {\n            list.add(a[i]);\n        }\n    }\n    for(int i=0;i<a.length;i++)\n    {\n        if(a[i]%2!=0)\n        {\n            list.add(a[i]);\n        }\n    }\n    for(int i=0;i<a.length;i++)\n    {\n        a[i]=list.get(i);\n    }\n    return a;\n}\nstatic int gcd(int a, int b) {\n    while (b != 0) {\n        int t = a;\n        a = b;\n        b = t % b;\n    }\n    return a;\n}\n   \n    public static HashMap<Integer, Integer> sortByValue(HashMap<Integer, Integer> hm)\n    {\n        \/\/ Create a list from elements of HashMap\n        List<Map.Entry<Integer, Integer> > list =\n               new LinkedList<Map.Entry<Integer, Integer> >(hm.entrySet());\n \n        \/\/ Sort the list\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer> >() {\n            public int compare(Map.Entry<Integer, Integer> o1,\n                               Map.Entry<Integer, Integer> o2)\n            {\n                return (o1.getValue()).compareTo(o2.getValue());\n            }\n        });\n         \n        \/\/ put data from sorted list to hashmap\n        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();\n        for (Map.Entry<Integer, Integer> aa : list) {\n            temp.put(aa.getKey(), aa.getValue());\n        }\n        return temp;\n    }\n    static int DigitSum(int n)\n    {\n        int r=0,sum=0;\n        while(n>=0)\n        {\n            r=n%10;\n            sum=sum+r;\n            n=n\/10;\n        }\n        return sum;\n    }\n}","for _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    if(n==1):\n        print(a[0])\n        continue\n    else:\n        a.sort()\n        s=a[0]\n        for i in range(1,n):\n            a[i]-=s\n            s+=a[i]\n        print(max(a))","import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic long[]fac=new long[200100];\n\tstatic long[] two= new long[200100] ;\n\tstatic long mod=((long)1e18)+7;\n\tstatic String[]pow=new String[63];\n\tstatic int n;\n\tstatic int x=0;\n\tstatic int[][]perm,b;\n\tstatic int[]pe,aa,a;\n\tpublic static void main(String[] args) throws IOException, InterruptedException{\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tint n=sc.nextInt();\n\t\t\tLong[]a=new Long[n];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextLong();\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\tlong ans=a[0];\n\t\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\t\tans=Math.max(ans, a[i]-a[i-1]);\n\t\t\t}\n\t\t\tpw.println(ans);\n\t\t}\n\t\t\n\t\tpw.close();\n\t}\t\n\t\n\tpublic static long[] Extended(long p, long q) {\n\t      if (q == 0)\n\t         return new long[] { p, 1, 0 };\n\n\t      long[] vals = Extended(q, p % q);\n\t      long d = vals[0];\n\t      long a = vals[2];\n\t      long b = vals[1] - (p \/ q) * vals[2];\n\t      return new long[] { d, a, b };\n\t   }\n\t\n\tstatic class STree{\n\t\tint N;\n\t\tlong[]arr;\n\t\tlong[]tree;\n\t\tint[]lazy;\n\t\tlong id;\n\t\tpublic static long operation(long x,long y) {\n\t\t\treturn x^y;\n\t\t}\n\t\t\n\t\tpublic STree(int[]a,long id) {\n\t\t\tthis.id=id;\n\t\t\tN=1;\n\t\t\tint n=a.length;\n\t\t\twhile(N<n) {\n\t\t\t\tN*=2;\n\t\t\t}\n\t\t\tarr=new long[N+1];\n\t\t\tArrays.fill(arr, id);\n\t\t\tfor (int i = 1; i <= a.length; i++) {\n\t\t\t\tarr[i]=a[i-1];\n\t\t\t}\n\t\t\ttree=new long[2*N];\n\t\t\tArrays.fill(tree, id);\n\t\t\tbuild(1,N,1);\n\t\t\tlazy=new int[2*N];\n\t\t}\n\t\t\n\t\tpublic void build(int l,int r,int node) {\n\t\t\tif(l==r) {\n\t\t\t\ttree[node]=arr[l];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mid=(l+r)\/2;\n\t\t\tbuild(l,mid,node*2);\n\t\t\tbuild(mid+1,r,node*2+1);\n\t\t\ttree[node]=operation(tree[node*2],tree[node*2+1]);\n\t\t}\n\t\t\n\/\/\t\tpublic void update(int node,int value) {\n\/\/\t\t\tint i=node+N-1;\n\/\/\t\t\ttree[i]=value;\n\/\/\t\t\ti\/=2;\n\/\/\t\t\twhile(i>0) {\n\/\/\t\t\t\ttree[i]=operation(tree[i*2], tree[i*2+1]);\n\/\/\t\t\t\ti\/=2;\n\/\/\t\t\t}\n\/\/\t\t}\n\/\/\t\t\n\/\/\t\tpublic void updateRange(int l,int r,int v) {\n\/\/\t\t\tupdateRange(1, N, l, r, 1,v);\n\/\/\t\t}\n\/\/\t\t\n\/\/\t\tpublic void updateRange(int s,int e,int l,int r,int node,int v) {\n\/\/\t\t\tif(s>=l&&e<=r) {\n\/\/\t\t\t\tlazy[node]^=v;\n\/\/\t\t\t\ttree[node]=propagate(tree[node],lazy[node],e-s+1);\n\/\/\/\/\t\t\t\tlazy[node]=0;\n\/\/\t\t\t\treturn;\n\/\/\t\t\t}\n\/\/\t\t\tif(s>r||e<l)return;\n\/\/\t\t\tint mid=(s+e)\/2;\n\/\/\t\t\tlazy[node*2] ^= lazy[node];\n\/\/\t\t\tlazy[node*2+1] ^= lazy[node];\n\/\/\t\t\ttree[node*2] = propagate(tree[node*2], v, (e-s+1)\/2);\n\/\/\t\t\ttree[node*2+1] =  propagate(tree[node*2+1], v, (e-s+1)\/2);\n\/\/\t\t\tlazy[node] = 0;\n\/\/\t\t\tupdateRange(s, mid, l, r, node*2, v);\n\/\/\t\t\tupdateRange(mid+1, e, l, r, node*2+1, v);\n\/\/\t\t\ttree[node]=operation(tree[node*2], tree[node*2+1]);\n\/\/\t\t\treturn;\n\/\/\t\t}\n\/\/\t\t\n\t\tpublic long q(int l,int r) {\n\t\t\treturn q(1,N,l,r,1);\n\t\t}\n\t\t\n\t\tpublic long q(int s,int e,int l,int r,int node) {\n\t\t\tif(s>=l&&r>=e) {\n\t\t\t\treturn tree[node];\n\t\t\t}\n\t\t\tif(s>r||e<l)\n\t\t\t\treturn id;\n\t\t\tint mid=(s+e)\/2;\n\t\t\t\n\t\t\treturn operation(q(s,mid,l,r,node*2), q(mid+1,e,l,r,node*2+1));\n\t\t}\n\/\/\t\tpublic static segment propagate(segment x,int v,int length) {\n\/\/\t\t\tint[]bit=x.bit.clone();\n\/\/\t\t\tlong sum=x.sum;\n\/\/\t\t\tfor (int i = 0; i < bit.length; i++) {\n\/\/\t\t\t\tif((v&1<<i)!=0) {\n\/\/\t\t\t\t\tsum-=(1<<i)*(bit[i]);\n\/\/\t\t\t\t\tsum+=(1<<i)*(length-bit[i]);\n\/\/\t\t\t\t\tbit[i]=length-bit[i];\n\/\/\t\t\t\t}\n\/\/\t\t\t}\n\/\/\t\t\treturn new segment(sum, bit);\n\/\/\t\t}\n\t}\n\n\tpublic static class segment{\n\t\tlong sum;\n\t\tint[] bit;\n\t\t\n\t\tpublic segment (long sum,int[]bit) {\n\t\t\tthis.sum=sum;\n\t\t\tthis.bit=bit.clone();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn sum+\" \"+Arrays.toString(bit);\n\t\t}\n\t}\n\t\n\tpublic static int LIS(int[] a) {\n\n\t\tint n = a.length;\n\t\tint[] ser = new int[n];\n\t\tint[]ser1=new int[n];\n\t\tArrays.fill(ser1, Integer.MAX_VALUE);\n\t\tArrays.fill(ser, Integer.MAX_VALUE);\n\t\tint cur = -1;\n\t\tint[]inc=new int[n];\n\t\tint[]dec=new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint low = 0;\n\t\t\tint high = n - 1;\n\t\t\tint mid = (low + high) \/ 2;\n\t\t\twhile (low <= high) {\n\t\t\t\tif (ser[mid] < a[i]) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}\n\t\t\t\tmid = (low + high) \/ 2;\n\t\t\t}\n\t\t\tinc[i]=high+2;\n\t\t\tcur = Math.max(cur, high + 1);\n\t\t\tser[high + 1] = Math.min(ser[high + 1], a[i]);\n\t\t}\n\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\tint low = 0;\n\t\t\tint high = n - 1;\n\t\t\tint mid = (low + high) \/ 2;\n\t\t\twhile (low <= high) {\n\t\t\t\tif (ser1[mid] < a[i]) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}\n\t\t\t\tmid = (low + high) \/ 2;\n\t\t\t}\n\t\t\tdec[i]=high+2;\n\t\t\tcur = Math.max(cur, high + 1);\n\t\t\tser1[high + 1] = Math.min(ser1[high + 1], a[i]);\n\t\t}\n\t\tint ans=1;\n\t\tfor (int i = 0; i < dec.length; i++) {\n\t\t\tans=Math.max(ans, 2*Math.min(inc[i], dec[i])-1);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tpublic static void permutation(int idx,int v) {\n\t\tif(v==(1<<n)-1) {\n\t\t\tperm[x++]=pe.clone();\n\t\t\treturn ;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif((v&1<<i)==0) {\n\t\t\t\tpe[idx]=aa[i];\n\t\t\t\tpermutation(idx+1, v|1<<i);\n\t\t\t}\n\t\t}\n\t\treturn ;\n\t}\n\t\n\tpublic static void pre2() {\n\t\tfor (int i = 0; i < pow.length; i++) {\n\t\t\tlong x=1l<<i;\n\t\t\tpow[i]=x+\"\";\n\t\t}\n\t}\n\t\t\n\tpublic static void sort(int[]a) {\n\t\tmergesort(a, 0, a.length-1);\n\t}\n\t\n\tpublic static void sortIdx(long[]a,long[]idx) {\n\t\tmergesortidx(a, idx, 0, a.length-1);\n\t}\n\t\n\tpublic static long C(int a,int b) {\n\t\tlong x=fac[a];\n\t\tlong y=fac[a-b]*fac[b];\n\t\treturn x*pow(y,mod-2)%mod;\n\t}\n\t\n\tpublic static long pow(long a,long b) {\n\t\tlong ans=1;a%=mod;\n\t\tfor(long i=b;i>0;i\/=2) {\n\t\t\tif((i&1)!=0)\n\t\t\t\tans=ans*a%mod;\n\t\t\ta=a*a%mod;\n\t\t }    \n\t\t    \n\t\t return ans;\n\t}\n\t\n\tpublic static void pre(){\n\t\tfac[0]=1;\n\t\tfac[1]=1;\n\t\tfac[2]=1;\n\t\tfor (int i = 3; i < fac.length; i++) {\n\t\t\tfac[i]=((fac[i-1]*2*i)\/2)%mod;\n\t\t}\n\t}\n\t\n\tpublic static long eval(String s) {\n\t\tlong p=1;\n\t\tlong res=0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tres+=p*(s.charAt(s.length()-1-i)=='1'?1:0);\n\t\t\tp*=2;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static String binary(long x) {\n\t\tString s=\"\";\n\t\twhile(x!=0) {\n\t\t\ts=(x%2)+s;\n\t\t\tx\/=2;\n\t\t}\n\t\treturn s;\n\t}\n\t\n\tpublic static boolean allSame(String s) {\n\t\tchar x=s.charAt(0);\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif(s.charAt(i)!=x)return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isPalindrom(String s) {\n\t\tint l=0;\n\t\tint r=s.length()-1;\n\t\twhile(l<r) {\n\t\t\tif(s.charAt(r--)!=s.charAt(l++))return false;\n\t\t\t\n\t\t}\n\t\treturn true;\n\t}\n\t \n\t\n\tpublic static boolean isSubString(String s,String t) {\n\t\tint ls=s.length();\n\t\tint lt=t.length();\n\t\tboolean res=false;\n\t\tfor (int i = 0; i <=lt-ls; i++) {\n\t\t\tif(t.substring(i, i+ls).equals(s)) {\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static boolean isSorted(long[]a) {\n\t\tfor (int i = 0; i < a.length-1; i++) {\n\t\t\tif(a[i]>a[i+1])return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isPrime(long n)\n    {\n \n        \/\/ Check if number is less than\n        \/\/ equal to 1\n        if (n <= 1)\n            return false;\n \n        \/\/ Check if number is 2\n        else if (n == 2)\n            return true;\n \n        \/\/ Check if n is a multiple of 2\n        else if (n % 2 == 0)\n            return false;\n \n        \/\/ If not, then just check the odds\n        for (int i = 3; i <= Math.sqrt(n); i += 2)\n        {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\tpublic static int whichPower(int x) {\n\t\tint res=0;\n\t\tfor (int j = 0; j < 31; j++) {\n\t\t\tif((1<<j&x)!=0) {\n\t\t\t\tres=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n \n\tpublic static long evaln(String x,int n) {\n\t\tlong res=0;\n\t\tfor (int i = 0; i < x.length(); i++) {\n\t\t\tres+=Long.parseLong(x.charAt(x.length()-1-i)+\"\")*Math.pow(n, i);\n\t\t}\n\t\treturn res;\n\t}\n\tstatic void merge(int[] arr,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tint[] l=new int[len1];\n\t\tint[] r=new int[len2];\n\t\tfor(int i=0;i<len1;i++)l[i]=arr[b+i];\n\t\tfor(int i=0;i<len2;i++)r[i]=arr[m+1+i];\n\t\tint i=0,j=0,k=b;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<r[j])arr[k++]=l[i++];\n\t\t\telse arr[k++]=r[j++];\n\t\t}\n\t\twhile(i<len1)arr[k++]=l[i++];\n\t\twhile(j<len2)arr[k++]=r[j++];\n\t\treturn;\n\t}\n\tstatic void mergesortidx(long[] arr,long[]idx,int b,int e) {\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tmergesortidx(arr,idx,b,m);\n\t\t\tmergesortidx(arr,idx,m+1,e);\n\t\t\tmergeidx(arr,idx,b,m,e);\n\t\t}\n\t\treturn;\n\t\t\n\t}\n\tstatic void mergeidx(long[] arr,long[]idx,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tlong[] l=new long[len1];\n\t\tlong[] lidx=new long[len1];\n\t\tlong[] r=new long[len2];\n\t\tlong[] ridx=new long[len2];\n\t\tfor(int i=0;i<len1;i++) {\n\t\t\tl[i]=arr[b+i];\n\t\t\tlidx[i]=idx[b+i];\n\t\t}\n\t\tfor(int i=0;i<len2;i++) {\n\t\t\tr[i]=arr[m+1+i];\n\t\t\tridx[i]=idx[m+1+i];\n\t\t}\n\t\tint i=0,j=0,k=b;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<=r[j]) {\n\t\t\t\tarr[k++]=l[i++];\n\t\t\t\tidx[k-1]=lidx[i-1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarr[k++]=r[j++];\n\t\t\t\tidx[k-1]=ridx[j-1];\n\t\t\t}\n\t\t}\n\t\twhile(i<len1) {\n\t\t\tidx[k]=lidx[i];\n\t\t\tarr[k++]=l[i++];\n\t\t}\n\t\twhile(j<len2) {\n\t\t\tidx[k]=ridx[j];\n\t\t\tarr[k++]=r[j++];\n\t\t}\n\t\treturn;\n\t}\n\tstatic void mergesort(int[] arr,int b,int e) {\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tmergesort(arr,b,m);\n\t\t\tmergesort(arr,m+1,e);\n\t\t\tmerge(arr,b,m,e);\n\t\t}\n\t\treturn;\n\t\t\n\t}\n\t\n\tstatic long mergen(int[] arr,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tint[] l=new int[len1];\n\t\tint[] r=new int[len2];\n\t\tfor(int i=0;i<len1;i++)l[i]=arr[b+i];\n\t\tfor(int i=0;i<len2;i++)r[i]=arr[m+1+i];\n\t\tint i=0,j=0,k=b;\n\t\tlong c=0;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<r[j])arr[k++]=l[i++];\n\t\t\telse {\n\t\t\t\tarr[k++]=r[j++];\n\t\t\t\tc=c+(long)(len1-i);\n\t\t\t}\n\t\t}\n\t\twhile(i<len1)arr[k++]=l[i++];\n\t\twhile(j<len2)arr[k++]=r[j++];\n\t\treturn c;\n\t}\n\tstatic long mergesortn(int[] arr,int b,int e) {\n\t\tlong c=0;\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tc=c+(long)mergesortn(arr,b,m);\n\t\t\tc=c+(long)mergesortn(arr,m+1,e);\n\t\t\tc=c+(long)mergen(arr,b,m,e);\n\t\t}\n\t\treturn c;\n\t\t\n\t}\n\tpublic static long fac(int n) {\n\t\tif(n==0)return 1;\n\t\treturn n*fac(n-1);\n\t}\n\tpublic static long gcd(long a, long b)\n    {\n      if (b == 0)\n        return a;\n      return gcd(b, a % b);\n    }\n     \n\tpublic static long summ(long x) {\n\t\tlong sum=0;\n\t\twhile(x!=0) {\n\t\t\tsum+=x%10;\n\t\t\tx=x\/10;\n\t\t}\n\t\treturn sum;\n\t\t\t\t\n\t}\n\t\n\tpublic  static ArrayList<Integer> findDivisors(int n){\n\t        ArrayList<Integer>res=new ArrayList<Integer>();\n\t        for (int i=1; i<=Math.sqrt(n); i++)\n\t        {\n\t            if (n%i==0)\n\t            {\n\t                \/\/ If divisors are equal, print only one\n\t                if (n\/i == i)\n\t                \tres.add(i);\n\t                else {\n\t                \tres.add(i);\n\t                \tres.add(n\/i);\n\t                }\t\n\t            }\n\t        }\n\t        return res;\n\t    }\n\n\t\n\tpublic static void sort2darray(Integer[][]a){\n\t\tArrays.sort(a,Comparator.<Integer[]>comparingInt(x -> x[0]).thenComparingInt(x -> x[1]));\n \n\t}\n\t\n\t\n\t\n\t\t\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\t\tpublic Scanner(String file) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t\tpublic int[] nextArrint(int size) throws IOException {\n\t\t\tint[] a=new int[size];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic long[] nextArrlong(int size) throws IOException {\n\t\t\tlong[] a=new long[size];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextLong();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic int[][] next2dArrint(int rows,int columns) throws IOException{\n\t\t\tint[][]a=new int[rows][columns];\n\t\t\tfor (int i = 0; i < rows; i++) {\n\t\t\t\tfor (int j = 0; j < columns; j++) {\n\t\t\t\t\ta[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic long[][] next2dArrlong(int rows,int columns) throws IOException{\n\t\t\tlong[][]a=new long[rows][columns];\n\t\t\tfor (int i = 0; i < rows; i++) {\n\t\t\t\tfor (int j = 0; j < columns; j++) {\n\t\t\t\t\ta[i][j]=sc.nextLong();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}\n\t\n\tstatic class Side{\n\t\tPoint a;\n\t\tPoint b;\n\t\tpublic Side(Point a,Point b) {\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tSide s=(Side)obj;\n\t\t\treturn (s.a.equals(a)&&s.b.equals(b))||(s.b.equals(a)&&s.a.equals(b));\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\n\t\t\treturn \"(\"+a.toString()+\",\"+b.toString()+\")\";\n\t\t}\n\t}\n\tstatic class Point{\n\t\tint x;\n\t\tint y;\n\t\tint z;\n\t\tpublic Point(int x,int y,int z) {\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.z=z;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tPoint p=(Point)obj;\n\t\t\treturn x==p.x&&y==p.y&&z==p.z;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\"+x+\",\"+y+\",\"+z+\")\";\n\t\t}\n\t}\n\tstatic class Pair implements Comparable{\n\t\tlong x;\n\t\tlong y;\n\t\tpublic Pair(long x,long y) {\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tPair p=(Pair)obj;\n\t\t\treturn x==p.x&&y==p.y;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\/\/ TODO Auto-generated method stub\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Object o) {\n\t\t\tPair p=(Pair)o;\n\t\t\treturn x>p.x?1:x==p.x?0:-1;\n\t\t}\n\t}\n\tstatic class sPair{\n\t\tString s;\n\t\tPair p;\n\t\tpublic sPair(String s,Pair p) {\n\t\t\tthis.p=p;\n\t\t\tthis.s=s;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\/\/ TODO Auto-generated method stub\n\t\t\treturn s+\" \"+p;\n\t\t}\n\t}\n\tstatic Scanner sc=new Scanner(System.in);\n\tstatic PrintWriter pw=new PrintWriter(System.out);\n}","#include <bits\/stdc++.h>\nusing namespace std;\nlong long solve() {\n  long long n, maxi = INT_MIN, sum = 0;\n  cin >> n;\n  long long arr[n];\n  for (long long i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n  if (n == 1) return arr[0];\n  sort(arr, arr + n);\n  for (long long i = 0; i < n; i++) {\n    maxi = max(maxi, arr[i] - sum);\n    sum = arr[i];\n  }\n  return maxi;\n}\nsigned main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    cout << solve() << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvector<int> v;\nint main() {\n  long long int q, n, sum = 0;\n  cin >> q;\n  for (int k = 1; k <= q; k++) {\n    long long minn = -1e18;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n      int x;\n      cin >> x;\n      v.push_back(x);\n    }\n    sort(v.begin(), v.end());\n    int ok = 0;\n    for (int i = 0; i < v.size(); i++) {\n      minn = max(minn, v[i] + sum);\n      sum += (v[i] + sum) * -1;\n    }\n    if (!ok) {\n      cout << minn << \"\\n\";\n    }\n    v.clear();\n    sum = 0;\n  }\n  return 0;\n}\n","import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.text.DecimalFormat;\nimport java.util.*;\n\n\/\/import sun.java2d.opengl.WGLSurfaceData.WGLVSyncOffScreenSurfaceData;\n\n\n \npublic class Codeforces {\n\t\n\tstatic int mod=998244353 ;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tFastScanner fs=new FastScanner();\n\t\tint t=fs.nextInt();\n\n\t\twhile(t-->0) {\n\t\t\tint n=fs.nextInt();\n\t\t\tint arr[]=fs.readArray(n);\n\t\t\tif(n==1) {\n\t\t\t\tout.println(arr[0]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(arr);\n\t\t\tlong minus=0;\n\t\t\tlong ans= Integer.MIN_VALUE;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tarr[i]-=minus;\n\t\t\t\tans=Math.max(ans, arr[i]);\n\t\t\t\tminus+=arr[i];\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\tout.close();\n\t\t\n\t}\n\t\n\tstatic long pow(long a,long b) {\n\t\tif(b<0) return 1;\n\t\tlong res=1;\n\t\twhile(b!=0) {\n\t\t\tif((b&1)!=0) {\n\t\t\t\tres*=a;\n\t\t\t\tres%=mod;\n\t\t\t}\n\t\t\ta*=a;\n\t\t\ta%=mod;\n\t\t\tb=b>>1;\n\t\t}\n\t\treturn res;\n\t}\n\tstatic long gcd(long  a,long  b) {\n\t\tif(b==0) return a;\n\t\treturn gcd(b,a%b);\n\t}\n\tstatic long nck(int n,int k) {\n\t\tif(k>n) return 0;\n\t\tlong res=1;\n\t\tres*=fact(n);\n\t\tres%=mod;\n\t\tres*=modInv(fact(k));\n\t\tres%=mod;\n\t\tres*=modInv(fact(n-k)); \n\t\tres%=mod;\n\t\treturn res;\n\t}\n\tstatic long fact(long n) {\n\/\/\t\treturn fact[(int)n];\n\t\tlong res=1;\n\t\tfor(int i=2;i<=n;i++) {\n\t\t\tres*=i;\n\t\t\tres%=mod;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstatic long modInv(long n) {\n\t\treturn pow(n,mod-2);\n\t}\n\t\n\tstatic void sort(int[] a) {\n\t\t\/\/suffle\n\t\tint n=a.length;\n\t\tRandom r=new Random();\n\t\tfor (int i=0; i<a.length; i++) {\n\t\t\tint oi=r.nextInt(n);\n\t\t\tint temp=a[i];\n\t\t\ta[i]=a[oi];\n\t\t\ta[oi]=temp;\n\t\t}\n\t\t\n\t\t\/\/then sort\n\t\tArrays.sort(a);\n\t}\n\t\n\t\/\/ Use this to input code since it is faster than a Scanner\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong[] lreadArray(int n) {\n\t\t\tlong a[]=new long[n];\n\t\t\tfor(int i=0;i<n;i++) a[i]=nextLong();\n\t\t\treturn a;\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n \n}","#include <bits\/stdc++.h>\nusing namespace std;\nlong long int n, k, t, a[1000000], b[1000000], c, d, e, f, g;\nvector<int> v;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (long long int i = 1; i <= n; i++) cin >> a[i];\n    if (n == 1) {\n      cout << a[1] << \"\\n\";\n      continue;\n    }\n    sort(a + 1, a + n + 1);\n    for (long long int i = 2; i <= n; i++) {\n      b[i] = a[i] - a[i - 1];\n    }\n    b[1] = a[1];\n    sort(b + 1, b + n + 1);\n    cout << b[n] << \"\\n\";\n  }\n}\n","for _ in range(int(input())):\n    n = int(input())\n    x = sorted(list(map(int, input().split())))\n    cur, ans = x[0], x[0]\n    for i in x[1:]:\n        ans = max(ans, i - cur)\n        cur += i - cur\n    print(ans)\n","test = int(input())\n\nfor _ in range(test):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    arr.sort()\n\n    ans = arr[0]\n    diff = arr[0]\n\n    for i in range(1, n):\n        ele = arr[i] - diff\n        ans = max(ans, ele)\n        diff += ele\n\n    print(ans)\n","import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs=new FastScanner();\n\n\t\t\/******  CODE STARTS HERE  *****\/\n\t\t\n\t\tint t = fs.nextInt();\n\t\twhile(t-->0) {\n\t\t\tint n = fs.nextInt();\n\t\t\tPriorityQueue<Integer> pq = new PriorityQueue<>();\n\t\t\tfor(int i=0; i<n; i++)pq.add(fs.nextInt());\n\t\t\t\n\t\t\tint o_max = Integer.MIN_VALUE;\n\t\t\tif(pq.size() == 1) {\n\t\t\t\tSystem.out.println(pq.poll());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\to_max = Math.max(o_max, pq.peek());\n\t\t\twhile(pq.size()>1) {\n\t\t\t\tint e1 = pq.poll();\n\t\t\t\tint e2 = pq.poll();\n\t\t\t\to_max = Math.max(o_max, e2-e1);\n\t\t\t\tpq.add(e2);\n\t\t\t}\n\t\t\tSystem.out.println(o_max);\n\t\t}\n\t}\n    \n\t\/\/******  CODE ENDS HERE  *****\n\t\/\/----------------------------------------------------------------------------------------------------------------\n\t\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t\n\t\n\t\/\/----------- FastScanner class for faster input---------------------------\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\t\n}","#include <bits\/stdc++.h>\nconst long long mod = 1e9 + 7;\nint noans = 0;\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long arr[n];\n    for (long long i = 0; i < n; i++) cin >> arr[i];\n    sort(arr, arr + n);\n    long long maxi = arr[0];\n    long long sum = arr[0];\n    for (long long i = 1; i < n; i++) {\n      arr[i] -= sum;\n      maxi = max(maxi, arr[i]);\n      sum += arr[i];\n    }\n    cout << maxi << \"\\n\";\n  }\n}\n","for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print(a[0])\n        continue\n    s = 0\n    a.sort()\n    mx = a[0]\n    for i in range(n - 1):\n        s -= a[i] + s\n        mx = max(mx, a[i + 1] + s)\n    print(mx)\n","import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main {\n    static FastReader in;\n    static PrintWriter out;\n\n    static int bit(long n) {\n        return (n == 0) ? 0 : (1 + bit(n & (n - 1)));\n    }\n\n    static void p(Object o) {\n        out.print(o);\n    }\n\n    static void pn(Object o) {\n        out.println(o);\n    }\n\n    static void pni(Object o) {\n        out.println(o);\n        out.flush();\n    }\n\n    static String n() throws Exception {\n        return in.next();\n    }\n\n    static String nln() throws Exception {\n        return in.nextLine();\n    }\n\n    static int ni() throws Exception {\n        return Integer.parseInt(in.next());\n    }\n\n    static long nl() throws Exception {\n        return Long.parseLong(in.next());\n    }\n\n    static double nd() throws Exception {\n        return Double.parseDouble(in.next());\n    }\n\n    static class FastReader {\n        static BufferedReader br;\n        static StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws Exception {\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        String next() throws Exception {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new Exception(e.toString());\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() throws Exception {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                throw new Exception(e.toString());\n            }\n            return str;\n        }\n    }\n\n    static long power(long a, long b) {\n        if (b == 0)\n            return 1;\n        long val = power(a, b \/ 2);\n        val = val * val;\n        if ((b % 2) != 0)\n            val = val * a;\n        return val;\n    }\n\n    static ArrayList<Long> prime_factors(long n) {\n        ArrayList<Long> ans = new ArrayList<Long>();\n        while (n % 2 == 0) {\n            ans.add(2L);\n            n \/= 2;\n        }\n        for (long i = 3; i <= Math.sqrt(n); i++) {\n            while (n % i == 0) {\n                ans.add(i);\n                n \/= i;\n            }\n        }\n        if (n > 2)\n            ans.add(n);\n        return ans;\n    }\n\n    static void sort(long[] a) {\n        Arrays.sort(a);\n    }\n\n    static void reverse_sort(long[] a) {\n        Arrays.sort(a);\n        for (int i = 0; i < a.length; i++) {\n            long temp = a[i];\n            a[i] = a[a.length - i - 1];\n            a[a.length - i - 1] = temp;\n        }\n    }\n\n    static void sort(ArrayList<Long> a) {\n        Collections.sort(a);\n    }\n\n    static void reverse_sort(ArrayList<Long> a) {\n        Collections.sort(a, Collections.reverseOrder());\n    }\n\n    static void temp(long[] a, int i, int j) {\n        long temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    static void temp(List<Long> a, int i, int j) {\n        long temp = a.get(i);\n        a.set(j, a.get(i));\n        a.set(j, temp);\n    }\n\n    static void sieve(boolean[] prime) {\n        int n = prime.length - 1;\n        Arrays.fill(prime, true);\n        for (int i = 2; i * i <= n; i++) {\n            if (prime[i]) {\n                for (int j = 2 * i; j <= n; j += i) {\n                    prime[j] = false;\n                }\n            }\n        }\n    }\n\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    static long mod = 1000000007;\n\n    static class pair implements Comparable<pair> {\n        long x, y;\n\n        public pair(long x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(pair p) {\n            return this.y * (p.x - 1L) > p.y * (this.x - 1L) ? 1 : -1;\n        }\n\n    }\n\n    public static void main(String[] args) throws Exception {\n        in = new FastReader();\n        out = new PrintWriter(System.out);\n        int t = ni();\n        while (t-- > 0) {\n            int n = ni();\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nl();\n            }\n            merge_sort(arr,0,n-1);\n            if (n == 1) {\n                pn(arr[0]);\n                continue;\n            }\n            long[] a = new long[n - 1];\n            for (int i = 1; i < n; i++) {\n                a[i - 1] = arr[i] - arr[0];\n            }\n            merge_sort(a,0,a.length-1);\n            long ans = Math.max(a[0],arr[0]);\n            long diff = a[0];\n            for (int i = 0; i < a.length; i++) {\n                ans = Math.max(ans, a[i] - diff);\n                if (i != 0)\n                    diff += a[i] - a[i - 1];\n            }\n            pn(ans);\n        }\n        out.flush();\n        out.close();\n    }\n    public static void merge_sort(long[] arr, int l, int r){\n        if(l>=r)return ;\n        int mid=(l+r)\/2;\n        merge_sort(arr, l, mid);\n        merge_sort(arr, mid+1, r);\n        merge(arr,l,mid,r);\n    }\n    static void merge(long[] arr, int l, int mid, int r){\n        long[] left=new long[mid-l+1];\n        long[] right=new long[r-mid];\n        for(int i=l;i<=mid;i++){\n            left[i-l]=arr[i];\n        }\n        for(int i=mid+1;i<=r;i++){\n            right[i-(mid+1)]=arr[i];\n        }\n        int left_start=0;\n        int right_start=0;\n        int left_length=mid-l+1;\n        int right_length=r-mid;\n        int temp=l;\n        while(left_start<left_length && right_start<right_length){\n            if(left[left_start]<right[right_start]){\n                arr[temp]=left[left_start++];\n            }else{\n                arr[temp]=right[right_start++];\n            }\n            temp++;\n        }\n        while(left_start<left_length){\n            arr[temp++]=left[left_start++];\n        }\n        while(right_start<right_length){\n            arr[temp++]=right[right_start++];\n        }\n    }\n}\n","import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.lang.*;\nimport static java.lang.Math.*;\n\n\/\/ Sachin_2961 submission \/\/\npublic class Codeforces {\n\n    static void solve(){\n        int n = fs.nInt();\n        long[]ar = new long[n];\n        for(int i=0;i<n;i++){\n            ar[i] = fs.nLong();\n        }\n        sort(ar);\n        long ans = ar[0];\n        long last = ar[0];\n        for(int i=1;i<n;i++){\n            ans = max(ans,ar[i]-last);\n            last = ar[i];\n        }\n        out.println(ans);\n    }\n\n    static class Pair{\n        int f,s;\n        Pair(int f,int s){\n            this.f = f;\n            this.s = s;\n        }\n    }\n    static boolean multipleTestCase = true;\n    static FastScanner fs;\n    static PrintWriter out;\n    public static void main(String[]args){\n       try{\n           out = new PrintWriter(System.out);\n           fs = new FastScanner();\n           int tc = multipleTestCase?fs.nInt():1;\n           while (tc-->0)solve();\n           out.flush();\n           out.close();\n       }catch (Exception e){\n           e.printStackTrace();\n       }\n    }\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String n() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        String Line()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        int nInt() {return Integer.parseInt(n()); }\n        long nLong() {return Long.parseLong(n());}\n        double nDouble(){return Double.parseDouble(n());}\n        int[]aI(int n){\n            int[]ar = new int[n];\n            for(int i=0;i<n;i++)\n                ar[i] = nInt();\n            return ar;\n        }\n    }\n    public static void sort(int[] arr){\n        ArrayList<Integer> ls = new ArrayList<Integer>();\n        for(int x: arr)\n            ls.add(x);\n        Collections.sort(ls);\n        for(int i=0; i < arr.length; i++)\n            arr[i] = ls.get(i);\n    }\n    public static void sort(long[] arr){\n        ArrayList<Long> ls = new ArrayList<>();\n        for(long x: arr)\n            ls.add(x);\n        Collections.sort(ls);\n        for(int i=0; i < arr.length; i++)\n            arr[i] = ls.get(i);\n    }\n}","t=int(input())\nfor i in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    if n==1:\n        print(a[0])\n    elif n==2:\n        print(max(min(a),max(a)-min(a)))\n    else:\n        a.sort()\n        a1 = []\n        a1.append(a[0])\n        s=-float(\"inf\")\n        for i in range(len(a)-1):\n            a1.append(a[i+1]-a[i])\n        print(max(a1))\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long M = 1000000007;\nlong long bin(long long n, long long k) {\n  long long res = 1;\n  if (k > n - k) k = n - k;\n  for (int i = 0; i < k; i++) {\n    res *= (n - i);\n    res \/= (i + 1);\n    res %= M;\n  }\n  return res;\n}\nvoid solve() {\n  long long n, i, k, x, ct = 0, ans = 0;\n  cin >> n;\n  long long a[n];\n  for (i = 0; i < n; i++) cin >> a[i];\n  sort(a, a + n);\n  long long mn = a[0];\n  k = a[0];\n  for (i = 1; i < n; i++) {\n    mn = max(mn, a[i] - a[i - 1]);\n  }\n  cout << mn << endl;\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n","import java.util.*;\n\npublic class Solution {\n\n    public static void main(String[] args) throws Exception {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        scanner.nextLine();\n        List<List<Long>> list = new ArrayList<>();\n        for(int i = 0;i < n;i++){\n            int m = scanner.nextInt();\n            List<Long> inlist = new ArrayList<>();\n            for(int j = 0;j < m;j++){\n                inlist.add(scanner.nextLong());\n            }\n            list.add(inlist);\n            scanner.nextLine();\n        }\n        for(List<Long> l : list){\n            Collections.sort(l);\n            int s = l.size();\n            long ans = l.get(0);\n            for(int i = 1;i < s;i++){\n                ans = Math.max(ans,l.get(i)-l.get(i-1));\n            }\n            System.out.println(ans);\n        }\n    }\n\n\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint result() {\n  int result = 0, len, i;\n  string keyboard, word;\n  cin >> keyboard >> word;\n  len = word.length();\n  i = len - 1;\n  for (int i = len - 1; i > 0; i--) {\n    int f = keyboard.find(word[i]) + 1;\n    int g = keyboard.find(word[i - 1]) + 1;\n    result += abs(f - g);\n  }\n  return result;\n}\nint minimum() {\n  long long n, min, integer;\n  cin >> n;\n  vector<long long> arr;\n  for (int i = 0; i < n; i++) {\n    cin >> integer;\n    arr.push_back(integer);\n  }\n  if (n == 1)\n    return arr[0];\n  else {\n    sort(arr.begin(), arr.end());\n    long long min = arr[0];\n    for (int i = 1; i < n; i++) {\n      min = max(min, arr[i] - arr[i - 1]);\n    }\n    return min;\n  }\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    cout << minimum() << endl;\n  }\n  return 0;\n}\n","from sys import stdin as f\nfrom heapq import heapify, heappush, heappop\n\n\nt = int(next(f))\nout = []\n\n\nfor _ in range(t):\n    n = int(next(f))\n    a = list(map(int, input().split()))\n    heapify(a)\n    c = 0\n    mx = -float('inf')\n    m = heappop(a)\n    while len(a) > 0:\n        if m > mx:\n            mx = m\n        c += m\n        m = heappop(a) - c\n    if m > mx:\n        mx = m\n    out.append(mx)\n\nprint(*out, sep='\\n')\n","\/\/ Problem: C. Minimum Extraction\n\/\/ Contest: Codeforces - Codeforces Round #753 (Div. 3)\n\/\/ URL: https:\/\/codeforces.com\/contest\/1607\/problem\/C\n\/\/ Memory Limit: 256 MB\n\/\/ Time Limit: 1000 ms\n\/\/ \n\/\/ Powered by CP Editor (https:\/\/cpeditor.org)\n\n\n\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\nimport java.util.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.io.InputStreamReader;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\n   \n         \n\n\n    public static void main(String[] args) throws IOException {\n\n\/\/        try {\n\/\/             Scanner in = new Scanner(System.in) ;\n        FastScanner in = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n\n\n        \n\t\tint t = in.nextInt() ;\n\t\twhile(t-- > 0){\n\t\t\t\n\t\t\tint n = in.nextInt() ;\n\t\t\tlong a[] = new long[n] ;\n\t\t\tfor(int i=0 ; i<n ; i++)a[i] = in.nextLong() ;\n\t\t\tsort1(a) ;\n\n\t\t\tlong min = a[0] ;\n\t\t\tlong ans = a[0] ;\n\t\t\t\n\t\t\tfor(int i=1 ; i<n ; i++){\n\t\t\t\t\n\t\t\t\tif(a[i] - ans >= min){\n\t\t\t\t\tmin = a[i] - ans ;}\n\t\t\t\t\tans += a[i] - ans ;\n\t\t\t\t \n\t\t\t\t\n\t\t\t\t \n\t\t\t\t\n\t\t\t}  \n\t\t\tout.append(min + \"\\n\") ;\n\n\t\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        out.flush();\n        out.close();\n\n\n\/\/        } catch (Exception e) {\n\/\/            return;\n\/\/        }\n\n    }\n\n    static long gcd(long a, long b) {\n        return (b == 0) ? a : gcd(b, a % b);\n    }\n\n    static int gcd(int a, int b) {\n        return (b == 0) ? a : gcd(b, a % b);\n    }\n\n    static void sort(int ar[]) {\n        int n = ar.length;\n        ArrayList<Integer> a = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            a.add(ar[i]);\n        Collections.sort(a);\n        for (int i = 0; i < n; i++)\n            ar[i] = a.get(i);\n    }\n\n    static void sort1(long ar[]) {\n        int n = ar.length;\n        ArrayList<Long> a = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            a.add(ar[i]);\n        Collections.sort(a);\n        for (int i = 0; i < n; i++)\n            ar[i] = a.get(i);\n    }\n\n    static long ncr(long n, long r, long mod) {\n        if (r == 0)\n            return 1;\n        long val = ncr(n - 1, r - 1, mod);\n        val = (n * val) % mod;\n        val = (val * modInverse(r, mod)) % mod;\n        return val;\n    }\n\n    static long fast_pow(long base, long n, long M) {\n        if (n == 0)\n            return 1;\n        if (n == 1)\n            return base % M;\n        long halfn = fast_pow(base, n \/ 2, M);\n        if (n % 2 == 0)\n            return (halfn * halfn) % M;\n        else\n            return (((halfn * halfn) % M) * base) % M;\n    }\n\n    static long modInverse(long n, long M) {\n        return fast_pow(n, M - 2, M);\n    }\n\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n\n}\n\n\n\n\n\n\n\n","import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.regex.*;\n \npublic class Solution\n{\n \n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n        InputReader sc=new InputReader(System.in);\n\t\tint t = sc.readInt();\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\n\t\twhile(t-->0){\n            int n = sc.readInt();\n            ArrayList<Integer> a = new ArrayList<>();\n            for(int i=0;i<n;i++){\n                a.add(sc.readInt());\n            }\n\n            Collections.sort(a);\n            int sum=a.get(0);\n            int max = a.get(0);\n\n            for(int i=1;i<n;i++){\n                if(a.get(i)-sum>max){\n                    max=a.get(i)-sum;\n                }\n                sum+=a.get(i)-sum;\n            }\n\n            pw.println(max);\n\t\t}\n\n        pw.close();\n\t}\n\n\n\n\n    static  class InputReader\n{\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n \n    public InputReader(InputStream stream)\n    {\n        this.stream = stream;\n    }\n \n    public int read()\n    {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars)\n        {\n            curChar = 0;\n            try\n            {\n                numChars = stream.read(buf);\n            } catch (IOException e)\n            {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n \n    public int readInt()\n    {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-')\n        {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do\n        {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n \n    public String readString()\n    {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do\n        {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n    public String readLine() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndOfLine(c));\n        return res.toString();\n    }\n    \n \n    public double readDouble() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        double res = 0;\n        while (!isSpaceChar(c) && c != '.') {\n            if (c == 'e' || c == 'E')\n                return res * Math.pow(10, readInt());\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        }\n        if (c == '.') {\n            c = read();\n            double m = 1;\n            while (!isSpaceChar(c)) {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, readInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                m \/= 10;\n                res += (c - '0') * m;\n                c = read();\n            }\n        }\n        return res * sgn;\n    }\n    public long readLong() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n    public boolean isSpaceChar(int c)\n    {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n \n    public String next()\n    {\n        return readString();\n    }\n \n    public interface SpaceCharFilter\n    {\n        public boolean isSpaceChar(int ch);\n    }\n    public boolean isEndOfLine(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n}\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; ++i) cin >> a[i];\n    sort(a, a + n);\n    int ans = a[0];\n    for (int i = 1; i < n; ++i) ans = max(ans, a[i] - a[i - 1]);\n    cout << ans << \"\\n\";\n  }\n}\n","import java.util.*;\nimport java.io.*;\nimport java.lang.*;\n\npublic class Problem {\n    static int Mod = 1000000007;\n\n    public static void main(String[] args) {\n        MyScanner scan = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int t = scan.nextInt();\n        \/\/ int t=1;\n        while (t-- > 0) {\n            int n = scan.nextInt();\n            int a[] = new int[n];\n            int max = Integer.MAX_VALUE;\n            for (int i = 0; i < n; i++) {\n                a[i] = scan.nextInt();\n                max = Math.min(max, a[i]);\n            }\n\n            if (n == 1) {\n                out.println(a[0]);\n                continue;\n            }\n            sort(a);\n\n            for (int i = 1; i < n; i++) {\n                max = Math.max(max, a[i] - a[i - 1]);\n            }\n            out.println(max);\n\n        }\n        out.close();\n    }\n\n    static class Pair {\n        int l;\n        int r;\n\n        Pair(int l, int r) {\n            this.l = l;\n            this.r = r;\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + l;\n            result = prime * result + r;\n            return result;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            Pair other = (Pair) obj;\n            if (l != other.l)\n                return false;\n            if (r != other.r)\n                return false;\n            return true;\n        }\n\n        @Override\n        public String toString() {\n            return \"Pair [l=\" + l + \", r=\" + r + \"]\";\n        }\n    }\n\n    public static void sort(int[] array) {\n        ArrayList<Integer> copy = new ArrayList<>();\n        for (Integer i : array)\n            copy.add(i);\n        Collections.sort(copy);\n        for (int i = 0; i < array.length; i++)\n            array[i] = copy.get(i);\n    }\n\n    public static void sort(long[] array) {\n        ArrayList<Long> copy = new ArrayList<>();\n        for (Long i : array)\n            copy.add(i);\n        Collections.sort(copy);\n        for (int i = 0; i < array.length; i++)\n            array[i] = copy.get(i);\n    }\n\n    public static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b); \/\/ gcd(a,b) = gcd(a-b,b) or gcd(a,b) = gcd(b,a%b) where a>b\n    }\n\n    public static int gcd(int a, int b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b); \/\/ gcd(a,b) = gcd(a-b,b) or gcd(a,b) = gcd(b,a%b) where a>b\n    }\n\n    public static long lcm(long a, long b) {\n        return (a \/ gcd(a, b)) * b;\n    }\n\n    static long power(long x, long y) {\n        long temp;\n        if (y == 0) \/\/ a^b= (a^b\/2)^2 if b is even\n            return 1; \/\/ = (a*a^(b-1)) if b is odd\n        temp = power(x, y \/ 2);\n        if (y % 2 == 0)\n            return temp * temp;\n        else\n            return x * temp * temp;\n    }\n\n    static long mod(long x) {\n        return ((x % Mod + Mod) % Mod);\n    }\n\n    static long add(long a, long b) {\n        return mod(mod(a) + mod(b));\n    }\n\n    static long mul(long a, long b) {\n        return mod(mod(a) * mod(b));\n    }\n\n    static long pow(long x, long y, long p) {\n        long res = 1; \/\/ Initialize result\n        x = x % p; \/\/ Update x if it is more than or equal to p\n\n        if (x == 0)\n            return 0; \/\/ In case x is divisible by p;\n\n        while (y > 0) {\n            \/\/ If y is odd, multiply x with result\n            if ((y & 1) != 0)\n                res = (res * x) % p;\n\n            \/\/ y must be even now\n            y = y >> 1; \/\/ y = y\/2\n            x = (x * x) % p;\n        }\n        return res;\n    }\n\n    static long modInverse(long a, long m) {\n        \/\/ int g = gcd(a, m);\n        \/\/ if (g != 1)\n        \/\/ System.out.println(\"Inverse doesn't exist\");\n        \/\/ else {\n        \/\/ \/\/ If a and m are relatively prime, then modulo\n        \/\/ \/\/ inverse is a^(m-2) mode m\n        \/\/ return power(a, m - 2, m);\n        \/\/ }\n        return pow(a, m - 2, m);\n    }\n\n}\n\nclass MyScanner {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public MyScanner() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n\n}\n","#include <bits\/stdc++.h>\nconst int N = 1e5;\nconst int inf = 1e9 + 10;\nusing namespace std;\nvoid yes() { cout << \"YES\" << endl; }\nvoid no() { cout << \"NO\" << endl; }\nmap<long long int, long long int> cnt;\nvoid prime_factorization(long long int n) {\n  for (long long int i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      n \/= i;\n      ++cnt[i];\n    }\n  }\n  if (n > 1) ++cnt[n];\n}\nvoid solve() {\n  long long int x, y, a, b;\n  cin >> x >> y;\n  a = x, b = y;\n  if (x > y) {\n    cout << x + y;\n    return;\n  }\n  if (x == y) {\n    cout << x;\n    return;\n  }\n  if (y % x == 0) {\n    cout << x;\n    return;\n  }\n  cout << (y \/ x) * x + (y % x) \/ 2;\n  return;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int a[n + 1];\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    if (n == 1)\n      cout << a[1] << endl;\n    else {\n      sort(a + 1, a + n + 1);\n      long long int cross = 0, mn = a[1], second = 0;\n      for (int i = 2; i <= n; i++) {\n        second += mn;\n        mn = a[i] - second;\n        a[i] = mn;\n        ++cross;\n      }\n      sort(a + 1, a + n + 1);\n      cout << a[n];\n      cout << endl;\n    }\n  }\n}\n","import heapq as hq\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    hq.heapify(a)\n    ans = a[0]\n    ad = 0\n\n    for i in range(n):\n        #b = [i+ad for i in a]\n        #print(b)\n        x = hq.heappop(a) + ad\n        #print(x, ad)\n        ad -= x\n        ans = max(ans, x)\n        #print(x)\n    print(ans)","#include <bits\/stdc++.h>\nusing namespace std;\nint t, n;\nconst int maxn = 2e5 + 5;\nint a[maxn];\nint max1;\nvoid solve() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  if (n == 1) {\n    cout << a[1] << endl;\n    return;\n  }\n  sort(a + 1, a + n + 1);\n  max1 = a[1];\n  for (int i = 2; i <= n; i++) {\n    max1 = max(max1, a[i] - a[i - 1]);\n  }\n  cout << max1 << endl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","t=int(input())\nfor _ in range(t):\n    n=int(input())\n    l=list(map(int,input().split()))\n    l.sort()\n    ans=[]\n    ans.append(l[0])\n    if(n==1):\n        print(l[0])\n    else:\n        for i in range(n-1):\n            ans.append(l[i+1]-l[i])\n        print(max(ans))","import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n##########################################################\nfrom collections import Counter, defaultdict\nimport math\nimport heapq\nimport bisect\ndef nck(n, k):\n    res = 1\n    for i in range(1, k + 1):\n        res = res * (n - i + 1) \/\/ i\n    return res\n\nfor _ in range(int(input())):\n    n=int(input())\n    #n,k=map(int, input().split())\n    #if abs(n)%2==1:\n    arr=sorted(list(map(int, input().split())))\n\n    a=0\n    if n==1:\n        print(arr[0])\n    else:\n        var=arr[0]\n        ans=arr[0]\n        for i in range(1,n):\n            ans=max(ans,arr[i]-var)\n            var+=(arr[i]-var)\n        print(ans)\n","for _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    a.sort()\n    if n==1:\n        print(a[0])\n        continue\n    else:\n        ans=a[0]\n        for i in range(n-1):\n            \n            \n            ans=max(ans,a[i+1]-a[i])\n            \n                     \n        print(ans)","#include <bits\/stdc++.h>\nusing namespace std;\nint32_t main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n, k, sum = 0, c = 0, mn = INT_MIN, m;\n    cin >> n;\n    long long a[n];\n    for (long long i = 0; i < n; i++) cin >> a[i];\n    sort(a, a + n);\n    if (n == 2) {\n      cout << max(a[0], a[1] - a[0]) << endl;\n    } else {\n      for (long long i = 0; i < n - 1; i++) {\n        m = a[i + 1] - a[i];\n        mn = max(m, mn);\n      }\n      mn = max(mn, a[0]);\n      cout << mn << endl;\n    }\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a, a + n);\n    int out = a[0];\n    if (n == 1) {\n      out = a[0];\n    }\n    if (n == 2) {\n      out = max(a[0], a[1] - a[0]);\n    }\n    for (int i = 0; i < n - 1; i++) {\n      out = max(out, a[i + 1] - a[i]);\n    }\n    cout << out << endl;\n  }\n  return 0;\n}\n","from collections import Counter, defaultdict, deque\nimport bisect\nfrom sys import stdin, stdout\nfrom itertools import repeat\nimport math, random\n\n\ndef inp(force_list=False):\n    re = map(int, raw_input().split())\n    if len(re) == 1 and not force_list:\n        return re[0]\n    return re\n\ndef inst():\n    return raw_input().strip()\n\ndef gcd(x, y):\n   while(y):\n       x, y = y, x % y\n   return x\n\nmod = 1000000007\n\ndef my_main():\n    kase = inp()\n    pans = []\n    mx = int(1e17)\n    for ka in range(kase):\n        n = inp()\n        da = inp(True)\n        da.sort()\n        mx = da[0]\n        sm = 0\n        for i in range(1, n):\n            mx = max(mx, da[i] - da[i-1])\n        pans.append(str(mx))\n    print '\\n'.join(pans)\n\nmy_main()\n","#include <bits\/stdc++.h>\nint main() {\n  std::cin.tie(NULL)->ios_base::sync_with_stdio(false);\n  int t, n, max, a[200000];\n  std::cin >> t;\n  while (t--) {\n    std::cin >> n;\n    for (int i = 0; i < n; i++) std::cin >> a[i];\n    std::sort(a, a + n);\n    max = a[0];\n    for (int i = 1; i < n; i++)\n      if (a[i] - a[i - 1] > max) max = a[i] - a[i - 1];\n    std::cout << max << '\\n';\n  };\n  return 0;\n};\n","import sys\nreadline = sys.stdin.readline\n\nT = int(readline())\n\nfor t in range(T):\n  N = int(readline())\n  A = list(map(int,readline().split()))\n  A = sorted(A)\n  \n  minus_sum = 0\n  best = A[0]\n  \n  for i in range(N - 1):\n    minus_sum += A[i]\n    A[i + 1] -= minus_sum\n    if A[i + 1] > best:\n      best = A[i + 1]\n  print(best)\n","import os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n \nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    A = list(map(int, input().split(' ')))\n\n    if 1 == n:\n        M = A[0]\n    else:\n        A.sort()\n\n        M, s = A[0], 0\n        for a in A:\n            M = max(M, a - s)\n            s += a - s\n\n    print(M)\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long md = 1e9 + 7;\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> v(n);\n  for (auto &x : v) cin >> x;\n  sort(v.begin(), v.end());\n  if (v.size() == 1) {\n    cout << v[0] << '\\n';\n    return;\n  }\n  long long x = 0, ans = INT_MIN;\n  for (int i = 0; i < n; i++) {\n    ans = max(ans, v[i] - x);\n    x = v[i];\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    long long ans = LLONG_MIN;\n    long long p = 0;\n    for (int x : a) {\n      ans = max(ans, x - p);\n      p = x;\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n","import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\npublic class Main\n{\n\tstatic String shengxiao[] =\n\t{ \"rat\", \"ox\", \"tiger\", \"rabbit\", \"dragon\", \"snake\", \"horse\", \"goat\", \"monkey\", \"rooster\", \"dog\", \"pig\" };\n\tstatic String shengxiaoo[] =\n\t{ \"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Goat\", \"Monkey\", \"Rooster\", \"Dog\", \"Pig\" };\n\tstatic int month[] =\n\t{ 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\tstatic int zhong[] =\n\t{ -1, 1, 0, 0, -1, -1, 1, 1 };\n\tstatic int heng[] =\n\t{ 0, 0, -1, 1, -1, 1, -1, 1 };\n\tstatic int zhongg[] =\n\t{ -1, -1, 0, 1, 1, 1, 0, -1 };\n\tstatic int hengg[] =\n\t{ 0, 1, 1, 1, 0, -1, -1, -1 };\n\tstatic int inf = Integer.MAX_VALUE;\n\tstatic long inff = Long.MAX_VALUE;\n\n\tstatic int mod = (int) 998244353;\n\tstatic int N = (int) 36 + 10;\n\tstatic int M = (int) 1e6 + 10;\n\n\tstatic void init()\n\t{\n\n\t}\n\n\t\/\/ static boolean is(int x)\n\tstatic boolean is()\n\t{\n\n\t\treturn true;\n\t}\n\n\t\/\/ static void solve(String s)\n\t\/\/ static void solve(int n)\n\t\/\/ static void solve(long n)\n\tstatic void solve()\n\t{\n\t\tint n = sc.nextInt();\n\t\tlong shu[] = new long[n + 10];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tshu[i] = sc.nextLong();\n\t\tif (n == 1)\n\t\t{\n\t\t\tout.println(shu[1]);\n\t\t\treturn;\n\t\t}\n\n\t\tlong max = Integer.MIN_VALUE;\n\n\t\tArrays.sort(shu, 1, n + 1);\n\t\tlong yuan = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tlong a = shu[i] - yuan;\n\t\t\tmax = Math.max(max, a);\n\t\t\tyuan += a;\n\t\t}\n\t\tout.println(max);\n\n\t}\n\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tinit();\n\n\/\/\t\twhile (sc.hasNext())\n\t\t{\n\/\/\t\t\tint t = 1;\n\t\t\tint t = sc.nextInt();\n\t\t\tfor (int x = 1; x <= t; x++)\n\/\/\t\t\t\tsolve();\n\t\t\t{\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tLong[] a = new Long[n];\n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\ta[i] = sc.nextLong();\n\t\t\t\tif (n == 1)\n\t\t\t\t\tout.println(a[0]);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tArrays.sort(a);\n\t\t\t\t\tlong ans = a[1] - a[0];\n\t\t\t\t\tfor (int i = 2; i < n; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tans = Math.max(ans, a[i] - a[i - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tout.println(Math.max(ans, a[0]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/\/ String s = sc.next();\n\t\t\t\/\/ solve(s);\n\n\t\t\tout.flush();\n\t\t}\n\n\t\tout.close();\n\t}\n\n\tstatic InputStream inputStream = System.in;\n\tstatic InputReader sc = new InputReader(inputStream);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic class InputReader\n\t{\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next()\n\t\t{\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tboolean hasNext()\n\t\t{\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (Exception e)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t\t\/\/ TODO: handle exception\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic String nextLine()\n\t\t{\n\t\t\tString str = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstr = reader.readLine();\n\t\t\t} catch (IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tpublic int nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic Double nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic BigInteger nextBigInteger()\n\t\t{\n\t\t\treturn new BigInteger(next());\n\t\t}\n\n\t\tpublic BigDecimal nextBigDecimal()\n\t\t{\n\t\t\treturn new BigDecimal(next());\n\t\t}\n\n\t}\n\n}","import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class Solution{\n\tstatic FastScanner fs  = new FastScanner();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic void output(){\n\t\tint n = fs.nextInt();\n\t\tint[] a = fs.readArray(n);\n\t\tsort(a);\n\t\tlong ans = 0;\n\t\tlong max = a[0];\n\t\tfor(int i=0;i<n;i++){\t\n\t\t\ta[i] -= ans;\n\t\t\tmax = Math.max(max,a[i]);\n\t\t\tans += a[i];\n\t\t}\n\t\tout.println(max);\n\t\tout.flush();\n\t}\n\tpublic static void main(String[] args) {\n\t\tint T = 1;\n\t    T=fs.nextInt();\n\t\tfor (int tt=0; tt<T; tt++) {\n\t\t\toutput();\n\t\t}\n\t}\n\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n","import java.util.*;\nimport java.io.*;\n \npublic class Main{\n    public static void main(String [] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(br.readLine());\n        for(int z=0;z<t;z++){\n            int n = Integer.parseInt(br.readLine());\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            ArrayList<Integer> al = new ArrayList<Integer>();\n            ArrayList<Integer> ans = new ArrayList<Integer>();\n            while(st.hasMoreTokens())\n                al.add(Integer.parseInt(st.nextToken()));\n            Collections.sort(al);\n            \/\/System.out.println(al);\n            ans.add(al.get(0));\n            int val = 0;\n            for(int i=1;i<al.size();i++){\n                val += ans.get(i-1);\n                ans.add(al.get(i)-val);\n            }\n            System.out.println(Collections.max(ans));\n        }\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  int t;\n  cin >> t;\n  while (t) {\n    int n, mx;\n    long long r = 0;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; i++) {\n      cin >> v[i];\n    }\n    sort(v.begin(), v.end());\n    mx = v[0];\n    for (int i = 0; i < n; i++) {\n      if ((v[i] - r) >= mx) {\n        mx = v[i] - r;\n      }\n      r += v[i] - r;\n    }\n    cout << mx << endl;\n    t--;\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint t, n, p;\nlong long a[200001], ans, d;\nint main() {\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a, a + n);\n    p = 1;\n    ans = a[0];\n    d = a[0];\n    while (p < n) {\n      a[p] -= d;\n      ans = max(ans, a[p]);\n      d += a[p];\n      p++;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n","#rOkY\n#FuCk\n\n################################### KoPaL ####################################\n\n\nt=int(input())\nwhile(t>0):\n    ma=0\n    a=int(input())\n    l=list(map(int,input().split()))\n    mn=min(l)\n    l.sort()\n    for i in range(0,len(l)-1,1):\n        mn=max(mn,l[i+1]-l[i])\n    print(mn)\n    t-=1\n","for _ in range(1,int(input())+1):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    arr.sort()\n    if n==1:\n        print(arr[0])\n    else:\n        maxi=arr[0]\n        for i in range(len(arr)-1):\n            j=abs(arr[i]-arr[i+1])\n            maxi=max(maxi,j)\n        print(maxi)","import sys, collections, math, bisect, heapq, random, functools\n\ninput = sys.stdin.readline\nout = sys.stdout.flush\n\n\ndef solve():\n    n = int(input())\n    k = [*map(int, input().split())]\n    k.sort()\n    ans = k[0]\n    diff = -k[0]\n    for i in range(1,n):\n        cur = k[i] + diff\n        ans = max(cur,ans)\n        diff -= cur\n    print(ans)\n\n\n\n\nif __name__ == '__main__':\n    for i in range(int(input())):\n        solve()","import sys\nimport heapq\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\ndef get_int(): return int(sys.stdin.readline().strip())\ndef get_list_strings(): return list(map(str, sys.stdin.readline().strip().split()))\n\n\n# Output for list\n# sys.stdout.write(\" \".join(map(str, final)) + \"\\n\")\n\n# Output for int or str\n# sys.stdout.write(str(best) + \"\\n\")\n\n\n\ndef solve(n, arr):\n  ans = min(arr)\n\n  c = 0\n\n  heapq.heapify(arr)\n\n  while n > 1:\n    temp = heapq.heappop(arr)\n    n -= 1\n\n    temp1 = temp - c\n\n    ans = max(ans, temp1)\n\n    c += temp1\n\n    # print(arr)\n\n  temp = heapq.heappop(arr)\n  temp1 = temp - c\n\n  ans = max(ans, temp1)\n\n\n  print(ans)\n\n    \n\n\n\n\n\n\n\nT = get_int()\nwhile T:\n  n = get_int()\n  arr = get_list()\n  solve(n, arr)\n  T -= 1\n","import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\n\/*\n * mprodev for codeforces\n *  8\n    1\n    10\n    2\n    0 0\n    3\n    -1 2 0\n    4\n    2 10 1 7\n    2\n    2 3\n    5\n    3 2 -4 -2 0\n    2\n    -1 1\n    1\n    -2\n *\/\n\npublic class C {\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        int T = fs.nextInt();\n        for (int tt = 0; tt < T; tt++) {\n            int n = fs.nextInt();\n            int[] arr = fs.readArray(n);\n            sort(arr);\n            long subtraction = arr[0];\n            long ans = arr[0];\n            for (int i = 1; i < n; i++) {\n                int curr = arr[i];\n                long possible = curr - subtraction;\n                ans = Math.max(ans, possible);\n                subtraction += possible;\n            }\n            System.out.println(ans);\n        }\n\n    }\n\n    static void sort(int[] a) {\n        ArrayList<Integer> l = new ArrayList<>();\n        for (int i : a) l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++) a[i] = l.get(i);\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n\n}","import sys\nimport math\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom math import inf\ninput = sys.stdin.readline\n\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int,input().split()))\n    arr.sort()\n\n    mx = arr[0]\n\n    for i in range(n-1):\n        mx = max(mx,arr[i+1]-arr[i])\n\n    print(mx)\n    ","b = int(input())\nwhile b:\n    b = b - 1\n    n = int(input())\n    k=list(map(int,input().split()))\n    k.sort()\n    ans=k[0]\n    if n==1:\n        print(ans)\n    else:\n        for i in range(1,n):\n            ans=max(ans,k[i]-k[i-1])\n        print(ans)\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nclock_t startTime;\ndouble getCurrentTime() {\n  return (double)(clock() - startTime) \/ CLOCKS_PER_SEC;\n}\nconst int N = 2e5 + 5;\nvoid solve() {\n  int n;\n  cin >> n;\n  int a[n + 1];\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  sort(a + 1, a + 1 + n);\n  long long ans = a[1];\n  for (int i = 2; i <= n; i++) {\n    ans = max(ans, 1ll * (a[i] - a[i - 1]));\n  }\n  cout << ans << endl;\n}\nint main() {\n  startTime = clock();\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) solve();\n  return 0;\n}\n","#include <bits\/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target( \\\n    \"fma,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nconst long long int M = 1000000007;\nlong long int fact[200001] = {};\ninline bool comp(long long int x, long long int y) { return x < y; }\ninline long long int mod(long long int x) {\n  long long int a1 = (x % M);\n  if (a1 < 0) {\n    a1 += M;\n  }\n  return a1;\n}\ninline long long int power(long long int x, unsigned long long int y,\n                           long long int p = LLONG_MAX) {\n  long long int res = 1;\n  x = x % p;\n  if (x == 0) {\n    return 0;\n  }\n  while (y > 0) {\n    if (y & 1) {\n      res = (res * x) % p;\n    }\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\ninline long long int inversePrimeModular(long long int a, long long int p) {\n  return power(a, p - 2, p);\n}\ninline void calcFact(long long int n) {\n  fact[0] = 1;\n  for (long long int i = 1; i <= n; i++) {\n    fact[i] = fact[i - 1] * i;\n    fact[i] = mod(fact[i]);\n  }\n}\ninline long long int ncr(long long int n, long long int r) {\n  if (n < r) return 0;\n  return mod(inversePrimeModular(mod(fact[n - r] * fact[r]), M) * fact[n]);\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int t;\n  cin >> t;\n  while (t--) {\n    long long int n;\n    cin >> n;\n    long long int arr[n];\n    for (long long int indexaa = 0; indexaa < n; indexaa++) cin >> arr[indexaa];\n    ;\n    sort(arr, arr + n);\n    long long int curr = arr[0];\n    long long int mx = arr[0];\n    for (long long int i = 1; i < n; i++) {\n      arr[i] = arr[i] - curr;\n      mx = max(mx, arr[i]);\n      curr += arr[i];\n    }\n    cout << mx << \"\\n\";\n  }\n  cerr << fixed << setprecision(10);\n  cerr << \"time taken : \" << (float)clock() \/ CLOCKS_PER_SEC << \" secs\"\n       << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 10;\nlong long n, a[N];\nvoid init() {}\nvoid solve() {\n  cin >> n;\n  long long res = -1e10;\n  for (long long i = 1; i <= n; i++) cin >> a[i];\n  sort(a + 1, a + n + 1);\n  for (long long i = 1; i <= n; i++) res = max(a[i] - a[i - 1], res);\n  cout << res << '\\n';\n}\nsigned main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","def solve():\n    n = int(input())\n    l = input()\n    l = [int(i) for i in l.split()]\n    try:\n      if (n == 1):\n        print(l[0])\n        return\n      elif(n == 2):\n        a = min(l)\n        l.remove(a)\n        a = max(a, l[0] - a)\n        print(a)\n        return\n      else:\n        l.sort()\n        mx = l[0]\n        for i in range(n - 1):\n          mx = max(mx, l[i + 1] - l[i])\n        print(mx)\n    \n    except EOFError as e:\n      print(\"Error\")\n\n#cases\nfor case in range(int(input())):\n  solve()\n","import math\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nM = 1000000007\nimport random\nimport heapq\nimport threading\nimport bisect\nimport time\nfrom functools import *\nfrom collections import *\nfrom itertools import *\nBUFSIZE = 8192\nimport array\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\")  # for fast input\ndef out(var): sys.stdout.write(str(var))  # for fast output, always take string\ndef lis(): return list(map(int, inp().split()))\ndef stringlis(): return list(map(str, inp().split()))\ndef sep(): return map(int, inp().split())\ndef strsep(): return map(str, inp().split())\ndef fsep(): return map(float, inp().split())\ndef inpu(): return int(inp())\n\ndef build(arr,a,b,st,node):\n    if a==b:\n        st[node] =  arr[a]\n        return st[node]\n    mid = (a+b)\/\/2\n    st[node] = min(build(arr,a,mid,st,2*node+1) , build(arr,mid+1,b,st,2*node+2))\n    return st[node]\n\ndef getmin(arr,a,b,l,r,st,node):\n    if l>b or r<a:\n        return float(\"inf\")\n    if l<=a and r>=b:\n        return st[node]\n    mid = (a+b)\/\/2\n    return min(getmin(arr,a,mid,l,r,st,2*node+1),getmin(arr,mid+1,b,l,r,st,2*node+2))\n\n\ndef main():\n    t = 1\n    t = int(input())\n    for _ in range(t):\n        n = inpu()\n        arr = lis()\n        arr.sort()\n        ans=arr[0]\n        for i in range(1,n):\n            ans = max(ans,arr[i]-arr[i-1])\n        print(ans)\n\n\nif __name__ == '__main__':\n    \"\"\"\n    threading.stack_size(2*10**8)\n    threading.Thread(target=main).start()\n    \"\"\"\n    main()\n","import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class competitive1 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int t = Integer.parseInt(in.nextLine());\n        for (int k = 0; k < t; k++) {\n            ArrayList<Integer> a = new ArrayList<>();\n            int n = in.nextInt();\n            for (int i =0; i<n; i++){\n                a.add(in.nextInt());\n            }\n            Collections.sort(a);\n            int cumulativeSub = 0;\n            int min;\n            int answer = a.get(0);\n            for(int i =0; i < a.size(); i++){\n                min = a.get(i) - cumulativeSub;\n                cumulativeSub = cumulativeSub + min;\n                if(min > answer){\n                    answer = min;\n                }\n            }\n            System.out.println(answer);\n        }\n    }\n}","import sys\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\ninp_vars_int = lambda: map(int, input().split())\ninp_list_int = lambda: list(map(int, input().split()))\n\nt = int(input())\n\nfor _ in range(t):\n    _ = input()\n    a = inp_list_int()\n    n = len(a)\n    a_s = sorted(a)\n    diff = [a_s[i] - a_s[i-1] for i in range(1, n)]\n    d_s = sorted(diff)\n    if n == 1:\n        print(a[0])\n    else:\n        print(max(a_s[0], max(d_s)))","t= int(input())\nres=[]\nfor i in range(t):\n    n= int(input())\n    l=input().split()\n    l=[int(i) for i in l]\n    l.sort()\n    sum=0\n    max=-10**9-1\n    for i in range(n):\n        # if i-sum>=0:\n        #     break\n\n        # else:\n        #     sum+=i\n        # temp=l[i]\n        l[i]-=sum\n        sum+=l[i]\n\n        if l[i]>max:\n            max=l[i]\n\n\n    res.append(max)\n\nfor i in res:\n    print(i)\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst long long MOD2 = 998244353;\nlong long power(long long a, long long b) {\n  long long res = 1;\n  a = a % MOD;\n  while (b > 0) {\n    if (b & 1) {\n      res = (res * a) % MOD;\n    }\n    a = (a * a) % MOD;\n    b >>= 1;\n  }\n  return res;\n}\nlong long fermat_inv(long long y) { return power(y, MOD - 2); }\nlong long gcd(long long a, long long b) { return (b == 0) ? a : gcd(b, a % b); }\nvoid solveQuestion() {\n  long long n;\n  cin >> n;\n  vector<long long> arr(n);\n  for (long long &x : arr) {\n    cin >> x;\n  }\n  sort(arr.begin(), arr.end());\n  long long ans = arr[0];\n  for (long long i = 1; i < n; i++) {\n    ans = max(ans, arr[i] - arr[i - 1]);\n  }\n  cout << ans << \"\\n\";\n}\nint32_t main(int32_t argc, char const *argv[]) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long tt = 1;\n  cin >> tt;\n  while (tt-- > 0) {\n    solveQuestion();\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  int n;\n  cin >> n;\n  multiset<long long> order;\n  for (int i = 0; i < n; ++i) {\n    long long a;\n    cin >> a;\n    order.insert(a);\n  }\n  long long add = 0, ans = -1e18;\n  while (order.size() > 1) {\n    long long cur = *order.begin() + add;\n    ans = max(ans, cur);\n    add -= cur;\n    order.erase(order.begin());\n  }\n  ans = max(ans, *order.begin() + add);\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) solve();\n  return 0;\n}\n","import java.util.*;\nimport java.io.*;\n\/* Name of the class has to be \"Main\" only if the class is public. *\/\npublic class d3\n{\n    static int odd = 0;\n    static int even = 0;\n    static HashSet<Integer> set;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        while(n-->0){\n            st = new StringTokenizer(br.readLine());\n            int len = Integer.parseInt(st.nextToken());\n            st = new StringTokenizer(br.readLine());\n            ArrayList<Integer> al = new ArrayList<>();\n            while(st.hasMoreTokens()){\n                al.add(Integer.parseInt(st.nextToken()));\n            }\n            Collections.sort(al);\n            int min = al.get(0);\n            for(int i = 0;i<len-1;i++){\n               int diff = Math.abs(al.get(i)-al.get(i+1));\n               min = Math.max(min,diff);\n            }\n            System.out.println(min);\n        }\n   }\nclass rat_maze{\n    int[][] maze;\n    int[][] ans;\n    int n;\n    int m;\n    rat_maze(int[][] maze,int n,int m){\n        this.maze = maze;\n        this.n = n;\n        this.m = m;\n        this.ans = new int[n][m];\n    }\n    boolean print_maze(int[][] maze,int i,int j){\n      if(i == n-1 && j == m-1 && maze[i][j] == 1){\n          return true;\n      }\n      if(is_safe(maze,i,j)){\n          ans[i][j] = 1;\n              print_maze(maze, i+1, j);\n            print_maze(maze, i,j+1);\n      }\n      ans[i][j] = 0;\n      return false;\n    }\n    boolean is_safe(int[][] maze,int i,int j){\n        if(i < 0 || j < 0 || i >= maze.length || j >= maze[0].length || maze[i][j] == 0){\n            return false;\n        }\n        return true;\n    }\n    void print_ans(){\n        for(int i = 0;i<ans.length;i++){\n            for(int j=0;j<ans[0].length;j++){\n                System.out.print(ans[i][j]+\" \");\n            }\n            System.out.println();\n        }\n    }\n}\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false), cin.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> v(n);\n    for (auto &p : v) {\n      cin >> p;\n    }\n    vector<long long> ans;\n    sort(v.begin(), v.end());\n    reverse(v.begin(), v.end());\n    long long x = v[v.size() - 1];\n    if (x < 0 && v.size() > 1) v.pop_back();\n    ans.push_back(x);\n    if (n > 1) {\n      for (auto &p : v) {\n        p = p - x;\n      }\n    }\n    ans.push_back(v[v.size() - 1]);\n    for (int i = 1; i <= v.size() - 1; i++) {\n      ans.push_back(v[i - 1] - v[i]);\n    }\n    if (v.size() == 1) ans.push_back(v[0]);\n    sort(ans.begin(), ans.end());\n    cout << ans[ans.size() - 1] << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint t;\nint d[1000010];\nint main() {\n  cin >> t;\n  while (t--) {\n    int n, m = -(1 << 30);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n      cin >> d[i];\n    }\n    sort(d + 1, d + n + 1);\n    for (int i = n; i >= 1; i--) {\n      d[i] -= d[i - 1];\n      m = max(m, d[i]);\n    }\n    cout << m << endl;\n  }\n  return 0;\n}\n","t=int(input())\nfor i in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    a.sort()\n    li=[a[0]]\n    for i in range(1,n):\n        li.append(a[i]-a[i-1])\n    print(max(li))","#include <bits\/stdc++.h>\nusing namespace std;\ndouble EPS = 1e-9;\nconst long long PL = (long long)2e18;\nlong long mod = 1000000007;\nlong long INFF = 1000000000000000005LL;\ndouble PI = acos(-1);\nlong long dirx[8] = {-1, 0, 0, 1, -1, -1, 1, 1};\nlong long diry[8] = {0, 1, -1, 0, -1, 1, -1, 1};\nlong long minn(long long a, long long b, long long c) {\n  if (a < b && a < c) return a;\n  if (b < a && b < c) return b;\n  return c;\n}\nvoid primes(long long n) {\n  bool prime[n + 1];\n  memset(prime, true, sizeof(prime));\n  for (long long p = 2; p * p <= n; p++) {\n    if (prime[p] == true) {\n      for (long long i = p * p; i <= n; i++) {\n        prime[i] = false;\n      }\n    }\n  }\n}\nbool issorted(long long a[], long long b[], long long n) {\n  for (long long i = 0; i < n; i++) {\n    if (a[i] != b[i]) return false;\n  }\n  return true;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return (a \/ gcd(a, b)) * b; }\nlong long binarySearch(long long arr[], long long l, long long r, long long x) {\n  while (l <= r) {\n    long long m = l + (r - l) \/ 2;\n    if (arr[m] == x) return m;\n    if (arr[m] < x)\n      l = m + 1;\n    else\n      r = m - 1;\n  }\n  return -1;\n}\nbool isPerfectSquare(long long x) {\n  long long left = 1, right = x;\n  while (left <= right) {\n    long long mid = (left + right) \/ 2;\n    if (mid * mid == x) {\n      return true;\n    }\n    if (mid * mid < x) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return false;\n}\nlong long square(long long n) {\n  if (n == 0) return 0;\n  if (n < 0) n = -n;\n  long long x = n >> 1;\n  if (n & 1)\n    return ((square(x) << 2) + (x << 2) + 1);\n  else\n    return (square(x) << 2);\n}\nlong long power(long long a, long long b, long long P = mod) {\n  long long res = 1;\n  for (; b; b >>= 1, a = 1ll * a * a % P)\n    if (b & 1) res = 1ll * res * a % P;\n  return res;\n}\nvoid permute(string s, long long l, long long r, set<string> &perm) {\n  if (l == r) {\n    perm.insert(s);\n  } else {\n    for (long long i = l; i <= r; i++) {\n      swap(s[l], s[i]);\n      permute(s, l + 1, r, perm);\n      swap(s[l], s[i]);\n    }\n  }\n}\nclass Offset {\n public:\n  multiset<long long> st;\n  long long delta;\n  long long fetch() { return (*st.begin()) + delta; }\n  void decrease(long long x) { delta -= x; }\n  void add(long long x) { st.insert(x - delta); }\n  void rem() { st.erase(st.begin()); }\n};\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> a(n);\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  multiset<long long> ms(a.begin(), a.end());\n  Offset obj;\n  for (long long i = 0; i < n; i++) {\n    obj.add(a[i]);\n  }\n  sort(a.begin(), a.end());\n  long long res = a[0];\n  for (long long i = 0; i < n; i++) {\n    long long temp = obj.fetch();\n    res = max(res, temp);\n    obj.decrease(temp);\n    obj.rem();\n  }\n  cout << res << '\\n';\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  ;\n  long long t;\n  t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long N_max = 2e5;\nlong long A[N_max + 5];\nvoid run_case() {\n  long long n, i, ans, carry, temp;\n  cin >> n;\n  for (i = 0; i < n; i++) {\n    cin >> A[i];\n  }\n  sort(A, A + n);\n  ans = A[0], carry = A[0];\n  for (i = 1; i < n; i++) {\n    A[i] -= carry;\n    ans = max(ans, A[i]);\n    carry += A[i];\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long T = 1;\n  cin >> T;\n  while (T--) run_case();\n  return 0;\n}\n","t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a = sorted(a)\n    for i in range(n-1, 0, -1):\n        a[i] -= a[i-1]\n    print(max(a))","#include <bits\/stdc++.h>\nusing namespace std;\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  long long t, n, sum, min;\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    sum = 0;\n    vector<long long> a(n);\n    for (long long i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    min = a[0];\n    sum = a[0];\n    for (long long i = 1; i < n; i++) {\n      a[i] -= sum;\n      if (min <= (a[i])) {\n        min = a[i];\n      }\n      sum += a[i];\n    }\n    cout << min << '\\n';\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int ta = 1;\n  cin >> ta;\n  while (ta--) {\n    int n;\n    cin >> n;\n    long long a[n];\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a, a + n);\n    long long res = a[0];\n    long long sub = a[0];\n    for (int i = 1; i < n; i++) {\n      long long can = a[i] - sub;\n      res = max(res, can);\n      sub += can;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n","t = int(input())\nfor case in range(t):\n  n = int(input())\n  a = list(map(int,input().split()))\n  a.sort()\n  ans = -float('inf')\n  count = 0\n  for i in range(n):\n      a[i]-=count\n      ans = max(ans,a[i])\n      count+=a[i]\n  print(ans)","for i in range(int(input())):\n    n = int(input())\n    arr = list(map(int,input().split()))\n    arr.sort()\n    m = -10**9-1\n    for i in range(len(arr)-1):\n        x = arr[i+1] - arr[i]\n        m = max(m,x)\n    if len(arr) > 1:\n        print(max(arr[0],m))\n    else:\n        print(arr[0])","a = int(input())\nres = []\nfor i in range(a):\n    k = int(input())\n    n = input().split()\n    for i in range(k):\n        n[i] = int(n[i])\n    n = sorted(n)\n    m = n[0]\n    for i in range(k - 1):\n        if n[i + 1] - n[i] > m:\n            m = n[i + 1] - n[i]\n    res.append(m)\nfor i in res:\n    print(i)","import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    static long startTime = System.currentTimeMillis();\n\n    \/\/ for global initializations and methods starts here\n\n    \/\/ global initialisations and methods end here\n\n    static void run() {\n        boolean tc = true;\n        AdityaFastIO r = new AdityaFastIO();\n        \/\/FastReader r = new FastReader();\n\n        try (OutputStream out = new BufferedOutputStream(System.out)) {\n\n            \/\/long startTime = System.currentTimeMillis();\n\n            int testcases = tc ? r.ni() : 1;\n            int tcCounter = 1;\n            \/\/ Hold Here Sparky------------------->>>\n            \/\/ Solution Starts Here\n\n            start:\n            while (testcases-- > 0) {\n\n                int n = r.ni();\n                List<Long> al = new ArrayList<>();\n                for (int i = 0; i < n; i++) al.add(r.nl());\n\n                boolean neg = Collections.min(al) < 0;\n\n                Collections.sort(al);\n\n                if (n == 1) {\n                    out.write((al.get(0) + \" \").getBytes());\n                    out.write((\"\\n\").getBytes());\n                    continue start;\n                }\n\n                long first = al.get(0);\n                int count = 0;\n                if (neg) {\n                    for (int i = 1; i < n; i++) {\n                        al.set(i, al.get(i) - first);\n                    }\n                    count++;\n                }\n\n                long min = al.get(count);\n                long get = al.get(count);\n\n                int i = count;\n                while (i < n) {\n                    al.set(i, al.get(i) - get);\n                    get += al.get(i);\n                    min = Math.max(al.get(i), min);\n                    i++;\n                }\n\n                out.write((min + \" \").getBytes());\n                out.write((\"\\n\").getBytes());\n\n            }\n            \/\/ Solution Ends Here\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class AdityaFastIO {\n        final private int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n        public BufferedReader br;\n        public StringTokenizer st;\n\n        public AdityaFastIO() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public AdityaFastIO(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String word() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String line() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[100000001]; \/\/ line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int ni() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public long nl() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public double nd() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') \/ (div *= 10);\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null) return;\n            din.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        run();\n    }\n\n    static long mod = 998244353;\n\n    static long modInv(long base, long e) {\n        long result = 1;\n        base %= mod;\n        while (e > 0) {\n            if ((e & 1) > 0) result = result * base % mod;\n            base = base * base % mod;\n            e >>= 1;\n        }\n        return result;\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String word() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String line() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int ni() {\n            return Integer.parseInt(word());\n        }\n\n        long nl() {\n            return Long.parseLong(word());\n        }\n\n        double nd() {\n            return Double.parseDouble(word());\n        }\n    }\n\n    static int MOD = (int) (1e9 + 7);\n\n    static long powerLL(long x, long n) {\n        long result = 1;\n        while (n > 0) {\n            if (n % 2 == 1) result = result * x % MOD;\n            n = n \/ 2;\n            x = x * x % MOD;\n        }\n        return result;\n    }\n\n    static long powerStrings(int i1, int i2) {\n        String sa = String.valueOf(i1);\n        String sb = String.valueOf(i2);\n        long a = 0, b = 0;\n        for (int i = 0; i < sa.length(); i++) a = (a * 10 + (sa.charAt(i) - '0')) % MOD;\n        for (int i = 0; i < sb.length(); i++) b = (b * 10 + (sb.charAt(i) - '0')) % (MOD - 1);\n        return powerLL(a, b);\n    }\n\n    static long gcd(long a, long b) {\n        if (a == 0) return b;\n        else return gcd(b % a, a);\n    }\n\n    static long lcm(long a, long b) {\n        return (a * b) \/ gcd(a, b);\n    }\n\n    static long lower_bound(int[] arr, int x) {\n        int l = -1, r = arr.length;\n        while (l + 1 < r) {\n            int m = (l + r) >>> 1;\n            if (arr[m] >= x) r = m;\n            else l = m;\n        }\n        return r;\n    }\n\n    static int upper_bound(int[] arr, int x) {\n        int l = -1, r = arr.length;\n        while (l + 1 < r) {\n            int m = (l + r) >>> 1;\n            if (arr[m] <= x) l = m;\n            else r = m;\n        }\n        return l + 1;\n    }\n\n    static void addEdge(ArrayList<ArrayList<Integer>> graph, int edge1, int edge2) {\n        graph.get(edge1).add(edge2);\n        graph.get(edge2).add(edge1);\n    }\n\n    public static class Pair implements Comparable<Pair> {\n        int first;\n        int second;\n\n        public Pair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(Pair o) {\n            \/\/ TODO Auto-generated method stub\n            if (this.first != o.first)\n                return (int) (this.first - o.first);\n            else return (int) (this.second - o.second);\n        }\n    }\n\n    public static class PairC<X, Y> implements Comparable<PairC> {\n        X first;\n        Y second;\n\n        public PairC(X first, Y second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(PairC o) {\n            \/\/ TODO Auto-generated method stub\n            return o.compareTo((PairC) first);\n        }\n    }\n\n    static boolean isCollectionsSorted(List<Long> list) {\n        if (list.size() == 0 || list.size() == 1) return true;\n        for (int i = 1; i < list.size(); i++) if (list.get(i) <= list.get(i - 1)) return false;\n        return true;\n    }\n\n    static boolean isCollectionsSortedReverseOrder(List<Long> list) {\n        if (list.size() == 0 || list.size() == 1) return true;\n        for (int i = 1; i < list.size(); i++) if (list.get(i) >= list.get(i - 1)) return false;\n        return true;\n    }\n\n}","for tc in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    if n==1:\n        print(l[0])\n        continue\n    l.sort()\n    maxi=l[0]\n    for i in range(1,n):\n        maxi=max(l[i]-l[i-1],maxi)\n    print(maxi) ","#!\/usr\/bin\/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\ndef solve(n, a):\n    if n == 1:\n        return a[0]\n    a.sort()\n    m = a[0]\n    for i in range(1, n):\n        m = max(m, a[i] - a[i - 1])\n    return m\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = [int(x) for x in input().split()]\n        print(solve(n, a))\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n","for s in[*open(0)][2::2]:a=0,*sorted(map(int,s.split()));print(max(y-x for x,y in zip(a,a[1:])))","\/*\n * Everything is Hard \n * Before Easy \n * Jai Mata Dii \n *\/ \n \nimport java.util.*;\nimport java.io.*; \n  \npublic class Main {\n\tstatic class FastReader{ BufferedReader br;StringTokenizer st;public FastReader(){br = new BufferedReader(new InputStreamReader(System.in));}String next(){while (st == null || !st.hasMoreElements()){try{st = new StringTokenizer(br.readLine());}catch (IOException  e){e.printStackTrace();}}return st.nextToken();}int nextInt(){ return Integer.parseInt(next());}long nextLong(){return Long.parseLong(next());}double nextDouble(){return Double.parseDouble(next());}String nextLine(){String str = \"\"; try{str = br.readLine(); } catch (IOException e) {e.printStackTrace();} return str; }} \n\tstatic long mod = (long)(1e9+7); \n\/\/\t static long mod = 998244353; \n\/\/\t static Scanner sc = new Scanner(System.in); \n\tstatic FastReader sc = new FastReader(); \n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tpublic static void main (String[] args) {\n\t\tint ttt = 1;\n\t\tttt = sc.nextInt();\n\t\tz :for(int tc=1;tc<=ttt;tc++){\n\t\t\tint n = sc.nextInt();\n\t\t\tlong arr[] = new long[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tarr[i] = sc.nextLong();\n\t\t\t}\n\t\t\tsort(arr);\n\t\t\tArrayList<Long> a = new ArrayList<>();\n\t\t\tint i = 0;\n\t\t\twhile(i<n) {\n\t\t\t\ta.add(arr[i++]);\n\t\t\t}\n\t\t\tlong ans = Math.min(a.get(0), a.get(n-1));\n\t\t\tint l=0, h=n-1;\n\t\t\tlong cur = 0;\n \n\t\t\twhile(l<=h) {\n\t\t\t\tlong now = cur + Math.min(a.get(l)-cur, a.get(h)-cur);\n\t\t\t\tif(a.get(l)-cur > a.get(h)-cur) {\n\t\t\t\t\tans = Math.max(ans, a.get(h)-cur);\n\t\t\t\t\tcur = now;\n\t\t\t\t\th--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans = Math.max(ans, a.get(l)-cur);\n\t\t\t\t\tcur = now;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.write(ans+\"\\n\");\n\t\t}\n\t\tout.close();\n\t}\n\tstatic long pow(long a, long b){long ret = 1;while(b>0){if(b%2 == 0){a = (a*a)%mod;b \/= 2;}else{ret = (ret*a)%mod;b--;}}return ret%mod;}\n\tstatic long gcd(long a,long b){if(b==0) return  a; return gcd(b,a%b); } \n\tprivate static void sort(int[] a) {List<Integer> k = new ArrayList<>();for(int val : a) k.add(val);Collections.sort(k);for(int i=0;i<a.length;i++) a[i] = k.get(i);} \n\tprivate static void ini(List<Integer>[] tre2){for(int i=0;i<tre2.length;i++){tre2[i] = new ArrayList<>();}} \n\tprivate static void init(List<int[]>[] tre2){for(int i=0;i<tre2.length;i++){tre2[i] = new ArrayList<>();}} \n\tprivate static void sort(long[] a) {List<Long> k = new ArrayList<>();for(long val : a) k.add(val);Collections.sort(k);for(int i=0;i<a.length;i++) a[i] = k.get(i);} \n}","#include <bits\/stdc++.h>\nusing namespace std;\nconst int maxn = 2e6;\nlong long a[maxn];\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    sort(a + 1, a + 1 + n);\n    long long maxx = a[1];\n    for (int i = 2; i <= n; i++) {\n      if (a[i] - a[i - 1] > maxx) maxx = a[i] - a[i - 1];\n    }\n    cout << maxx << endl;\n  }\n}\n","import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n    \/\/ Graph\n    \/\/ prefix sums\n    \/\/inputs\n    public static void main(String args[])throws Exception{\n        Input sc=new Input();\n        precalculates p=new precalculates();\n        StringBuilder sb=new StringBuilder();\n        int t=sc.readInt();\n        for(int f=0;f<t;f++){\n            int n=sc.readInt();\n            long a[]=sc.readArrayLong();\n            HashSet<Long> map=new HashSet<>();\n            for(int i=0;i<n;i++){\n                map.add(a[i]);\n            }\n            int previous=a.length;\n            n=map.size();\n            a=new long[n];\n            int j=0;\n            for(Long val:map){\n                a[j++]=val;\n            }\n            Arrays.sort(a);\n            long sum=0;\n            long prev=0;long ans=Long.MIN_VALUE;\n            for(int i=0;i<n && n!=1;i++){\n                sum=sum+((a[i])-prev);\n                ans=Math.max(ans,a[i]-prev);\n                prev=sum;\n                \/\/System.out.println(sum+\"%%\");\n            }\n            \/*if(a.length>1 && a[0]==0) {\n                ans = Math.max(ans, a[n - 2]);\n            }else*\/ if(a.length>0 && a[n-1]!=0){\n                ans=Math.max(ans,a[n-1]-prev);\n            }\n\n\/\/            if(n>0 && a[0]==0)\n\/\/            {\n\/\/                ans=0;\n\/\/            }\n            if(n==1 && previous!=1){\n                ans=Math.max(a[n-1],0);\n            }\n            if(ans!=Long.MIN_VALUE)\n                sb.append(ans+\"\\n\");\n            else\n                sb.append(a[n-1]+\"\\n\");\n\n        }\n        \/\/ 1 2 7 10   1\n        \/\/ 0 1 6 9    2\n        \/\/ 0 0 5 8\n        \/\/ -1 0 2\n        \/\/ 0  1 3\n        \/\/ 0 0 2\n        System.out.print(sb);\n    }\n}\nclass Input{\n    BufferedReader br;\n    StringTokenizer st;\n    Input(){\n        br=new BufferedReader(new InputStreamReader(System.in));\n        st=new StringTokenizer(\"\");\n    }\n    public int[] readArray() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        int a[]=new int[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Integer.parseInt(st.nextToken());\n        }\n        return a;\n    }\n    public long[] readArrayLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        long a[]=new long[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Long.parseLong(st.nextToken());\n        }\n        return a;\n    }\n    public int readInt() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Integer.parseInt(st.nextToken());\n    }\n    public long readLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Long.parseLong(st.nextToken());\n    }\n    public String readString() throws Exception{\n        return br.readLine();\n    }\n    public int[][] read2dArray(int n,int m)throws Exception{\n        int a[][]=new int[n][m];\n        for(int i=0;i<n;i++){\n            st=new StringTokenizer(br.readLine());\n            for(int j=0;j<m;j++){\n                a[i][j]=Integer.parseInt(st.nextToken());\n            }\n        }\n        return a;\n    }\n}\nclass precalculates{\n    public int[] prefixSumOneDimentional(int a[]){\n        int n=a.length;\n        int dp[]=new int[n];\n        for(int i=0;i<n;i++){\n            if(i==0)\n                dp[i]=a[i];\n            else\n                dp[i]=dp[i-1]+a[i];\n        }\n        return dp;\n    }\n    public int[] postSumOneDimentional(int a[]) {\n        int n = a.length;\n        int dp[] = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            if (i == n - 1)\n                dp[i] = a[i];\n            else\n                dp[i] = dp[i + 1] + a[i];\n        }\n        return dp;\n    }\n    public int[][] prefixSum2d(int a[][]){\n        int n=a.length;int m=a[0].length;\n        int dp[][]=new int[n+1][m+1];\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=m;j++){\n                dp[i][j]=a[i-1][j-1]+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];\n            }\n        }\n        return dp;\n    }\n    public long pow(long a,long b){\n        long mod=1000000007;\n        long ans=0;\n        if(b<=0)\n            return 1;\n        if(b%2==0){\n            ans=pow(a,b\/2)%mod;\n            return ((ans%mod)*(ans%mod))%mod;\n        }else{\n            return ((a%mod)*(ans%mod))%mod;\n        }\n    }\n\n}\nclass GraphInteger{\n    HashMap<Integer,vertex> vtces;\n    class vertex{\n        HashMap<Integer,Integer> children;\n        public vertex(){\n            children=new HashMap<>();\n        }\n    }\n    public GraphInteger(){\n        vtces=new HashMap<>();\n    }\n    public void addVertex(int a){\n        vtces.put(a,new vertex());\n    }\n    public void addEdge(int a,int b,int cost){\n        if(!vtces.containsKey(a)){\n            vtces.put(a,new vertex());\n        }\n        if(!vtces.containsKey(b)){\n            vtces.put(b,new vertex());\n        }\n        vtces.get(a).children.put(b,cost);\n\/\/        vtces.get(b).children.put(a,cost);\n    }\n    public boolean isCyclicDirected(){\n        boolean isdone[]=new boolean[vtces.size()+1];\n        boolean check[]=new boolean[vtces.size()+1];\n        for(int i=1;i<=vtces.size();i++) {\n            if (!isdone[i] && isCyclicDirected(i,isdone, check)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private boolean isCyclicDirected(int i,boolean isdone[],boolean check[]){\n        if(check[i])\n            return true;\n        if(isdone[i])\n            return false;\n        check[i]=true;\n        isdone[i]=true;\n        Set<Integer> set=vtces.get(i).children.keySet();\n        for(Integer ii:set){\n            if(isCyclicDirected(ii,isdone,check))\n                return true;\n        }\n        check[i]=false;\n        return false;\n    }\n}","import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\nimport static java.lang.Math.abs;\nimport static java.lang.Math.max;\nimport static java.lang.System.*;\nimport static java.util.Arrays.sort;\nimport static java.util.Collections.replaceAll;\nimport static java.util.Collections.reverseOrder;\n\npublic class C {\n    public static final boolean LOCAL = System.getProperty(\"ONLINE_JUDGE\") == null;\n    \/\/ public static final boolean LOCAL = System.getProperty(\"LOCAL\")!=null;\n    public static final String ANSI_RED = \"\\u001B[31m\";\n    public static final String ANSI_RESET = \"\\u001B[0m\";\n    static final int M = (int) 1e9 + 7;\n    static final long MM = (long) M * M;\n    static final int MAX = Integer.MAX_VALUE;\n    static final int MIN = Integer.MIN_VALUE;\n    static final int SIZE = (int) 1e9 * 2;\n    static ArrayList<Integer> primes = new ArrayList<>();\n    \/\/static Scanner sc = new Scanner(System.in);\n    static FastReader sc = new FastReader();\n    static long startTime;\n    static long endTime;\n    static boolean[] prime;\n    static int[] visited;\n    static ArrayList<ArrayList<Integer>> graph;\n    static ArrayList<Integer> dfs;\n    static boolean isCyclic = false;\n\n    public static int swap(int... args) {\n        return args[0];\n    }\n\n    public static void main(String[] args) throws IOException {\n        do {\n            startTime = currentTimeMillis();\n            \/\/setOut(new PrintStream(\"output\"));\n            \/\/setIn(new FileInputStream(\"input\"));\n            lcms[0] = 2;\n            for (int k = 1 ; k < lcms.length; k++) {\n                lcms[k] = lcm(lcms[k-1],k+2);\n            }\n\n            int T = sc.nextInt();while (T-- != 0)\n            {\n                solve();\n\n            }\n            endTime = currentTimeMillis();\n            long duration = endTime - startTime;\n            \/\/out.println(duration);\n            if (false) {\n                out.println(max(3, 2));\n                Integer[] ARRAY = new Integer[2];\n                ArrayList<Integer> LIST = new ArrayList<>();\n                LIST.add(2);\n                \/\/ sort(LIST, reverseOrder());\n                LIST.sort(reverseOrder());\n                sort(ARRAY, reverseOrder());\n                out.println(LIST + \" \" + Arrays.toString(ARRAY));\n            }\n        } while (LOCAL);\n    }\n   static long[] lcms = new long[100000];\n    public static void solve(){\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        int n =sc.nextInt();\n    Integer [] arr = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            arr[i]=sc.nextInt();\n        }\n        Arrays.sort(arr);\n     \/\/   long ans = arr[n-1];\n        long sum = arr[0];\n        long min = arr[0];\n        for (int i = 1; i < n; i++) {\n            min = Long.max(min,arr[i]-sum);\n            sum+=(arr[i]-sum);\n\n\n        }\n        out.println(min);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    }\n    static void dfs(int src) {\n        visited[src] = 1;\n        for (Integer integer : graph.get(src)) {\n            if (visited[integer] != 1) {\n                dfs(integer);\n            }\n        }\n        dfs.add(src);\n\n    }\n\n    static void detectCycle(int src) {\n        visited[src] = 2;\n        for (Integer integer : graph.get(src)) {\n            if (visited[integer] == 0) {\n                detectCycle(integer);\n            } else if (visited[integer] == 2) {\n                isCyclic = true;\n                return;\n            }\n\n        }\n        visited[src] = 1;\n    }\n\n    static <Array, Target> int count(Array[] array, Target target) {\n        int cn = 0;\n        for (Array value : array) {\n            if (value.equals(target)) cn++;\n        }\n        return cn;\n    }\n\n    static int count(String string, char target) {\n        int cn = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (string.charAt(i) == target) cn++;\n        }\n        return cn;\n    }\n\n    static <Array> void revArray(Array[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n \/ 2; i++) {\n            Array temp = arr[i];\n            arr[i] = arr[n - i - 1];\n            arr[n - i - 1] = temp;\n        }\n\n    }\n\n    static <Array> void printArray(Array[] arr) {\n        int n = arr.length;\n        for (Array array : arr) out.print(array + \" \");\n        out.println();\n    }\n\n    static void yes() {\n        out.println(\"YES\");\n    }\n\n    static void no() {\n        out.println(\"NO\");\n    }\n\n    public static boolean isPal(String s) {\n        StringBuilder stringBuilder = new StringBuilder(s);\n        return s.equals(stringBuilder.reverse().toString());\n    }\n\n    public static int lowerBound(Integer[] array, int length, int value) {\n        int low = -1;\n        int hi = length;\n        while (low + 1 < hi) {\n            int mid = (low + hi) \/ 2;\n            if (array[mid] <= value) {\n                low = mid;\n            } else {\n                hi = mid;\n            }\n        }\n        return low;\n    }\n\n    public static int upperBound(Integer[] array, int length, int value) {\n        int low = -1;\n        int hi = length;\n        while (low + 1 < hi) {\n            int mid = (low + hi) >> 1;\n            if (array[mid] >= value) {\n                hi = mid;\n            } else low = mid;\n        }\n        return hi;\n    }\n\n    public static int binarySearch(Integer[] arr, int length, int value) {\n        int low = 0;\n        int hi = length - 1;\n        int ans = -1;\n        while (low <= hi) {\n            int mid = (low + hi) >> 1;\n            if (arr[mid] > value) {\n                hi = mid - 1;\n            } else if (arr[mid] < value) {\n                low = mid + 1;\n            } else {\n                ans = mid;\n                break;\n            }\n        }\n        return ans;\n    }\n\n    public static long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public static long lcm(long  a, long b) {\n        return a \/ gcd(a, b) * b;\n    }\n\n    public static int countDivs(int n) {\n        int cn = 0;\n        int sqr = (int) Math.sqrt(n);\n        for (int i = 1; i <= sqr; ++i) {\n            if (n % i == 0) {\n                ++cn;\n            }\n        }\n        cn *= 2;\n        if (sqr * sqr == n) cn--;\n        return cn;\n    }\n\n    static void prime(int x) {\n        \/\/sieve algorithm. nlog(log(n)).\n        prime = new boolean[(x + 1)];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int i = 2; i * i <= x; i++)\n            if (prime[i])\n                for (int j = i * i; j <= x; j += i)\n                    prime[j] = false;\n    }\n\n    static boolean isEven(long x) {\n        return x % 2 == 0;\n    }\n\n    static boolean isPrime(long x) {\n        boolean flag = true;\n        int sqr = (int) Math.sqrt(x);\n        if (x < 2) return false;\n        for (int i = 2; i <= sqr; i++) {\n            if (x % i == 0) {\n                flag = false;\n                break;\n            }\n        }\n        return flag;\n    }\n\n    static long factorial(long x) {\n        long total = 1;\n        for (int i = 2; i <= x; i++)\n            total = (total * i) % M;\n        return total;\n    }\n\n    static long power(long x, long n) {\n        if (n == 0) {\n            return 1;\n        }\n        long pow = power(x, n \/ 2L);\n        if ((n & 1) == 1) {\n            return (x * (pow) * (pow));\n        }\n        return (pow * pow);\n    }\n\n    private static <T> String ts(T t) {\n        if (t == null) {\n            return \"null\";\n        }\n        try {\n            return ts((Iterable) t);\n        } catch (ClassCastException e) {\n            if (t instanceof int[]) {\n                String s = Arrays.toString((int[]) t);\n                return \"{\" + s.substring(1, s.length() - 1) + \"}\";\n            } else if (t instanceof long[]) {\n                String s = Arrays.toString((long[]) t);\n                return \"{\" + s.substring(1, s.length() - 1) + \"}\";\n            } else if (t instanceof char[]) {\n                String s = Arrays.toString((char[]) t);\n                return \"{\" + s.substring(1, s.length() - 1) + \"}\";\n            } else if (t instanceof double[]) {\n                String s = Arrays.toString((double[]) t);\n                return \"{\" + s.substring(1, s.length() - 1) + \"}\";\n            } else if (t instanceof boolean[]) {\n                String s = Arrays.toString((boolean[]) t);\n                return \"{\" + s.substring(1, s.length() - 1) + \"}\";\n            }\n            try {\n                return ts((Object[]) t);\n            } catch (ClassCastException e1) {\n                return t.toString();\n            }\n        }\n    }\n\n    private static <T> String ts(T[] arr) {\n        StringBuilder ret = new StringBuilder();\n        ret.append(\"{\");\n        boolean first = true;\n        for (T t : arr) {\n            if (!first) {\n                ret.append(\", \");\n            }\n            first = false;\n            ret.append(ts(t));\n        }\n        ret.append(\"}\");\n        return ret.toString();\n    }\n\n    private static <T> String ts(Iterable<T> iter) {\n        StringBuilder ret = new StringBuilder();\n        ret.append(\"{\");\n        boolean first = true;\n        for (T t : iter) {\n            if (!first) {\n                ret.append(\", \");\n            }\n            first = false;\n            ret.append(ts(t));\n        }\n        ret.append(\"}\");\n        return ret.toString();\n    }\n\n    public static void dbg(Object... o) {\n        if (LOCAL) {\n            System.err.print(\"Line #\" + Thread.currentThread().getStackTrace()[2].getLineNumber() + \": [\");\n            for (int i = 0; i < o.length; i++) {\n                if (i != 0) {\n                    System.err.print(\", \");\n                }\n                System.err.print(ts(o[i]));\n            }\n            System.err.println(\"]\");\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static class Pair implements Comparable<Pair> {\n        private final int key;\n        private final int value;\n\n        public Pair(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        public int second() {\n            return value;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            return -Integer.compare(key, o.key);\n        }\n\n        @Override\n        public String toString() {\n            return \"Pair{\" + \"x=\" + key + \", y=\" + value + '}';\n        }\n    }\n\n}","import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\nimport static java.lang.Math.min;\nimport static java.lang.Math.max;\nimport static java.lang.Math.abs;\n\n@SuppressWarnings(\"unused\")\npublic class D {\n\tstatic boolean DEBUG = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInstant start = Instant.now();\n\t\tif (args.length == 2) {\n\t\t\tSystem.setIn(new FileInputStream(new File(\"D:\\\\program\\\\javaCPEclipse\\\\CodeForces\\\\src\\\\input.txt\")));\n\t\t\t\/\/ System.setOut(new PrintStream(new File(\"output.txt\")));\n\t\t\tSystem.setErr(new PrintStream(new File(\"D:\\\\program\\\\javaCPEclipse\\\\CodeForces\\\\src\\\\error.txt\")));\n\t\t\tDEBUG = true;\n\t\t}\n\t\tReader fs = new Reader();\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint t = fs.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tint n = fs.nextInt();\n\t\t\tArrayList<Integer>a = new ArrayList<Integer>();\n\t\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\t\ta.add(fs.nextInt());\n\t\t\t}\n\t\t\tCollections.sort(a);\n\t\t\tLazySegTree lst = new LazySegTree(n);\n\t\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\t\tlst.update(i, i, a.get(i));\n\t\t\t}\n\t\t\tint ans= Integer.MIN_VALUE;\n\t\t\tfor(int i = 0 ; i < n; i++) {\n\t\t\t\tint temp = lst.query(i, n-1);\n\t\t\t\tans = max(ans, temp);\n\t\t\t\tlst.update(i+1, n-1, -temp);\n\t\t\t}\n\t\t\tpw.println(ans);\n\t\t}\n\t\tInstant end = Instant.now();\n\t\tif (DEBUG) {\n\t\t\tpw.println(Duration.between(start, end));\n\t\t}\n\t\tpw.close();\n\t}\n\n\tpublic static void print(long a, long b, long c, PrintWriter pw) {\n\t\tpw.println(a + \" \" + b + \" \" + c);\n\t\treturn;\n\t}\n\n\tstatic class Reader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Reader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tint[] readArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] read2Array(int n, int m) {\n\t\t\tint a[][] = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\ta[i][j] = nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}\n}\n\nclass LazySegTree\n{\n    \/\/definitions\n    public int NULL = -1;\n    public int[] tree;\n    public int[] lazy;\n    public int length;\n\n    public LazySegTree(int N)\n    {\n        length = N;   int b;\n        for(b=0; (1<<b) < length; b++);\n        tree = new int[1<<(b+1)];\n        lazy = new int[1<<(b+1)];\n    }\n    public int query(int left, int right)\n    {\n        \/\/left and right are 0-indexed\n        return get(1, 0, length-1, left, right);\n    }\n    private int get(int v, int currL, int currR, int L, int R)\n    {\n        if(L > R)\n            return Integer.MAX_VALUE;\n        if(L <= currL && currR <= R)\n            return tree[v];\n        propagate(v);\n        int mid = (currL+currR)\/2;\n        return comb(get(v*2, currL, mid, L, Math.min(R, mid)),\n                get(v*2+1, mid+1, currR, Math.max(L, mid+1), R));\n    }\n    public void update(int left, int right, int delta)\n    {\n        add(1, 0, length-1, left, right, delta);\n\/\/        for(int x : tree) {\n\/\/        \tSystem.out.print(x + \" \");\n\/\/        }\n\/\/        System.out.println();\n    }\n    private void add(int v, int currL, int currR, int L, int R, int delta)\n    {\n        if(L > R)\n            return;\n        if(currL == L && currR == R)\n        {\n            \/\/exact covering\n            tree[v] += delta;\n            lazy[v] += delta;\n            return;\n        }\n        propagate(v);\n        int mid = (currL+currR)\/2;\n        add(v*2, currL, mid, L, Math.min(R, mid), delta);\n        add(v*2+1, mid+1, currR, Math.max(L, mid+1), R, delta);\n        tree[v] = comb(tree[v*2], tree[v*2+1]);\n    }\n    private void propagate(int v)\n    {\n        \/\/tree[v] already has lazy[v]\n        if(lazy[v] == 0)\n            return;\n        tree[v*2] += lazy[v];\n        lazy[v*2] += lazy[v];\n        tree[v*2+1] += lazy[v];\n        lazy[v*2+1] += lazy[v];\n        lazy[v] = 0;\n    }\n    private int comb(int a, int b)\n    {\n        return Math.min(a, b);\n    }\n}","\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class C {\n    static class RealScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n    \/\/    static class MultiTreeSet<E> {\n\/\/        TreeMap<E, Integer> freqTreeMap = new TreeMap<E, Integer>();\n\/\/        int size;\n\/\/\n\/\/        public MultiTreeSet() {\n\/\/        }\n\/\/\n\/\/        public MultiTreeSet(Collection<? extends E> c) {\n\/\/            for (E element : c)\n\/\/                add(element);\n\/\/        }\n\/\/\n\/\/        public int size() {\n\/\/            return size;\n\/\/        }\n\/\/\n\/\/        public void add(E element) {\n\/\/            Integer freq = freqTreeMap.get(element);\n\/\/            if (freq == null)\n\/\/                freqTreeMap.put(element, 1);\n\/\/            else\n\/\/                freqTreeMap.put(element, freq + 1);\n\/\/            ++size;\n\/\/        }\n\/\/\n\/\/        public void remove(E element) {\n\/\/            Integer freq = freqTreeMap.get(element);\n\/\/            if (freq != null) {\n\/\/                if (freq == 1)\n\/\/                    freqTreeMap.remove(element);\n\/\/                else\n\/\/                    freqTreeMap.put(element, freq - 1);\n\/\/                --size;\n\/\/            }\n\/\/        }\n\/\/\n\n    public static void main(String[] args) {\n        RealScanner sc = new RealScanner();\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            int n = sc.nextInt();\n            LinkedList<Long> l = new LinkedList<>();\n            for (int i = 0; i < n; i++) {\n                l.add(sc.nextLong());\n            }\n            Collections.sort(l, Collections.reverseOrder());\n            \/\/ System.out.println(l);\n            long max = Collections.min(l);\n            long con = max;\n            while (l.size() > 1) {\n                long val = l.get(l.size() - 2);\n                val = val - con;\n                con += val;\n                max = Math.max(max, val);\n                l.remove(l.size() - 1);\n\/\/                for (int i:l){\n\/\/                    System.out.println(i);\n\/\/                }\n                \/\/System.out.println(l);\n            }\n            System.out.println(max);\n        }\n    }\n}\n","\nimport java.io.*;\nimport java.util.*;\n\npublic final class Main {\n\n    static PrintWriter out = new PrintWriter(System.out);\n    static FastReader in = new FastReader();\n    static Pair[] moves = new Pair[]{new Pair(-1, 0), new Pair(0, 1), new Pair(1, 0), new Pair(0, -1)};\n    static int mod = (int) (1e9 + 7);\n    static int mod2 = 998244353;\n\n    public static void main(String[] args) {\n        int tt = i();\n        while (tt-- > 0) {\n            solve();\n        }\n        out.flush();\n    }\n\n    public static void solve() {\n        int n = i();\n        int[] a = input(n);\n        shuffleAndSort(a);\n        long ans = a[0];\n        for (int i = 1; i < n; i++) {\n            ans = Math.max(ans, a[i] - a[i-1]);\n        }\n\n        out.println(ans);\n    }\n\n    static long[] pre(int[] a) {\n        long[] pre = new long[a.length + 1];\n        pre[0] = 0;\n        for (int i = 0; i < a.length; i++) {\n            pre[i + 1] = pre[i] + a[i];\n        }\n        return pre;\n    }\n\n    static void print(char A[]) {\n        for (char c : A) {\n            out.print(c);\n        }\n        out.println();\n    }\n\n    static void print(boolean A[]) {\n        for (boolean c : A) {\n            out.print(c + \" \");\n        }\n        out.println();\n    }\n\n    static void print(int A[]) {\n        for (int c : A) {\n            out.print(c + \" \");\n        }\n        out.println();\n    }\n\n    static void print(long A[]) {\n        for (long i : A) {\n            out.print(i + \" \");\n        }\n        out.println();\n    }\n\n    static void print(List<Integer> A) {\n        for (int a : A) {\n            out.print(a + \" \");\n        }\n    }\n\n    static int i() {\n        return in.nextInt();\n    }\n\n    static long l() {\n        return in.nextLong();\n    }\n\n    static double d() {\n        return in.nextDouble();\n    }\n\n    static String s() {\n        return in.nextLine();\n    }\n\n    static int[][] inputWithIdx(int N) {\n        int A[][] = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            A[i] = new int[]{i, in.nextInt()};\n        }\n        return A;\n    }\n\n    static int[] input(int N) {\n        int A[] = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = in.nextInt();\n        }\n        return A;\n    }\n\n    static long[] inputLong(int N) {\n        long A[] = new long[N];\n        for (int i = 0; i < A.length; i++) {\n            A[i] = in.nextLong();\n        }\n        return A;\n    }\n\n    static int GCD(int a, int b) {\n        if (b == 0) {\n            return a;\n        } else {\n            return GCD(b, a % b);\n        }\n    }\n\n    static long GCD(long a, long b) {\n        if (b == 0) {\n            return a;\n        } else {\n            return GCD(b, a % b);\n        }\n    }\n\n    static long LCM(int a, int b) {\n        return (long) a \/ GCD(a, b) * b;\n    }\n\n    static long LCM(long a, long b) {\n        return a \/ GCD(a, b) * b;\n    }\n\n    static void shuffleAndSort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            int rand = (int) (Math.random() * arr.length);\n            int temp = arr[rand];\n            arr[rand] = arr[i];\n            arr[i] = temp;\n        }\n        Arrays.sort(arr);\n    }\n\n    static void shuffleAndSort(int[][] arr, Comparator<? super int[]> comparator) {\n        for (int i = 0; i < arr.length; i++) {\n            int rand = (int) (Math.random() * arr.length);\n            int[] temp = arr[rand];\n            arr[rand] = arr[i];\n            arr[i] = temp;\n        }\n        Arrays.sort(arr, comparator);\n    }\n\n    static void shuffleAndSort(long[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            int rand = (int) (Math.random() * arr.length);\n            long temp = arr[rand];\n            arr[rand] = arr[i];\n            arr[i] = temp;\n        }\n        Arrays.sort(arr);\n    }\n\n    static boolean isPerfectSquare(double number) {\n        double sqrt = Math.sqrt(number);\n        return ((sqrt - Math.floor(sqrt)) == 0);\n    }\n\n    static void swap(int A[], int a, int b) {\n        int t = A[a];\n        A[a] = A[b];\n        A[b] = t;\n    }\n\n    static long pow(long a, long b, int mod) {\n        long pow = 1;\n        long x = a;\n        while (b != 0) {\n            if ((b & 1) != 0) {\n                pow = (pow * x) % mod;\n            }\n            x = (x * x) % mod;\n            b \/= 2;\n        }\n        return pow;\n    }\n\n    static long pow(long a, long b) {\n        long pow = 1;\n        long x = a;\n        while (b != 0) {\n            if ((b & 1) != 0) {\n                pow *= x;\n            }\n            x = x * x;\n            b \/= 2;\n        }\n        return pow;\n    }\n\n    static long modInverse(long x, int mod) {\n        return pow(x, mod - 2, mod);\n    }\n\n    static boolean isPrime(long N) {\n        if (N <= 1) {\n            return false;\n        }\n        if (N <= 3) {\n            return true;\n        }\n        if (N % 2 == 0 || N % 3 == 0) {\n            return false;\n        }\n        for (int i = 5; i * i <= N; i = i + 6) {\n            if (N % i == 0 || N % (i + 2) == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static String reverse(String str) {\n        if (str == null) {\n            return null;\n        }\n        return new StringBuilder(str).reverse().toString();\n    }\n\n    public static String repeat(char ch, int repeat) {\n        if (repeat <= 0) {\n            return \"\";\n        }\n        final char[] buf = new char[repeat];\n        for (int i = repeat - 1; i >= 0; i--) {\n            buf[i] = ch;\n        }\n        return new String(buf);\n    }\n\n    public static int[] manacher(String s) {\n        char[] chars = s.toCharArray();\n        int n = s.length();\n        int[] d1 = new int[n];\n        for (int i = 0, l = 0, r = -1; i < n; i++) {\n            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);\n            while (0 <= i - k && i + k < n && chars[i - k] == chars[i + k]) {\n                k++;\n            }\n            d1[i] = k--;\n            if (i + k > r) {\n                l = i - k;\n                r = i + k;\n            }\n        }\n        return d1;\n    }\n\n    public static int[] kmp(String s) {\n        int n = s.length();\n        int[] res = new int[n];\n        for (int i = 1; i < n; ++i) {\n            int j = res[i - 1];\n            while (j > 0 && s.charAt(i) != s.charAt(j)) {\n                j = res[j - 1];\n            }\n            if (s.charAt(i) == s.charAt(j)) {\n                ++j;\n            }\n            res[i] = j;\n        }\n        return res;\n    }\n}\n\nclass Pair {\n\n    int i, j;\n\n    Pair(int i, int j) {\n        this.i = i;\n        this.j = j;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        Pair pair = (Pair) o;\n        return i == pair.i && j == pair.j;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(i, j);\n    }\n}\n\nclass FastReader {\n\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}\n\nclass Node {\n\n    int data, open, close;\n\n    Node() {\n        this(0, 0, 0);\n    }\n\n    Node(int data, int open, int close) {\n        this.data = data;\n        this.open = open;\n        this.close = close;\n    }\n}\n\nclass ST {\n\n    int n;\n    Node[] st;\n\n    ST(int n) {\n        this.n = n;\n        st = new Node[4 * Integer.highestOneBit(n)];\n    }\n\n    void build(Node[] nodes) {\n        build(0, 0, n - 1, nodes);\n    }\n\n    private void build(int id, int l, int r, Node[] nodes) {\n        if (l == r) {\n            st[id] = nodes[l];\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build((id << 1) + 1, l, mid, nodes);\n        build((id << 1) + 2, mid + 1, r, nodes);\n        st[id] = comb(st[(id << 1) + 1], st[(id << 1) + 2]);\n    }\n\n    void update(int i, Node node) {\n        update(0, 0, n - 1, i, node);\n    }\n\n    private void update(int id, int l, int r, int i, Node node) {\n        if (i < l || r < i) {\n            return;\n        }\n        if (l == r) {\n            st[id] = node;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        update((id << 1) + 1, l, mid, i, node);\n        update((id << 1) + 2, mid + 1, r, i, node);\n        st[id] = comb(st[(id << 1) + 1], st[(id << 1) + 2]);\n    }\n\n    Node get(int x, int y) {\n        return get(0, 0, n - 1, x, y);\n    }\n\n    private Node get(int id, int l, int r, int x, int y) {\n        if (x > r || y < l) {\n            return new Node();\n        }\n        if (x <= l && r <= y) {\n            return st[id];\n        }\n        int mid = (l + r) >> 1;\n        return comb(get((id << 1) + 1, l, mid, x, y), get((id << 1) + 2, mid + 1, r, x, y));\n    }\n\n    Node comb(Node a, Node b) {\n        if (a == null) {\n            return b;\n        }\n        if (b == null) {\n            return a;\n        }\n        int min = Math.min(a.open, b.close);\n        return new Node(a.data + b.data + min * 2, a.open + b.open - min, a.close + b.close - min);\n    }\n}","import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n \n\t\tpublic FastReader()\n\t\t{\n\t\t\tbr = new BufferedReader(\n\t\t\t\tnew InputStreamReader(System.in));\n\t\t}\n \n\t\tString next()\n\t\t{\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tint nextInt() { return Integer.parseInt(next()); }\n \n\t\tlong nextLong() { return Long.parseLong(next()); }\n \n\t\tdouble nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tString nextLine()\n\t\t{\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t\t\n        int[] getArr(int size)\n    \t{\n    \t    int[] a = new int[size];\n    \t    \n    \t    for(int i=0;i<size;i++)\n    \t        a[i] = nextInt();\n    \t        \n    \t   return a;     \n    \t}\n\t}\n \n\tpublic static void main(String[] args)\n\t{\n\t\tFastReader s = new FastReader();\n\t\tint t = s.nextInt();\n\t\tStringBuffer sb = new StringBuffer();\n\t    \n\t    while(t-->0)\n\t    {\n\t        int n = s.nextInt();\n\t        int[] a = s.getArr(n);\n\t        \n\t        sort(a);\n\t        \n\t        long sum = a[0];\n\t        long ans = a[0];\n\t        \n\t        for(int i=1;i<n;i++)\n\t        {\n\t            long val = a[i]-sum;\n\t            ans = Math.max(ans,val);\n\t            sum+=val;\n\t        }\n\t        \n\t        \n\t        sb.append(ans+\"\\n\");\n\t        \n\t    }\n\t    \n\t    System.out.println(sb);\n\t}\n\t\n\tstatic void sort(int[] a)\n\t{\n\t    ArrayList<Integer> list = new ArrayList<>(a.length);\n\t    \n\t    for(int i=0;i<a.length;i++)\n\t    list.add(a[i]);\n\t    \n\t    Collections.sort(list);\n\t    \n\t    for(int i=0;i<a.length;i++)\n\t    a[i] = list.get(i);\n\t    \n\t}\n\tstatic long gcd(long a, long b)\n    {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n     \n    \/\/ method to return LCM of two numbers\n    static long lcm(long a, long b)\n    {\n        return (a \/ gcd(a, b)) * b;\n    }\n\t\n}","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nint main() {\n  int tc;\n  cin >> tc;\n  for (; tc--;) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a.rbegin(), a.rend());\n    long long diff = 0;\n    long long mx = a.back();\n    for (; a.size() > 1;) {\n      long long getA = a[a.size() - 2], getB = a.back();\n      long long hapus = a.back() + diff;\n      a.pop_back();\n      diff -= hapus;\n      mx = max(mx, a.back() + diff);\n    }\n    cout << mx << endl;\n  }\n  return 0;\n}\n","\/\/ Working program with FastReader \nimport java.io.*;\nimport java.util.*;\npublic class hh\n{ \n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n\n        public FastReader() \n        { \n            br = new BufferedReader(new\n                InputStreamReader(System.in)); \n        } \n\n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n\n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n\n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n\n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n\n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n\n    static final int MAXN = 100001;\n    \/\/ stores smallest prime factor for every number\n    static int spf[] = new int[MAXN];\n    \/\/ Calculating SPF (Smallest Prime Factor) for every\n    \/\/ number till MAXN.\n    \/\/ Time Complexity : O(nloglogn)\n    static void sieve()\n    {\n        spf[1] = 1;\n        for (int i=2; i<MAXN; i++)\n\n        \/\/ marking smallest prime factor for every\n        \/\/ number to be itself.\n            spf[i] = i;\n\n        \/\/ separately marking spf for every even\n        \/\/ number as 2\n        for (int i=4; i<MAXN; i+=2)\n            spf[i] = 2;\n\n        for (int i=3; i*i<MAXN; i++)\n        {\n            \/\/ checking if i is prime\n            if (spf[i] == i)\n            {\n                \/\/ marking SPF for all numbers divisible by i\n                for (int j=i*i; j<MAXN; j+=i)\n\n                \/\/ marking spf[j] if it is not\n                \/\/ previously marked\n                    if (spf[j]==j)\n                        spf[j] = i;\n            }\n        }\n    }\n    \/\/ A O(log n) function returning primefactorization\n    \/\/ by dividing by smallest prime factor at every step\n    static int getFactorization(int x)\n    {\n        int c=0;\n        while (x != 1)\n        {\n            c++;\n            x = x \/ spf[x];\n        }\n        return c;\n    }\n\n    \/*\n    static int LowerBound(int a[], int x) { \/\/ x is the target value or key\n    int l=-1,r=a.length;\n    while(l+1<r) {\n    int m=(l+r)>>>1;\n    if(a[m]>=x) r=m;\n    else l=m;\n    }\n    return r;\n    }\n\n    static int UpperBound(int a[], int x) {\/\/ x is the key or target value\n    int l=-1,r=a.length;\n    while(l+1<r) {\n    int m=(l+r)>>>1;\n    if(a[m]<=x) l=m;\n    else r=m;\n    }\n    return l+1;\n    }\n     *\/\n    static int gcd(int a, int b)\n    {\n        if (a == 0)\n            return b; \n        return gcd(b % a, a); \n    }\n\n    \/\/ method to return LCM of two numbers\n    static int lcm(int a, int b)\n    {\n        return (a \/ gcd(a, b)) * b;\n    }\n\n    public static int[] swap(int a[], int left, int right)\n    {\n        int temp = a[left];\n        a[left] = a[right];\n        a[right] = temp;\n        return a;\n    }\n\n    public static int[] reverse(int a[], int left, int right)\n    {\n        \/\/ Reverse the sub-array\n        while (left < right) {\n            int temp = a[left];\n            a[left++] = a[right];\n            a[right--] = temp;\n        }\n        return a;\n    }\n\n    public static int[] findNextPermutation(int a[])\n    {\n        int last = a.length - 2;\n\n        \/\/ find the longest non-increasing suffix\n        \/\/ and find the pivot\n        while (last >= 0) {\n            if (a[last] < a[last + 1]) {\n                break;\n            }\n            last--;\n        }\n        \/\/ If there is no increasing pair\n        \/\/ there is no higher order permutation\n        if (last < 0)\n            return a;\n\n        int nextGreater = a.length - 1;\n\n        \/\/ Find the rightmost successor to the pivot\n        for (int i = a.length - 1; i > last; i--) {\n            if (a[i] > a[last]) {\n                nextGreater = i;\n                break;\n            }\n        }\n\n        \/\/ Swap the successor and the pivot\n        a = swap(a, nextGreater, last);\n\n        \/\/ Reverse the suffix\n        a = reverse(a, last + 1, a.length - 1);\n\n        \/\/ Return true as the next_permutation is done\n        return a;\n    }\n\n    static void sort(int[] a) {\n        ArrayList<Integer> l = new ArrayList<>();\n        for (int i : a)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n    static void sort(long[] a) {\n        ArrayList<Long> l = new ArrayList<>();\n        for (long i : a)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n    static double pow(double p,double tt)\n    {\n        double ii,q,r;\n        q=1;\n        r=p;\n        while(tt>1)\n        {\n            for(ii=1;2*ii<=tt;ii*=2)\n                p*=p;\n            tt-=ii;\n            q*=p;\n            p=r;\n        }\n        if(tt==1)\n            q*=r;\n        return q;\n    }\n\n    static long pow(long p,long tt,long mod)\n    {\n        long ii,q,r;\n        q=1l;\n        r=p;\n        while(tt>1)\n        {\n            for(ii=1l;2*ii<=tt;ii*=2l)\n                p=((p%mod)*(p%mod))%mod;\n            tt-=ii;\n            q=((q%mod)*(p%mod))%mod;\n            p=r;\n        }\n        if(tt==1)\n            q=((q%mod)*(r%mod))%mod;\n        return q;\n    }\n\n    static int factorial(int n)\n    {\n        return (n == 1 || n == 0) ? 1 : n * factorial(n - 1);\n    }\n\n    public static long primeFactors(long n)\n    {\n        long c=0l;\n        long max=0l;\n        long z=0l;\n        \/\/ArrayList <Integer> ll=new ArrayList<>();\n        \/\/ Print the number of 2s that divide n\n        while (n%2==0)\n        {\n            c++;\n            n \/= 2l;\n            \/\/ll.add(2);\n        }\n        if(c>max)\n        {\n            max=c;\n            z=2;\n        }\n        \/\/ n must be odd at this point. So we can\n        \/\/ skip one element (Note i = i +2)\n        for (int i = 3; i <= Math.sqrt(n); i+= 2)\n        {\n            \/\/ While i divides n, print i and divide n\n            c=0;\n            while (n%i == 0)\n            {\n                c++;\n                n \/= i;\n                \/\/ll.add(i);\n            }\n            if(c>max)\n            {\n                max=c;\n                z=i;\n            }\n        }\n        c=0;\n        \/\/ This condition is to handle the case whien\n        \/\/ n is a prime number greater than 2\n        if (n > 2)\n        {\n            c++;\n            \/\/ll.add((int)n);\n        }\n        if(c>max)\n        {\n            max=c;\n            z=n;\n        }\n        return z;\n    }\n\n    static void PrimeList(){\n        int i,j;\n        int sieve[]=new int[100001];\n        for(i=2;i*i<=100000;i++)\n        {\n            if(sieve[i]==0)\n            {\n                for(j=i*i;j<=100000;j+=i)\n                    sieve[j]=1;\n            }\n        }\n        ArrayList<Integer> primes=new ArrayList<>();\n        for(i=2;i<=100000;i++)\n        {\n            if(sieve[i]==0)\n                primes.add(i);\n        }\n    }\n\n    static int comp(int a[],int b[],int n)\n    {\n        int z=0;\n        for(int i=0;i<n;i++)\n        {\n            if(a[i]!=b[i])\n            {\n                z=1;\n                break;\n            }\n        }\n        if(z==0)\n            return 1;\n        else\n            return 0;\n    }\n\n    static boolean isPowerOfTwo(int x)\n    {\n        return x!=0 && ((x&(x-1))==0);\n    }\n\n    static long calc (int a[],int b[],int n,int mod)\n    {\n        long sum=0l;\n        int i;\n        HashMap<Long,Long>x=new HashMap<>();\n        HashMap<Long,Long>y=new HashMap<>();\n        for(i=0;i<n;i++)\n        {\n            x.put((long)a[i],(long)i);\n            y.put((long)b[i],(long)i);\n        }\n        for(i=0;i<n;i++)\n        {\n            sum=(sum+Math.abs(x.get((long)i)-y.get((long)i))%mod)%mod;\n        }\n        return sum;\n    }\n\n    static int[] rotate(int arr[])\n    {\n        int x = arr[arr.length-1], i;\n        for (i = arr.length-1; i > 0; i--)\n            arr[i] = arr[i-1];\n        arr[0] = x;\n        return arr;\n    }\n\n    public static void main(String[] args) \n    {\n        \/\/try\n        \/\/{\n        FastReader d=new FastReader();\n        PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        StringBuilder sb=new StringBuilder();\n        int t,i,j,k,l,r,n;\n        int mod = (int) 1e9 + 7;\n\n        int Inf=Integer.MAX_VALUE;\n        int negInf=Integer.MIN_VALUE;\n        t=d.nextInt();\n        \/\/t=1;\n        String s,s1;\n        \/\/char ch1,ch2,ch3,ch4;\n        long ans,c,z;\n\n        while(t-->0)\n        {\n            z=c=0l;\n            ans=0l;\n            n=d.nextInt();\n            long a[]=new long[n];\n            for(i=0;i<n;i++)\n                a[i]=d.nextLong();\n            sort(a);\n            long x=0l;\n            if(n==1)\n                pr.println(a[0]);\n            else\n            {\n                long min=a[0];\n                x=a[0];\n                for(i=1;i<n;i++)\n                {\n                    if(a[i]-x>min)\n                    min=a[i]-x;\n                    x=a[i];\n                }\n                pr.println(min);\n            }\n        }\n        \/*\n        }catch(Exception e) {\n        System.out.println(0);\n        }*\/\n        pr.flush();\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nlong long int getN(long long int sum) {\n  sum = sum * 8;\n  sum = sqrt(sum + 1) - 1;\n  sum \/= 2;\n  return sum;\n}\nlong long int apSum(long long int n) {\n  long long int a = 1, d = 1;\n  long long int res = (2 * a + (n - 1) * d) * n;\n  res \/= 2;\n  return res;\n}\nlong long int gcd(long long int a, long long int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nbool isPrime(long long int n) {\n  for (long long int i = 2; i * i <= n; i++)\n    if (n % i == 0) return false;\n  return true;\n}\nvoid solveKaro() {\n  long long int n;\n  cin >> n;\n  vector<long long int> arr(n);\n  for (long long int i = 0; i < arr.size(); i++) {\n    cin >> arr[i];\n  };\n  sort(arr.begin(), arr.end());\n  long long int sum = arr[0], ans = arr[0];\n  for (long long int i = 1; i < n; i++) {\n    ans = max(arr[i] - sum, ans);\n    sum += (arr[i] - sum);\n  }\n  cout << ans << \"\\n\";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int tCase = 1;\n  cin >> tCase;\n  while (tCase--) {\n    solveKaro();\n  }\n}\n","import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        int t = nextInt();\n        while (t-- != 0) {\n            int n = nextInt();\n            Long[] a = new Long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            if(n==1)out.println(a[0]);\n            else{\n                Arrays.sort(a);\n                long ans=a[1]-a[0];\n                for (int i = 2; i <n ; i++) {\n                    ans=Math.max(ans,a[i]-a[i-1]);\n                }\n                out.println(Math.max(ans,a[0]));\n            }\n        }\n        out.close();\n    }\n\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter out = new PrintWriter(System.out);\n    static StringTokenizer in = new StringTokenizer(\"\");\n\n\n    public static boolean hasNext() throws IOException {\n        if (in.hasMoreTokens()) return true;\n        String s;\n        while ((s = br.readLine()) != null) {\n            in = new StringTokenizer(s);\n            if (in.hasMoreTokens()) return true;\n        }\n        return false;\n    }\n\n    public static String nextToken() throws IOException {\n        while (!in.hasMoreTokens()) {\n            in = new StringTokenizer(br.readLine());\n        }\n        return in.nextToken();\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}","\/\/created by Whiplash99\nimport java.io.*;\nimport java.util.*;\npublic class C\n{\n    private static void shuffleArray(long[] arr)\n    {\n        int n = arr.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i)\n        {\n            long tmp = arr[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            arr[i] = arr[randomPos];\n            arr[randomPos] = tmp;\n        }\n    }\n    public static void main(String[] args) throws Exception\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n        int i,N;\n\n        int T=Integer.parseInt(br.readLine().trim());\n        StringBuilder sb=new StringBuilder();\n\n        while (T-->0)\n        {\n            N=Integer.parseInt(br.readLine().trim());\n            String[] s=br.readLine().trim().split(\" \");\n            long[] a=new long[N];\n            for(i=0;i<N;i++) a[i]=Integer.parseInt(s[i]);\n\n            shuffleArray(a);\n            Arrays.sort(a);\n\n            long max=a[0], sum=a[0];\n            for(i=1;i<N;i++)\n            {\n                max=Math.max(max,a[i]-sum);\n                if(a[i]!=a[i-1]) sum+=(a[i]-sum);\n            }\n\n            sb.append(max).append(\"\\n\");\n        }\n        System.out.println(sb);\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long int a[n];\n    for (int i = 0; i < n; i++) cin >> a[i];\n    int max;\n    if (n != 1) {\n      sort(a, a + n);\n      max = a[1] - a[0];\n      for (int i = 2; i < n; i++) {\n        if (a[i] - a[i - 1] > max) max = a[i] - a[i - 1];\n      }\n      if (a[0] > max) max = a[0];\n    }\n    if (n == 1) max = a[0];\n    cout << max << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int q;\n  cin >> q;\n  while (q--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto& x : a) cin >> x;\n    sort(a.begin(), a.end());\n    int ans = a[0];\n    for (int i = 1; i < n; i++) ans = max(ans, a[i] - a[i - 1]);\n    cout << ans << \"\\n\";\n  }\n}\n","t=int(input())\nfor i in range(t) :\n    n=int(input())\n    araye=input().split()\n    for ii in range(n) :\n        araye[ii]=int(araye[ii])\n    araye.sort()\n    mini=araye[0]\n    for j in range(n-1) :\n        if araye[j+1]-araye[j] > mini :\n             mini = araye[j+1]-araye[j]\n    print(mini)\n","#!\/usr\/bin\/env python\n\nfrom __future__ import division, print_function\nimport os\nimport sys\nfrom fileinput import input\nfrom io import BytesIO, IOBase\n\n\nimport math\n# import random\n# import bisect\n# import collections\nimport heapq\n# from collections import deque\n# from functools import reduce\n\ninf=float(\"inf\")\nmod=1000000007\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n#   n = int(input())\n#   arr=list (map(int, input().split()))\n\ndef main():\n    # fact=[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 227020758, 178290591, 674358851, 789741546, 425606191, 660911389, 557316307, 146326063, 72847302, 602640637, 860734560, 657629300, 440732388, 459042011, 394134213, 35757887, 36978716, 109361473, 390205642, 486580460]\n\n    def solve():\n        n = int(input())\n        arr = list(map(int, input().split()))\n        heapq.heapify(arr)\n        ans=arr[0]\n        x=0\n\n        while len(arr)>1:\n            temp=heapq.heappop(arr)\n            ans=max(ans,temp-x)\n            x+=(temp-x)\n        ans=max(ans,arr[0]-x)\n        print(ans)\n\n\n\n\n\n\n    t = int(input())\n    for i in range(t):\n        # print(solve())\n        solve()\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n\n","import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.*;\npublic class c731 {\n\n\tpublic static void main(String[] args) throws IOException {\n\/\/try {\nFastReader sc = new FastReader();\nBufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\nBufferedReader br = new BufferedReader(\n        new InputStreamReader(System.in));\nint t = sc.nextInt();\nfor(int o = 0 ; o<t;o++) {\nint n = sc.nextInt();\n\/\/int[] arr = new int[n];\nArrayList<Integer> al = new ArrayList<Integer>();\nlong ans = Integer.MAX_VALUE;\n\nfor(int i = 0; i<n;i++) {\n\/\/\tarr[i] = sc.nextInt();\n\tal.add(sc.nextInt());\n\tans = Math.min(al.get(i), ans);\n}\n\/\/Arrays.sort();\nCollections.sort(al);\nfor(int i = 0 ; i<n-1;i++) {\n\tans = Math.max(al.get(i+1)-al.get(i), ans);\n}\nSystem.out.println(ans);\n}\n\n\n}\n\tpublic static boolean check(String s , ArrayList<Integer> al) {\n\t\tString st = \"\";\n\t\tint a = 0;\n\t\tfor(int x : al) {\n\t\t\tst += s.substring(a,x);\n\t\t\ta = x+1;\n\t\t}\n\tst += s.substring(a,s.length());\n\tint i = 0;\n\tint j = st.length()-1;\n\/\/\tSystem.out.println(st + \" \" + al);\n\twhile(i<=j) {\n\t\tif(st.charAt(i)!=st.charAt(j)) {\n\t\t\treturn false;\n\t\t}\n\ti++;\n\tj--;\n\t}\n\t\treturn true;\n\t\n\t}\n}\n\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader()\n    {\n        br = new BufferedReader(\n            new InputStreamReader(System.in));\n    }\n\n    String next()\n    {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n\n            \n            \n            \n            \n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() { return Integer.parseInt(next()); }\n\n    long nextLong() { return Long.parseLong(next()); }\n\n    double nextDouble()\n    {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine()\n    {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}","import heapq\nt = int(input())\nfor case in range(t):\n  n = int(input())\n  l = [int(i) for i in input().split()]\n  heapq.heapify(l)\n  best = heapq.heappop(l)\n  subtract = best\n  while l:\n    x = heapq.heappop(l)\n    best = max(best, x - (subtract))\n    subtract = subtract + (x - subtract)\n  print(best)","#include <bits\/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 7;\nint a[maxn];\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n    sort(a + 1, a + 1 + n);\n    long long ans = a[1];\n    long long cnt = 0;\n    for (int i = 2; i <= n; i++) ans = max(ans, (long long)a[i] - a[i - 1]);\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n","import heapq\nimport math\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int,input().split()))\n \n    if len(arr) == 1:\n        print(arr[0])\n    else:\n        heapq.heapify(arr)\n        ans = 0\n        \n        maxv = -math.inf\n        \n        while arr:\n            m = heapq.heappop(arr)            \n            left = m-ans\n            ans += (m-ans)\n            maxv= max(maxv,left)\n        print(maxv)\n        \n","t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    a.sort()\n    max_min = -(10**10)\n    d = 0;\n    for i in range(n):\n        max_min = max(max_min, a[i] - d)\n        d = a[i]\n    print(max_min)","for _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    if(n==1):\n        print(a[0])\n        continue\n    else:\n        a.sort()\n        m=a[0]\n        for i in range(len(a)-1):\n            m=max(a[i+1]-a[i],m)\n        print(m)","t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    nums = list(map(int, input().split()))\n\n    nums.sort()\n    max_min = float('-inf')\n    cur = 0\n    for i in range(n):\n        new = nums[i] + cur\n        max_min = max(max_min, new)\n        cur -= new\n\n    print(max_min)","import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n    static long mod = (int)1e9 + 7;\n    \/\/ static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tFastReader sc =new FastReader();\n\t\t\n\t    int t=sc.nextInt();\n\t    \n\t   \/\/ int t=1;\n\t    \n\t    while(t-->0)\n\t    {\n\t        int n = sc.nextInt();\n\t        int arr[] = sc.readArray(n);\n\t        \n\t        radixSort2(arr);\n\t        \n\t        if(n == 1)\n\t        {\n\t            System.out.println(arr[0]);\n\t            continue;\n\t        }\n\t        \n\t        long ans = arr[0];\n\t        int stored = arr[0];\n\t        int sub = 0;\n\t        \n\t        for(int i=1;i<n;i++)\n\t        {\n\t            sub = arr[i] - stored;\n\t            stored += sub;\n\t            ans = Math.max(ans , sub);\n\t        }\n\t        System.out.println(ans);\n\t    }\n\t    \n\t}\n\t\n\t\n\t\n\t\n\tstatic class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(\n                new InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() { return Integer.parseInt(next()); }\n \n        long nextLong() { return Long.parseLong(next()); }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n        \n        float nextFloat()\n        {\n            return Float.parseFloat(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tlong[] readArrayLong(int n) {\n\t\t\tlong[] a=new long[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextLong();\n\t\t\treturn a;\n\t\t}\n\t\t\n    }\n    \n    \n    \n    public static int[] radixSort2(int[] a)\n\t{\n\t\tint n = a.length;\n\t\tint[] c0 = new int[0x101];\n\t\tint[] c1 = new int[0x101];\n\t\tint[] c2 = new int[0x101];\n\t\tint[] c3 = new int[0x101];\n\t\tfor(int v : a) {\n\t\t\tc0[(v&0xff)+1]++;\n\t\t\tc1[(v>>>8&0xff)+1]++;\n\t\t\tc2[(v>>>16&0xff)+1]++;\n\t\t\tc3[(v>>>24^0x80)+1]++;\n\t\t}\n\t\tfor(int i = 0;i < 0xff;i++) {\n\t\t\tc0[i+1] += c0[i];\n\t\t\tc1[i+1] += c1[i];\n\t\t\tc2[i+1] += c2[i];\n\t\t\tc3[i+1] += c3[i];\n\t\t}\n\t\tint[] t = new int[n];\n\t\tfor(int v : a)t[c0[v&0xff]++] = v;\n\t\tfor(int v : t)a[c1[v>>>8&0xff]++] = v;\n\t\tfor(int v : a)t[c2[v>>>16&0xff]++] = v;\n\t\tfor(int v : t)a[c3[v>>>24^0x80]++] = v;\n\t\treturn a;\n\t}\n\t\n\tstatic void reverse_sorted(int[] arr)\n\t{\n\t    ArrayList<Integer> list = new ArrayList<>();\n\t    for(int i=0;i<arr.length;i++)\n\t    {\n\t        list.add(arr[i]);\n\t    }\n\t    Collections.sort(list , Collections.reverseOrder());\n\t    for(int i=0;i<arr.length;i++)\n\t    {\n\t        arr[i] = list.get(i);\n\t    }\n\t}\n\t\n\tstatic int LowerBound(int a[], int x) { \/\/ x is the target value or key\n        int l=-1,r=a.length;\n        while(l+1<r) {\n            int m=(l+r)>>>1;\n            if(a[m]>=x) r=m;\n            else l=m;\n        }\n        return r;\n    }\n    \n    static int UpperBound(ArrayList<Integer> list, int x) {\/\/ x is the key or target value\n        int l=-1,r=list.size();\n        while(l+1<r) {\n            int m=(l+r)>>>1;\n            if(list.get(m)<=x) l=m;\n            else r=m;\n        }\n        return l+1;\n    }\n    \n    public static HashMap<String, Integer> sortByValue(HashMap<String, Integer> hm)\n    {\n        \/\/ Create a list from elements of HashMap\n        List<Map.Entry<String, Integer> > list =\n               new LinkedList<Map.Entry<String, Integer> >(hm.entrySet());\n \n        \/\/ Sort the list\n        Collections.sort(list, new Comparator<Map.Entry<String, Integer> >() {\n            public int compare(Map.Entry<String, Integer> o1,\n                               Map.Entry<String, Integer> o2)\n            {\n                return (o1.getValue()).compareTo(o2.getValue());\n            }\n        });\n         \n        \/\/ put data from sorted list to hashmap\n        HashMap<String, Integer> temp = new LinkedHashMap<String, Integer>();\n        for (Map.Entry<String, Integer> aa : list) {\n            temp.put(aa.getKey(), aa.getValue());\n        }\n        return temp;\n    }\n    \n    static class Queue_Pair implements Comparable<Queue_Pair> {\n\t\tint first , second;\n\t\tpublic Queue_Pair(int first, int second) {\n\t\t\tthis.first=first;\n\t\t\tthis.second=second;\n\t\t}\n\t\tpublic int compareTo(Queue_Pair o) {\n\t\t\treturn Integer.compare(o.first, first);\n\t\t}\n\t}\n    \n    static void leftRotate(char arr[], int d, int n)\n    {\n        for (int i = 0; i < d; i++)\n            leftRotatebyOne(arr, n);\n    }\n \n    static void leftRotatebyOne(char arr[], int n)\n    {\n        int i;\n        char temp = arr[0];\n        for (i = 0; i < n - 1; i++)\n            arr[i] = arr[i + 1];\n        arr[n-1] = temp;\n        \n    }\n    \n    static void rightRotate(char arr[], int d, int n)\n    {\n        for (int i = 0; i < d; i++)\n            rightRotatebyOne(arr, n);\n    }\n \n    static void rightRotatebyOne(char arr[], int n)\n    {\n        int i;\n        char temp = arr[n - 1];\n        for (i = n - 1; i > 0; i--)\n            arr[i] = arr[i - 1];\n        arr[0] = temp;\n        \n    }\n    \n    static boolean isPalindrome(String str)\n    {\n \n        \/\/ Pointers pointing to the beginning\n        \/\/ and the end of the string\n        int i = 0, j = str.length() - 1;\n \n        \/\/ While there are characters to compare\n        while (i < j) {\n \n            \/\/ If there is a mismatch\n            if (str.charAt(i) != str.charAt(j))\n                return false;\n \n            \/\/ Increment first pointer and\n            \/\/ decrement the other\n            i++;\n            j--;\n        }\n \n        \/\/ Given string is a palindrome\n        return true;\n    }\n    \n    static boolean palindrome_array(char arr[], int n)\n    {\n        \/\/ Initialise flag to zero.\n        int flag = 0;\n \n        \/\/ Loop till array size n\/2.\n        for (int i = 0; i <= n \/ 2 && n != 0; i++) {\n \n            \/\/ Check if first and last element are different\n            \/\/ Then set flag to 1.\n            if (arr[i] != arr[n - i - 1]) {\n                flag = 1;\n                break;\n            }\n        }\n \n        \/\/ If flag is set then print Not Palindrome\n        \/\/ else print Palindrome.\n        if (flag == 1)\n            return false;\n        else\n            return true;\n    }\n    \n\tstatic boolean allElementsEqual(long[] arr,int n)\n\t{\n\t    int z=0;\n\t        for(int i=0;i<n-1;i++)\n\t\t    {\n\t\t        if(arr[i]==arr[i+1])\n\t\t        {\n\t\t            z++;\n\t\t        }\n\t\t    }\n\t\t    if(z==n-1)\n\t\t    {\n\t\t        return true;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t        return false;\n\t\t    }\n\t\t    \n\t}\n\t\n\tstatic boolean allElementsDistinct(int[] arr,int n)\n\t{\n\t    int z=0;\n\t        for(int i=0;i<n-1;i++)\n\t\t    {\n\t\t        if(arr[i]!=arr[i+1])\n\t\t        {\n\t\t            z++;\n\t\t        }\n\t\t    }\n\t\t    if(z==n-1)\n\t\t    {\n\t\t        return true;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t        return false;\n\t\t    }\n\t\t    \n\t\t    \n\t}\n\t\n\tpublic static void reverse(int[] array)\n    {\n  \n        \/\/ Length of the array\n        int n = array.length;\n  \n        \/\/ Swaping the first half elements with last half\n        \/\/ elements\n        for (int i = 0; i < n \/ 2; i++) {\n  \n            \/\/ Storing the first half elements temporarily\n            int temp = array[i];\n  \n            \/\/ Assigning the first half to the last half\n            array[i] = array[n - i - 1];\n  \n            \/\/ Assigning the last half to the first half\n            array[n - i - 1] = temp;\n        }\n    }\n    \n    public static void reverse_Long(long[] array)\n    {\n  \n        \/\/ Length of the array\n        int n = array.length;\n  \n        \/\/ Swaping the first half elements with last half\n        \/\/ elements\n        for (int i = 0; i < n \/ 2; i++) {\n  \n            \/\/ Storing the first half elements temporarily\n            long temp = array[i];\n  \n            \/\/ Assigning the first half to the last half\n            array[i] = array[n - i - 1];\n  \n            \/\/ Assigning the last half to the first half\n            array[n - i - 1] = temp;\n        }\n    }\n\t\n\tstatic boolean isSorted(int[] a)\n    {\n        for (int i = 0; i < a.length - 1; i++)\n        {\n            if (a[i] > a[i + 1]) {\n                return false;\n            }\n        }\n \n        return true;\n    }\n    \n    \n    \n    static boolean isReverseSorted(int[] a)\n    {\n        for (int i = 0; i < a.length - 1; i++)\n        {\n            if (a[i] < a[i + 1]) {\n                return false;\n            }\n        }\n \n        return true;\n    }\n    \n    static int[] rearrangeEvenAndOdd(int arr[], int n)\n    {\n        ArrayList<Integer> list = new ArrayList<>();\n\t\t    \n\t\t    for(int i=0;i<n;i++)\n\t\t    {\n\t\t        if(arr[i]%2==0)\n\t\t        {\n\t\t            list.add(arr[i]);\n\t\t        }\n\t\t    }\n\t\t    \n\t\t    for(int i=0;i<n;i++)\n\t\t    {\n\t\t        if(arr[i]%2!=0)\n\t\t        {\n\t\t            list.add(arr[i]);\n\t\t        }\n\t\t    }\n\t\t    int len = list.size();\n\t\t    int[] array = list.stream().mapToInt(i->i).toArray();\n\t\t    return array;\n    }\n    \n    static long[] rearrangeEvenAndOddLong(long arr[], int n)\n    {\n        ArrayList<Long> list = new ArrayList<>();\n\t\t    \n\t\t    for(int i=0;i<n;i++)\n\t\t    {\n\t\t        if(arr[i]%2==0)\n\t\t        {\n\t\t            list.add(arr[i]);\n\t\t        }\n\t\t    }\n\t\t    \n\t\t    for(int i=0;i<n;i++)\n\t\t    {\n\t\t        if(arr[i]%2!=0)\n\t\t        {\n\t\t            list.add(arr[i]);\n\t\t        }\n\t\t    }\n\t\t    int len = list.size();\n\t\t    long[] array = list.stream().mapToLong(i->i).toArray();\n\t\t    return array;\n    }\n\t\n\t\n    \n    static boolean isPrime(long n)\n    {\n \n        \/\/ Check if number is less than\n        \/\/ equal to 1\n        if (n <= 1)\n            return false;\n \n        \/\/ Check if number is 2\n        else if (n == 2)\n            return true;\n \n        \/\/ Check if n is a multiple of 2\n        else if (n % 2 == 0)\n            return false;\n \n        \/\/ If not, then just check the odds\n        for (long i = 3; i <= Math.sqrt(n); i += 2)\n        {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n    \n    static long getSum(long n)\n    {    \n        long sum = 0;\n          \n        while (n != 0)\n        {\n            sum = sum + n % 10;\n            n = n\/10;\n        }\n      \n    return sum;\n    }\n    \n    static int gcd(int a, int b)\n    {\n      if (b == 0)\n        return a;\n      return gcd(b, a % b);\n    }\n     \n    static long gcdLong(long a, long b)\n    {\n        if (b == 0)\n        return a;\n      return gcdLong(b, a % b);\n    }\n    \n    static void swap(int i, int j)\n    {\n        int temp = i;\n        i = j;\n        j = temp;\n    }\n\t\n\tstatic int countDigit(int n)\n    {\n        return (int)Math.floor(Math.log10(n) + 1);\n    }\n\t\n}\n\nclass Pair\n{\n    int first , second;\n    Pair(int first , int second)\n    {\n        this.first = first;\n        this.second = second;\n    }\n}","import java.util.*;\nimport java.io.*;\npublic class minExtraction{\n   public static void main(String[] args) throws IOException{\n      BufferedReader f= new BufferedReader(new InputStreamReader(System.in));\n      StringTokenizer s=new StringTokenizer(f.readLine());\n      int t=Integer.parseInt(s.nextToken());\n      for(int i=0;i<2*t;i+=2){\n         ArrayList<Integer> arr=new ArrayList<Integer>();\n         s=new StringTokenizer(f.readLine());\n         int n=Integer.parseInt(s.nextToken());\n         s=new StringTokenizer(f.readLine());\n         for(int k=0;k<n;k++){\n            arr.add(Integer.parseInt(s.nextToken()));\n         }\n         Collections.sort(arr);\n         int max=arr.get(0);\n         for(int k=1;k<arr.size();k++){\n            max=Math.max(max,arr.get(k)-arr.get(k-1));\n         }\n         System.out.println(max);\n      }\n   }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    int ans = a[0];\n    for (int i = 1; i < n; i++) ans = max(ans, a[i] - a[i - 1]);\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n","import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class C {\n    public static void main(String[] args)\n    {\n        FastScanner sc=new FastScanner();\n        int t=sc.nextInt();\n        PrintWriter pw=new PrintWriter(System.out);\n        while(t-->0) {\n            int n=sc.nextInt();\n            long mini=Integer.MAX_VALUE;\n            ArrayList<Long> a=new ArrayList<>();\n            ArrayList<Long> b=new ArrayList<>();\n            int idx=-1;\n            for(int i=0;i<n;i++){\n                int val=sc.nextInt();\n                if(val<mini){\n                    mini=val;\n                    idx=i;\n                }\n                a.add((long) val);\n            }\n            if(n==1){\n                pw.println(a.get(0));\n                continue;\n            }\n            long ans=mini;\n            for(int i=0;i<n;i++){\n                if(i==idx){\n                    continue;\n                }\n                b.add(a.get(i)-mini);\n            }\n            Collections.sort(b,Collections.reverseOrder());\n            for(int i=0;i<b.size()-1;i++){\n                ans=Math.max(ans,b.get(i)-b.get(i+1));\n            }\n            ans=Math.max(ans,b.get(b.size()-1));\n            pw.println(ans);\n\n        }\n        pw.flush();\n    }\n\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        int[] readArray(int n) {\n            int[] a=new int[n];\n            for (int i=0; i<n; i++) a[i]=nextInt();\n            return a;\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n","\/\/Avoid division by decimal digits :). Always try to multiply with whole numbers or fractions instead.\n\/\/if getting wrong answer then use long\/double instead of int\/float\n\/\/e + e = o; o + o = e; e + o = o;\n\/\/see stuff in a jugaad way... if you are being complicated you are doing it wrong\n\/\/If a=b+1 and b is even, then a\u2227b=1\n\/\/If there is a statement in the question that it can be proved that ... then it means there is a very very simple logic behind it, and is not a simulation or  dp question.\n\/\/Be confident in Maths you are not that bad at it.\n\/\/ add break statement where you are stopping. Do not forget that, as people may use that weakness to hack your solution.\n \n \nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.*;\n \npublic class Main {\n \n    public static void main(String[] args) {\n        \/\/ write your code here\n        Scanner reader = new Scanner(System.in);\n        int test = reader.nextInt();\n \n        for (int o = 0; o < test; o++) {\n            int n = reader.nextInt();\n            Long[] arr =new Long[n];\n            for (int i = 0; i < n; i++){arr[i] = reader.nextLong();}\n \n            Arrays.sort(arr);\n \n            long ans = arr[0];\n            long kk = 0;\n            for (int i = 1; i < n; i++){\n                kk += arr[i - 1];\n                ans = Math.max(ans, arr[i] - kk);\n                arr[i] -= kk;\n            }\n            ans = Math.max(ans, arr[n -1 ]);\n            System.out.println(ans);\n        }\n    }\n}\n\/\/------------------------------------XX---Templatecode---XX--------------------------------------\nclass Template{\n    public static long gcd(long a, long b){\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n \n    public static long lcm(long a,long b){\n        return (a*b)\/gcd(a, b);\n    }\n \n}\n \nclass FastReader\n{\n    BufferedReader br;\n    StringTokenizer st;\n \n    public FastReader()\n    {\n        br = new BufferedReader(new\n                InputStreamReader(System.in));\n    }\n \n    String next()\n    {\n        while (st == null || !st.hasMoreElements())\n        {\n            try\n            {\n                st = new StringTokenizer(br.readLine());\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n \n    int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n \n    long nextLong()\n    {\n        return Long.parseLong(next());\n    }\n \n    double nextDouble()\n    {\n        return Double.parseDouble(next());\n    }\n \n    String nextLine()\n    {\n        String str = \"\";\n        try\n        {\n            str = br.readLine();\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}","for _ in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    if n==1:\n        print(l[0])\n        continue\n    l.sort()\n    t=[]\n    for i in range(1,n):\n        t.append(l[i]-l[i-1])\n    if max(t)<min(l):\n        print(min(l))\n    else:\n        print(max(t))\n\n    \n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve();\nvoid cumsum(vector<long long> vec, vector<long long> sum) {\n  long long s = 0;\n  for (int i = 0; i < vec.size(); i++) {\n    s += vec[i];\n    sum.push_back(s);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  solve();\n  return 0;\n}\nvoid solve() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (int(i) = 0; (i) < (n); (i)++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    if (n == 1) {\n      cout << a[0] << endl;\n      continue;\n    }\n    vector<long long> b(n);\n    b[0] = a[0];\n    for (int i = 0; i < n - 1; i++) {\n      b[i + 1] = a[i + 1] - a[i];\n    }\n    cout << *max_element(b.begin(), b.end()) << endl;\n  }\n}\n","from heapq import *\n\nt = int(input())\ndef solve(n, a, idx, offset):\n    mins = []\n    heap = a\n    heapify(heap)\n    offset = 0\n    while (len(heap) != 1):\n        mins.append(heappop(heap) - offset)\n        offset += mins[-1]\n    mins.append(heap[0] - offset)\n    return max(mins)\n\n    \nfor case in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a = sorted(a)\n    print(solve(n, a, 0, 0))\n\n   \n","\nimport sys\nfrom os import path\n\nif(path.exists('input.txt')):\n    sys.stdout = open('output.txt', 'w')\n    sys.stdin = open('input.txt', 'r')\n\n\ndef main():\n    inp = [int(x) for x in sys.stdin.buffer.read().split()]\n    ii = 0\n    out = []\n\n    t = int(inp[ii])\n    ii += 1\n    for _ in range(t):\n\n        n = int(inp[ii]); ii+=1\n        arr = list(map(int, inp[ii:ii+n])); ii += n\n        arr.sort()\n\n        # if n == 1:\n        #     out.append(arr[0])\n        #     continue\n\n        ans = arr[0]\n        for i in range(n):\n            if i == 0:\n                continue\n            ans = max(ans, arr[i] - arr[i-1])\n        \n        out.append(ans)\n\n        pass\n\n    out_str = \"\\n\".join(str(x) for x in out)\n    sys.stdout.write(out_str)\n\n\nmain()\n","#include <bits\/stdc++.h>\nusing namespace std;\nint a[200100];\nint sub[200100];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n      cin >> a[i];\n    }\n    sort(a + 1, a + n + 1);\n    for (int i = 1; i <= n; i++) {\n      sub[i] = sub[i - 1] + a[i - 1];\n      a[i] = a[i] - sub[i];\n    }\n    sort(a + 1, a + 1 + n);\n    cout << a[n] << endl;\n    memset(sub, 0, sizeof(sub));\n  }\n}\n","import java.util.*;\nimport java.io.*;\n \npublic class SolutionC{\n       static HashSet<Integer> s;\n       public static void main(String[] args) throws Exception{\n               Fast sc=new Fast();\n        PrintWriter out=new PrintWriter(System.out); \n         int t=sc.nextInt();\n         \n         while(t-->0){\n          int n=sc.nextInt();\n          long[] ar=new long[n];\n          for(int i=0;i<n;i++){\n            ar[i]=sc.nextLong();\n          }\n\n          if(n==1){\n            out.println(ar[0]);\n          }\n          else{\n                   Sort(ar);\n                   long sum=0;\n                   long ans=ar[0];\n                     sum=ar[0];\n                   for(int i=1;i<n;i++){\n                        ans=Math.max(ans,ar[i]-(sum));\n\n                        sum=ar[i];\n\n                   }\n                   out.println(ans);\n          }\n         \n      }\n        out.close();\n }   \n   \nstatic void Sort(long[] ar){\n    ArrayList<Long> al=new ArrayList<>();\n    for(int i=0;i<ar.length;i++){al.add(ar[i]);}\n    Collections.sort(al);\n    for(int i=0;i<al.size();i++)ar[i]=al.get(i);\n  }\nstatic int gcd(int a,int b){\n    if(b==0) return a;\n    else return  gcd(b,a%b);\n}\n}\nclass Pair{\n    int x, y;\n     Pair(int x,int y){\n        this.x=x;\n        this.y=y;\n     }\n}\nclass Fast{\n  BufferedReader br; \n  StringTokenizer st;\n  public Fast(){ br=new BufferedReader(new InputStreamReader(System.in)); }\n  String next() \n        {  while (st == null || !st.hasMoreElements()) \n            {   try\n                {     st = new StringTokenizer(br.readLine()); } \n                catch (IOException  e) \n                {    e.printStackTrace(); } \n            } \n            return st.nextToken(); \n        }\n  int nextInt(){  return Integer.parseInt(next()); }\n  long nextLong(){     return Long.parseLong(next()); } \n  double nextDouble() {     return Double.parseDouble(next()); } \n  String nextLine() \n        { \n            String str = \"\"; \n            try{      str = br.readLine(); } \n            catch (IOException e)  {  e.printStackTrace(); } \n            return str; \n        } \n}\n    ","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    long long arr[n];\n    set<long long> s;\n    for (long long i = 0; i < n; i++) {\n      cin >> arr[i];\n      s.insert(arr[i]);\n    }\n    if (n == 1) {\n      cout << arr[0] << endl;\n      continue;\n    } else {\n      sort(arr, arr + n);\n      long long maxi = arr[0];\n      for (long long i = 0; i < n - 1; i++) {\n        long long temp = arr[i + 1] - arr[i];\n        maxi = max(maxi, temp);\n      }\n      long long p = 0;\n      if (s.size() != n) {\n        maxi = max(maxi, p);\n      }\n      cout << maxi << endl;\n    }\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint t, n;\nlong long a[200005], ans;\nint main() {\n  scanf(\"%d\", &t);\n  while (t--) {\n    ans = -1000000000000;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n    if (n == 1) {\n      printf(\"%lld\\n\", a[0]);\n      continue;\n    }\n    sort(a, a + n);\n    long long temp = 0;\n    for (int i = 0; i < n; i++) {\n      ans = max(a[i] - temp, ans);\n      temp += (a[i] - temp);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n","import java.io.*;\nimport java.util.*;\n\npublic class MinimumExtraction {\n\n    public static void main(String[] args) throws IOException {\n    \tFastScanner in = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int t = in.nextInt();\n        for (int i = 1; i <= t; i++)  {\n        \tint n = in.nextInt();\n\n        \tArrayList<Long> a = new ArrayList<>();\n        \tfor (int j = 0; j < n; j++)  {\n        \t\ta.add(in.nextLong());\n        \t}\n            Collections.sort(a);\n        \tif (n == 1)  {\n        \t\tout.println(a.get(0));\n        \t}\n        \telse  {\n    \t\t\tlong biggestGap = a.get(0);\n    \t\t\tfor (int j = 1; j < n; j++)  {\n    \t\t\t\tlong gap = a.get(j) - a.get(j - 1);\n    \t\t\t\tif (gap > biggestGap)  {\n    \t\t\t\t\tbiggestGap = gap;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tout.println(biggestGap);\n        \t}\n        }\n        out.close();\n    }\n    \n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try { \n                    st = new StringTokenizer(br.readLine());                               \n                } catch (IOException e) {\n                    \/\/ noop\n                }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble()  {\n            return Double.parseDouble(next());\n        }\n    }\n}","t=int(input())\nfor _ in range(t):\n    n=int(input())\n    aaa=list(map(int,input().split()))\n    aaa.sort()\n    go=True\n    s=0\n    b=aaa[0]\n    bm=b\n    for j in range (1,n):\n        s-=aaa[j-1]+s\n        #print(j,aaa[j],s,b)\n        if aaa[j]+s >bm : bm=aaa[j]+s\n        #print(j,s,b,bm)\n        \n    \n    \n    print(bm)\n","import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n    static Scanner in = new Scanner(System.in);\n    static int[] a;\n    static int n;\n\n    public static void main(String[] args) {\n        int t = in.nextInt();\n        while (t-- > 0) {\n            n = in.nextInt();\n            long x;\n\n            PriorityQueue<Long> q = new PriorityQueue<>((a,b) -> (int)(a - b));\n            for (int i = 0; i < n; i++) {\n                x = in.nextLong();\n                q.add(x);\n            }\n            long tmp = 0;\n            long ans = q.peek();\n            while (!q.isEmpty()) {\n                long cur = q.poll();\n                ans = Math.max(ans, cur + tmp);\n                tmp -= cur + tmp;\n            }\n            System.out.println(ans);\n        }\n    }\n}","t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    maxim = a[0]\n    s = maxim\n    for i in range(1, n):\n        maxim = max(maxim, a[i] - s)\n        a[i] = a[i] - s\n        s += a[i]\n    print(maxim)","# alh = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    mass = list(map(int, input().split()))\n    if n == 1:\n        print(*mass)\n        continue\n    mass = sorted(mass)\n    ans = [mass[0], mass[1]-mass[0]]\n    i = 2\n    while i < n:\n        ans.append(mass[i]-mass[i-1])\n        i += 1\n    print(max(ans))","t = int(input())\nwhile t:\n    n = int(input())\n    s = input()\n    s = s.split(' ')\n    for i in range(0, n):\n        s[i] = int(s[i])\n    s.sort()\n    maxraz = 0\n    if len(s) > 1:\n        for i in range(1, len(s)):\n            if s[i] - s[i - 1] > maxraz:\n                maxraz = s[i] - s[i - 1] \n        if maxraz > s[0]:\n            print(maxraz)\n        else:\n            print(s[0])\n    else:\n        print(s[0])\n\n    t -= 1\n\n","import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class C {\n\tpublic static void main(String args[]) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint t = Integer.parseInt(br.readLine().trim());\n\t\twhile (t-- > 0) {\n\t\t\tint N = Integer.parseInt(br.readLine().trim());\n\t\t\tint arr[] = nextIntArray(N, br);\n\t\t\tsb.append(getVal(arr)).append(\"\\n\");\n\t\t}\n\n\t\tbr.close();\n\t\tSystem.out.println(sb);\n\t}\n\n\tprivate static long getVal(int arr[]) {\n\t\tlong ret = Long.MIN_VALUE;\n\t\tlong diff = 0;\n\t\tPriorityQueue<Integer> pq = new PriorityQueue<>();\n\t\tfor (int i : arr)\n\t\t\tpq.add(i);\n\n\t\twhile (!pq.isEmpty()) {\n\t\t\tint n = pq.remove();\n\t\t\tn -= diff;\n\t\t\tret = Math.max(ret, n);\n\t\t\tdiff += n;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate static int[] nextIntArray(int N, BufferedReader br) throws Exception {\n\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim(), \" \");\n\t\tint arr[] = new int[N];\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tarr[i] = Integer.parseInt(st.nextToken());\n\t\treturn arr;\n\t}\n}\n","from __future__ import print_function\nfrom math import *\nfrom collections import deque\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n#import time\n \ndef main():\n    pass\n \n# region fastio\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n#sys.stdin, sys.stdout =open(\"test.txt\",\"r\"),open(\"result.txt\",\"w\")\n#ini=time.time()\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nmod=10**9+7\n############ ---- Input Functions ---- ############\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(list(s[:len(s) ]))\ndef invr():\n    return(map(int,input().split()))\nfor _ in range(inp()):\n    n=inp()\n    l=inlt()\n    l.sort()\n    ans=l[0]\n    tmp=0\n    for i in range(n-1):\n        tmp+=(l[i]-tmp)\n        #print(tmp,\"Aa\")\n        #print(l[i+1])\n        ans=max(ans,l[i+1]-tmp)\n        #print(ans,\"hhh\")\n    print(ans)","#include <bits\/stdc++.h>\nusing namespace std;\nint t, n;\nlong long a[200005];\nlong long solve() {\n  sort(a, a + n);\n  long long ns = 0, m = a[0], ans = a[0];\n  for (int i = 1; i < n; i++) {\n    ns += m;\n    m = a[i] - ns;\n    ans = max(ans, m);\n  }\n  return ans;\n}\nint main() {\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    cout << solve() << '\\n';\n  }\n  return 0;\n}\n","import java.util.*;\nimport java.io.*;\npublic class Main {\n\t\tstatic long mod = 1000000007;\n\t\tstatic long max ;\n\t\tstatic PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\t\tpublic static void main(String[] args) throws IOException  {\n\t\t\tFastReader sc = new FastReader();\n\t\t\tint t = sc.nextInt();\n\t\t\twhile( t-- > 0) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint arr[] = new int[n];\n\t\t\t\tfor( int i = 0 ;i < n; i++) {\n\t\t\t\t\tarr[i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tmySort(arr);\n\t\t\t\tlong temp = 0;\n\t\t\t\tlong max = Long.MIN_VALUE;\n\t\t\t\tfor(int i= 0 ;i < n;i++) {\n\t\t\t\t\tmax = Math.max(max , arr[i] -  temp);\n\t\t\t\t\ttemp+=(arr[i] - temp);\n\/\/\t\t\t\t\tout.println( max + \" \" + temp);\n\t\t\t\t}\n\t\t\t\tout.println(max);\n\t\t\t}\n\t\t\tout.flush();\n\t\t}\n\t\n\t\tpublic static boolean ifpowof2(long n ) {\n\t\t\treturn ((n&(n-1)) == 0);\n\t\t}\n\t\t\n\t\tpublic static int[] nextLargerElement(int[] arr, int n)\t{ \n\t\t\tStack<Integer> stack = new Stack<>();\n\t\t\tint rtrn[] = new int[n];\n\t\t\trtrn[n-1] = -1;\n\t        stack.push( n-1);\n\t        for( int i = n-2 ;i >= 0 ; i--){\n\t            int temp = arr[i];\n\t            int lol = -1;\n\t            while( !stack.isEmpty() && arr[stack.peek()] <= temp){\n\t            \tif(arr[stack.peek()] == temp ) {\n\t            \t\tlol = stack.peek();\n\t            \t}\n\t                stack.pop();\n\t            }\n\t            if( stack.isEmpty()){\n\t            \tif( lol != -1) {\n\t            \t\trtrn[i] = lol;\n\t            \t}\n\t            \telse {\n\t            \t\trtrn[i] = -1;\n\t            \t}\n\t            }\n\t            else{\n\t            \trtrn[i] = stack.peek();\n\t            }\n\t            stack.push( i);\n\t        }\n\t        return rtrn;\n\t\t}\n\t\t\n\t\t@SuppressWarnings(\"unused\")\n\t\tprivate static void mySort(int[] arr) {\n\t        for(int i=0;i<arr.length;i++) {\n\t            int rand = (int) (Math.random() * arr.length);\n\t            int loc = arr[rand];\n\t            arr[rand] = arr[i];\n\t            arr[i] = loc;\n\t        }\n\t        Arrays.sort(arr);\n\t    }\n\t\t\n\t\tstatic long gcd(long a, long b)\n\t\t{\n\t\t\tif (a == 0)\n\t\t\t\treturn b;\n\t\t\treturn gcd(b % a, a);\n\t\t}\n\t\t\n\t\t\t   \n\t\t static long lcm(long a, long b)\n\t\t {\n\t\t\t return (a \/ gcd(a, b)) * b;\n\t\t }\n\t\t \n\n\t\t static long rightmostsetbit(long n) {\n\t\t\t return n&-n;\n\t\t }\n\t\t \n\t\t static long leftmostsetbit(long n)\n\t\t    {\n\t\t        long k = (long)(Math.log(n) \/ Math.log(2));\n\t\t        return 1 << k;\n\t\t    }\n\t \n\t\t static HashMap<Long,Long> primefactor( long n){\n\t\t\t HashMap<Long ,Long> hm = new HashMap<>();\n\t\t\t long temp = 0;\n\t\t\t while( n%2 == 0) {\n\t\t\t\t temp++;\n\t\t\t\t n\/=2;\n\t\t\t }\t\n\t\t\t if( temp!= 0) {\n\t\t\t\t hm.put( 2L, temp);\n\t\t\t }\n\t\t\t long c = (long)Math.sqrt(n);\n\t\t\t for( long i = 3 ; i <= c ; i+=2) {\n\t\t\t\t temp = 0;\n\t\t\t\t while( n% i == 0) {\n\t\t\t\t\t temp++;\n\t\t\t\t\t n\/=i;\n\t\t\t\t }\n\t\t\t\t if( temp!= 0) {\n\t\t\t\t\t hm.put( i, temp);\n\t\t\t\t }\n\t \t\t }\n\t \t\t if( n!= 1) {\n\t \t\t\t hm.put( n , 1L);\n\t \t\t }\n\t \t\t return hm;\t\n\t\t }\n\t\t \n\t\t @SuppressWarnings(\"unused\")\n\t\tprivate static ArrayList<Integer> allfactors(int abs) {\n\t\t\t HashMap<Integer,Integer> hm = new HashMap<>();\n\t\t\t ArrayList<Integer> rtrn = new ArrayList<>();\n\t\t\t for( int i = 2 ;i*i <= abs; i++) {\n\t\t\t\t if( abs% i == 0) {\n\t\t\t\t\t hm.put( i , 0);\n\t\t\t\t\t hm.put(abs\/i, 0);\n\t\t\t\t }\n\t\t\t }\n\t\t\t for( int x : hm.keySet()) {\n\t\t\t\t rtrn.add(x);\n\t\t\t }\n\t\t\t \n\t\t\t if( abs != 0) {\n\t\t\t\t rtrn.add(abs);\n\t\t\t }\n\t\t\t \n\t\t\t return rtrn;\n\t\t }\n\t\t\t\n\t \n\t\t static class FastReader {\n\t\t\t BufferedReader br;\n\t\t\t StringTokenizer st;\n\t\t \n\t\t\t public FastReader()\n\t\t\t {\n\t\t\t\t br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t }\n\t\t        \n\t\t\t String next()\n\t\t\t {\n\t\t\t\t while (st == null || !st.hasMoreElements()) {\n\t\t\t\t\t try {\n\t\t\t\t\t\t st = new StringTokenizer(br.readLine());\n\t\t\t\t\t }\n\t\t\t\t\t catch (IOException e) {\n\t\t\t\t\t\t e.printStackTrace();\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t return st.nextToken();\n\t\t\t }\n\t\t \n\t\t\t int nextInt() { return Integer.parseInt(next()); }\n\t\t\t \n\t\t\t long nextLong() { return Long.parseLong(next()); }\n\t\t\t \n\t\t\t double nextDouble()\n\t\t\t {\n\t\t\t\t return Double.parseDouble(next());\n\t\t\t }\t\n\t\t \n\t\t\t String nextLine()\n\t\t\t {\n\t\t\t\t String str = \"\";\n\t\t\t\t try {\n\t\t\t\t\t str = br.readLine();\n\t\t\t\t }\n\t\t\t\t catch (IOException e) {\n\t\t\t\t\t e.printStackTrace();\n\t\t\t\t }\n\t\t\t\t return str;\n\t\t\t }\n\t\t }\t\n}\n","import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\nimport static java.lang.Long.bitCount;\nimport static java.lang.Long.parseLong;\n\n\/\/Make it Divisible by 25\n\n\/\/-00\n\/\/-25\n\/\/-50\n\/\/-75\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException, NumberFormatException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\n        int t = Integer.parseInt(br.readLine());\n        while (t-- > 0) {\n\n            long n =Long.parseLong(br.readLine());\n\n            String s [] = br.readLine().split(\" \");\n            List<Integer> l = new ArrayList<>();\n            for(int i=0;i<n;i++){\n                l.add(Integer.parseInt(s[i]));\n            }\n\n            if(n>1) {\n                Collections.sort(l);\n                int max = l.get(0);\n                for(int i=1;i<l.size();i++){\n                    max = Math.max(max,l.get(i)-l.get(i-1));\n                }\n\n                System.out.println(max);\n            }else{\n                System.out.println(l.get(0));\n            }\n        }}\n\n    public static long solve(long n,long k){\n        if(k==1){\n            return 1;\n        }\n        if(k==0){\n            return 0;\n        }\n        long l=1;\n        long m =1000000007;\n        long ans = 1;\n        while(l*2 <= k){\n            ans = (ans*n)%m;\n            l = l*2;\n        }\n        ans = (ans + solve(n,(k-l)))%m;\n        return ans;\n    }\n\n\n\n\n\n\n\n\n\n    \/\/ ------------------------------------------swap----------------------------------------------------------------------\n\n    static void swap(int arr[],int i,int j)\n    {\n        int temp=arr[i];\n        arr[i]=arr[j];\n        arr[j]=temp;\n    }\n\n\n    \/\/-------------------------------------------seiveOfEratosthenes----------------------------------------------------\n\n\n    static boolean prime[];\n    static void sieveOfEratosthenes(int n)\n    {\n        \/\/ Create a boolean array\n        \/\/ \"prime[0..n]\" and\n        \/\/ initialize all entries\n        \/\/ it as true. A value in\n        \/\/ prime[i] will finally be\n        \/\/ false if i is Not a\n        \/\/ prime, else true.\n        prime= new boolean[n + 1];\n        for (int i = 0; i <= n; i++)\n            prime[i] = true;\n\n        for (int p = 2; p * p <= n; p++)\n        {\n            \/\/ If prime[p] is not changed, then it is a\n            \/\/ prime\n            if (prime[p] == true)\n            {\n                \/\/ Update all multiples of p\n                for (int i = p * p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        }\n\n        \/\/ Print all prime numbers\n\/\/        for (int i = 2; i <= n; i++)\n\/\/        {\n\/\/            if (prime[i] == true)\n\/\/                System.out.print(i + \" \");\n\/\/        }\n    }\n\n\n\n    \/\/ ---------------------------------------- power------------------------------------------------------------------\n\n\n\n    public static long power(int a , int b) {\n        if (b == 0) {\n            return 1;\n        } else if (b == 1) {\n            return a;\n\n        } else {\n\n            long R = power(a, b \/ 2);\n            if (b % 2 != 0) {\n\n\n                return (((power(a, b \/ 2))) * a * ((power(a, b \/ 2))));\n            } else {\n                return ((power(a, b \/ 2))) * ((power(a, b \/ 2)));\n            }\n        }\n\n    }\n\n\n\n    \/\/--------------------------------------lower bound----------------------------------------------------------\n\n\n    static int LowerBound(int a[], int x)\n    { \/\/ x is the target value or key\n        int l=-1,r=a.length;\n        while(l+1<r) {\n            int m=(l+r)>>>1;\n            if(a[m]>=x) r=m;\n            else l=m;\n        }\n        return r;\n    }\n\n    \/\/--------------------------------------------------------------------------------------------------------------\n    public static int log2(int x) {\n        return (int) (Math.log(x) \/ Math.log(2));\n    }\n}\n\n\n\n\n\n\n","\/\/package application;\n\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        for (int i = 0; i < t; i++) {\n            int n = sc.nextInt();\n\n            PriorityQueue<Long> pq = new PriorityQueue<>();\n            for (int j = 0; j < n; j++) {\n                pq.add(sc.nextLong());\n            }\n\n            long s = 0;\n            long max = pq.peek();\n\n            while (!pq.isEmpty()) {\n                long curr = pq.poll() - s;\n                if (curr > max) {\n                    max = curr;\n                }\n                s += curr;\n            }\n\n            System.out.println(max);\n        }\n    }\n}\n","for _ in range(int(input())):\n    n=int(input())\n    ans=-1e10\n    if(n==1):\n        ans=input()\n\n    else:\n        arr=list(map(int, input().split()))\n        #print(arr)\n        arr.sort()\n        #print(arr)\n        ans=arr[0]\n        for i in range(1,n):\n            h=arr[i]-arr[i-1]\n            if ans<=h:\n                #print(\"debug\",h, ans)\n                ans=h\n    print(ans)","import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Main\n{\n    static void sort(int a[]){\n        ArrayList<Integer> arr=new ArrayList<>();\n        for(int i=0;i<a.length;i++)arr.add(a[i]);\n        Collections.sort(arr);\n        for(int i=0;i<a.length;i++)a[i]=arr.get(i);\n    }\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    Scanner sc=new Scanner(System.in);\n\t   \/\/ BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t    int t=1;\n\t    t=sc.nextInt();\n\t  \/\/  int t=Integer.parseInt(br.readLine());\n\t    while(--t>=0){\n\t        int n=sc.nextInt();\n\t         int a[]=new int[n];\n\t         long min=(long)1e9;\n\t        for(int i=0;i<n;i++){\n\t            a[i]=sc.nextInt();\n\t            min=Math.min(min,(long)a[i]);\n\t        }\n\t        sort(a);\n\t        for(int i=1;i<n;i++){\n\t            min=Math.max(min,a[i]-a[i-1]);\n\t        }\n\t     System.out.println(min);\n\t        \n\t    }\n\t    \n\t}\n}\n","'''Author- Akshit Monga'''\nfrom sys import stdin, stdout\ninput = stdin.readline\n\ndef ceil(a,b):\n    return (a+b-1)\/\/b\n\nt = int(input())\nfor _ in range(t):\n    n=int(input())\n    a=[int(x) for x in input().split()]\n    a=sorted(a)\n    ans=a[0]\n    delta=0\n    # print(a)\n    for i in range(n-1):\n        delta-=(a[i]+delta)\n        # print(delta)\n        ans=max(ans,a[i+1]+delta)\n    print(ans)","import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n\n    public static void main(String[] args) {\n\n        FastReader sc = new FastReader();\n\n       int t = sc.nextInt();\n\n       for (int j = 0 ; j < t ; j++) {\n       int n = sc.nextInt();\n       Integer[] vals = new Integer[n];\n       for (int k = 0 ; k < n ; k++) {\n           vals[k] = sc.nextInt();\n\n       }\n\n       Arrays.sort(vals);\n\n           long max = vals[0];\n           for (int k = 1 ; k < n ; k++) {\n\n               max = Math.max(max,vals[k] - vals[k-1] );\n\n           }\n\n           System.out.println(max);\n\n       }\n\n    }\n\n\n}","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long maxn = 2e5 + 9;\nconst long long inf = 0x3f3f3f3f;\nint main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    long long a[maxn];\n    for (long long i = 0; i < n; i++) cin >> a[i];\n    sort(a, a + n);\n    long long s = 0;\n    long long ans = a[0];\n    a[n] = a[0] - 1;\n    for (long long i = 0; i < n; i++) {\n      long long x = a[i] + s;\n      s = s - x;\n      ans = max(ans, x);\n    }\n    cout << ans << endl;\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    if (n <= 1) {\n      cout << a[0] << endl;\n    } else {\n      sort(a, a + n);\n      int mx = a[0];\n      for (int i = 0; i < n - 1; i++) {\n        mx = max(a[i + 1] - a[i], mx);\n      }\n      cout << mx << endl;\n    }\n  }\n  return 0;\n}\n","# 8\n# 1\n# 10\n# 2\n# 0 0\n# 3\n# -1 2 0\n# 4\n# 2 10 1 7\n# 2\n# 2 3\n# 5\n# 3 2 -4 -2 0\n# 2\n# -1 1\n# 1\n# -2\n\n# 10\n# 0\n# 2\n# 5\n# 2\n# 2\n# 2\n# -2\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    l = list(map(int, input().split()))\n    l.sort()\n    if len(l) == 1:\n        print(l[0])\n        continue\n    if l[0] >= 0:\n        l.insert(0, 0)\n    max_val = 0\n    for j in range(len(l)-1):\n        if l[j+1] - l[j] > max_val:\n            max_val = l[j+1] - l[j]\n    print(max_val)\n","# Sujith\nfrom sys import stdin,stdout,setrecursionlimit\nfrom io import BytesIO, IOBase\n# from heapq import heappush as push,heappop as hp,heapify as h\n# from math import gcd,floor,sqrt,ceil\nfrom collections import Counter,deque as dq,defaultdict\n# from itertools import accumulate as acc,permutations as perm\n# from bisect import bisect_left as bl,bisect_right as br,bisect as bis\n\nsetrecursionlimit(10000)\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n        self.BUFSIZE = 8192\n\n    def read(self):\n        while True:\n            a = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n            if not a:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(a), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            a = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n            self.newlines = a.count(b\"\\n\") + (not a)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(a), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ninput = lambda: stdin.readline().rstrip(\"\\r\\n\")\n\n# inf = float('inf')\n# ninf = float('-inf')\n# abc = 'abcdefghijklmnopqrstuvwxyz'\ninp = lambda: int(input())\nst = lambda: input().strip()\njn = lambda x,l: x.join(map(str,l))\nint_arr = lambda : list(map(int,input().strip().split()))\nstr_arr = lambda :list(map(str,input().split()))\nget_str = lambda : map(str,input().strip().split())\nget_int = lambda: map(int,input().strip().split())\nget_float = lambda : map(float,input().strip().split())\n\nmod = 1000000007\n\n#main()\nfor _ in range(inp()):\n    n = inp()\n    arr = int_arr()\n\n    if n == 1:\n        print(arr[0])\n    else:\n        arr.sort()\n        ele = arr[0]\n        tot = 0\n        mx = arr[0]\n        for i in range(1,n):\n            arr[i] -= ele + tot\n            tot += ele\n            mx = max(arr[i],mx)\n            ele = arr[i]\n        print(mx)\n\n\n\n\n\n\n","import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    static long startTime = System.currentTimeMillis();\n\n    \/\/ for global initializations and methods starts here\n    static long hash;\n\n    \/\/ global initialisations and methods end here\n\n    static void run() {\n        boolean tc = true;\n        AdityaFastIO r = new AdityaFastIO();\n        \/\/FastReader r = new FastReader();\n\n        try (OutputStream out = new BufferedOutputStream(System.out)) {\n\n            \/\/long startTime = System.currentTimeMillis();\n\n            int testcases = tc ? r.ni() : 1;\n            int tcCounter = 1;\n            \/\/ Hold Here Sparky------------------->>>\n            \/\/ Solution Starts Here\n\n            start:\n            while (testcases-- > 0) {\n\n                int n = r.ni();\n                List<Long> al = new ArrayList<>();\n                for (int i = 0; i < n; i++) al.add(r.nl());\n\n                PriorityQueue<Long> pq = new PriorityQueue<>();\n                for (long ele : al) pq.add(ele - hash);\n\n                Collections.sort(al);\n\n                long ans = al.get(0);\n                for (int i = 0; i < n; i++) {\n                    long get = pq.poll() + hash;\n                    ans = Math.max(ans, get);\n                    hash -= get;\n                }\n\n                out.write((ans + \" \").getBytes());\n                out.write((\"\\n\").getBytes());\n\n            }\n            \/\/ Solution Ends Here\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class AdityaFastIO {\n        final private int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n        public BufferedReader br;\n        public StringTokenizer st;\n\n        public AdityaFastIO() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public AdityaFastIO(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String word() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String line() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[100000001]; \/\/ line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int ni() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public long nl() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public double nd() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') \/ (div *= 10);\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null) return;\n            din.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        run();\n    }\n\n    static long mod = 998244353;\n\n    static long modInv(long base, long e) {\n        long result = 1;\n        base %= mod;\n        while (e > 0) {\n            if ((e & 1) > 0) result = result * base % mod;\n            base = base * base % mod;\n            e >>= 1;\n        }\n        return result;\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String word() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String line() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int ni() {\n            return Integer.parseInt(word());\n        }\n\n        long nl() {\n            return Long.parseLong(word());\n        }\n\n        double nd() {\n            return Double.parseDouble(word());\n        }\n    }\n\n    static int MOD = (int) (1e9 + 7);\n\n    static long powerLL(long x, long n) {\n        long result = 1;\n        while (n > 0) {\n            if (n % 2 == 1) result = result * x % MOD;\n            n = n \/ 2;\n            x = x * x % MOD;\n        }\n        return result;\n    }\n\n    static long powerStrings(int i1, int i2) {\n        String sa = String.valueOf(i1);\n        String sb = String.valueOf(i2);\n        long a = 0, b = 0;\n        for (int i = 0; i < sa.length(); i++) a = (a * 10 + (sa.charAt(i) - '0')) % MOD;\n        for (int i = 0; i < sb.length(); i++) b = (b * 10 + (sb.charAt(i) - '0')) % (MOD - 1);\n        return powerLL(a, b);\n    }\n\n    static long gcd(long a, long b) {\n        if (a == 0) return b;\n        else return gcd(b % a, a);\n    }\n\n    static long lcm(long a, long b) {\n        return (a * b) \/ gcd(a, b);\n    }\n\n    static long lower_bound(int[] arr, int x) {\n        int l = -1, r = arr.length;\n        while (l + 1 < r) {\n            int m = (l + r) >>> 1;\n            if (arr[m] >= x) r = m;\n            else l = m;\n        }\n        return r;\n    }\n\n    static int upper_bound(int[] arr, int x) {\n        int l = -1, r = arr.length;\n        while (l + 1 < r) {\n            int m = (l + r) >>> 1;\n            if (arr[m] <= x) l = m;\n            else r = m;\n        }\n        return l + 1;\n    }\n\n    static void addEdge(ArrayList<ArrayList<Integer>> graph, int edge1, int edge2) {\n        graph.get(edge1).add(edge2);\n        graph.get(edge2).add(edge1);\n    }\n\n    public static class Pair implements Comparable<Pair> {\n        int first;\n        int second;\n\n        public Pair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(Pair o) {\n            \/\/ TODO Auto-generated method stub\n            if (this.first != o.first)\n                return (int) (this.first - o.first);\n            else return (int) (this.second - o.second);\n        }\n    }\n\n    public static class PairC<X, Y> implements Comparable<PairC> {\n        X first;\n        Y second;\n\n        public PairC(X first, Y second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(PairC o) {\n            \/\/ TODO Auto-generated method stub\n            return o.compareTo((PairC) first);\n        }\n    }\n\n    static boolean isCollectionsSorted(List<Long> list) {\n        if (list.size() == 0 || list.size() == 1) return true;\n        for (int i = 1; i < list.size(); i++) if (list.get(i) <= list.get(i - 1)) return false;\n        return true;\n    }\n\n    static boolean isCollectionsSortedReverseOrder(List<Long> list) {\n        if (list.size() == 0 || list.size() == 1) return true;\n        for (int i = 1; i < list.size(); i++) if (list.get(i) >= list.get(i - 1)) return false;\n        return true;\n    }\n\n}","t = int(input())\n\ninf = -(10**17)\n\nans = []\nfor _ in range(t):\n    n = int(input())\n    nums = [int(_) for _ in input().split()]\n    nums.sort()\n    val = nums[0]\n    pre = nums[0]\n    flag = True\n    for n in nums[1:]:\n        val, pre = max(val, n-pre), n\n    ans.append(str(val))\n\nprint('\\n'.join(ans))","#include <bits\/stdc++.h>\nusing namespace std;\n#pragma GCC target( \\\n    \"sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\nconst long long inf = 1e18;\nconst double pi = 3.14159265358979323846264338327950288419716939937510;\nconst long long mod = 1e9 + 7;\nconst long long mod2 = 998244353;\nconst double eps = (0.00000000001);\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  a %= b;\n  return gcd(b, a);\n}\nlong long gcdExtended(long long, long long, long long*, long long*);\nlong long gcdExtended(long long a, long long b, long long* x, long long* y) {\n  if (a == 0) {\n    *x = 0, *y = 1;\n    return b;\n  }\n  long long x1, y1;\n  long long gcd = gcdExtended(b % a, a, &x1, &y1);\n  *x = y1 - (b \/ a) * x1;\n  *y = x1;\n  return gcd;\n}\nlong long powerForInverse(long long x, long long y, long long m) {\n  if (y == 0) return 1;\n  long long temp = powerForInverse(x, y \/ 2, m);\n  temp = (temp * temp) % m;\n  if (y & 1) temp = ((temp % m) * (x % m)) % m;\n  return temp;\n}\nlong long modInverse(long long a, long long m) {\n  return powerForInverse(a, m - 2, m);\n}\nlong long nCr(long long n, long long r) {\n  if (r > n) return 0;\n  if (r > n - r) r = n - r;\n  long long ans = 1;\n  for (long long i = 1; i < r + 1; i++) {\n    ans *= (n - i + 1);\n    ans *= modInverse(i, mod);\n  }\n  return ans;\n}\nlong long nCrM(long long n, long long r) {\n  if (r > n) return 0;\n  if (r > n - r) r = n - r;\n  long long ans = 1;\n  for (long long i = 1; i < r + 1; i++) {\n    ans *= (n - i + 1);\n    ans %= mod;\n    ans *= modInverse(i, mod);\n    ans %= mod;\n  }\n  return ans;\n}\nlong long lcm(long long a, long long b) { return (a \/ gcd(a, b)) * b; }\nlong long binpowM(long long a, long long b) {\n  if (b == 0) return 1;\n  if (b == 1) return a % mod;\n  long long res = binpowM(a, b \/ 2) % mod;\n  if (b % 2 == 1)\n    return (((res * res) % mod) * a) % mod;\n  else\n    return (res * res) % mod;\n}\nlong long binpow(long long a, long long b) {\n  if (b == 0) return 1;\n  if (b == 1) return a;\n  long long res = binpow(a, b \/ 2);\n  if (b % 2 == 1)\n    return (((res * res)) * a);\n  else\n    return (res * res);\n}\nvoid sieve(vector<long long>& primes, long long n, vector<long long>& touched) {\n  primes.clear();\n  long long arr[n + 1];\n  for (long long i = 0; i < n + 1; i++) arr[i] = i;\n  touched[0] = true;\n  touched[1] = true;\n  for (long long i = 2; i < (int)sqrt(n) + 1; i++) {\n    if (!touched[i]) {\n      touched[i] = true;\n      primes.push_back(i);\n      for (long long j = i * i; j < n + 1; j++) {\n        touched[j] = true;\n        j--;\n        j += i;\n      }\n    }\n  }\n  for (long long i = (int)sqrt(n) + 1; i < n; i++) {\n    if (!touched[i]) primes.push_back(i);\n  }\n}\nlong long binary_search(long long arr[], long long n, long long elem) {\n  long long l = 0, r = n - 1;\n  while (r >= l) {\n    long long mid = (l + r) \/ 2;\n    if (arr[mid] > elem)\n      r = mid - 1;\n    else if (arr[mid] < elem)\n      l = mid + 1;\n    else\n      return mid;\n  }\n  return -1;\n}\nlong long binary_search_vector(vector<long long>& arr, long long elem) {\n  long long n = arr.size();\n  long long l = 0, r = n - 1;\n  while (r >= l) {\n    long long mid = (l + r) \/ 2;\n    if (arr[mid] > elem)\n      r = mid - 1;\n    else if (arr[mid] < elem)\n      l = mid + 1;\n    else\n      return mid;\n  }\n  return -1;\n}\nlong long factorial(long long n) {\n  long long res = 1;\n  for (long long i = 2; i < n + 1; i++) res *= i;\n  return res;\n}\nlong long factorialM(long long n) {\n  long long res = 1;\n  for (long long i = 2; i < n + 1; i++) res = (res * i) % mod;\n  return res % mod;\n}\nbool checkPrime(long long n) {\n  long long count = 0;\n  for (long long i = 2; i < 1 + (long long)sqrt(n); i++) {\n    if (n % i == 0) count++;\n  }\n  if (count > 0)\n    return false;\n  else\n    return true;\n}\nbool compare(pair<long long, long long> p1, pair<long long, long long> p2) {\n  if (p1.second > p2.second)\n    return true;\n  else if (p1.second == p2.second)\n    return p1.first < p2.first;\n  else\n    return false;\n}\nclass Graph {\n public:\n  vector<vector<long long> > adj;\n  vector<bool> visited;\n  Graph(long long n) {\n    adj.resize(n + 1);\n    visited.resize(n + 1);\n  }\n  void addEdge(long long first, long long second, bool directed = false);\n  void dfs(long long start);\n  void check(long long ans[], long long n);\n};\nvoid Graph::addEdge(long long first, long long second, bool directed) {\n  adj[first].push_back(second);\n  if (!directed) adj[second].push_back(first);\n}\nvoid Graph::dfs(long long start) {\n  visited[start] = true;\n  cout << start << \" \";\n  for (long long i = 0; i < adj[start].size(); i++) {\n    if (!visited[adj[start][i]]) dfs(adj[start][i]);\n  }\n}\nvoid Graph::check(long long ans[], long long n) {\n  for (long long i = 0; i < adj.size(); i++) {\n    ans[adj[i].size()]++;\n  }\n}\nlong long noOfDigits(long long x) {\n  long long digits = 0;\n  while (x > 0) {\n    x \/= 10;\n    digits++;\n  }\n  return digits;\n}\nlong long sumOfDigits(long long n) {\n  long long sum = 0;\n  while (n > 0) {\n    sum += n % 10;\n    n \/= 10;\n  }\n  return sum;\n}\nbool cmp(pair<long long, long long> a, pair<long long, long long> b) {\n  return a.first < b.first;\n}\nvoid reverse(string& str, long long start, long long end) {\n  for (long long i = start; i < start + ((end - start + 1) \/ 2); i++) {\n    swap(str[i], str[end + start - i]);\n  }\n}\nlong long findGCD(long long arr[], long long n) {\n  long long result = arr[0];\n  for (int i = 1; i < n; i++) {\n    result = gcd(arr[i], result);\n    if (result == 1) {\n      return 1;\n    }\n  }\n  return result;\n}\nlong long findGCD1(long long arr[], long long n, long long i1, long long i2) {\n  long long result;\n  if (i1 == 0) {\n    result = arr[0] * arr[i2];\n  } else {\n    result = arr[0];\n  }\n  for (int i = 1; i < n; i++) {\n    if (i == i1) {\n      result = gcd(arr[i] * arr[i2], result);\n    } else if (i == i2) {\n      result = gcd(arr[i] * arr[i1], result);\n    } else {\n      result = gcd(arr[i], result);\n    }\n    if (result == 1) {\n      return 1;\n    }\n  }\n  return result;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  srand(time(NULL));\n  long long t;\n  cin >> t;\n  for (long long tc = 1; tc <= t; tc++) {\n    long long n;\n    cin >> n;\n    long long arr[n];\n    for (long long i = 0; i < n; i++) {\n      cin >> arr[i];\n    };\n    sort(arr, arr + n);\n    if (n == 1) {\n      cout << arr[0] << \"\\n\";\n      continue;\n    }\n    long long ans = INT_MIN;\n    ans = max(ans, arr[0]);\n    for (long long i = 0; i < n - 1; i++) {\n      ans = max(ans, arr[i + 1] - arr[i]);\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n","from heapq import heapify, heappop\nfrom sys import stdin\n\n\ndef maximize(l):\n    heapify(l)\n    total = 0\n    result = None\n    while len(l) != 0:\n        s = heappop(l)\n        d = s - total\n        total = s\n        if result is None:\n            result = d\n        else:\n            result = max(result, d)\n\n    return result\n\n\nt = int(stdin.readline())\n\nfor _ in range(t):\n    stdin.readline()\n    data = [int(d) for d in stdin.readline().strip().split()]\n    result = maximize(data)\n    print(result)\n","import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\/**\n *\n * @author eslam\n *\/\npublic class MinimumExtraction {\n\n    static class FastReader {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(\n                    new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        FastReader input = new FastReader();\n        BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));\n        int t =  input.nextInt();\n        loop:for (int i = 0; i < t; i++) {\n            int n = input.nextInt();\n            Long a[] = new Long[n];\n            for (int j = 0; j < n; j++) {\n                a[j] = input.nextLong();\n            }\n            if(n==1){\n                log.write(a[0]+\"\\n\");\n            }else{\n                Arrays.parallelSort(a);\n                long ans = a[0];\n                for (int j = 0; j < n-1; j++) {\n                    ans = Math.max(a[j+1]-a[j], ans);\n                }\n                log.write(ans+\"\\n\");\n            }\n        }\n        log.flush();\n    }\n    \n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main(int argc, char const *argv[]) {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> arr(n, 0);\n    for (long long i = 0; i <= n - 1; i++) {\n      cin >> arr[i];\n    }\n    sort(arr.begin(), arr.end());\n    long long ans = arr[0];\n    for (long long i = 1; i <= n - 1; i++) {\n      ans = max(ans, arr[i] - arr[i - 1]);\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long int combi(int n, int k) {\n  long long int ans = 1;\n  if (k > n) {\n    ans = 0;\n  } else {\n    k = k > n - k ? n - k : k;\n    long long int j = 1;\n    for (; j <= k; j++, n--) {\n      if (n % j == 0) {\n        ans *= n \/ j;\n      } else if (ans % j == 0) {\n        ans = ans \/ j * n;\n      } else {\n        ans = (ans * n) \/ j;\n      }\n    }\n  }\n  return ans;\n}\nunordered_map<int, int> hm;\nvoid countFreq(int b[], int n) {\n  for (int i = 0; i < n; i++) hm[b[i]]++;\n  int max_count = 0, res = -1;\n  for (auto i : hm) {\n    if (max_count < i.second) {\n      res = i.first;\n      max_count = i.second;\n    }\n  }\n}\nint query(int x) { return hm[x]; }\nint previousFibonacci(int n) {\n  double a = n \/ ((1 + sqrt(5)) \/ 2.0);\n  return round(a);\n}\nint maxRepeating(string str) {\n  int n = str.length();\n  int count = 0;\n  char res = str[0];\n  int cur_count = 1;\n  for (int i = 0; i < n; i++) {\n    if (i < n - 1 && str[i] == str[i + 1]) {\n      cur_count++;\n    } else {\n      if (cur_count > count) {\n        count = cur_count;\n        res = str[i];\n      }\n      cur_count = 1;\n    }\n  }\n  return count;\n}\nbool sortbysec(const pair<int, int> &a, const pair<int, int> &b) {\n  return (a.second < b.second);\n}\nint findIndex(int n) {\n  float fibo = 2.078087 * log(n) + 1.672276;\n  return round(fibo);\n}\nstring fib(int n) {\n  int a = 0, b = 1, c, i;\n  string s0 = \"0\", s1 = \"1\", s;\n  for (i = 2; i <= n; i++) {\n    c = a + b;\n    a = b;\n    b = c;\n    s = s1 + s0;\n    s0 = s1;\n    s1 = s;\n  }\n  return s1;\n}\nint findSubSequence(string s, int num) {\n  int res = 0;\n  int i = 0;\n  while (num) {\n    if (num & 1) res += s[i] - '0';\n    i++;\n    num = num >> 1;\n  }\n  return res;\n}\nint combinedSum(string s) {\n  int n = s.length();\n  int c_sum = 0;\n  int range = (1 << n) - 1;\n  for (int i = 0; i <= range; i++)\n    c_sum += (findSubSequence(s, i) % 1000000007);\n  return c_sum;\n}\nint maxFreq(int *arr, int n) {\n  int res = 0;\n  int count = 1;\n  for (int i = 1; i < n; i++) {\n    if (arr[i] == arr[res]) {\n      count++;\n    } else {\n      count--;\n    }\n    if (count == 0) {\n      res = i;\n      count = 1;\n    }\n  }\n  return arr[res];\n}\nint getIndex(vector<string> v, string K) {\n  auto it = find(v.begin(), v.end(), K);\n  int index;\n  if (it != v.end()) {\n    index = it - v.begin();\n  } else {\n    index = -1;\n  }\n  return index;\n}\nint const N = 10000000;\nint is_prime[N];\nbool sieve() {\n  int i = 2;\n  while (i * i <= N) {\n    if (is_prime[i] == 0) {\n      i++;\n      continue;\n    }\n    int j = 2 * i;\n    while (j < N) {\n      is_prime[j] = 0;\n      j += i;\n    }\n    i++;\n  }\n}\nint mod(string num, int a) {\n  int res = 0;\n  for (int i = 0; i < num.length(); i++)\n    res = (res * 10 + (int)num[i] - '0') % a;\n  return res;\n}\nstring decimalToBinary(long long int n) {\n  string s = bitset<64>(n).to_string();\n  const auto loc1 = s.find('1');\n  if (loc1 != string::npos) return s.substr(loc1);\n  return \"0\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int a[n], b[n - 1];\n    for (int i = 0; i < n; i++) cin >> a[i];\n    if (n == 1)\n      cout << a[0] << endl;\n    else {\n      sort(a, a + n);\n      for (int i = 0; i < n - 1; i++) b[i] = a[i + 1] - a[i];\n      sort(b, b + n - 1);\n      cout << max(b[n - 2], a[0]) << endl;\n    }\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  cin.tie(0);\n  cout.tie(0);\n  ios_base::sync_with_stdio(false);\n  long long n, t, a, b, x, y;\n  string s, f;\n  long long ans;\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    vector<int> as;\n    for (int i = 0; i < n; i++) {\n      cin >> a;\n      as.push_back(a);\n    }\n    sort(as.begin(), as.end());\n    long long ans = as[0];\n    long long q = as[0];\n    for (int i = 1; i < n; i++) {\n      ans = max(ans, as[i] - q);\n      q += as[i] - q;\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n","t = int(input())\nfor i in range(0,t):\n    n = int(input())\n    lst = list(map(int,input().split()))\n    lst2 = []\n    if n == 1:\n        print(lst[0])\n    else:\n        lst2.append(min(lst))\n        lst.sort()\n        for a in range(1,n):\n            lst2.append(lst[a]-lst[a-1])\n        print(max(lst2))\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n;\n  cin >> n;\n  long long a[n];\n  for (long long i = 0; i < n; i++) cin >> a[i];\n  sort(a, a + n);\n  long long ans = a[0];\n  for (long long i = 1; i < n; i++) {\n    ans = max(ans, a[i] - a[i - 1]);\n  }\n  cout << ans << \"\\n\";\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) solve();\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> c(n);\n    for (int i = 0; i < n; i++) cin >> c[i];\n    sort(c.begin(), c.end());\n    int m = c[0];\n    for (int i = 1; i < n; i++) {\n      if (c[i] - c[i - 1] > m) m = c[i] - c[i - 1];\n    }\n    cout << m;\n    cout << '\\n';\n  }\n  return 0;\n}\n","import math\nfrom collections import Counter\nimport copy\n#'YES'\n\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tarr = [int(i) for i in input().split()]\n\tarr.sort()\n\tprev = arr[0]\n\tans = prev\n\tfor i in range(1, n):\n\t\ttemp = arr[i] - prev\n\t\tans = max(ans, temp)\n\t\tprev += temp\n\tprint(ans)\n\n","for _ in range(int(input())):\n    n=int(input())\n    s=sorted(list(map(int,input().split()))[:n])\n    m=d=s[0]\n    for i in range(1,n):\n        s[i]-=d\n        d+=s[i]\n        m=max(m,s[i])\n    print(m)","#include <bits\/stdc++.h>\nusing namespace std;\nconst unsigned int ev = 0xAAAAAAAA;\nconst unsigned int od = 0x55555555;\nconst long long MOD2 = 1000000007;\nconst long long MOD1 = 998244353;\nvoid kmp(long long n, long long a[], long long s[]) {\n  a[0] = 0;\n  for (auto i = 1; i < n; i++) {\n    long long j = a[i - 1];\n    while (j > 0 && s[j] != s[i]) {\n      j = a[j - 1];\n    }\n    if (s[i] == s[j]) {\n      j++;\n    }\n    a[i] = j;\n  }\n}\nvoid dfsUtil(vector<vector<long long>> &adj, long long s, long long par,\n             long long b[], long long a[]) {\n  for (auto pro : adj[s]) {\n    if (pro != par) {\n      dfsUtil(adj, pro, s, b, a);\n    }\n  }\n  b[s] = a[s];\n  for (auto pro : adj[s]) {\n    b[s] += b[pro];\n  }\n}\nlong long fp(long long x, long long n, long long MOD) {\n  long long ans = 1;\n  while (n > 0) {\n    if (n & 1) ans *= x;\n    x *= x;\n    ans %= MOD;\n    x %= MOD;\n    n \/= 2;\n  }\n  return ans;\n}\nvoid mobiusmu(long long n, long long vals[], bool comps[]) {\n  vals[1] = 1;\n  vector<long long> primevec;\n  for (auto i = 2; i <= n; i++) {\n    if (!comps[i]) {\n      primevec.push_back(i);\n      vals[i] = -1;\n    }\n    for (auto j = 0; j < primevec.size() && (primevec[j]) * i <= n; j++) {\n      if (i % (primevec[j]) == 0) {\n        vals[i * (primevec[j])] = 0;\n        break;\n      } else {\n        vals[i * (primevec[j])] = vals[i] * vals[primevec[j]];\n      }\n    }\n  }\n}\nvoid makesegtree(vector<long long> &segtree, long long n, long long a[]) {\n  for (auto i = n; i <= 2 * n - 1; i++) {\n    segtree[i] = a[i - n];\n  }\n  for (long long i = n - 1; i > 0; i--) {\n    segtree[i] = min(segtree[2 * i], segtree[2 * i + 1]);\n  }\n}\nvoid update(vector<long long> &segtree, long long n, long long l,\n            long long al) {\n  l -= 1;\n  l += n;\n  segtree[l] = al;\n  while (l \/ 2 > 0) {\n    if (l % 2) {\n      segtree[l \/ 2] = max(segtree[l - 1], segtree[l]);\n    } else {\n      segtree[l \/ 2] = max(segtree[l], segtree[l + 1]);\n    }\n    l \/= 2;\n  }\n}\nlong long operate(vector<long long> &segtree, long long n, long long x1,\n                  long long x2) {\n  long long maax = 1000000000000000;\n  long long i1 = x1 - 1;\n  long long i2 = x2 - 1;\n  i1 += n;\n  i2 += n;\n  while (i1 <= i2) {\n    if (i1 % 2) {\n      maax = min(maax, segtree[i1++]);\n    }\n    if (i2 % 2 == 0) {\n      maax = min(maax, segtree[i2--]);\n    }\n    i1 \/= 2;\n    i2 \/= 2;\n  }\n  return maax;\n}\nlong long eugcd(long long a, long long b) {\n  a = abs(a);\n  b = abs(b);\n  while (b) {\n    long long temp = a;\n    a = b;\n    b = temp % a;\n  }\n  return a;\n}\nlong long fensum(long long arr[], long long i) {\n  long long res = 0;\n  while (i >= 0) {\n    res += arr[i];\n    i = (i & (i + 1)) - 1;\n  }\n  return res;\n}\nvoid fenupdate(long long arr[], long long i, long long del, long long n) {\n  while (i < n) {\n    arr[i] += del;\n    i |= (i + 1);\n  }\n}\nlong long fact[600001];\nlong long invfact[600001];\nlong long nck(long long n, long long k) {\n  long long ans = 1;\n  ans *= fact[n];\n  ans *= invfact[k];\n  ans %= 998244353;\n  ans *= invfact[n - k];\n  ans %= 998244353;\n  return ans;\n}\nlong long answer(vector<vector<long long>> &adj, long long n, long long s,\n                 long long a[], long long b[]) {\n  if (adj[s].size() == 0) {\n    return b[s];\n  } else {\n    long long maax = 0;\n    long long ind = -1;\n    for (auto pro : adj[s]) {\n      maax = max(maax, b[pro]);\n      if (maax == b[pro]) {\n        ind = pro;\n      }\n    }\n    for (auto pro : adj[s]) {\n      if (a[s] >= maax - b[pro]) {\n        a[s] -= (maax - b[pro]);\n        b[pro] = maax;\n      }\n    }\n    if (a[s]) {\n      long long siz = adj[s].size();\n      for (auto pro : adj[s]) {\n        b[pro] += a[s] \/ siz;\n        ind = pro;\n      }\n      if (a[s] % siz) {\n        for (auto pro : adj[s]) {\n          b[pro] += 1;\n          ind = pro;\n          break;\n        }\n      }\n    }\n    return answer(adj, n, ind, a, b);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    long long a[n];\n    for (auto i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a, a + n);\n    long long negsig = 0;\n    long long ans = a[0];\n    for (auto i = 0; i < n; i++) {\n      a[i] -= negsig;\n      ans = max(ans, a[i]);\n      negsig += a[i];\n    }\n    cout << ans << endl;\n  }\n}\n","from bisect import insort,bisect_right,bisect_left\nfrom sys import stdout, stdin, setrecursionlimit\nfrom heapq import heappush, heappop, heapify \nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import * \nfrom string import *\nfrom queue import *\nfrom math import *\nfrom re import *\nfrom os import *\n# sqrt,ceil,floor,factorial,gcd,log2,log10,comb\nfrom operator import truediv\n\n####################################---fast-input-output----#########################################\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = read(self._fd, max(fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ngraph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())\ndef getStr(): return input()\ndef getInt(): return int(input())\ndef listStr(): return list(input())\ndef getStrs(): return input().split()\ndef isInt(s): return '0' <= s[0] <= '9'\ndef input(): return stdin.readline().strip()\ndef zzz(): return [int(i) for i in input().split()]\ndef output(answer, end='\\n'): stdout.write(str(answer) + end)\ndef lcd(xnum1, xnum2): return (xnum1 * xnum2 \/\/ gcd(xnum1, xnum2))\n\n\ndef getPrimes(N = 10**5):\n    SN = int(sqrt(N))\n    sieve = [i for i in range(N+1)]\n    sieve[1] = 0\n    for i in sieve:\n        if i > SN:\n            break\n        if i == 0:\n            continue\n        for j in range(2*i, N+1, i):\n            sieve[j] = 0\n    prime = [i for i in range(N+1) if sieve[i] != 0] \n    return prime\ndef primeFactor(n,prime=getPrimes()):\n    lst = []\n    mx=int(sqrt(n))+1\n    for i in prime:\n        if i>mx:break\n        while n%i==0:\n            lst.append(i)\n            n\/\/=i\n    if n>1:\n        lst.append(n)\n    return lst    \n\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\ndaysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n\n#################################################---Some Rule For Me To Follow---#################################\n\"\"\"\n    --instants of Reading problem continuously try to understand them.\n\n    --Try & again try, maybe you're just one statement away!\n\n\"\"\"\n##################################################---START-CODING---###############################################\n\n\nnum = getInt()\n\nfor _ in range(num):\n    n = getInt()\n\n    arr = szzz()\n\n    res = arr[0]\n    \n    curr = arr[0]\n    for i in range(1,n):\n        \n        arr[i]-=curr\n        res = max(res,arr[i])\n        curr+=arr[i]\n        \n    print(res)\n\n\n\n\n\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long mxlli = 1e18;\nconst int mod = 1e9 + 7;\nconst int msize = 2e5 + 2;\nint solv(int T) {\n  int n, i;\n  cin >> n;\n  vector<long long> a(n);\n  long long r = -mxlli, mn = mxlli;\n  for (i = 0; i < n; i++) {\n    cin >> a[i];\n    mn = min(mn, a[i]);\n  }\n  sort(a.begin(), a.end());\n  reverse(a.begin(), a.end());\n  if (n == 1) {\n    cout << a[0] << \"\\n\";\n    return 0;\n  }\n  for (i = 1; i < n; i++) {\n    r = max(r, a[i - 1] - a[i]);\n  }\n  cout << max(mn, r) << \"\\n\";\n  return 0;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int testcases = 1;\n  cin >> testcases;\n  for (int T = 1; T <= testcases; T++) {\n    solv(T);\n  }\n}\n","\/\/package codeforces.round753div3;\n\nimport java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\n\/\/Think through the entire logic before jump into coding!\n\/\/If you are out of ideas, take a guess! It is better than doing nothing!\n\/\/Read both C and D, it is possible that D is easier than C for you!\n\n\/\/Be aware of integer overflow!\n\/\/If you find an answer and want to return immediately, don't forget to flush before return!\n\npublic class C {\n    static InputReader in;\n    static PrintWriter out;\n\n    public static void main(String[] args) {\n        \/\/initReaderPrinter(true);\n        initReaderPrinter(false);\n        solve(in.nextInt());\n        \/\/solve(1);        \n    }\n\n    static void solve(int testCnt) {\n        for (int testNumber = 0; testNumber < testCnt; testNumber++) {\n            int n = in.nextInt();\n            PriorityQueue<Integer> q = new PriorityQueue<>();\n            for(int i = 0; i < n; i++) {\n                int v = in.nextInt();\n                q.add(v);\n            }\n            long ans = Long.MIN_VALUE, base = 0;\n            while(q.size() > 1) {\n                int v = q.poll();\n                v -= base;\n                ans = max(ans, v);\n                base += v;\n            }\n            ans = max(ans, q.peek() - base);\n            out.println(ans);\n        }\n        out.close();\n    }\n\n    static void initReaderPrinter(boolean test) {\n        if (test) {\n            try {\n                in = new InputReader(new FileInputStream(\"src\/input.in\"));\n                out = new PrintWriter(new FileOutputStream(\"src\/output.out\"));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            in = new InputReader(System.in);\n            out = new PrintWriter(System.out);\n        }\n    }\n\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        InputReader(InputStream stream) {\n            try {\n                br = new BufferedReader(new InputStreamReader(stream), 32768);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        Integer[] nextIntArray(int n) {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArrayPrimitive(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArrayPrimitiveOneIndexed(int n) {\n            int[] a = new int[n + 1];\n            for (int i = 1; i <= n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        Long[] nextLongArray(int n) {\n            Long[] a = new Long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        long[] nextLongArrayPrimitive(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        long[] nextLongArrayPrimitiveOneIndexed(int n) {\n            long[] a = new long[n + 1];\n            for (int i = 1; i <= n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        String[] nextStringArray(int n) {\n            String[] g = new String[n];\n            for (int i = 0; i < n; i++) g[i] = next();\n            return g;\n        }\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nconst int maxn = 3e5 + 5;\nconst int inf = 1e9 + 5;\nconst int mod = 1e9 + 7;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int a[n + 5];\n    for (int i = 1; i <= n; i++) {\n      cin >> a[i];\n    }\n    sort(a + 1, a + n + 1);\n    int del = 0;\n    int ans = -inf;\n    for (int i = 1; i <= n; i++) {\n      ans = max(ans, a[i] - del);\n      del += a[i] - del;\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n","import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n    public static void print(int[] arr) {\n        \/\/for debugging only\n        for (int x : arr)\n            System.out.print(x + \" \");\n        System.out.println();\n    }\n\n    public static boolean isPrime(long n) {\n        if (n < 2) return false;\n        if (n == 2 || n == 3) return true;\n        if (n % 2 == 0 || n % 3 == 0) return false;\n        long sqrtN = (long) Math.sqrt(n) + 1;\n        for (long i = 6L; i <= sqrtN; i += 6) {\n            if (n % (i - 1) == 0 || n % (i + 1) == 0) return false;\n        }\n        return true;\n    }\n\n    public static long gcd(long a, long b) {\n        if (a > b)\n            a = (a + b) - (b = a);\n        if (a == 0L)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    public static ArrayList<Integer> findDiv(int N) {\n        \/\/gens all divisors of N\n        ArrayList<Integer> ls1 = new ArrayList<Integer>();\n        ArrayList<Integer> ls2 = new ArrayList<Integer>();\n        for (int i = 1; i <= (int) (Math.sqrt(N) + 0.00000001); i++)\n            if (N % i == 0) {\n                ls1.add(i);\n                ls2.add(N \/ i);\n            }\n        Collections.reverse(ls2);\n        for (int b : ls2)\n            if (b != ls1.get(ls1.size() - 1))\n                ls1.add(b);\n        return ls1;\n    }\n\n    public static void sort(int[] arr) {\n        \/\/because Arrays.sort() uses quicksort which is dumb\n        \/\/Collections.sort() uses merge sort\n        ArrayList<Integer> ls = new ArrayList<Integer>();\n        for (int x : arr)\n            ls.add(x);\n        Collections.sort(ls);\n\n        for (int i = 0; i < arr.length; i++)\n            arr[i] = ls.get(i);\n    }\n\n    public static long power(long x, long y, long p) {\n        \/\/0^0 = 1\n        \/\/Modular Exponentiation (Power in Modular Arithmetic)\n        \/\/ O(logy)\n        long res = 1L;\n        x = x % p;\n        while (y > 0) {\n            if ((y & 1) == 1)\n                res = (res * x) % p;\n            y >>= 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n\n    public static void main(String hi[]) throws Exception {\n        FastScanner scn = new FastScanner();\n        \/\/Write from here\n        int t=scn.nextInt();\n        while(t-->0)\n        {\n            int n=scn.nextInt();\n            int[] arr=scn.nextInts(n);\n            sort(arr);\n            int max=Integer.MIN_VALUE;\n            for (int i = 1; i < arr.length; i++) {\n                if(max<arr[0])\n                    max=arr[0];\n                if(max<arr[i]-arr[i-1])\n                {\n                    max=arr[i]-arr[i-1];\n                }\n            }\n            if(max==Integer.MIN_VALUE)\n                max=arr[0];\n            System.out.println(max);\n        }\n    }\n\n}\n\n\nclass FastScanner {\n\n    \/\/I don't understand how this works lmao\n    private int BS = 1 << 16;\n    private char NC = (char) 0;\n    private byte[] buf = new byte[BS];\n    private int bId = 0, size = 0;\n    private char c = NC;\n    private double cnt = 1;\n    private BufferedInputStream in;\n\n    public FastScanner() {\n        in = new BufferedInputStream(System.in, BS);\n    }\n\n    public FastScanner(String s) {\n        try {\n            in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n        } catch (Exception e) {\n            in = new BufferedInputStream(System.in, BS);\n        }\n    }\n\n    private char getChar() {\n        while (bId == size) {\n            try {\n                size = in.read(buf);\n            } catch (Exception e) {\n                return NC;\n            }\n            if (size == -1) return NC;\n            bId = 0;\n        }\n        return (char) buf[bId++];\n    }\n\n    public int nextInt() {\n        \/\/returns Int\n        return (int) nextLong();\n    }\n\n    public int[] nextInts(int N) {\n        \/\/returns array of integers of size N\n        int[] res = new int[N];\n        for (int i = 0; i < N; i++) {\n            res[i] = (int) nextLong();\n        }\n        return res;\n    }\n\n    public long[] nextLongs(int N) {\n        \/\/returns array of Longs of size N\n        long[] res = new long[N];\n        for (int i = 0; i < N; i++) {\n            res[i] = nextLong();\n        }\n        return res;\n    }\n\n    public long nextLong() {\n        \/\/return long\n        cnt = 1;\n        boolean neg = false;\n        if (c == NC) c = getChar();\n        for (; (c < '0' || c > '9'); c = getChar()) {\n            if (c == '-') neg = true;\n        }\n        long res = 0;\n        for (; c >= '0' && c <= '9'; c = getChar()) {\n            res = (res << 3) + (res << 1) + c - '0';\n            cnt *= 10;\n        }\n        return neg ? -res : res;\n    }\n\n    public double nextDouble() {\n        \/\/return double\n        double cur = nextLong();\n        return c != '.' ? cur : cur + nextLong() \/ cnt;\n    }\n\n    public double[] nextDoubles(int N) {\n        \/\/return array of doubles\n        double[] res = new double[N];\n        for (int i = 0; i < N; i++) {\n            res[i] = nextDouble();\n        }\n        return res;\n    }\n\n    public String next() {\n        StringBuilder res = new StringBuilder();\n        while (c <= 32) c = getChar();\n        while (c > 32) {\n            res.append(c);\n            c = getChar();\n        }\n        return res.toString();\n    }\n\n    public String nextLine() {\n        StringBuilder res = new StringBuilder();\n        while (c <= 32) c = getChar();\n        while (c != '\\n') {\n            res.append(c);\n            c = getChar();\n        }\n        return res.toString();\n    }\n\n    public boolean hasNext() {\n        if (c > 32) return true;\n        while (true) {\n            c = getChar();\n            if (c == NC) return false;\n            else if (c > 32) return true;\n        }\n    }\n}\n","\/\/\/\/solution at bottom \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\n\n      public class test\n{\n         \n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        }\n         \n        int[][] tdiarr(int m , int n){\n            int[][] a = new int[m][n];\n            for(int i=0;i<m;i++){\n                for(int j=0;j<n;j++){\n                    a[i][j]=Integer.parseInt(next());\n                }\n            }\n            return a;\n        }\n        long[][] tdlarr(int m , int n){\n            long[][] a = new long[m][n];\n            for(int i=0;i<m;i++){\n                for(int j=0;j<n;j++){\n                    a[i][j]=Long.parseLong(next());\n                }\n            }\n            return a;\n        }\n \n        int[] niarr(int n)\n        {\n            int[] a = new int[n];\n            for(int i=0;i<n;i++)a[i]=Integer.parseInt(next());\n            return a;\n        }\n        long[] nlarr(int n)\n        {\n            long[] a = new long[n];\n            for(int i=0;i<n;i++)a[i]=Long.parseLong(next());\n            return a;\n        }\n        char[] ncarr(){\n            return next().trim().toCharArray();\n            \n            \n        }\n        \n  \n        int ni() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nl() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nd() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nstr() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n     \n    \n     \n    static FastReader br=new FastReader();\n\/*\n \n*\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n \n \n \n \n \n    public static void main (String[] args) throws java.lang.Exception\n    {\n         try{\n             System.setIn(new FileInputStream(\"input.txt\"));\n             System.setOut(new PrintStream(new FileOutputStream(\"output.txt\")));\n        }\n        catch(Exception e){\n             }\n long start__time = System.currentTimeMillis();\n \n         \n        int t=1;\n        br=new FastReader();\n                       t=br.ni();   \n     in1 :   for(int TC = 1; TC <= t ; TC++)\n        {\n\n            solve();\n             \n\n\n        }\n          \n             \n        System.out.println(sb);\n                \n       \nlong end__time = System.currentTimeMillis();\nlong elapsed__time = end__time - start__time;\nSystem.err.println(elapsed__time);\n\n    }\n    \/\/\/end main\n     static StringBuilder sb = new StringBuilder();\n    \n    static void solve() throws Exception{\n                int n = br.ni();\n                long[] a = br.nlarr(n);\n                shuffle(a);\n                Arrays.sort(a);\n                long ans = a[0];\n                long uu = ans;\n                for(int i=1;i<n;i++){\n                   uu = a[i] - a[i-1];\n                    ans = Math.max(ans , uu);\n                }\n                sb.append(ans+\"\\n\");\n\n\n                 \n                \n\n\n\n    }                    \n    \/\/end solve\n     static void shuffle( long arr[])\n    {\n        int n = arr.length;\n        Random r = new Random();\n         \n       for (int i = n-1; i > 0; i--) {\n           int j = r.nextInt(i+1);\n             \n            long temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n      \n    \n\n      \n    }\n\n    \/\/end class  \n \n    \/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?)\n    * do smth instead of nothing and stay organized\n    * WRITE STUFF DOWN\n    * DON'T GET STUCK ON ONE APPROACH\n  \n TC:\n   \n \n \n      *\/   \n           \n\n          \n","#include <bits\/stdc++.h>\nusing namespace std;\ninline long long int mul(long long int a, long long int b) {\n  return (long long int)((long long)a * b % 1000000007);\n}\ninline long long int inv(long long int a) {\n  a %= 1000000007;\n  if (a < 0) a += 1000000007;\n  long long int b = 1000000007, u = 0, v = 1;\n  while (a) {\n    long long int t = b \/ a;\n    b -= t * a;\n    swap(a, b);\n    u -= t * v;\n    swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += 1000000007;\n  return u;\n}\nvoid solve() {\n  long long int n;\n  cin >> n;\n  long long int arr[n];\n  for (long long int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n  sort(arr, arr + n);\n  long long int m = arr[0];\n  for (long long int i = 1; i < n; i++) {\n    m = max(arr[i] - arr[i - 1], m);\n  }\n  if (n == 1) {\n    cout << arr[0] << endl;\n  } else {\n    cout << m << endl;\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","for i in range(int(input())):\n    n = int(input())\n    arr = [int(num) for num in input().split(\" \")]\n    arr.sort()\n    s = 0\n    newArr = [arr[0]]\n    j = 1\n    for j in range(len(arr)-1):\n        newArr.append(arr[j+1] - arr[j])\n    print(max(newArr))\n","import sys\n\ninput = sys.stdin.readline\n\n\ndef solve():\n    N = int(input())\n    A = list(map(int, input().split()))\n    if N == 1:\n        print(A[0])\n    else:\n        A.sort()\n        print(max(A[0], max(y - x for x, y in zip(A, A[1:]))))\n\n\nfor _ in range(int(input())):\n    solve()\n","for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int,input().split()))\n    a.sort()\n    ans = a[0]\n    for i in range(1,len(a)):\n        ans = max(ans, a[i]-a[i-1])\n    print(ans)\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n;\n  cin >> n;\n  long long a[n];\n  for (int i = 0; i < n; i++) cin >> a[i];\n  sort(a, a + n);\n  long long ans = a[0];\n  for (int i = 1; i < n; i++) {\n    ans = max(ans, a[i] - a[i - 1]);\n  }\n  cout << ans << endl;\n}\nint main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5;\nint t, n;\nlong long a[maxn + 10];\nint main() {\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n      scanf(\"%lld\", &a[i]);\n    }\n    sort(a + 1, a + n + 1);\n    int i = 0;\n    long long add = a[1], ans = a[1];\n    for (i = 2; i <= n; ++i) {\n      if ((a[i] - add) > ans) {\n        ans = a[i] - add;\n      }\n      add = a[i];\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    long long n, ans = 0, m = INT_MIN;\n    cin >> n;\n    long long a[n];\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a, a + n);\n    for (int i = 0; i < n; i++) {\n      long long x = a[i] - ans;\n      ans += x;\n      m = max(x, m);\n    }\n    cout << m << endl;\n  }\n  return 0;\n}\n","from heapq import heapify,heappush,heappop,heappushpop\nfrom collections import defaultdict as dd, deque as dq,Counter as C\nfrom math import factorial as f ,ceil,gcd,sqrt,log\nfrom bisect import bisect_left as bl ,bisect_right as br\nfrom itertools import combinations as c,permutations as p\nfrom math import factorial as f ,ceil,gcd,sqrt,log\nfrom sys import stdin\ninput = stdin.readline\nmp = lambda : map(int,input().split())\nit = lambda: int(input())\nls = lambda : list(input().strip().split())\nmt = lambda  r : [ ls() for _ in range(r)]\nlcm = lambda a,b : (a*b)\/\/gcd(a,b)\n\nfor _ in range(it()):\n\ta = it()\n\tb = list(mp())\n\tb.sort()\n\tb = dq(b)\n\ttot =0\n\tmx = b[0]\n\twhile b:\n\t\tk = b.popleft()\n\t\ttot+=k\n\t\tif b:\n\t\t\tmx = max(b[0]-tot,mx)\n\t\t\tb[0]-=tot\n\tprint(mx)","import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class MinimumExtraction {\n\tpublic static void solve(ArrayList<Long> arr,int n) {\n\t\tlong cp=0;\n\t\tlong cn=0;\n\t\tlong max=arr.get(0);\n\t\t\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\n\t\t\tlong x=arr.get(i);\n\t\t\tif(x<0) {\n\t\t\t\tcp+=Math.abs(x);\n\t\t\t\tarr.set(i+1,arr.get(i+1)+cp-cn);\n\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcn+=x;\n\t\t\t\tarr.set(i+1,arr.get(i+1)+cp-cn);\n\t\t\t}\n\t\t\tif(arr.get(i+1)>max) {\n\t\t\t\tmax=arr.get(i+1);\n\t\t\t}\n\/\/\t\t\tSystem.out.println(\"hi\"+max);\n\t\t}\n\t\n\t\tSystem.out.println(max);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t\/\/ TODO Auto-generated method stub\n\t\tScanner in=new Scanner(System.in);\n\t\tint t=in.nextInt();\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tint n=in.nextInt();\n\t\t\tArrayList<Long> arr=new ArrayList<Long>();\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tarr.add(in.nextLong());\n\t\t\t}\n\t\t\tCollections.sort(arr);\n\t\t\tsolve(arr, n);\n\t\t}\n\t}\n\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  for (int i = 0; i < t; i++) {\n    int n, a[200005];\n    scanf(\"%d\", &n);\n    for (int j = 0; j < n; j++) {\n      scanf(\"%d\", &a[j]);\n    }\n    sort(a, a + n);\n    int ans = a[0];\n    for (int j = 1; j < n; j++) ans = max(ans, a[j] - a[j - 1]);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n","import java.util.*;\nimport java.io.*;\n\n\/\/           THIS TEMPLATE MADE BY AKSH BANSAL.\n\npublic class Solution {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static void sort(int a[]){ \/\/ int -> long\n        ArrayList<Integer> arr=new ArrayList<>(); \/\/ Integer -> Long\n        for(int i=0;i<a.length;i++)\n        arr.add(a[i]);\n        Collections.sort(arr);\n        for(int i=0;i<a.length;i++)\n        a[i]=arr.get(i);\n        \n    }\n    private static long gcd(long a, long b){\n        if(b==0)return a;\n        return gcd(b,a%b);\n    }\n    private static long pow(long x,long y){\n        if(y==0)return 1;\n        long temp = pow(x, y\/2);\n        if(y%2==1){\n            return x*temp*temp;\n        }\n        else{\n            return temp*temp;\n        }\n    }\n    static int log(long n){\n        int res = 0;\n        while(n>0){\n            res++;\n            n\/=2;\n        }\n        return res;\n    }\n\n    static int mod = (int)1e9+7;\n    static PrintWriter out;\n    static FastReader sc ;\n    public static void main(String[] args) throws IOException {\n        sc = new FastReader();\n        out = new PrintWriter(System.out);\n        \/\/ primes();\n        \/\/ ________________________________\n\n        int test = sc.nextInt();\n        StringBuilder output = new StringBuilder();\n\n        while (test-- > 0) {\n            int n= sc.nextInt();\n            int[]arr =new int[n];\n            for(int i=0;i<n;i++){\n                arr[i] = sc.nextInt();\n            }\n            output.append(solver(arr, n)).append(\"\\n\");\n        }\n\n        out.println(output);\n        \/\/ _______________________________\n\n        \/\/ int n = sc.nextInt();\n        \/\/ out.println(solver());\n        \/\/ ________________________________\n        out.flush();\n    }\n\n    public static long solver(int[] arr, int n) {\n        long cur = 0;\n        sort(arr);\n        long res = Integer.MIN_VALUE;\n        for(int i=0;i<n;i++){\n            res = Math.max(res, arr[i]-cur);\n            cur+=(arr[i]-cur);\n        }\n        return res;\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    priority_queue<int, vector<int>, greater<int>> pq;\n    int mx = INT_MIN;\n    for (int i = 0; i < n; i++) {\n      int x;\n      cin >> x;\n      mx = max(mx, x);\n      pq.push(x);\n    }\n    int add = 0;\n    int mn = pq.top();\n    int ans = INT_MIN;\n    for (int i = 0; i < n - 1; i++) {\n      mn = pq.top() - add;\n      pq.pop();\n      mx = mx - mn;\n      add = add + mn;\n      ans = max(ans, mn);\n    }\n    ans = max(ans, mx);\n    cout << ans << endl;\n  }\n  return 0;\n}\n","\nfor _ in range(int(input())):\n    n=int(input())\n    a=sorted(list(map(int,input().split())))\n    c=a[0]\n    for i in range(1,n):\n        c=max(c,a[i]-a[i-1])\n    print(c)\n","import sys\nimport os.path\n \nif(os.path.exists('input.txt')) :\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\n    sys.stderr = open(\"error.txt\", \"w\")\n    \ndepth = 1000000\nmod = 1000000007 \nlim = mod * mod\nsys.setrecursionlimit(depth) \n \nlinp = lambda: list(minp())\nminp = lambda: map(int, input().split())\n \nfrom math import inf, ceil, sqrt, log2, gcd\nfrom collections import defaultdict, deque\n \ndxy = [(1, 0),(-1, 0),(0, 1),(0, -1)]\n\nfor _ in range(int(input())) :\n    n = int(input())\n    a = sorted(linp())\n    ans = a[0]\n    for i in range(1, n) :\n        ans = max(ans, a[i]-a[i-1])\n    print(ans)","#include <bits\/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nint main() {\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int j = 0; j < n; j++) {\n      cin >> a[j];\n    }\n    int mn = INF;\n    for (int j = 0; j < n; j++) {\n      mn = min(mn, a[j]);\n    }\n    int ans = mn;\n    sort(a.begin(), a.end());\n    for (int j = 0; j < n - 1; j++) {\n      ans = max(ans, a[j + 1] - a[j]);\n    }\n    cout << ans << endl;\n  }\n}\n","'''removing a negative minimum will always result in good things,\nsince the next minimum will be larger than the previous, and will also be increased by the removal.\nSolution is greedy. Remove a minimum if 2nd_minimum-1st_minimum > 1st_minimum.\n'''\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print(a[0])\n        continue\n    a.sort()\n    ma_min = a[0]\n    add = 0\n    for v in a:\n        if v+add > ma_min:\n            ma_min = v+add\n        add += -v-add\n    print(ma_min)\n","t=int(input())\nfor o in range(t):\n    n = int(input())\n    l= sorted(list(map(int , input().split())))\n    \n    arr=[l[0]]\n    for i in range(n-1):\n        arr+=[l[i+1]-l[i]]\n    if(arr==[]):\n        print(l[0])\n    else:\n        r=max(arr)\n        print(r)\n","import sys\nimport math\nfrom  collections import defaultdict, Counter, deque\nfrom heapq import heapify, heappop, heappush\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\nclass Solution:\n\n\tdef __init__(self, n, a):\n\t\ta.sort()\n\t\tself.ans = diff = a[0]\n\t\tfor i in range(1, n):\n\t\t\ta[i] -= diff\n\t\t\tdiff += a[i]\n\t\t\tself.ans = max(self.ans, a[i])\n\n\n\tdef exec(self):\n\t\tprint(self.ans)\n\n\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\ttest_cases = int(input())\n\tfor t in range(1, test_cases + 1):\n\t\tn = int(input())\n\t\ta = list(map(int, input().split()))\n\t\tSolution(n, a).exec()","import heapq\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    heapq.heapify(a)\n    ans = heapq.heappop(a)\n    keep = ans\n    while n > 1:\n        b = heapq.heappop(a)\n        ans = max(ans, b-keep)\n        keep = b\n        n -= 1\n    print(ans)\n    ","from collections import deque\n\nt = int(input())\nfor _ in range(t):\n    ln = int(input())\n    arr = deque(sorted(list(map(int, input().split()))))\n    ans = -1000000000\n    stk = 0\n    for _ in range(len(arr)):\n        #print(arr)\n        mi = arr.popleft()\n        #print('f', mi, stk)\n        if ans < mi-stk:\n            ans = mi-stk\n        stk += mi-stk\n    print(ans)\n    \n    ","\nimport java.util.*;\n\nimport javax.swing.text.Segment;\n\nimport java.io.*;\nimport java.math.*;\nimport java.sql.Array;\n\n\n\npublic class Main {\n\t  static class Scanner{\n\t\t  \n\t\t\tBufferedReader br;\n\t\t\tStringTokenizer st;\n\t\t\tpublic Scanner() {\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t}\n\t\t\tString next() \n\t\t    { \n\t\t        while (st == null || !st.hasMoreElements()) \n\t\t        { \n\t\t            try\n\t\t            { \n\t\t                st = new StringTokenizer(br.readLine()); \n\t\t            } \n\t\t            catch (IOException  e) \n\t\t            { \n\t\t                e.printStackTrace(); \n\t\t            } \n\t\t        } \n\t\t        return st.nextToken(); \n\t\t    } \n\n\t\t    int nextInt() \n\t\t    { \n\t\t        return Integer.parseInt(next()); \n\t\t    } \n\n\t\t    long nextLong() \n\t\t    { \n\t\t        return Long.parseLong(next()); \n\t\t    } \n\n\t\t    double nextDouble() \n\t\t    { \n\t\t        return Double.parseDouble(next()); \n\t\t    } \n\n\t\t    String nextLine() \n\t\t    { \n\t\t        String str = \"\"; \n\t\t        try\n\t\t        { \n\t\t            str = br.readLine(); \n\t\t        } \n\t\t        catch (IOException e) \n\t\t        { \n\t\t            e.printStackTrace(); \n\t\t        } \n\t\t        return str; \n\t\t    } \n\t\t}\n\t \n\t  static long mod = (long)(1e9 + 7);\n\t \n\tstatic void sort(long[] arr ) {\n\t\t ArrayList<Long> al = new ArrayList<>();\n\t\t for(long e:arr) al.add(e);\n\t\t Collections.sort(al);\n\t\t for(int i = 0 ; i<al.size(); i++) arr[i] = al.get(i);\n\t }\n\tstatic void sort(int[] arr ) {\n\t\t ArrayList<Integer> al = new ArrayList<>();\n\t\t for(int e:arr) al.add(e);\n\t\t Collections.sort(al);\n\t\t for(int i = 0 ; i<al.size(); i++) arr[i] = al.get(i);\n\t }\n\tstatic void sort(char[] arr) {\n\t\tArrayList<Character> al = new ArrayList<Character>();\n\t\tfor(char cc:arr) al.add(cc);\n\t\tCollections.sort(al);\n\t\tfor(int i = 0 ;i<arr.length ;i++) arr[i] = al.get(i);\n\t}\n\tstatic void rvrs(int[] arr) {\n\t\tint i =0 , j = arr.length-1;\n\t\twhile(i>=j) {\n\t\t\tint temp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\tstatic void rvrs(long[] arr) {\n\t\tint i =0 , j = arr.length-1;\n\t\twhile(i>=j) {\n\t\t\tlong temp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\n\tstatic long mod_mul(long a , long b ,long mod) {\n\t\treturn ((a%mod)*(b%mod))%mod;\n\t}\n\t static long gcd(long a, long b)\n\t  {      \n\t     if (b == 0)\n\t        return a;\n\t     return gcd(b, a % b); \n\t  }\n\t static boolean[] prime(int num) {\n\t\t\tboolean[] bool = new boolean[num];\n\t\t     \n\t\t      for (int i = 0; i< bool.length; i++) {\n\t\t         bool[i] = true;\n\t\t      }\n\t\t      for (int i = 2; i< Math.sqrt(num); i++) {\n\t\t         if(bool[i] == true) {\n\t\t            for(int j = (i*i); j<num; j = j+i) {\n\t\t               bool[j] = false;\n\t\t            }\n\t\t         }\n\t\t      }\n\t\t      if(num >= 0) {\n\t\t    \t  bool[0] = false;\n\t\t    \t  bool[1] = false;\n\t\t      }\n\t\t      \n\t\t      return bool;\n\t\t}\n\n\t static long modInverse(long a, long m)\n\t    {\n\t        long g = gcd(a, m);\n\t       \n\t          return   power(a, m - 2, m);\n\t        \n\t    }\n\t   static long lcm(long a , long b) {\n\t\t   return (a*b)\/gcd(a, b);\n\t   }\n\t   static int lcm(int a , int b) {\n\t\t   return (int)((a*b)\/gcd(a, b));\n\t   }\n\t static long power(long x, long y, long m){\n\t        if (y == 0) return 1; long p = power(x, y \/ 2, m) % m; p = (int)((p * (long)p) % m);\n\t        if (y % 2 == 0) return p; else return (int)((x * (long)p) % m); }\n\t   \n     static class Combinations{\n\t    \t private long[] z;\n\t    \t private long[] z1;\n\t    \t private long[] z2;\n\t    \t  public Combinations(long N , long mod) {\n\t\t\t\tz = new long[(int)N+1];\n\t\t\t\tz1 = new long[(int)N+1];\n\t\t\t\tz[0] = 1;\n\t\t\t\tfor(int i =1 ; i<=N ; i++) z[i] = (z[i-1]*i)%mod;\n\t\t\t     z2 = new long[(int)N+1];\n\t\t\t\tz2[0] = z2[1] = 1;\n\t\t\t    for (int i = 2; i <= N; i++)\n\t\t\t        z2[i] = z2[(int)(mod % i)] * (mod - mod \/ i) % mod;\n\t\t\t    \n\t\t\t    \n\t\t\t    z1[0] = z1[1] = 1;\n\t\t\t    \n\t\t\t    for (int i = 2; i <= N; i++)\n\t\t\t        z1[i] = (z2[i] * z1[i - 1]) % mod;\n\t\t\t}\n\t    \t  long fac(long n) {\n\t    \t\t  return z[(int)n];\n\t    \t  }\n\t    \t  long invrsNum(long n) {\n\t    \t\t  return z2[(int)n];\n\t    \t  }\n\t    \t  long invrsFac(long n) {\n\t    \t\t  return invrsFac((int)n);\n\t    \t  }\n\t    \t  long ncr(long N, long R, long mod)\n\t    \t  {\t\tif(R<0 || R>N ) return 0;\n\t    \t\t    long ans = ((z[(int)N] * z1[(int)R])\n\t    \t\t              % mod * z1[(int)(N - R)])\n\t    \t\t             % mod;\n\t    \t\t    return ans;\n\t    \t\t}\n\t      }\n\t      static class DisjointUnionSets {\n\t\t\t    int[] rank, parent;\n\t\t\t    int n;\n\t\t\t  \n\t\t\t    public DisjointUnionSets(int n)\n\t\t\t    {\n\t\t\t        rank = new int[n];\n\t\t\t        parent = new int[n];\n\t\t\t        this.n = n;\n\t\t\t        makeSet();\n\t\t\t    }\n\t\t\t  \n\t\t\t    void makeSet()\n\t\t\t    {\n\t\t\t        for (int i = 0; i < n; i++) {\n\t\t\t          \n\t\t\t            parent[i] = i;\n\t\t\t        }\n\t\t\t    }\n\t\t\t  \n\t\t\t    int find(int x)\n\t\t\t    {\n\t\t\t        if (parent[x] != x) {\n\t\t\t        \n\t\t\t            parent[x] = find(parent[x]);\n\t\t\t  \n\t\t\t        }\n\t\t\t  \n\t\t\t        return parent[x];\n\t\t\t    }\n\t\t\t  \n\t\t\t    void union(int x, int y)\n\t\t\t    {\n\t\t\t        int xRoot = find(x), yRoot = find(y);\n\t\t\t  \n\t\t\t        if (xRoot == yRoot)\n\t\t\t            return;\n\t\t\t  \n\t\t\t        if (rank[xRoot] < rank[yRoot])\n\t\t\t  \n\t\t\t            parent[xRoot] = yRoot;\n\t\t\t  \n\t\t\t        else if (rank[yRoot] < rank[xRoot])\n\t\t\t  \n\t\t\t            parent[yRoot] = xRoot;\n\t\t\t  \n\t\t\t        else\n\t\t\t        {\n\t\t\t            parent[yRoot] = xRoot;\n\t\t\t  \n\t\t\t            rank[xRoot] = rank[xRoot] + 1;\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t      static int max(int a , int b) {\n\t    \t  if(b>a) return b;\n\t    \t  return a;  \n\t      }\n\t      static long max(long a , long b) {\n\t    \t  if(b>a) return b;\n\t    \t  return a;  \n\t      }\n\t      static int min(int a , int b) {\n\t    \t  if(b<a) return b;\n\t    \t  return a;\n\t      }\n\t      static long min(long a , long b) {\n\t    \t  if(b<a) return b;\n\t    \t  return a;\n\t      }\n\t      static int[] KMP(String str) {\n\t    \t  int n = str.length();\n\t    \t  int[] kmp = new int[n];\n\t    \t  for(int i = 1 ; i<n ; i++) {\n\t    \t\t  int j = kmp[i-1];\n\t    \t\t  while(j>0 && str.charAt(i) != str.charAt(j)) {\n\t    \t\t\t  j = kmp[j-1];\n\t    \t\t  }\n\t    \t\t  if(str.charAt(i) == str.charAt(j)) j++;\n\t    \t\t  kmp[i] = j;\n\t    \t  }\n\t    \t  \n\t    \t  return kmp;\n\t      }\n\t      \n\t      \n\/************************************************ Query **************************************************************************************\/\t  \n\t \n\/***************************************** \t\tSparse Table\t********************************************************\/\n\t      static class SparseTable{\n\t    \t\t\n\t    \t\tprivate long[][] st;\n\t    \t\t\n\t    \t\tSparseTable(long[] arr){\n\t    \t\t\tint n = arr.length;\n\t    \t\t\tst = new long[n][25];\n\t    \t\t\tlog = new int[n+2];\n\t    \t\t\tbuild_log(n+1);\n\t    \t\t\tbuild(arr);\n\t    \t\t}\n\t    \t\t\n\t    \t\tprivate void build(long[] arr) {\n\t    \t\t\tint n = arr.length;\n\t    \t\t\t\n\t    \t\t\tfor(int i = n-1 ; i>=0 ; i--) {\n\t    \t\t\t\tfor(int j = 0 ; j<25 ; j++) {\n\t    \t\t\t\t\tint r = i + (1<<j)-1;\n\t    \t\t\t\t\tif(r>=n) break;\n\t    \t\t\t\t\tif(j == 0 ) st[i][j] = arr[i];\n\t    \t\t\t\t\telse st[i][j] = Math.max(st[i][j-1] , st[ i + ( 1 << (j-1) ) ][ j-1 ] );\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t}\n\t    \t\tpublic long gcd(long a  ,long b) {\n\t    \t\t\tif(a == 0) return b;\n\t    \t\t\treturn gcd(b%a , a);\n\t    \t\t}\n\t    \t\tpublic long query(int l ,int r) {\n\t    \t\t\tint w = r-l+1;\n\t    \t\t\tint power = log[w];\n\t    \t\t\treturn Math.max(st[l][power],st[r - (1<<power) + 1][power]);\n\t    \t\t}\n\t    \t\tprivate int[] log;\n\t    \t\tvoid build_log(int n) {\n\t    \t\t\tlog[1] = 0;\n\t    \t\t\tfor(int i = 2 ; i<=n ; i++) {\n\t    \t\t\t\tlog[i] = 1 + log[i\/2];\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t      \n\t      \n\/********************************************************\tSegement Tree\t*****************************************************\/\n\/**\n\t \t static class SegmentTree{\n\t\t\t long[] tree;\n\t\t\t long[] arr;\n\t\t\t int n;\n\t\t\t SegmentTree(long[] arr){\n\t\t\t\t this.n = arr.length;\n\t\t\t\t tree = new long[4*n+1];\n\t\t\t\t this.arr = arr;\n\t\t\t\t buildTree(0, n-1, 1);\n\t\t\t }\n\t\t\t \n\t\t\t \n\t\t\t  void buildTree(int s ,int e  ,int index ) {\n\t\t\t\t\tif(s == e) {\n\t\t\t\t\t\ttree[index] = arr[s];\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tint mid = (s+e)\/2;\n\t\t\t\t\t\n\t\t\t\t\tbuildTree( s,  mid, 2*index);\n\t\t\t\t\tbuildTree( mid+1, e, 2*index+1);\n\t\t\t\t\t\n\t\t\t\t\ttree[index] = Math.min(tree[2*index] , tree[2*index+1]);\n\t\t\t\t}\n\t\t\t  \n\t\t\t long query(int si ,int ei) {\n\t\t\t\t return query(0 ,n-1 , si ,ei , 1   );\n\t\t\t }\n\t\t\t private long query( int ss ,int se ,int qs , int qe,int index) {\n\t\t\t\t\t\n\t\t\t\t\tif(ss>=qs && se<=qe) return tree[index];\n\t\t\t\t\t\n\t\t\t\t\tif(qe<ss || se<qs) return (long)(1e17);\n\t\t\t\t\t\n\t\t\t\t\tint mid = (ss + se)\/2;\n\t\t\t\t\tlong left = query( ss , mid , qs ,qe , 2*index);\n\t\t\t\t\tlong right= query(mid + 1 , se , qs ,qe , 2*index+1);\n\t\t\t\t\treturn Math.min(left, right);\n\t\t\t\t}\n\t\t\t public void update(int index , int val) {\n\t\t\t\t arr[index] = val;\n\t\t\t\t for(long e:arr) System.out.print(e+\" \");\n\t\t\t\t update(index , 0 , n-1 , 1);\n\t\t\t }\n\t\t\t private void update(int id ,int si , int ei , int index) {\n\t\t\t\t if(id < si || id>ei) return;\n\t\t\t\t if(si == ei ) { \n\t\t\t\t\t tree[index] = arr[id];\n\t\t\t\t\t return;\n\t\t\t\t }\n\t\t\t\t if(si > ei) return;\n\t\t\t\t int mid = (ei + si)\/2;\n\t\t\t\t\t\n\t\t\t\t\tupdate( id,  si, mid , 2*index);\n\t\t\t\t\tupdate( id , mid+1, ei , 2*index+1);\n\t\t\t\t\t\n\t\t\t\t\ttree[index] = Math.min(tree[2*index] ,tree[2*index+1]);\n\t\t\t }\n\t\t\t  \n\t\t }\n\t\t *\/\n\n\/* ***************************************************************************************************************************************************\/\t \n\t \n\t      static Scanner sc = new Scanner();\n\t static StringBuilder sb = new StringBuilder();\n\t public static void main(String args[]) throws IOException {\n\n\t\t int tc = 1;\n\t\t  tc = sc.nextInt();\n\t\t\n\t\t for(int i = 1 ; i<=tc ; i++) {\n\n\/\/\t\t\t sb.append(\"Case #\" + i + \": \"  );\t\/\/ During KickStart && HackerCup\n\t\t\t TEST_CASE();\n\t\t\t  \n\t\t }\n\t\t System.out.println(sb);\n\t }\n\n\t static void TEST_CASE() {\n\t\t int n = sc.nextInt();\n\t\t long[] arr = new long[n];\n\t\tfor(int i = 0 ; i<n ; i++)\n\t\t\tarr[i] = sc.nextLong();\n\t\tsort(arr);\n\t\tint l = 0 , r = n-1;\n\t\twhile(l<=r) {\n\t\t\tlong temp = arr[l];\n\t\t\tarr[l] = arr[r];\n\t\t\tarr[r] = temp;\n\t\t\tl++;\n\t\t\tr--;\n\t\t\t\t\n\t\t}\n\/\/\t\tfor(long e:arr) System.out.print(e+\" \");\n\/\/\t\tSystem.out.println();\n\t\tlong[] suf = new long[n];\n\t\tsuf[n-1] = arr[n-1];\n\t\tlong max = arr[n-1];\n\t\tlong[] ans = new long[n];\n\t\tans[n-1] = arr[n-1];\n\t\tfor(int i = n-2 ; i>=0 ; i--) {\n\t\t\tans[i] = arr[i] - suf[i+1];\n\t\t\tsuf[i] += ans[i] + suf[i+1];\n\/\/\t\t\tSystem.out.println(i + \" \"+ans[i] + \" \"+suf[i]);\n\t\t\tmax = Math.max(max, ans[i]);\n\t\t}\n\/\/\t\tfor(long e:ans) System.out.print(e+\" \");\n\/\/\t\tSystem.out.println();\n\t\tsb.append(max+\"\\n\");\n\t }\n}\n\n\t \n\n\/*******************************************************************************************************************************************************\/\n\n\/**\n\t\n\t\n *\/\n\n \n\n","import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\n\/**\n *\n * @author Acer\n *\/\npublic class MaximumExtraction_2c {\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int T = sc.nextInt();\n        while(T-- > 0){\n            int n = sc.nextInt();\n            ArrayList<Integer> arr = new ArrayList<Integer>();           \n            for (int i = 0; i < n; i++) {\n                arr.add(sc.nextInt());\n            }\n            \n            if(n == 1){\n                System.out.println(arr.get(0));\n                continue;\n            }\n            \n            Collections.sort(arr);\n            \n            long max = arr.get(0);\n            for (int i = 1; i < n; i++) {\n                long x = arr.get(i) - arr.get(i-1);\n                max = Math.max(max, x);\n            }\n            System.out.println(max);\n        }\n    }\n    \n}","import com.sun.security.jgss.GSSUtil;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\npublic class javacp{\n\n\n    static FastReader fs=new FastReader();\n    static class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next(){\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt(){\n            return Integer.parseInt(next());\n        }\n        long nextLong(){\n            return Long.parseLong(next());\n        }\n        double nextDouble(){\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String str = \"\";\n            try{\n                str = br.readLine();\n            }catch (IOException e){\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] inputIntArray(int n){\n            int[] arr = new int[n];\n            for(int i=0;i<n;i++)\n                arr[i] = fs.nextInt();\n\n            return arr;\n        }\n    }\n\n    static void sort(int[] arr){\n        ArrayList<Integer> al = new ArrayList<>();\n        for(int val : arr){\n            al.add(val);\n        }\n\n        Collections.sort(al);\n        for(int i=0;i<arr.length;i++){\n            arr[i] = al.get(i);\n        }\n    }\n\n    static class Pair implements Comparable<Pair>{\n        int src;\n        int dest;\n        long wt;\n\n        Pair(int src,int dest,long wt){\n            this.src = src;\n            this.dest = dest;\n            this.wt = wt;\n        }\n\n        public int compareTo(Pair pair){\n            if(this.wt > pair.wt)\n                return 1;\n            else if(this.wt < pair.wt)\n                return -1;\n            else\n                return 0;\n        }\n    }\n\n\n    static int[] par1 , rank1 , size;\n    static int[] par2;\n    static int[] rank2;\n\n    static boolean union1(int vt1 , int vt2){\n        int parent1 = findParent1(vt1) , parent2 = findParent1(vt2);\n        int r1 = rank1[parent1] , r2 =  rank1[parent2];\n\n        if(parent1 == parent2) return false;\n\n        if(r1 < r2) {\n            par1[parent1] = parent2;\n            size[parent2] += size[parent1];\n        }\n        else{\n            par1[parent2] = parent1;\n            size[parent1] += size[parent2];\n        }\n\n        if(r1 == r2) rank1[parent1]++;\n\n        return true;\n    }\n\n    static void union2(int vt1 , int vt2){\n        int parent1 = findParent2(vt1) , parent2 = findParent2(vt2);\n        int r1 = rank2[parent1] , r2 =  rank2[parent2];\n\n        if(parent1 == parent2) return;\n\n        if(r1 < r2)\n            par2[parent1] = parent2;\n        else par2[parent2] = parent1;\n\n        if(r1 == r2) rank2[parent1]++;\n    }\n\n    static int findParent1(int vt){\n        if(par1[vt] == vt) return vt;\n        par1[vt] = findParent1(par1[vt]);\n\n        return par1[vt];\n    }\n\n    static int findParent2(int vt){\n        if(par2[vt] == vt) return vt;\n        par2[vt] = findParent2(par2[vt]);\n\n        return par2[vt];\n    }\n\n    static void initialise1(int numOfVtces){\n        par1 = new int[numOfVtces];\n        rank1 = new int[numOfVtces];\n        size = new int[numOfVtces];\n\n        for(int i=0;i<numOfVtces;i++){\n            par1[i] = i;\n            rank1[i] = 1;\n            size[i] = 1;\n        }\n    }\n\n    static void initialise2(int numOfVtces){\n        par2 = new int[numOfVtces];\n        rank2 = new int[numOfVtces];\n\n        for(int i=0;i<numOfVtces;i++){\n            par2[i] = i;\n            rank2[i] = 0;\n        }\n    }\n\n\n\n    public static void main(String[] args) throws IOException{\n\n        int t = 1;\n        t = fs.nextInt();\n\n        while (t-- > 0) {\n            int n = fs.nextInt();\n            int[] arr = fs.inputIntArray(n);\n\n            if(n == 1){\n                System.out.println(arr[0]);\n                continue;\n            }\n\n            sort(arr);\n            ArrayList<Integer> list = new ArrayList<>();\n            if(arr[0] < 0){\n                for(int i=1; i < n;i++)\n                    list.add(arr[i]-arr[0]);\n            }\n            else{\n                for (int i : arr) {\n                    list.add(i);\n                }\n            }\n\n            if(list.size() == 1)\n            {\n                System.out.println(list.get(0));\n                continue;\n            }\n\n            int min = list.get(0);\n            for(int i=1; i < list.size(); i++){\n                min = Math.max(min, list.get(i)-list.get(i-1));\n            }\n\n            System.out.println(min);\n        }\n    }\n\n    static int modInverse(int a, int m)\n    {\n        int m0 = m;\n        int y = 0, x = 1;\n\n        if (m == 1)\n            return 0;\n\n        while (a > 1) {\n            \/\/ q is quotient\n            int q = a \/ m;\n\n            int t = m;\n\n            \/\/ m is remainder now, process\n            \/\/ same as Euclid's algo\n            m = a % m;\n            a = t;\n            t = y;\n\n            \/\/ Update x and y\n            y = x - q * y;\n            x = t;\n        }\n\n        \/\/ Make x positive\n        if (x < 0)\n            x += m0;\n\n        return x;\n    }\n\n    static int mod = 1000000007;\n    static long  power(long a,long b,long m) {\n        a %= m;\n        long res = 1;\n        while (b > 0) {\n            if ((b & 1) == 1)\n                res = res * a % m;\n            a = a * a % m;\n            b >>= 1;\n        }\n        return res;\n    }\n\n    static class CustomSort implements Comparator<int[]> {\n\n        public int compare(int[] a, int[] b)\n        {\n            return a[0] - b[0];\n        }\n    }\n\n    static void printArr(int[] arr){\n        for(int i=0;i< arr.length;i++)\n        {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n\n    private static int lcm(int a, int b) {\n        int gcd = gcd(a,b);\n        return (int)((long)a*(long)b)\/gcd ;\n    }\n\n\n    private static int gcd(int a, int b) {\n        if(b == 0) return a;\n        else return gcd(b , a % b);\n    }\n\n\n    private static void swap(int[] arr, int start, int rand_pivot) {\n        int temp = arr[start];\n        arr[start] = arr[rand_pivot];\n        arr[rand_pivot] = temp;\n    }\n\n\n}","import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Math.log;\nimport static java.lang.Math.min;\n\npublic class Main {\n\n    \/\/------------------------------------------CONSTANTS---------------------------------------------------------------\n    public static final int MOD = (int) (1e9 + 7);\n\n    \/\/---------------------------------------------I\/0------------------------------------------------------------------\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(\n                    new InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() { return Integer.parseInt(next()); }\n\n        long nextLong() { return Long.parseLong(next()); }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    public static void print(String s) {\n        System.out.println(s);\n    }\n\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n\n        int t = 1;\n        t = sc.nextInt();\n\n        for(int i = 0; i<t; i++) {\n            System.out.println(solve(sc));\n        }\n    }\n\n    \/\/------------------------------------------------SOLVE-------------------------------------------------------------\n\n    public static long solve(FastReader sc) {\n        int n = sc.nextInt(); int[] a = new int[n];\n        for (int i = 0; i<n; i++) {\n            a[i] = sc.nextInt();\n        }\n        if (n == 1)\n            return a[0];\n\n        OrderedMultiSet<Integer> set = new OrderedMultiSet<>();\n        for (int i = 0; i<n; i++) {\n            set.add(a[i]);\n        }\n\n        int toRemove = 0;\n        int res = set.first();\n        while (set.size() > 1) {\n            toRemove += set.pollFirst()-toRemove;\n            if (set.first() - toRemove > res) {\n                res = set.first() - toRemove;\n            }\n        }\n        res = Math.max(res, set.first() - toRemove);\n        return res;\n    }\n\n    public static int firstNotDivisor(int n, int z) {\n        for (int i = z; i>=1; i--) {\n            if (n%i!=0)\n                return i;\n        }\n        return -1;\n    }\n\n    public static int factorial(int n) {\n        if (n == 0)\n            return 1;\n        int fact = 1;\n        for (int i = 2; i<=n; i++) {\n            fact *= i;\n        }\n        return fact;\n    }\n\n    public static int maxFactorial(int n) {\n        int k = 1;\n        int fact = 1;\n        while ((k+1)*fact < n) {\n            k++;\n            fact *= k;\n        }\n        return k;\n    }\n\n    public static boolean isPalindrome(String s) {\n        for (int i = 0; i<s.length()\/2; i++) {\n            if (s.charAt(i) != s.charAt(s.length()-1-i))\n                return false;\n        }\n        return true;\n    }\n\n    \/\/-----------------------------------------------FUNCTIONS----------------------------------------------------------\n\n    public static String printArray(int[] a) {\n        StringBuilder r = new StringBuilder(\"\");\n\n        for(int i = 0; i<a.length; i++) {\n            r.append(a[i] + \" \");\n        }\n        return r.toString();\n    }\n\n    public static <T> String printList(List<T> a) {\n        StringBuilder r = new StringBuilder(\"\");\n\n        for (T x: a) {\n            r.append(x.toString() + \" \");\n        }\n        return r.toString();\n    }\n\n    \/\/ first element that is not less than target\n    public static int lowerBound(int[] arr, int begin, int end, int target) {\n        while(begin < end) {\n            int mid = begin + (end - begin) \/ 2;\n            \/\/ When the element is less than the mid target\n            if(arr[mid] < target)\n                \/\/ begin to mid + 1, arr [begin] value is less than or equal target\n                begin = mid + 1;\n                \/\/ When the mid target element when greater than or equal\n            else if(arr[mid] >= target)\n                end = mid;\n        }\n        return begin;\n    }\n\n    \/\/ first element that is greater than target\n    public static int upperBound(int[] arr, int begin, int end, int target) {\n        while(begin < end) {\n            int mid = begin + (end - begin) \/ 2;\n            if(arr[mid] <= target)\n                begin = mid + 1;\n            else\n                end = mid;\n        }\n        return begin;\n    }\n\n    \/\/ generate permutations (call search and access through permutations)\n    public static class Permutations {\n        List<List<Integer>> permutations = new ArrayList<>();\n        List<Integer> permutation = new ArrayList<>();\n        boolean[] taken;\n        int[] a;\n\n        public Permutations(int[] a) {\n            this.a = a;\n            taken = new boolean[a.length];\n        }\n\n        void search() {\n            if (permutation.size()==a.length) {\n                permutations.add(new ArrayList<>(permutation));\n            } else {\n                for (int i = 0; i<a.length; i++) {\n                    if (taken[i]) {\n                        continue;\n                    }\n                    taken[i] = true;\n                    permutation.add(a[i]);\n                    search();\n                    taken[i] = false;\n                    permutation.remove(permutation.size()-1);\n                }\n            }\n        }\n    }\n\n    \/\/ generate subsets (call search and access subsets)\n    public static class Subsets {\n        List<List<Integer>> subsets = new ArrayList<>();\n        List<Integer> subset = new ArrayList<>();\n\n        void search(int[] a, int x) {\n            if (x == a.length) {\n                subsets.add(new ArrayList<>(subset));\n            } else {\n                subset.add(a[x]);\n                search(a, x+1);\n                subset.remove(subset.size() - 1);\n                search(a, x+1);\n            }\n        }\n    }\n\n    public static int gcd(int a, int b) {\n        while (b != 0) {\n            int t = b;\n            b = a % b;\n            a = t;\n        }\n        return a;\n    }\n\n    public static int lcm(int a, int b) {\n        return (a*b)\/gcd(a, b);\n    }\n\n    public static int[] prefixSum(int[] a) {\n        int n = a.length;\n        int[] ps = new int[n];\n        ps[0] = a[0];\n\n        for (int i = 1; i<n; i++) {\n            ps[i] = ps[i-1] + a[i];\n        }\n\n        return ps;\n    }\n\n    public static int[][] prefixSum2D(int[][] a) {\n        int n = a.length;\n        int m = a[0].length;\n        int[][] ps = new int[n][m];\n        ps[0][0] = a[0][0];\n\n        for (int j = 1; j<m; j++) {\n            ps[0][j] = ps[0][j-1] + a[0][j];\n        }\n        for (int i = 1; i<n; i++) {\n            ps[i][0] = ps[i-1][0] + a[i][0];\n        }\n\n        for (int i = 1; i<n; i++) {\n            for (int j = 1; j<m; j++) {\n                ps[i][j] = ps[i-1][j] + ps[i][j-1] - ps[i-1][j-1] + a[i][j];\n            }\n        }\n\n        return ps;\n    }\n\n    public static double log2(double a) {\n        return log(a)\/log(2);\n    }\n\n    \/\/----------------------------------------DATA-STRUCTURES-----------------------------------------------------------\n\n    \/\/ Range queries (i.e. RMQ) in O(1), others with functions in O(log n)\n    public static class SparseTable {\n        int[][] st;\n        int n;\n        int k;\n\n        public SparseTable(int[] a) {\n            n = a.length;\n            k = (int) log2(n);\n            st = new int[n][k+1];\n\n            for (int i = 0; i<n; i++) {\n                st[i][0] = a[i];\n            }\n\n            \/\/ 1<<j == 2^j\n            for (int j = 1; j<=k; j++) {\n                for (int i = 0; i + (1 << j) <= n; i++) {\n                    st[i][j] = min(st[i][j-1], st[i + (1 << (j - 1))][j - 1]);\n                }\n            }\n        }\n\n        \/\/not always available O(log n) -- change the constructor to use it\n        public long sumQuery(int l, int r) {\n            long sum = 0;\n            for (int j = k; j>=0; j--) {\n                if ((1 << j) <= r - l + 1) {\n                    sum += st[l][j];\n                    l += 1 << j;\n                }\n            }\n\n            return sum;\n        }\n\n        \/\/always available O(1) -- change this and the constructor for rangeMaxQuery\n        public int rangeMinQuery(int l, int r) {\n            int j = (int) log2(r - l + 1);\n            int min = min(st[l][j], st[r - (1 << j) + 1][j]);\n            return min;\n        }\n\n    }\n\n    \/\/Range Sum Dynamic Queries O(log n)\n    public static class BinaryIndexedTree {\n\n        int[] bit;\n\n        public BinaryIndexedTree(int[] a) {\n            int n = a.length;\n            bit = new int[n+1];\n            \/\/ Store the actual values in BITree[]\n            \/\/ using update()\n            for(int i = 0; i < n; i++)\n                updateBit(i, a[i]);\n        }\n\n        \/\/ O(log n) update delta at index in the array (do it on the array and then call this function)\n        public void updateBit(int index, int delta) {\n            index += 1;\n\n            while (index <= bit.length) {\n                bit[index] += delta;\n\n                index += index & (-index);\n            }\n        }\n\n        \/\/ Computes sum a[0...index] in O(log n)\n        public int getSum(int index) {\n            int sum = 0;\n\n            index += 1;\n\n            while (index > 0) {\n                sum += bit[index];\n\n                index -= index & (-index);\n            }\n\n            return sum;\n        }\n    }\n\n    public static class UnionFind {\n\n        int[] link;\n        int[] size;\n\n        UnionFind(int n) {\n            link = new int[n];\n            size = new int[n];\n            for (int i = 0; i<n; i++) {\n                link[i] = i;\n                size[i] = 1;\n            }\n        }\n\n        int find(int x) {\n            while (x != link[x]) x = link[x];\n            return x;\n        }\n\n        boolean same(int a, int b) {\n            return find(a) == find(b);\n        }\n\n        void unite(int a, int b) {\n            a = find(a);\n            b = find(b);\n\n            if (size[a] < size[b]) {\n                int temp = a;\n                a = b;\n                b = temp;\n            }\n\n            size[a] += size[b];\n            link[b] = a;\n        }\n    }\n\n    public static class SegmentTree {\n\n        int st[];\n\n        public SegmentTree(int arr[]) {\n            int n = arr.length;\n\n            int x = (int) (Math.ceil(log2(n)));\n\n            int maxSize = 2 * (int) Math.pow(2, x) - 1;\n\n            st = new int[maxSize];\n\n            build(arr, 0, n-1, 0);\n        }\n\n        int build(int arr[], int ss, int se, int si) {\n            if (ss == se) {\n                st[si] = arr[ss];\n                return arr[ss];\n            }\n\n            int mid = ss + (se - ss) \/ 2; \/\/ss+se\/2\n\n            st[si] = build(arr, ss, mid, si * 2 + 1) +\n                    build(arr, mid + 1, se, si * 2 + 2);\n            return st[si];\n        }\n\n        private int getSumUtil(int ss, int se, int l, int r, int si) {\n            if (l <= ss && r >= se) {\n                return st[si];\n            }\n\n            if (se < l || ss > r) {\n                return 0;\n            }\n\n            int mid = ss + (se - ss) \/ 2;\n            return getSumUtil(ss, mid, l, r, 2 * si + 1) +\n                    getSumUtil(mid + 1, se, l, r, 2 * si + 2);\n        }\n\n        void updateValueUtil(int ss, int se, int i, int diff, int si) {\n            if (i < ss || i > se) {\n                return;\n            }\n\n            st[si] = st[si] + diff;\n            if (se != ss) {\n                int mid = ss + (se - ss) \/ 2;\n                updateValueUtil(ss, mid, i, diff, 2 * si + 1);\n                updateValueUtil(mid + 1, se, i, diff, 2 * si + 2);\n            }\n        }\n\n        int getSum(int n, int l, int r) {\n            if (l < 0 || r > n - 1 || l > r) {\n                return -1;\n            }\n\n            return getSumUtil(0, n-1, l, r, 0);\n        }\n\n        \/\/ don't do it directly on the array but use this function that will\n        \/\/ do everything for you\n        void updateValue(int arr[], int n, int i, int newValue) {\n            if (i < 0 || i > n - 1) {\n                return;\n            }\n\n            int diff = newValue - arr[i];\n\n            arr[i] = newValue;\n\n            updateValueUtil(0, n - 1, i, diff, 0);\n        }\n    }\n\n    \/\/ Similar to Pair in c++, non-null objects as parameters\n    public static class Pair<T extends Comparable<T>, Q extends Comparable<Q>> implements Comparable<Pair<T, Q>>{\n        T a;\n        Q b;\n\n        public Pair(T a, Q b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Pair<?, ?> pair = (Pair<?, ?>) o;\n            return a.equals(pair.a) && b.equals(pair.b);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(a, b);\n        }\n\n\n        @Override\n        public int compareTo(Pair<T, Q> tqPair) {\n            int compareA = this.a.compareTo(tqPair.a);\n\n            if (compareA == 0) {\n                return this.b.compareTo(tqPair.b);\n            } else {\n                return compareA;\n            }\n        }\n    }\n\n    \/\/ Uses Map + TreeSet to get the structure\n    public static class OrderedMultiSet<T extends Comparable<T>> {\n        private final TreeSet<T> set = new TreeSet<>();\n        private final Map<T, Integer> frequencies = new HashMap<>();\n        private int size = 0;\n\n        public OrderedMultiSet() {}\n\n        public OrderedMultiSet(List<T> a) {\n            for (T x: a) {\n                this.add(x);\n                size++;\n            }\n        }\n\n        public void add(T element) {\n            set.add(element);\n            if (!frequencies.containsKey(element)) {\n                frequencies.put(element, 0);\n            }\n            frequencies.put(element, frequencies.get(element) + 1);\n            size++;\n        }\n\n        public boolean remove(T element) {\n            if (frequencies.containsKey(element)) {\n                int x = frequencies.get(element);\n                x--;\n                if (x == 0) {\n                    frequencies.remove(element);\n                    set.remove(element);\n                } else {\n                    frequencies.put(element, frequencies.get(element) - 1);\n                }\n                size--;\n                return true;\n            }\n            return false;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public T first() {\n            return set.first();\n        }\n\n        public T last() {\n            return set.last();\n        }\n\n        public T pollFirst() {\n            T t = set.first();\n            remove(t);\n            return t;\n        }\n\n        public T pollLast() {\n            T t = set.last();\n            set.\n            remove(t);\n            return t;\n        }\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 10000010;\nlong long a[N];\nint main() {\n  int T;\n  cin >> T;\n  while (T--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    sort(a + 1, a + n + 1);\n    long long t = 0;\n    long long res = a[1];\n    for (int i = 1; i <= n; i++) {\n      a[i] -= t;\n      res = max(res, a[i]);\n      t += a[i];\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long modular_pow(long long b, long long e, long long m) {\n  if (m == 1) return 0;\n  b %= m;\n  long long r = 1;\n  while (e > 0) {\n    if (e & 1) r = (r * b) % m;\n    b = (b * b) % m;\n    e >>= 1;\n  }\n  return r;\n}\nlong long npow(long long x, long long n) {\n  long long res = 1;\n  while (n) {\n    if (n % 2) res = (res * x);\n    n \/= 2;\n    x = (x * x);\n  }\n  return res;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return a \/ gcd(a, b) * b; }\nvoid io() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n}\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> a(n);\n  for (long long i = 0; i < n; i++) cin >> a[i];\n  if (n < 2) {\n    cout << a[0] << \"\\n\";\n    return;\n  }\n  sort(a.begin(), a.end());\n  long long i = 0, ans = LLONG_MIN, cnt = 0;\n  while (i < n) {\n    a[i] += cnt;\n    ans = max(ans, a[i]);\n    cnt += 0 - a[i++];\n  }\n  cout << ans << \"\\n\";\n}\nsigned main() {\n  io();\n  long long test;\n  cin >> test;\n  while (test--) {\n    solve();\n  }\n  return 0;\n}\n","import sys\n\ninput = sys.stdin.readline\nprint = sys.stdout.write\n\nfor _ in range(int(input())):\n    _ = input()\n    a = [0] + sorted(map(int, input().split()))\n    best = -9999999999\n    for i in range(1, len(a)):\n        best = max(best, a[i] - a[i - 1])\n    print(str(best) + \"\\n\")\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 9, M = 1e5 + 9, mod = 1e9 + 7, inf = 0x3f3f3f;\nint32_t main() {\n  std::ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> vec(n);\n    int mnn = 1e9;\n    for (int i = 0; i < n; i++) {\n      cin >> vec[i];\n      mnn = min(vec[i], mnn);\n    }\n    if (n == 1) {\n      cout << vec[0] << '\\n';\n      continue;\n    }\n    int mxxrr = mnn;\n    sort(vec.rbegin(), vec.rend());\n    for (int i = 1; i <= n; i++) {\n      int x = vec[n - i];\n      x -= mnn;\n      mnn += x;\n      mxxrr = max(mxxrr, x);\n    }\n    cout << mxxrr << '\\n';\n  }\n}\n","    #from _typeshed import SupportsKeysAndGetItem\nimport sys\nfrom collections import deque\nimport heapq\nimport bisect\nimport copy\n# sys.stdin=open(\"input.txt\",\"r\");\n# sys.stdout=open(\"output.txt\",\"w\")\n####### GLOBAL ###############\nMOD=1000000007\nNO=lambda:print(\"NO\")\nYES=lambda:print(\"YES\")\n_1=lambda:print(-1)\nari=lambda:[int(_) for _ in input().split()]\ncin=lambda:int(input())\ncis=lambda:input()\nshow=lambda x: print(x)\nfast= lambda:sys.stdin.readline()\n\n########### END #########\n######\ntest_case=1\ntest_case=int(input())\n######\nsys.setrecursionlimit(10**6)\n    \ndef ans():\n    n=cin()\n    \n    arr=ari()\n    if n==1:\n        print(*arr)\n        return\n    arr.sort()\n    maxi=arr[0]\n    # arr.append(0)\n    \n    for i in range(len(arr)-1):\n        maxi=max(maxi,arr[i+1]-arr[i])\n    print(maxi)\n    return\nfor _ in range(test_case):\n    ans()\n    ","t = int(input())\n\nfor test in range(t):\n    n = int(input())\n    p = list(map(int,input().split()))\n    if(len(p)==1):\n        print(p[0])\n        continue\n    elif(len(p)==2):\n        print(max(min(p[0],p[1]),abs(p[0]-p[1])))\n        continue\n    ans = min(p)\n    p.sort()\n    for i in range(len(p)-2,-1,-1):\n        ans = max(ans,p[i+1]-p[i])\n    print(ans)\n","\/\/package MyPackage;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br=new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next(){\n            while(st==null || !st.hasMoreTokens()){\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt(){\n            return Integer.parseInt(next());\n        }\n        long nextLong(){\n            return Long.parseLong(next());\n        }\n        double nextDouble(){\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String str=\"\";\n            try {\n                str=br.readLine().trim();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static class FastWriter {\n\t\tprivate final BufferedWriter bw;\n\n\t\tpublic FastWriter() {\n\t\t\tthis.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t}\n\n\t\tpublic void print(Object object) throws IOException {\n\t\t\tbw.append(\"\" + object);\n\t\t}\n\n\t\tpublic void println(Object object) throws IOException {\n\t\t\tprint(object);\n\t\t\tbw.append(\"\\n\");\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbw.close();\n\t\t}\n\t}\n    public static void main(String[] args)\n    {\n        try {\n            FastReader in=new FastReader();\n            FastWriter out = new FastWriter();\n            StringBuilder sb = new StringBuilder();\n            int testCases=in.nextInt();\n            while(testCases-- > 0) {\n                \/\/ write code here\n            \tint n = in.nextInt();\n            \tArrayList<Long> a = new ArrayList<>();\n            \tfor(int i = 0; i < n; i++)\n            \t{\n            \t\ta.add(in.nextLong());\n            \t}\n            \tCollections.sort(a);\n            \tlong ans = a.get(0);\n            \tfor(int i = 0; i < n - 1; i++)\n            \t{\n            \t\tans = Math.max(ans, a.get(i + 1) - a.get(i));\n            \t}\n        \t\tsb.append(ans + \"\\n\");\n            }\n            out.println(sb);\n            out.close();\n        } catch (Exception e) {\n            return;\n        }\n    }\n}\n","import java.io.*;\nimport java.util.*;\n\npublic class C {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static FastReader s = new FastReader();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    private static int[] rai(int n) {\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextInt();\n        }\n        return arr;\n    }\n\n    private static int[][] rai(int n, int m) {\n        int[][] arr = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                arr[i][j] = s.nextInt();\n            }\n        }\n        return arr;\n    }\n\n    private static long[] ral(int n) {\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextLong();\n        }\n        return arr;\n    }\n\n    private static long[][] ral(int n, int m) {\n        long[][] arr = new long[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                arr[i][j] = s.nextLong();\n            }\n        }\n        return arr;\n    }\n\n    private static int ri() {\n        return s.nextInt();\n    }\n\n    private static long rl() {\n        return s.nextLong();\n    }\n\n    private static String rs() {\n        return s.next();\n    }\n\n    static long gcd(long a,long b)\n    {\n        if(b==0)\n        {\n            return a;\n        }\n        return gcd(b,a%b);\n    }\n\n    static int gcd(int a,int b)\n    {\n        if(b==0)\n        {\n            return a;\n        }\n        return gcd(b,a%b);\n    }\n\n    static boolean isPrime(int n) {\n        \/\/check if n is a multiple of 2\n        if (n % 2 == 0) return false;\n        \/\/if not, then just check the odds\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\n    static long mpow(long base,long pow)\n    {\n        long res=1;\n        while(pow>0)\n        {\n            if(pow%2==1)\n            {\n                res=(res*base)%MOD;\n            }\n            pow>>=1;\n            base=(base*base)%MOD;\n        }\n        return res;\n    }\n\n    static TreeSet<Long> set= new TreeSet<>();\n    static void sieveOfEratosthenes(int n)\n    {\n        \/\/ Create a boolean array\n        \/\/ \"prime[0..n]\" and\n        \/\/ initialize all entries\n        \/\/ it as true. A value in\n        \/\/ prime[i] will finally be\n        \/\/ false if i is Not a\n        \/\/ prime, else true.\n        boolean[] prime = new boolean[n + 1];\n        for (int i = 0; i <= n; i++)\n            prime[i] = true;\n\n        for (int p = 2; p * p <= n; p++)\n        {\n            \/\/ If prime[p] is not changed, then it is a\n            \/\/ prime\n            if (prime[p])\n            {\n                \/\/ Update all multiples of p\n                for (int i = p * p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        }\n\n        \/\/ Print all prime numbers\n        for (int i = 2; i <= n; i++)\n        {\n            if (prime[i])\n            {\n                for(int pow = 1;pow<=10;pow++) {\n                    long val = (long) Math.pow((long)i, pow);\n                    set.add(val);\n                    if(val>1000)\n                    {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    static long smallestDivisor(long n)\n    {\n        \/\/ if divisible by 2\n        if (n % 2 == 0)\n            return 2;\n\n        \/\/ iterate from 3 to sqrt(n)\n        for (long i = 3; i * i <= n; i += 2) {\n            if (n % i == 0)\n                return i;\n        }\n\n        return n;\n    }\n\n\n    static long power(long x, long y, int p)\n    {\n\n        \/\/ Initialize result\n        long res = 1;\n\n        \/\/ Update x if it is more than or\n        \/\/ equal to p\n        x = x % p;\n\n        while (y > 0) {\n\n            \/\/ If y is odd, multiply x\n            \/\/ with result\n            if (y % 2 == 1)\n                res = (res * x) % p;\n\n            \/\/ y must be even now\n            y = y >> 1; \/\/ y = y\/2\n            x = (x * x) % p;\n        }\n\n        return res;\n    }\n\n    \/\/ Returns n^(-1) mod p\n    static long modInverse(long n, int p)\n    {\n        return power(n, p - 2, p);\n    }\n\n    \/\/ Returns nCr % p using Fermat's\n    \/\/ little theorem.\n    static long nCrModPFermat(int n, int r)\n    {\n\n        if (n<r)\n            return 0;\n        \/\/ Base case\n        if (r == 0)\n            return 1;\n\n        \/\/ Fill factorial array so that we\n        \/\/ can find all factorial of r, n\n        \/\/ and n-r\n\n\n        return (fac[n] * modInverse(fac[r], MOD)\n                % MOD * modInverse(fac[n - r], MOD)\n                % MOD)\n                % MOD;\n    }\n    static int MOD = (int)(1e9+7);\n    static long[] fac;\n    static void populateFact(int n)\n    {\n        fac = new long[n + 1];\n        fac[0] = 1;\n\n        for (int i = 1; i <= n; i++)\n            fac[i] = fac[i - 1] * i % MOD;\n    }\n\n    static long calculate(int[] arr, int n, int k, int i)\n    {\n        if(i==n)\n        {\n            long xor = arr[0], and=arr[0];\n            for(int x=1;x<n;x++)\n            {\n                xor^=arr[x];\n                and&=arr[x];\n            }\n            if(and>=xor)\n            {\n                return 1;\n            }\n            return 0;\n        }\n        long count = 0;\n        for(int j=0;j<(1<<k);j++)\n        {\n            arr[i]=j;\n            count+=calculate(arr,n,k,i+1);\n        }\n        return count;\n    }\n    static long calc(int n, int k)\n    {\n        int[] arr = new int[n];\n        return calculate(arr,n,k,0);\n    }\n\n    static int countRem(char[] arr, int l, int r, int n, char c)\n    {\n        int i=l,j=r;\n        int count = 0;\n        while(i<=j)\n        {\n            if(arr[i] != arr[j])\n            {\n                if(arr[i]==c)\n                {\n                    count++;\n                    i++;\n                }\n                else if(arr[j]==c)\n                {\n                    count++;\n                    j--;\n                }\n                else\n                {\n                    return -1;\n                }\n            }\n            else\n            {\n                i++;j--;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        StringBuilder ans = new StringBuilder();\n        int t = ri();\n\/\/        int t = 1;\n        while (t-- > 0)\n        {\n            int n=ri();\n            PriorityQueue<Long> pq = new PriorityQueue<>();\n            for(int i=0;i<n;i++)\n            {\n                pq.add(rl());\n            }\n\n            long res = pq.remove();\n            long val = res;\n            while(pq.size()>0)\n            {\n                long curr = pq.remove();\n                long mid = curr - val;\n                res=Math.max(res,mid);\n                val +=mid;\n            }\n            ans.append(res).append(\"\\n\");\n        }\n        out.print(ans.toString());\n        out.flush();\n    }\n\n}\n\/*\n4 3\n2 1\n1 3\n3 4\n8\n3\n1 2 3\n2 3 1\n3\n3\n2 1 2\n2 1 3\n3\n *\/","import java.util.*;\nimport java.io.*;\n\/\/ import java.lang.*;\n\/\/ import java.math.*;\n\npublic class Codeforces {\n    static FastReader sc=new FastReader();\n\tstatic PrintWriter out=new PrintWriter(System.out);\n\tstatic long mod=1000000007;\n\t\/\/ static long mod=998244353;\n\tstatic int MAX=Integer.MAX_VALUE;\n\tstatic int MIN=Integer.MIN_VALUE;\n\tstatic long MAXL=Long.MAX_VALUE;\n\tstatic long MINL=Long.MIN_VALUE;\n\tstatic ArrayList<Integer> graph[];\n\tstatic long fact[];\n\tstatic StringBuffer sb;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t\/\/ code goes here\n\t\tint t=I();\n\t\touter:while(t-->0)\n\t\t{\n\t\t\tint n=I();\n\t\t\tlong a[]=new long[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ta[i]=L();\n\t\t\t}\n\t\t\tsort(a);\n\t\t\tlong p=a[0],sml=a[0];\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tif(a[i]-p>=sml){\n\t\t\t\t\tsml=a[i]-p;\n\t\t\t\t\tp+=a[i]-p;\n\t\t\t\t}else{\n\t\t\t\t\tp+=a[i]-p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(sml);\n\t\t}\n\t\tout.close();\n\t}\n\tpublic static class pair\n    {\n    \tlong a;\n    \tlong b;\n    \tpublic pair(long val,long index)\n    \t{\n    \t    a=val;\n    \t    b=index;\n    \t}\n    }\n\tpublic static class myComp implements Comparator<pair>\n\t{\n\t\t\/\/sort in ascending order.\n\t\t\/\/ public int compare(pair p1,pair p2)\n\t\t\/\/ {\n\t\t\/\/ \tif(p1.a==p2.a)\n    \t\/\/     return 0;\n    \t\/\/     else if(p1.a<p2.a)\n    \t\/\/     return -1;\n    \t\/\/     else\n    \t\/\/     return 1;\n\t\t\/\/ }\n\t\t\/\/sort in descending order.\n\t\tpublic int compare(pair p1,pair p2)\n    \t{\n    \t    if(p1.a==p2.a)\n    \t    return 0;\n    \t    else if(p1.a<p2.a)\n    \t    return 1;\n    \t    else\n    \t    return -1;\n    \t}\n\t}\n\tpublic static long nPr(int n,int r)\n\t{\n\t\tlong ans=divide(fact(n),fact(n-r),mod);\n\t\treturn ans;\n\t}\n\tpublic static long nCr(int n,int r)\n\t{\n\t\tlong ans=divide(fact[n],mul(fact[n-r],fact[r]),mod);\n\t\treturn ans;\n\t}\n\tpublic static long kadane(long a[],int n)  \/\/largest sum subarray\n\t{\n\t\tlong max_sum=Long.MIN_VALUE,max_end=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tmax_end+=a[i];\n\t\t\tif(max_sum<max_end){max_sum=max_end;}\n\t\t\tif(max_end<0){max_end=0;}\n\t\t}\n\t\treturn max_sum;\n\t}\n\tpublic static void DFS(int s,boolean visited[])\n\t{\n\t\tvisited[s]=true;\n\t\tfor(int i:graph[s]){\n\t\t\tif(!visited[i]){\n\t\t\t\tDFS(i,visited);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void setGraph(int n,int m)\n\t{\n\t\tgraph=new ArrayList[n+1];\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tgraph[i]=new ArrayList<>();\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u=I(),v=I();\n\t\t\tgraph[u].add(v);\n\t\t\tgraph[v].add(u);\n\t\t}\n\t}\n\tpublic static int BS(long a[],long x,int ii,int jj)\n\t{\n\t\t\/\/ int n=a.length;\n\t\tint mid=0;\n\t\tint i=ii,j=jj;\n\t\twhile(i<=j)\n\t\t{\n\t\t\tmid=(i+j)\/2;\n\t\t\tif(a[mid]<x){\n\t\t\t\ti=mid+1;\n\t\t\t}else if(a[mid]>x){\n\t\t\t\tj=mid-1;\n\t\t\t}else{\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t\/\/LOWER_BOUND and UPPER_BOUND functions\n\n\tpublic static int lower_bound(long arr[],int start, int end, long X)   \/\/start=0,end=n-1\n\t{\n\t\tif(arr[arr.length-1]<X)return end;\n\t\tif(arr[0]>X)return -1;\n\t\tint left=start,right=end;\n\t\twhile(left<right){\n\t\t\tint mid=(left+right)\/2;\n\t\t\tif(arr[mid]==X){                                      \/\/Returns last index of lower bound value.\n\t\t\t\tif(mid<end && arr[mid+1]==X){\n\t\t\t\t\tleft=mid+1;\n\t\t\t\t}else{\n\t\t\t\t\treturn mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ if(arr[mid]==X){                                   \/\/Returns first index of lower bound value.\n\t\t\t\/\/ \tif(mid>start && arr[mid-1]==X){\n\t\t\t\/\/ \t\tright=mid-1;\n\t\t\t\/\/ \t}else{\n\t\t\t\/\/ \t\treturn mid;\n\t\t\t\/\/ \t}\n\t\t\t\/\/ }\n\t\t\telse if(arr[mid]>X){\n\t\t\t\tif(mid>start && arr[mid-1]<X){\n\t\t\t\t\treturn mid-1;\n\t\t\t\t}else{\n\t\t\t\t\tright=mid-1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(mid<end && arr[mid+1]>X){\n\t\t\t\t\treturn mid;\n\t\t\t\t}else{\n\t\t\t\t\tleft=mid+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\tpublic static int upper_bound(long arr[],int start,int end,long X)\t\t\t\/\/start=0,end=n-1\n\t{\n\t\tif(arr[0]>=X)return start;\n\t\tif(arr[arr.length-1]<X)return -1;\n\t\tint left=start,right=end;\n\t\twhile(left<right){\n\t\t\tint mid=(left+right)\/2;\n\t\t\tif(arr[mid]==X){                                   \/\/returns first index of upper bound value.\n\t\t\t\tif(mid>start && arr[mid-1]==X){\n\t\t\t\t\tright=mid-1;\n\t\t\t\t}else{\n\t\t\t\t\treturn mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ if(arr[mid]==X){\t\t\t\t\t\t\t\t\t\/\/returns last index of upper bound value.\n\t\t\t\/\/ \tif(mid<end && arr[mid+1]==X){\n\t\t\t\/\/ \t\tleft=mid+1;\n\t\t\t\/\/ \t}else{\n\t\t\t\/\/ \t\treturn mid;\n\t\t\t\/\/ \t}\n\t\t\t\/\/ }\n\t\t\telse if(arr[mid]>X){\n\t\t\t\tif(mid>start && arr[mid-1]<X){\n\t\t\t\t\treturn mid;\n\t\t\t\t}else{\n\t\t\t\t\tright=mid-1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(mid<end && arr[mid+1]>X){\n\t\t\t\t\treturn mid+1;\n\t\t\t\t}else{\n\t\t\t\t\tleft=mid+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\n\t\/\/END\n\n\tpublic static boolean isSorted(int a[])\n\t{\n\t\tint n=a.length;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tif(a[i]>a[i+1])return false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static boolean isSorted(long a[])\n\t{\n\t\tint n=a.length;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tif(a[i]>a[i+1])return false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static int computeXOR(int n) \/\/compute XOR of all numbers between 1 to n.\n    {\n        if (n % 4 == 0)\n            return n;\n        if (n % 4 == 1)\n            return 1;\n        if (n % 4 == 2)\n            return n + 1;\n        return 0;\n    }\n\tpublic static ArrayList<Integer> primeSieve(int n)\n\t{\n\t    ArrayList<Integer> arr=new ArrayList<>();\n\t    boolean prime[] = new boolean[n + 1];\n        for (int i = 0; i <= n; i++)\n        prime[i] = true;\n        for (int p = 2; p * p <= n; p++)\n        {\n            if (prime[p] == true)\n            {\n                for (int i = p * p; i <= n; i += p)\n                prime[i] = false;\n            }\n        }\n        for (int i = 2; i <= n; i++)\n        {\n            if (prime[i] == true)\n            arr.add(i);\n        }\n        return arr;\n\t}\n\n\t\/\/ Fenwick \/ BinaryIndexed  Tree  USE IT - FenwickTree ft1=new FenwickTree(n);\n\tpublic static class FenwickTree\n\t{\n\t\tint farr[];\n\t\tint n;\n\t\tpublic FenwickTree(int c)\n\t\t{\n\t\t\tn=c+1;\n\t\t\tfarr=new int[n];\n\t\t}\n\t\t\/\/ public void update_range(int l,int r,long p)\n\t\t\/\/ {\n\t\t\/\/ \tupdate(l,p);\n\t\t\/\/ \tupdate(r+1,(-1)*p);\n\t\t\/\/ }\n\t\tpublic void update(int x,int p)\n\t\t{\n\t\t\tfor(;x<n;x+=x&(-x))\n\t\t\t{\n\t\t\t\tfarr[x]+=p;\n\t\t\t}\n\t\t}\n\t\tpublic long get(int x)\n\t\t{\n\t\t\tlong ans=0;\n\t\t\tfor(;x>0;x-=x&(-x))\n\t\t\t{\n\t\t\t\tans=ans+farr[x];\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\t\/\/Disjoint Set Union\n\tpublic static class DSU\n\t{\n\t    int par[],rank[];\n\t    public DSU(int c)\n\t    {\n\t        par=new int[c+1];\n\t        rank=new int[c+1];\n\t        for(int i=0;i<=c;i++)\n\t        {\n\t            par[i]=i;\n\t            rank[i]=0;\n\t        }\n\t    }\n\t    public int find(int a)\n\t    {\n\t        if(a==par[a])\n\t        return a;\n\t        return par[a]=find(par[a]);\n\t    }\n\t    public void union(int a,int b)\n\t    {\n\t        int a_rep=find(a),b_rep=find(b);\n\t        if(a_rep==b_rep)\n\t        return;\n\t        if(rank[a_rep]<rank[b_rep])\n\t        par[a_rep]=b_rep;\n\t        else if(rank[a_rep]>rank[b_rep])\n\t        par[b_rep]=a_rep;\n\t        else\n\t        {\n\t            par[b_rep]=a_rep;\n\t            rank[a_rep]++;\n\t        }\n\t    }\n\t}\n\t\n    public static class myComp1 implements Comparator<pair1>\n    {\n\t\t\/\/sort in ascending order.\n    \tpublic int compare(pair1 p1,pair1 p2)\n    \t{\n    \t    if(p1.a==p2.a)\n    \t    return 0;\n    \t    else if(p1.a<p2.a)\n    \t    return -1;\n    \t    else\n    \t    return 1;\n    \t}\n\t\t\/\/sort in descending order.\n\t\t\/\/ public int compare(pair p1,pair p2)\n    \t\/\/ {\n    \t\/\/     if(p1.a==p2.a)\n    \t\/\/     return 0;\n    \t\/\/     else if(p1.a<p2.a)\n    \t\/\/     return 1;\n    \t\/\/     else\n    \t\/\/     return -1;\n    \t\/\/ }\n    }\n\tpublic static class pair1\n    {\n    \tlong a;\n    \tlong b;\n    \tpublic pair1(long val,long index)\n    \t{\n    \t    a=val;\n    \t    b=index;\n    \t}\n    }\n    public static ArrayList<pair1> mergeIntervals(ArrayList<pair1> arr)\n\t{\n\t    \/\/****************use this in main function-Collections.sort(arr,new myComp1());\n\t    ArrayList<pair1> a1=new ArrayList<>();\n\t    if(arr.size()<=1)\n\t    return arr;\n\t    a1.add(arr.get(0));\n\t    int i=1,j=0;\n\t    while(i<arr.size())\n\t    {\n\t        if(a1.get(j).b<arr.get(i).a)\n\t        {\n\t           a1.add(arr.get(i));\n\t           i++;\n\t           j++;\n\t        }\n\t        else if(a1.get(j).b>arr.get(i).a && a1.get(j).b>=arr.get(i).b)\n\t        {\n\t            i++;\n\t        }\n\t        else if(a1.get(j).b>=arr.get(i).a)\n\t        {\n\t            long a=a1.get(j).a;\n\t            long b=arr.get(i).b;\n\t            a1.remove(j);\n\t            a1.add(new pair1(a,b));\n\t            i++;\n\t        }\n\t    }\n\t    return a1;\n\t}\n\tpublic static ArrayList<Long> primeFact(long a)\n\t{\n\t    ArrayList<Long> arr=new ArrayList<>();\n\t    while(a%2==0){\n\t        arr.add(2L);\n\t        a=a\/2;\n\t    }\n\t    for(long i=3;i*i<=a;i+=2){\n\t        while(a%i==0){\n\t            arr.add(i);\n\t            a=a\/i;\n\t        }\n\t    }\n\t    if(a>2)arr.add(a);\n\t    return arr;\n\t}\n\tpublic static boolean isInteger(double N)\n\t{\n\t\tint X = (int)N;\n\t\tdouble temp2 = N - X;\n\t\tif (temp2 > 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static boolean isPalindrome(String s,int n)\n\t{\n\t\tfor(int i=0;i<=n\/2;i++){\n\t\t\tif(s.charAt(i)!=s.charAt(n-i-1)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static int gcd(int a,int b)\n\t{\n\t    if(b==0)\n\t    return a;\n\t    else\n\t    return gcd(b,a%b);\n\t}\n\tpublic static long gcd(long a,long b)\n\t{\n\t    if(b==0)\n\t    return a;\n\t    else\n\t    return gcd(b,a%b);\n\t}\n\tpublic static long fact(long n)\n\t{\n\t\tlong fact=1;\n\t\tfor(long i=2;i<=n;i++){\n\t\t\tfact=((fact%mod)*(i%mod))%mod;\n\t\t}\n\t\treturn fact;\n\t}\n\tpublic static long fact(int n)\n\t{\n\t\tlong fact=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tfact=((fact%mod)*(i%mod))%mod;\n\t\t}\n\t\treturn fact;\n\t} \n\tpublic static boolean isPrime(int n) \n\t{ \n\t    if (n <= 1) \n\t        return false; \n\t    if (n <= 3) \n\t        return true; \n\t    if (n % 2 == 0 || n % 3 == 0) \n\t        return false; \n\t    double sq=Math.sqrt(n);\n\t  \n\t    for (int i = 5; i <= sq; i = i + 6) \n\t        if (n % i == 0 || n % (i + 2) == 0) \n\t            return false; \n\t    return true; \n\t} \n    public static boolean isPrime(long n) \n\t{ \n\t    if (n <= 1) \n\t        return false; \n\t    if (n <= 3) \n\t        return true; \n\t    if (n % 2 == 0 || n % 3 == 0) \n\t        return false; \n\t    double sq=Math.sqrt(n);\n\t\n\t    for (int i = 5; i <= sq; i = i + 6) \n\t        if (n % i == 0 || n % (i + 2) == 0) \n\t            return false; \n\t    return true; \n\t}\n\tpublic static void printArray(long a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(int a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(char a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]);\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(String a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(boolean a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(pair a[])\n\t{\n\t\tfor(pair p:a){\n\t\t\tout.println(p.a+\"->\"+p.b);\n\t\t}\n\t}\n\tpublic static void printArray(int a[][])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tfor(int j=0;j<a[i].length;j++){\n\t\t\t\tout.print(a[i][j]+\" \");\n\t\t\t}out.println();\n\t\t}\n\t}\n\tpublic static void printArray(long a[][])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tfor(int j=0;j<a[i].length;j++){\n\t\t\t\tout.print(a[i][j]+\" \");\n\t\t\t}out.println();\n\t\t}\n\t}\n\tpublic static void printArray(char a[][])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tfor(int j=0;j<a[i].length;j++){\n\t\t\t\tout.print(a[i][j]+\" \");\n\t\t\t}out.println();\n\t\t}\n\t}\n\tpublic static void printArrayL(ArrayList<Long> arr)\n\t{\n\t\tfor(int i=0;i<arr.size();i++){\n\t\t\tout.print(arr.get(i)+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArrayI(ArrayList<Integer> arr)\n\t{\n\t\tfor(int i=0;i<arr.size();i++){\n\t\t\tout.print(arr.get(i)+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArrayS(ArrayList<String> arr)\n\t{\n\t\tfor(int i=0;i<arr.size();i++){\n\t\t\tout.print(arr.get(i)+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printMapInt(HashMap<Integer,Integer> hm){\n\t\tfor(Map.Entry<Integer,Integer> e:hm.entrySet()){\n\t\t\tout.println(e.getKey()+\"->\"+e.getValue());\n\t\t}out.println();\n\t}\n\tpublic static void printMapLong(HashMap<Long,Long> hm){\n\t\tfor(Map.Entry<Long,Long> e:hm.entrySet()){\n\t\t\tout.println(e.getKey()+\"->\"+e.getValue());\n\t\t}out.println();\n\t}\n\n\t\/\/Modular Arithmetic\n\n\tpublic static long add(long a,long b)\n\t{\n\t\ta+=b;\n\t\tif(a>=mod)a-=mod;\n\t\treturn a;\n\t}\n\tpublic static long sub(long a,long b)\n\t{\n\t\ta-=b;\n\t\tif(a<0)a+=mod;\n\t\treturn a;\n\t}\n\tpublic static long mul(long a,long b)\n\t{\n\t\treturn ((a%mod)*(b%mod))%mod;\n\t}\n\tpublic static long divide(long a,long b,long m)\n\t{\n\t\ta=mul(a,modInverse(b,m));\n\t\treturn a;\n\t}\n\tpublic static long modInverse(long a,long m)\n\t{\n\t\tint x=0,y=0;\n\t\town p=new own(x,y);\n\t\tlong g=gcdExt(a,m,p);\n\t\tif(g!=1){\n\t\t\tout.println(\"inverse does not exists\");\n\t\t\treturn -1;\n\t\t}else{\n\t\t\tlong res=((p.a%m)+m)%m;\n\t\t\treturn res;\n\t\t}\n\t}\n\tpublic static long gcdExt(long a,long b,own p)\n\t{\n\t\tif(b==0){\n\t\t\tp.a=1;\n\t\t\tp.b=0;\n\t\t\treturn a;\n\t\t}\n\t\tint x1=0,y1=0;\n\t\town p1=new own(x1,y1);\n\t\tlong gcd=gcdExt(b,a%b,p1);\n\t\tp.b=p1.a - (a\/b) * p1.b;\n\t\tp.a=p1.b;\n\t\treturn gcd;\n\t}\n\tpublic static long pwr(long m,long n)\n\t{\n\t\tlong res=1;\n\t\tif(m==0)\n\t\treturn 0;\n\t\twhile(n>0)\n\t\t{\n\t\t\tif((n&1)!=0)\n\t\t\t{\n\t\t\t\tres=(res*m);\n\t\t\t}\n\t\t\tn=n>>1;\n\t\t\tm=(m*m);\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static long modpwr(long m,long n)\n\t{\n\t\tlong res=1;\n\t\tm=m%mod;\n\t\tif(m==0)\n\t\treturn 0;\n\t\twhile(n>0)\n\t\t{\n\t\t\tif((n&1)!=0)\n\t\t\t{\n\t\t\t\tres=(res*m)%mod;\n\t\t\t}\n\t\t\tn=n>>1;\n\t\t\tm=(m*m)%mod;\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static class own\n    {\n    \tlong a;\n    \tlong b;\n    \tpublic own(long val,long index)\n    \t{\n    \t    a=val;\n    \t    b=index;\n    \t}\n    }\n\n\t\/\/Modular Airthmetic\n\n\tpublic static void sort(int[] A)\n\t{\n        int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i)\n\t\t{\n            int tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n        Arrays.sort(A);\n    }\n\tpublic static void sort(char[] A)\n\t{\n        int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i)\n\t\t{\n            char tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n        Arrays.sort(A);\n    }\n    public static void sort(long[] A)\n\t{\n\t    int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i)\n\t\t{\n            long tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n\t    Arrays.sort(A);\n\t}\n\tpublic static int I(){return sc.I();}\n    public static long L(){return sc.L();}\n    public static String S(){return sc.S();}\n    public static double D(){return sc.D();}\n}\nclass FastReader {  \n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader(){\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n    String next(){\n        while (st == null || !st.hasMoreElements()){\n            try {\n                st = new StringTokenizer(br.readLine());\n            }\n            catch (IOException e){\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    int I(){ \n        return Integer.parseInt(next());\n    }\n    long L(){ \n        return Long.parseLong(next());\n    }\n    double D(){\n         return Double.parseDouble(next());\n    }\n    String S(){\n        String str = \"\";\n        try \n        {\n            str = br.readLine();\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}\n","import java.io.*;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class CF_1607c{\n    public static final void main(String[] args){\n        Kattio io= new Kattio();\n        int t= io.getInt();\n        while(t-->0){\n            PriorityQueue<Integer> pq= new PriorityQueue<>();\n            int n= io.getInt(); \/\/ [1..2*10**5]\n            for(int i=0; i<n; i++){\n                pq.offer(io.getInt());\n            }\n            long min= pq.peek();\n            while(!pq.isEmpty()){\n                int smallest= pq.remove();\n                if(!pq.isEmpty()){\n                    min= Math.max(min, pq.peek()-smallest);\n                }\n            }\n            io.println(min);\n        }\n        io.close();\n    }\n\n    static void err(String format, Object... args){\n        System.err.println(String.format(format, args));\n    }    \n    static class Kattio extends PrintWriter {\n        private BufferedReader r;\n        private String line, token;\n        private StringTokenizer st;\n    \n        public Kattio(){this(System.in);}\n        public Kattio(InputStream i){\n        super(new BufferedOutputStream(System.out));\n            r= new BufferedReader(new InputStreamReader(i));\n        }\n        public Kattio(InputStream i, OutputStream o){\n        super(new BufferedOutputStream(o));\n            r= new BufferedReader(new InputStreamReader(i));\n        }\n        public boolean isLineEnd(){\n            return !st.hasMoreTokens();\n        }\n        public boolean hasMoreTokens(){\n            return peekToken()!=null;\n        }\n        public int getInt(){\n            return Integer.parseInt(nextToken());\n        }\n        public double getDouble(){ \n            return Double.parseDouble(nextToken());\n        }\n        public long getLong(){\n            return Long.parseLong(nextToken());\n        }\n        public String getWord(){\n            return nextToken();\n        }\n        private String peekToken(){\n            if(token==null) try {\n                while(st==null || !st.hasMoreTokens()) {\n                    line= r.readLine();\n                    if(line==null) return null;\n                    st= new StringTokenizer(line);\n                }\n                token= st.nextToken();\n            }catch(IOException e){}\n            return token;\n        }\n        private String nextToken() {\n            String ans= peekToken();\n            token= null;\n            return ans;\n        }\n    }    \n}","#include <bits\/stdc++.h>\nusing namespace std;\nint n, a[200005];\nint abs(int a) {\n  if (a > 0)\n    return a;\n  else\n    return -a;\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n      scanf(\"%d\", &a[i]);\n    }\n    sort(a + 1, a + 1 + n);\n    long long int res = (long long int)a[1];\n    for (int i = 1; i <= n - 1; i++) {\n      long long int k = (long long int)a[i + 1] - a[i];\n      res = max(res, k);\n    }\n    printf(\"%lli\\n\", res);\n  }\n}\n","for _ in range(int(input())):\n    n = int(input())\n    line = [int(i) for i in input().split()]\n    line.sort()\n    awn = line[0]\n    for i in range(n - 1):\n        i = line[i + 1] - line[i]\n        if i > awn:\n            awn = i\n\n    print(awn)","for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    if n == 1:\n        print(a[0])\n    else:\n        ans = min(a)\n        for i in range(len(a) - 1, -1, -1):\n            ans = max(ans, a[i] - a[i - 1])\n        print(ans)       ","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve();\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\nvoid solve() {\n  long long n;\n  cin >> n;\n  long long a[n];\n  for (auto i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  if (n == 1) {\n    cout << a[0] << endl;\n    return;\n  }\n  sort(a, a + n);\n  int max = a[0];\n  for (int i = 1; i < n; i++) {\n    if (max < (a[i] - a[i - 1])) {\n      max = a[i] - a[i - 1];\n    }\n  }\n  cout << max << endl;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base ::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  int n;\n  vector<long long> a;\n  while (t > 0) {\n    cin >> n;\n    int tmp;\n    long long maxN;\n    for (int i = 0; i < n; i++) {\n      cin >> tmp;\n      a.push_back(tmp);\n    }\n    if (n == 1) {\n      cout << tmp << endl;\n      t--;\n      a.clear();\n      continue;\n    }\n    sort(a.begin(), a.end());\n    maxN = a[0];\n    for (int i = 1; i < n; i++) {\n      maxN = max(maxN, a[i] - a[i - 1]);\n    }\n    cout << maxN << endl;\n    a.clear();\n    t--;\n  }\n  return 0;\n}\n","import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.lang.*;\nimport static java.lang.Math.*;\n\n\/\/ Sachin_2961 submission \/\/\npublic class Codeforces {\n\n    static void solve(){\n        int n = fs.nInt();\n        long[]ar = new long[n];\n        for(int i=0;i<n;i++)\n            ar[i] = fs.nLong();\n\n        sort(ar);\n        long d = ar[0];\n        long max = ar[0];\n        for(int i=1;i<n;i++){\n            ar[i] = ar[i] - d;\n\/\/            out.print(ar[i]+\" \"+d+\"\\n\");\n            max = max(max,ar[i]);\n            d += ar[i];\n        }\n        out.println(max);\n    }\n    \n    static class Pair{\n        int f,s;\n        Pair(int f,int s){\n            this.f = f;\n            this.s = s;\n        }\n    }\n    static boolean multipleTestCase = true;\n    static FastScanner fs;\n    static PrintWriter out;\n    public static void main(String[]args){\n       try{\n           out = new PrintWriter(System.out);\n           fs = new FastScanner();\n           int tc = multipleTestCase?fs.nInt():1;\n           while (tc-->0)solve();\n           out.flush();\n           out.close();\n       }catch (Exception e){\n           e.printStackTrace();\n       }\n    }\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String n() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        String Line()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        int nInt() {return Integer.parseInt(n()); }\n        long nLong() {return Long.parseLong(n());}\n        double nDouble(){return Double.parseDouble(n());}\n        int[]aI(int n){\n            int[]ar = new int[n];\n            for(int i=0;i<n;i++)\n                ar[i] = nInt();\n            return ar;\n        }\n    }\n    public static void sort(int[] arr){\n        ArrayList<Integer> ls = new ArrayList<Integer>();\n        for(int x: arr)\n            ls.add(x);\n        Collections.sort(ls);\n        for(int i=0; i < arr.length; i++)\n            arr[i] = ls.get(i);\n    }\n    public static void sort(long[] arr){\n        ArrayList<Long> ls = new ArrayList<>();\n        for(long x: arr)\n            ls.add(x);\n        Collections.sort(ls);\n        for(int i=0; i < arr.length; i++)\n            arr[i] = ls.get(i);\n    }\n}","import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\/**\n * @author Mubtasim Shahriar\n *\/\n\npublic class MinimumExtraction {\n\n    public static void main(String[] args) {\n\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader sc = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        int t = sc.nextInt();\n\/\/        int t = 1;\n        while (t-- != 0) {\n            solver.solve(sc, out);\n        }\n        out.close();\n\n    }\n\n    static class Solver {\n        public void solve(InputReader sc, PrintWriter out) {\n            int n = sc.nextInt();\n            long[] tarr = sc.nextLongArray(n);\n            if(n==1) {\n                out.println(tarr[0]);\n                return;\n            }\n            sort(tarr);\n            long[] arr = tarr;\n            if(tarr[0]<0) {\n                for (int i = 1; i < n; i++) {\n                    tarr[i] -= tarr[0];\n                }\n                arr = new long[n-1];\n                for(int i =1 ; i < n; i++) arr[i-1] = tarr[i];\n                n--;\n            }\n            long total = 0;\n            long ans = arr[0];\n            for(int i = 0; i < n-1; i++) {\n                total += (arr[i]-total);\n                ans = Math.max(ans,arr[i+1]-total);\n            }\n            out.println(ans);\n        }\n    }\n\n    static void sort(int[] arr) {\n        ArrayList<Integer> al = new ArrayList();\n        for (int i : arr) al.add(i);\n        Collections.sort(al);\n        int idx = 0;\n        for (int i : al) arr[idx++] = i;\n    }\n\n    static void sort(long[] arr) {\n        ArrayList<Long> al = new ArrayList();\n        for (long i : arr) al.add(i);\n        Collections.sort(al);\n        int idx = 0;\n        for (long i : al) arr[idx++] = i;\n    }\n\n    static void sortDec(int[] arr) {\n        ArrayList<Integer> al = new ArrayList();\n        for (int i : arr) al.add(i);\n        Collections.sort(al, Collections.reverseOrder());\n        int idx = 0;\n        for (int i : al) arr[idx++] = i;\n    }\n\n    static void sortDec(long[] arr) {\n        ArrayList<Long> al = new ArrayList();\n        for (long i : arr) al.add(i);\n        Collections.sort(al, Collections.reverseOrder());\n        int idx = 0;\n        for (long i : al) arr[idx++] = i;\n    }\n\n    static class InputReader {\n        private boolean finished = false;\n\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int peek() {\n            if (numChars == -1) {\n                return -1;\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private String readLine0() {\n            StringBuilder buf = new StringBuilder();\n            int c = read();\n            while (c != '\\n' && c != -1) {\n                if (c != '\\r') {\n                    buf.appendCodePoint(c);\n                }\n                c = read();\n            }\n            return buf.toString();\n        }\n\n        public String readLine() {\n            String s = readLine0();\n            while (s.trim().length() == 0) {\n                s = readLine0();\n            }\n            return s;\n        }\n\n        public String readLine(boolean ignoreEmptyLines) {\n            if (ignoreEmptyLines) {\n                return readLine();\n            } else {\n                return readLine0();\n            }\n        }\n\n        public BigInteger readBigInteger() {\n            try {\n                return new BigInteger(nextString());\n            } catch (NumberFormatException e) {\n                throw new InputMismatchException();\n            }\n        }\n\n        public char nextCharacter() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E') {\n                    return res * Math.pow(10, nextInt());\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E') {\n                        return res * Math.pow(10, nextInt());\n                    }\n                    if (c < '0' || c > '9') {\n                        throw new InputMismatchException();\n                    }\n                    m \/= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public boolean isExhausted() {\n            int value;\n            while (isSpaceChar(value = peek()) && value != -1) {\n                read();\n            }\n            return value == -1;\n        }\n\n        public String next() {\n            return nextString();\n        }\n\n        public SpaceCharFilter getFilter() {\n            return filter;\n        }\n\n        public void setFilter(SpaceCharFilter filter) {\n            this.filter = filter;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = nextInt();\n            return array;\n        }\n\n        public int[] nextSortedIntArray(int n) {\n            int array[] = nextIntArray(n);\n            Arrays.sort(array);\n            return array;\n        }\n\n        public int[] nextSumIntArray(int n) {\n            int[] array = new int[n];\n            array[0] = nextInt();\n            for (int i = 1; i < n; ++i) array[i] = array[i - 1] + nextInt();\n            return array;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] array = new long[n];\n            for (int i = 0; i < n; ++i) array[i] = nextLong();\n            return array;\n        }\n\n        public long[] nextSumLongArray(int n) {\n            long[] array = new long[n];\n            array[0] = nextInt();\n            for (int i = 1; i < n; ++i) array[i] = array[i - 1] + nextInt();\n            return array;\n        }\n\n        public long[] nextSortedLongArray(int n) {\n            long array[] = nextLongArray(n);\n            Arrays.sort(array);\n            return array;\n        }\n    }\n\n\n}\n","import java.io.*;\nimport java.util.*;\n\npublic class Solution{\n  public static void main(String[] args){\n   FastReader fs = new FastReader();\n   PrintWriter out = new PrintWriter(System.out);\t\n   \n   int t = fs.nextInt();\n   while(t > 0){\n   int n = fs.nextInt();\n   int[] a = new int[n];\n   for(int i = 0; i < a.length; i++){\n     a[i] = fs.nextInt();\n   }\n   sort(a);\n   long max = a[0];\n   for(int i = 1; i < a.length; i++){\n      max = Math.max(max, a[i] - a[i-1]);\n   }\n   out.println(max);\n   t--;\n   }\n   out.flush();\n}\n\n  static void sort(int[] a) {\n\t\tArrayList<Integer> l = new      ArrayList<>();\n\t\tfor (int i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n\t}\n\n  static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(\n                new InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() { return Integer.parseInt(next()); }\n \n        long nextLong() { return Long.parseLong(next()); }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n   }\n}\n","import java.io.*;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class codeforces_753_C {\n    private static void solve(FastIOAdapter io) {\n        int n = io.nextInt();\n        int[] a = io.readArray(n);\n\n        ruffleSort(a);\n        long minus = a[0];\n        long min = a[0];\n        for (int i = 1; i < n; i++) {\n            a[i] -= minus;\n            minus += a[i];\n            min = Math.max(min, a[i]);\n        }\n\n        io.out.println(min);\n    }\n\n    public static void main(String[] args) throws Exception {\n        try (FastIOAdapter ioAdapter = new FastIOAdapter()) {\n            int count = 1;\n            count = ioAdapter.nextInt();\n            while (count-- > 0) {\n                solve(ioAdapter);\n            }\n        }\n    }\n\n    static void ruffleSort(int[] arr) {\n        int n = arr.length;\n        Random rnd = new Random();\n        for (int i = 0; i < n; ++i) {\n            int tmp = arr[i];\n            int randomPos = i + rnd.nextInt(n - i);\n            arr[i] = arr[randomPos];\n            arr[randomPos] = tmp;\n        }\n        Arrays.sort(arr);\n    }\n\n    static class FastIOAdapter implements AutoCloseable {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        public PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter((System.out))));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        String nextLine() {\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long[] readArrayLong(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        @Override\n        public void close() throws Exception {\n            out.flush();\n            out.close();\n            br.close();\n        }\n    }\n}\n","t=int(input())\nfor i in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    a.sort()\n    k=p=0\n    smax=a[0]\n    for j in range(n-1):\n        k-=a[p]\n        smax=max(smax,k+a[p+1])\n        a[p+1]+=k\n        p+=1\n    print(smax)\n","import os\nimport sys\nfrom io import BytesIO, IOBase\n\n_str = str\nstr = lambda x=b\"\": x if type(x) is bytes else _str(x).encode()\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ntestcases = int(input())\nfor tc in range(testcases):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    ans = a[0]\n    buffer = 0\n\n    for i in range(n):\n        ans = max(ans, a[i] + buffer)\n        buffer += (-(a[i] + buffer))\n    \n    print(ans)\n","\/\/ \"static void main\" must be defined in a public class.\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n    static int k=0;\n   \n    static class FastReader {\n        \n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(\n                new InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() { return Integer.parseInt(next()); }\n \n        long nextLong() { return Long.parseLong(next()); }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    public static void main(String[] args) {\n         try{\n        FastReader sc = new FastReader();\n       StringBuilder str = new StringBuilder();int t=sc.nextInt();\n         while(t-->0)\n       {\n           int n=sc.nextInt();\n             long a[]=new long[n];\n             List<Long> ls=new ArrayList<>();\n             for(int i=0;i<n;i++)\n             {\n                 a[i]=sc.nextLong();\n                 ls.add(a[i]);\n             }\n             Collections.sort(ls);\n             for(int i=0;i<n;i++)\n             {\n                 a[i]=ls.get(i);\n             }\n             long ans=a[0];\n             for(int i=1;i<n;i++)\n             {\n                 if((a[i]-a[i-1])>ans)\n                     ans=a[i]-a[i-1];\n             }\n             if(t!=0)\n             str.append(ans+\"\\n\");\n             else \n             str.append(ans);\n       }\n            System.out.println(str.toString());\n         }\n        catch(Exception e)\n        {\n            System.out.println(\"sdf\");\n        }\n    }\n  }   ","for t in range(int(input())):\n    n= int(input())\n    lis = list(map(int, input().split()))\n    if len(lis)==1:\n        print(lis[0])\n    else:\n        lis.sort()\n        maximum=lis[-1]\n        count=0\n        index=-1\n        #print(lis)\n        if lis[0]<0:\n            temp=lis[0]\n            for i in range(len(lis)):\n                lis[i]= lis[i]-temp\n                #print(lis[i],temp)\n        for i in range(len(lis)):\n            if lis[i]==0:\n                index=i\n        if index == n-1:\n            print(0)\n        else:\n            lis = lis[index+1:]\n            #print(lis)\n            if len(lis)==1:\n                print(lis[0])\n            else:\n                count=0\n                res=lis[0]\n                for i in range(len(lis)):\n                    val=lis[i]-count\n                    #print(val,i)\n                    if val>res:\n                        res=val\n                    count+=val\n                print(res)","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int numTest;\n  cin >> numTest;\n  for (int num = 0; num < numTest; ++num) {\n    int n;\n    cin >> n;\n    int arr[n];\n    for (int i = 0; i < n; ++i) {\n      cin >> arr[i];\n    }\n    sort(arr, arr + n);\n    int temp = arr[0], temp2 = 0;\n    for (int i = 1; i < n; ++i) {\n      temp2 += arr[i - 1];\n      arr[i] -= temp;\n      temp += arr[i];\n      if (arr[0] < arr[i]) arr[0] = arr[i];\n    }\n    cout << arr[0] << endl;\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> arr;\n  for (int i = 0; i < n; i++) {\n    int v;\n    cin >> v;\n    arr.push_back(v);\n  }\n  sort(arr.begin(), arr.end());\n  int ma = arr[0];\n  for (int i = 1; i < arr.size(); i++) {\n    int v = (arr[i] - arr[i - 1]);\n    if (v > ma) ma = v;\n  }\n  cout << ma << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n","t=int(input())\nfor i in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    a.sort()\n    k=1\n    b=[0]*n\n    for j in range(1,n):\n        b[j]=-a[j-1]\n    for j in range(1,n):\n        \n        a[j]+=b[j]\n    print(max(a))","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int64_t t;\n  cin >> t;\n  for (int i = 0; i < t; i++) {\n    int64_t n;\n    cin >> n;\n    int64_t a[n];\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a, a + n);\n    int64_t s = a[0];\n    for (int i = 1; i < n; i++) {\n      s = max(s, a[i] - a[i - 1]);\n    }\n    cout << s << endl;\n  }\n  return 0;\n}\n","import java.io.*;\nimport java.util.*;\npublic class MyClass {\n    public static void main(String args[])throws IOException {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int t=Integer.parseInt(br.readLine());\n        BufferedWriter output = new BufferedWriter(new OutputStreamWriter(System.out));\n        while(t-->0){\n            int n=Integer.parseInt(br.readLine());\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            ArrayList<Long> a= new ArrayList<>();\n            for(int i=0;i<n;i++){\n                a.add(Long.parseLong(st.nextToken()));\n            }\n            Collections.sort(a);\n            long sum=0;\n            long min=a.get(0);\n            for(int i=0;i<n;i++){\n                a.set(i,a.get(i)-sum);\n                min=(min >= a.get(i)) ? min : a.get(i);\n                sum+=a.get(i);\n            }\n            System.out.println(min);\n        }\n    }\n}","import java.awt.*;\nimport java.util.*;\n\npublic class Main {\n    static double dist(Point p, Point q) {\n        return Math.abs(p.x - q.x) + Math.abs(p.y - q.y);\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int t = in.nextInt();\n        for (int i = 0; i < t; i++) {\n            long n = in.nextLong();\n            ArrayList<Long> mas = new ArrayList<>();\n            for (int j = 0; j <n; j++) {\n                Long x = in.nextLong();\n                mas.add(x);\n            }\n            Collections.sort(mas);\n            Long mx = mas.get(0);\n\/\/            while (mas.size()>1){\n\/\/                Collections.sort(mas);\n\/\/                if(mas.get(0)>mx){\n\/\/                    mx = mas.get(0);\n\/\/                }\n\/\/                Long mn = mas.get(0);\n                for (int j = 1; j < mas.size(); j++) {\n                    mx = Math.max(mx,mas.get(j)-mas.get(j-1));\n                }\n\/\/                mas.remove(0);\n\/\/            }\n\/\/            if(mas.get(0)>mx){\n\/\/                mx = mas.get(0);\n\/\/            }\n            System.out.println(mx);\n        }\n    }\n}","import java.util.*;\n\n\/\/CODE FORCES\n\npublic class anshulvmc {\n\n    \n    public static void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n    \n    \n    \n    \n    public static int gcd(int a, int b) {\n\t\tif (b==0) return a;\n\t\treturn gcd(b, a%b);\n\t}\n    \n    public static void google(int t) {\n    \tSystem.out.println(\"Case #\"+t+\": \");\n    }\n    \n    \n\/\/    public static void gt(int[][] arr,int k) {\n\/\/    \tint n = arr.length+1;\n\/\/    \tk = Math.min(k,n+1);\n\/\/    \t\n\/\/    \tNode[] nodes = new Node[n];\n\/\/    \tfor(int i=0;i<n;i++) nodes[i] = new Node();\n\/\/    \tfor(int i=0;i<n-1;i++) {\n\/\/    \t\tint a = arr[i][0];\n\/\/    \t\tint b = arr[i][1];\n\/\/    \t\tSystem.out.println(a+\" \"+b);\n\/\/    \t\tnodes[a].adj.add(nodes[b]);\n\/\/    \t\tnodes[b].adj.add(nodes[a]);\n\/\/    \t}\n\/\/    \t\n\/\/    \tArrayDeque<Node> bfs = new ArrayDeque<>();\n\/\/    \tfor(Node nn:nodes) {\n\/\/    \t\tif(nn.adj.size()<2) {\n\/\/    \t\t\tbfs.addLast(nn);\n\/\/    \t\t\tnn.dist=0;\n\/\/    \t\t}\n\/\/    \t}\n\/\/    \t\n\/\/    \twhile(bfs.size()>0) {\n\/\/    \t\tNode nn = bfs.removeFirst();\n\/\/    \t\tfor(Node a : nn.adj) {\n\/\/    \t\t\tif(a.dist!=-1) continue;\n\/\/    \t\t\ta.usedDegree++;\n\/\/    \t\t\tif(a.adj.size() - a.usedDegree <= 1) {\n\/\/    \t\t\t\ta.dist = nn.dist+1;\n\/\/    \t\t\t\tbfs.addLast(a);\n\/\/    \t\t\t}\n\/\/    \t\t}\n\/\/    \t}\n\/\/    \t\n\/\/    \tint[] cs = new int[n+1];\n\/\/    \tfor(Node nn:nodes) {\n\/\/    \t\tcs[nn.dist]++;\n\/\/    \t}\n\/\/    \tfor(int i=1;i<cs.length;i++) cs[i]+=cs[i-1];\n\/\/    \tSystem.out.println(n-cs[k-1]);\n\/\/    }\n    \n    public static class Node{\n    \tArrayList<Node> adj = new ArrayList<>();\n    \tint dist = -1;\n    \tint usedDegree = 0;\n    }\n    \n    \n    public static void cat_mice(int dest,int[] arr) {\n    \tsort(arr);\n    \tint time = dest;\n\t\tint timeleft = dest-1;\n\t\tint counter=0;\n\t\tfor(int i=arr.length-1;i>=0;i--) {\n\t\t\tint val = arr[i];\n\t\t\tint takes = time - val;\n\t\t\tif(takes <= timeleft) {\n\t\t\t\ttimeleft -= takes;\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n    \tSystem.out.println(counter);\n    }\n    \n    \n    public static void minex(int n,int[] arr) {\n    \tsort(arr);\n    \tint ans=arr[0];\n    \tfor(int i=0;i<arr.length-1;i++) {\n    \t\tans = Math.max(ans,arr[i+1] - arr[i]);\n    \t}\n    \tSystem.out.println(ans);\n    }\n\t\n    \n    public static void robot(int n,int m,String moves) {\n    \tint left = 0;\n    \tint right = 0;\n    \tint up = 0;\n    \tint down = 0;\n    \tint h = 0;\n    \tint v = 0;\n    \tfor(int i=0;i<moves.length();i++) {\n    \t\tchar ch = moves.charAt(i);\n    \t\tif(ch == 'L') {\n    \t\t\th--;\n    \t\t}\n    \t\telse if(ch == 'R') {\n    \t\t\th++;\n    \t\t}\n    \t\telse if(ch == 'U') {\n    \t\t\tv--;\n    \t\t}\n    \t\telse {\n    \t\t\tv++;\n    \t\t}\n    \t\t\n    \t\tleft = Math.min(left,h);\n    \t\tright = Math.max(right,h);\n    \t\tup = Math.max(v,up);\n    \t\tdown = Math.min(down,v);\n    \t}\n    \tSystem.out.println(left+\" \"+right+\" \"+up+\" \"+down);\n    \tint vmov = up - down;\n    \tint hmov = right - left;\n    \tSystem.out.println(hmov+\" \"+vmov);\n    \tif(vmov <= n && hmov <= m) {\n    \t\tSystem.out.println(\"possible\");\n    \t}\n    \telse {\n    \t\tSystem.out.println(\"not possible\");\n    \t}\n    }\n    \n    public static void main(String args[])\n    \n    \n    {\t\n    \tScanner scn = new Scanner(System.in);\n    \tint test = scn.nextInt();\n    \tfor(int i=0;i<test;i++) {\n    \t\tint n = scn.nextInt();\n    \t\tint[] arr = new int[n];\n    \t\tfor(int j=0;j<n;j++) {\n    \t\t\tarr[j] = scn.nextInt();\n    \t\t}\n    \t\t\n    \t\tminex(n,arr);\n    \t}\n\/\/    \tint n = 1;\n\/\/    \tint[] dp = new int[2];\n\/\/    \tSystem.out.println(fact(n,dp));\n    \t\t\t\n    }\n\n}","for _ in range(int(input())):\n    l = int(input())\n    a = input().split()\n    for i in range(len(a)):\n        a[i] = int(a[i])\n    if len(a) == 1:\n        print(a[0])\n        continue\n    a.sort()\n    m = a[0]\n    for i in range(len(a) - 1):\n        m = max(m,a[i+1] - a[i])\n\n    print(m)\n","\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.time.LocalDate;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class h {\n\n\tpublic static int r1=0;\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n\tpublic static void main(String[] args)  {\n\t\tOutputStream outputStream =System.out;\n\t    PrintWriter out =new PrintWriter(outputStream);\n\t\tFastReader s=new FastReader();\n\t\tint t=s.nextInt();\n\/\/\t\tsieve();\n\/\/\t\tSystem.out.println(primes.size());\n\t\twhile(t>0) {\n\t\t\tint n=s.nextInt();\n\t\t\tlong[] a=new long[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i]=s.nextLong();\n\t\t\t}\n\t\t\tlong[] b=merge_sort(a,0,n-1);\n\/\/\t\t\t\t\tArrays.sort(a);\n\/\/\t\t\t\t\tlong sum=a[0];\n\t\t\t\t\tlong max=b[0];\n\t\t\t\t\tfor(int i=1;i<n;i++) {\n\t\t\t\t\t\tmax=Math.max(max, b[i]-b[i-1]);\n\/\/\t\t\t\t\t\tsum+=a[i];\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(max);\n\t\t\tt--;\n\t\t}\t\n\t\t\n\tout.close();\n\t}\n\tpublic static int[] is_prime=new int[100001];\n\tpublic static ArrayList<Long> primes=new ArrayList<>();\n\tpublic static void sieve() {\n\t\tlong maxN=100000;\n\t\tfor(long i=1;i<=maxN;i++) {\n\t\t\tis_prime[(int) i]=1;\n\t\t}\n\t\tis_prime[0]=0;\n\t\tis_prime[1]=0;\n\t\tfor(long i=2;i*i<=maxN;i++) {\n\t\t\tif(is_prime[(int) i]!=0) {\n\t\t\t\tprimes.add( i);\n\t\t\t\tlong c=1;\n\t\t\t\tfor(long j=i*i;j<=maxN;j+=i) {\n\t\t\t\t\tis_prime[(int) j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(long i=2;i<=maxN;i++) {\n\t\t\tis_prime[(int) i]=is_prime[(int) (i-1)]+is_prime[(int) i];\n\t\t}\n\/\/\t\tint count=0;\n\/\/\t\tfor(long i=1;i<=maxN;i++) {\n\/\/\t\t\tif(is_prime[(int) i]==1) {\n\/\/\t\t\t\tcount++;\n\/\/\t\t\t}\n\/\/\t\t\tif(is_prime[count]==1) {\n\/\/\t\t\t\tarr[(int) i]=1;\n\/\/\t\t\t}else {\n\/\/\t\t\t\tarr[(int)i]=0;\n\/\/\t\t\t}\n\/\/\t\t}\n\t}\n\tpublic static long[] merge_sort(long[] A, int start, int end) {\n\t\tif (end > start) {\n\t\t\tint mid = (end + start) \/ 2;\n\t\t\tlong[] v = merge_sort(A, start, mid);\n\t\t\tlong[] o = merge_sort(A, mid + 1, end);\n\t\t\treturn (merge(v, o));\n\t\t} else {\n\t\t\tlong[] y = new long[1];\n\t\t\ty[0] = A[start];\n\t\t\treturn y;\n\t\t}\n\t}\n\tpublic static long[] merge(long a[], long b[]) {\n\/\/\t\tint count=0;\n\t\tlong[] temp = new long[a.length + b.length];\n\t\tint m = a.length;\n\t\tint n = b.length;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint c = 0;\n\t\twhile (i < m && j < n) {\n\t\t\tif (a[i] < b[j]) {\n\t\t\t\ttemp[c++] = a[i++];\n\t\t\t\n\t\t\t} else {\n\t\t\t\ttemp[c++] = b[j++];\n\t\t\t}\n\t\t}\n\t\twhile (i < m) {\n\t\t\ttemp[c++] = a[i++];\n\t\t}\n\t\twhile (j < n) {\n\t\t\ttemp[c++] = b[j++];\n\t\t}\n\t\treturn temp;\n\t}\n\t\n\t\n\t\n}","import java.util.*;\nimport java.io.*;\n\npublic class C {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs = new FastScanner();\n\t\tint t = fs.nextInt();\n\t\tfor (int tt = 0; tt < t; tt++) {\n\t\t\tint n = fs.nextInt();\n\t\t\tif (n > 1) {\n\t\t\t\tint[] a = new int[n];\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\ta[i] = fs.nextInt();\n\t\t\t\t}\n\t\t\t\tsort(a);\n\t\t\t\tint max = a[0];\n\t\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\t\tif (a[i + 1] - a[i] > max) {\n\t\t\t\t\t\tmax = a[i + 1] - a[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(fs.nextInt());\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tif (b > a) {\n\t\t\treturn gcd(b, a);\n\t\t}\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t}\n\t\tif (a % b == 0) {\n\t\t\treturn b;\n\t\t} else {\n\t\t\treturn gcd(b, a % b);\n\t\t}\n\t}\n\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> al = new ArrayList<>();\n\t\tfor (int i : a)\n\t\t\tal.add(i);\n\t\tCollections.sort(al);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = al.get(i);\n\t}\n\n\tstatic class FastScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}","# Code by : Sam._.072\nimport sys\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    x=a[0]\n    h=a[0]\n    for i in range(1,n):\n        if a[i]-x>h:\n            h=a[i]-x\n        x+=(a[i]-x)\n    print(h)\n","import sys\ninput = sys.stdin.readline\n\nT = int(input())\nresult = []\nfor _ in range(T):\n    _ = input()\n    a = list(map(int, input()[:-1].split()))\n\n    # Values\n    max_val = float(-float('inf'))\n    sub_count = 0\n\n    # Sorting\n    a.sort()\n\n    if len(a) == 1:\n        result.append(str(a[0]))\n        continue\n\n    for i in range(0, len(a) - 1):\n        # Checking max_val\n        fst = a[i]\n        max_val = max(max_val, fst)\n        \n        # set sub_count\n        sub_count += fst\n        # calculate\n        a[i + 1] -= sub_count\n\n    # Last\n    result.append(str(max(max_val, a[-1])))\n\nprint('\\n'.join(result))","#include <bits\/stdc++.h>\nusing namespace std;\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    long long a[n];\n    for (auto &x : a) cin >> x;\n    ;\n    sort(a, a + n);\n    long long val = a[0];\n    priority_queue<long long> pq;\n    pq.push(val);\n    for (long long i = 1; i < n; ++i) {\n      pq.push(a[i] - val);\n      val = a[i];\n    }\n    cout << pq.top() << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> a(n);\n  for (auto &i : a) cin >> i;\n  sort((a).begin(), (a).end());\n  long long vic = 0;\n  long long mn = a[0];\n  for (long long j = 0; j < n - 1; ++j) {\n    vic += (a[j] - vic);\n    mn = max(mn, a[j + 1] - vic);\n  }\n  cout << mn << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  long long n;\n  cin >> n;\n  for (long long i = 0; i < n; ++i) {\n    solve();\n  }\n}\n","t= int(input())\nfor q in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    arr.sort()\n    lis = [ arr[0]]\n    for i in range(n-1):\n        lis.append(arr[i+1] - arr[i])\n    print(max(lis))    ","#include <bits\/stdc++.h>\nconst int N = 1e5;\nconst int inf = 1e9 + 10;\nusing namespace std;\nvoid yes() { cout << \"YES\" << endl; }\nvoid no() { cout << \"NO\" << endl; }\nmap<long long int, long long int> cnt;\nvoid prime_factorization(long long int n) {\n  for (long long int i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      n \/= i;\n      ++cnt[i];\n    }\n  }\n  if (n > 1) ++cnt[n];\n}\nvoid solve() {\n  long long int x, y, a, b;\n  cin >> x >> y;\n  a = x, b = y;\n  if (x > y) {\n    cout << x + y;\n    return;\n  }\n  if (x == y) {\n    cout << x;\n    return;\n  }\n  if (y % x == 0) {\n    cout << x;\n    return;\n  }\n  cout << (y \/ x) * x + (y % x) \/ 2;\n  return;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long int a[n + 1];\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    if (n == 1)\n      cout << a[1] << endl;\n    else {\n      sort(a + 1, a + n + 1);\n      long long int cross = 0, mn = a[1], second = 0, ans = a[1];\n      for (int i = 2; i <= n; i++) {\n        second += mn;\n        mn = a[i] - second;\n        a[i] = mn;\n        ans = max(mn, ans);\n      }\n      sort(a + 1, a + n + 1);\n      cout << ans;\n      cout << endl;\n    }\n  }\n}\n","\n\ndef solve(a, n):\n    a.sort()\n    ans = a[0]\n    for i in range(1, n):\n        ans = max(ans, a[i] - a[i - 1])\n    return ans\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(a, n))","import math\nfrom collections import OrderedDict\t\t\n\n\nt = int(input())\nwhile(t>0):\n\tn = int(input())\n\tinp = input()\n\n\ta = list(map(int,inp.split(\" \")))\n\tflag = 1\n\ta.sort()\n\tif(n == 1):\n\t\tprint(a[0])\n\telse:\t\n\t\tmax = a[0]\n\t\tfor i in range(0,n-1):\n\t\t\ts = a[i+1] - a[i]\n\t\t\tif(s>max):\n\t\t\t\tmax = s\t\n\n\t\tprint(max)\n\n\n\t# print(a[i] - adder)\n\t\t\t\t\t\n\tt-=1\t\n\n\t\t\t\n\n#\t\t\t\t\t\t\t\u2580\u2588 \u2584\u2588 \u2588\u2580\u2588 \u2588\u2580\u2588 \n#\t\t\t\t\t\t\t\u2588\u2584 \u2591\u2588 \u2588\u2584\u2588 \u2588\u2584\u2588\n","import sys\n# import math\ninput= sys.stdin.buffer.readline\nfor _ in range(int(input())):\n    n = int(input())\n    arr=[int(c) for c in input().split()]\n    arr.sort()\n    ans = float(\"-inf\")\n    curr = 0\n    for i in arr:\n        s = i-curr\n        ans = max(ans,s)\n        curr = i\n    \n    print(ans)","t=int(input())\nfor _ in range(t):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    arr.sort()\n    mx=arr[0]\n    for i in range(n-1):\n        if arr[i+1]-arr[i]>mx:\n            mx=arr[i+1]-arr[i]\n    print(mx)","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long INF = 1e9 + 7;\nconst long long MOD = 998244353;\nlong long power(long long a, long long b, long long mod) {\n  if (b == 0) {\n    return 1;\n  }\n  long long ans = power(a, b \/ 2, mod);\n  ans *= ans;\n  ans %= mod;\n  if (b % 2) {\n    ans *= a;\n  }\n  return ans % mod;\n}\nvoid batman() {\n  long long n;\n  cin >> n;\n  long long a[n];\n  for (int i = 0; i < n; i++) cin >> a[i];\n  if (n == 1) {\n    cout << a[n - 1] << endl;\n    return;\n  }\n  sort(a, a + n);\n  vector<int> v;\n  v.push_back(a[0]);\n  for (int i = 0; i < n - 1; i++) {\n    v.push_back((a[i + 1] - a[i]));\n  }\n  sort(v.begin(), v.end());\n  int x = v.size();\n  cout << v[x - 1] << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int ttt;\n  cin >> ttt;\n  while (ttt--) {\n    batman();\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 9;\nconst long long M = 5e5 + 9;\nconst long long mod = 1e9 + 7;\nlong long Max(long long a, long long b) { return a > b ? a : b; }\nlong long Min(long long a, long long b) { return a > b ? b : a; }\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long lcm(long long a, long long b) { return a * (b \/ gcd(a, b)); }\nlong long Abs(long long x) { return x < 0 ? -x : x; }\nvoid updata(long long &a, long long b) {\n  if (b > a) a = b;\n}\nvoid lowdata(double &a, double b) {\n  if (b < a) a = b;\n}\nvoid swapp(long long &a, long long &b) {\n  long long t = a;\n  a = b;\n  b = t;\n}\nlong long roundd(double number) {\n  return (number > 0.0) ? (number + 0.5) : (number - 0.5);\n}\nlong long multi(long long a, long long b, long long modd) {\n  long long res = 0;\n  while (b) {\n    if (b & 1) res = (res + a) % modd;\n    a = (a + a) % modd;\n    b \/= 2;\n  }\n  return res;\n}\nlong long a[N];\nint main() {\n  long long t;\n  scanf(\"%lld\", &t);\n  ;\n  while (t--) {\n    long long n;\n    scanf(\"%lld\", &n);\n    ;\n    for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n    ;\n    sort(a + 1, a + 1 + n);\n    long long ans = a[1], maxn = a[1], add = 0;\n    for (int i = 2; i <= n; i++) {\n      long long tmp = ans;\n      ans = a[i] - ans - add;\n      add += tmp;\n      updata(maxn, ans);\n    }\n    printf(\"%lld\", maxn);\n    ;\n    printf(\"\\n\");\n    ;\n  }\n  return 0;\n}\n","import sys\ntesting = len(sys.argv) == 4 and sys.argv[3] == \"myTest\"\ninteractive = False\nif testing:\n    cmd = sys.stdout\n    from time import time\n    start_time = int(round(time() * 1000)) \n    readAll = open(sys.argv[1], 'r').read\n    sys.stdout = open(sys.argv[2], 'w')\nelse:\n    readAll = sys.stdin.read\n\n# ############ ---- I\/O Functions ---- ############\n\nclass InputData:\n    def __init__(self):\n        self.lines = readAll().split('\\n')\n        self.n = len(self.lines)\n        self.ii = -1\n    def input(self):\n        self.ii += 1\n        assert self.ii < self.n\n        return self.lines[self.ii]\n\nflush = sys.stdout.flush\nif interactive and not testing:\n    input = sys.stdin.readline\nelse:\n    inputData = InputData()\n    input = inputData.input\n\ndef intin():\n    return(int(input()))\ndef intlin():\n    return(list(map(int,input().split())))\ndef chrin():\n    return(list(input()))\ndef strin():\n    return input()\ndef lout(l, sep=\"\\n\", toStr=True):\n    print(sep.join(map(str, l) if toStr else l))\ndef dout(*args, **kargs):\n    if not testing: return\n    if args: print(args[0] if len(args)==1 else args)\n    if kargs: print([(k,v) for k,v in kargs.items()])\ndef ask(q):\n    sys.stdout.write(str(q)+'\\n')\n    flush()\n    return intin()\n    \n# ############ ---- I\/O Functions ---- ############\n\n# from math import ceil\n# from collections import defaultdict as ddict, Counter\nfrom heapq import *\n# from Queue import Queue\n\ndef main():\n    n = intin()\n    a = intlin()\n    heapify(a)\n    ans = a[0]\n    cml = 0\n    # dout(a)\n    while len(a)>1:\n        cur = heappop(a)\n        # dout(a)\n        cml = cur\n        ans = max(ans, a[0]-cml)\n        # dout(cur=cur,cml=cml,a0=a[0], ans=ans)\n\n    return ans\n\nanss = []\nfor _ in xrange(intin()):\n    anss.append(main())\n    # anss.append(\"YES\" if main() else \"NO\")\nlout(anss)\n\nif testing:\n    sys.stdout = cmd\n    print(int(round(time() * 1000))  - start_time)","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n;\n  cin >> n;\n  long long a[n];\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sort(a, a + n);\n  if (n == 1) {\n    cout << a[0] << \"\\n\";\n  } else {\n    long long sum = a[0];\n    long long m = a[0];\n    for (long long i = 1; i < n; i++) {\n      a[i] = a[i] - sum;\n      m = max(m, a[i]);\n      sum = sum + a[i];\n    }\n    cout << m << \"\\n\";\n  }\n}\nsigned main() {\n  long long t;\n  cin >> t;\n  while (t--) solve();\n}\n","T = int(input())\nwhile T>0:\n    T -= 1\n    n = int(input())\n    array = sorted([int(x) for x in input().split()])\n    ans = array[0]\n    for i in range(len(array) - 1):\n        ans = max(ans, array[i+1] - array[i])\n    print(ans)","\/\/---#ON_MY_WAY---\nimport static java.lang.Math.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class C {\n\tstatic class pair {\n\t\tint x, y;\n\n\t\tpublic pair(int a, int b) {\n\t\t\tx = a;\n\t\t\ty = b;\n\t\t}\n\t}\n\n\tstatic FastReader x = new FastReader();\n\tstatic OutputStream outputStream = System.out;\n\tstatic PrintWriter out = new PrintWriter(outputStream);\n\n\t\/*---------------------------------------CODE STARTS HERE-------------------------*\/\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tlong startTime = System.nanoTime();\n\t\tint mod = 1000000007;\n\t\tint t = x.nextInt();\n\t\tStringBuilder str = new StringBuilder();\n\t\twhile (t > 0) {\n\t\t\tint n = x.nextInt();\n\t\t\tInteger a[] = new Integer[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = x.nextInt();\n\t\t\t}\n\t\t\tTreeSet<Integer> ts = new TreeSet<>(Arrays.asList(a));\n\t\t\tTreeSet<Integer> ans = new TreeSet<>();\n\t\t\tif(n==1) {\n\t\t\t\tstr.append(a[0]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong s = ts.first(), c = ts.first();\n\t\t\t\tfor(Integer i:ts) {\n\t\t\t\t\tint k = (int) (i-s);\n\t\t\t\t\tans.add(k);\n\t\t\t\t\ts += k;\n\t\t\t\t}\n\t\t\t\tstr.append(max(c, ans.last()));\n\t\t\t}\n\t\t\tstr.append(\"\\n\");\n\t\t\tt--;\n\t\t}\n\t\tout.println(str);\n\t\tout.flush();\n\t\tlong endTime = System.nanoTime();\n\t\t\/\/System.out.println((endTime-startTime)\/1000000000.0);\n\t}\n\n\t\/*--------------------------------------------FAST I\/O--------------------------------*\/\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tchar nextchar() {\n\t\t\tchar ch = ' ';\n\t\t\ttry {\n\t\t\t\tch = (char) br.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn ch;\n\t\t}\n\t}\n\n\t\/*--------------------------------------------BOILER PLATE---------------------------*\/\n\tstatic int[] readarr(int n) {\n\t\tint arr[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = x.nextInt();\n\t\t}\n\t\treturn arr;\n\t}\n\n\tstatic int[] sortint(int a[]) {\n\t\tArrayList<Integer> al = new ArrayList<>();\n\t\tfor (int i : a) {\n\t\t\tal.add(i);\n\t\t}\n\t\tCollections.sort(al);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = al.get(i);\n\t\t}\n\t\treturn a;\n\t}\n\n\tstatic long[] sortlong(long a[]) {\n\t\tArrayList<Long> al = new ArrayList<>();\n\t\tfor (long i : a) {\n\t\t\tal.add(i);\n\t\t}\n\t\tCollections.sort(al);\n\t\tfor (int i = 0; i < al.size(); i++) {\n\t\t\ta[i] = al.get(i);\n\t\t}\n\t\treturn a;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tlong result = 1;\n\t\twhile (y > 0) {\n\t\t\tif (y % 2 == 0) {\n\t\t\t\tx = x * x;\n\t\t\t\ty = y \/ 2;\n\t\t\t} else {\n\t\t\t\tresult = result * x;\n\t\t\t\ty = y - 1;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic long pow(long x, long y, long mod) {\n\t\tlong result = 1;\n\t\tx %= mod;\n\t\twhile (y > 0) {\n\t\t\tif (y % 2 == 0) {\n\t\t\t\tx = (x % mod * x % mod) % mod;\n\t\t\t\ty \/= 2;\n\t\t\t} else {\n\t\t\t\tresult = (result % mod * x % mod) % mod;\n\t\t\t\ty--;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int[] revsort(int a[]) {\n\t\tArrayList<Integer> al = new ArrayList<>();\n\t\tfor (int i : a) {\n\t\t\tal.add(i);\n\t\t}\n\t\tCollections.sort(al, Comparator.reverseOrder());\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = al.get(i);\n\t\t}\n\t\treturn a;\n\t}\n\n\tstatic int[] gcd(int a, int b, int ar[]) {\n\t\tif (b == 0) {\n\t\t\tar[0] = a;\n\t\t\tar[1] = 1;\n\t\t\tar[2] = 0;\n\t\t\treturn ar;\n\t\t}\n\t\tar = gcd(b, a % b, ar);\n\t\tint t = ar[1];\n\t\tar[1] = ar[2];\n\t\tar[2] = t - (a \/ b) * ar[2];\n\t\treturn ar;\n\t}\n\n\tstatic boolean[] esieve(int n) {\n\t\tboolean p[] = new boolean[n + 1];\n\t\tArrays.fill(p, true);\n\t\tfor (int i = 2; i * i <= n; i++) {\n\t\t\tif (p[i] == true) {\n\t\t\t\tfor (int j = i * i; j <= n; j += i) {\n\t\t\t\t\tp[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\tstatic ArrayList<Integer> primes(int n) {\n\t\tboolean p[] = new boolean[n + 1];\n\t\tArrayList<Integer> al = new ArrayList<>();\n\t\tArrays.fill(p, true);\n\t\tint i = 0;\n\t\tfor (i = 2; i * i <= n; i++) {\n\t\t\tif (p[i] == true) {\n\t\t\t\tal.add(i);\n\t\t\t\tfor (int j = i * i; j <= n; j += i) {\n\t\t\t\t\tp[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = i; i <= n; i++) {\n\t\t\tif (p[i] == true) {\n\t\t\t\tal.add(i);\n\t\t\t}\n\t\t}\n\t\treturn al;\n\t}\n\n\tstatic int etf(int n) {\n\t\tint res = n;\n\t\tfor (int i = 2; i * i <= n; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tres \/= i;\n\t\t\t\tres *= (i - 1);\n\t\t\t\twhile (n % i == 0) {\n\t\t\t\t\tn \/= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (n > 1) {\n\t\t\tres \/= n;\n\t\t\tres *= (n - 1);\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (a == 0) {\n\t\t\treturn b;\n\t\t}\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\tif (a == 0) {\n\t\t\treturn b;\n\t\t}\n\t\treturn gcd(b % a, a);\n\t}\n}","import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class Solution {\n    \/\/ br.readLine()\n    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    \/\/ pw.printf()\n    private static PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n    \/*\n    NOTES:\n    -\n     *\/\n\n    \/\/ GLOBAL VARIABLES\n    private static int N;\n\n    public static void main(String args[]) throws IOException {\n        FastScanner sc = new FastScanner(br);\n        \/\/ CODE BELOW\n        int T = sc.nextInt(); sc.nextLine();\n        for(int t = 0; t < T; t++) {\n            long n = sc.nextLong(); sc.nextLine();\n            PriorityQueue<Integer> mins = new PriorityQueue<>();\n            int max = Integer.MIN_VALUE;\n            for(int i = 0; i < n; i++) {\n                int num = sc.nextInt();\n                mins.add(num);\n                if(num > max) max = num;\n            }\n            sc.nextLine();\n            int offset = 0;\n            int maxmin = mins.peek();\n            \/\/ try for everything\n            while(mins.size() > 1) {\n                offset += mins.remove() - offset;\n                maxmin = Math.max(maxmin, mins.peek() - offset);\n            }\n            pw.println(maxmin);\n        }\n\n\n\n\n\n        pw.close();\n    }\n\n\n\n\n\n    \/\/ FastScanner CLASS BELOW.\n    \/\/ !!! Always call nextLine() when done with a line!\n    private static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        private FastScanner(BufferedReader br) {\n            this.br = br;\n        }\n\n        private String nextLine() throws IOException {\n            \/\/ if this is first operation on this line, return whole line\n            if(st == null) return br.readLine();\n            \/\/ otherwise, the line must have been tokenized. return rest of tokens separated by space\n            \/\/ and set st to null to indicate we are on next line\n            String line = tokenizerToString(st);\n            st = null;\n            return line;\n        }\n\n        private String tokenizerToString(StringTokenizer st) {\n            StringBuilder sb = new StringBuilder();\n            while(st.hasMoreTokens()) {\n                if(sb.length() > 0) sb.append(\" \");\n                sb.append(st.nextToken());\n            }\n            return sb.toString();\n        }\n\n        private String next() throws IOException {\n            if(st == null) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        private int nextInt() throws IOException {\n            if(st == null) st = new StringTokenizer(br.readLine());\n            return Integer.parseInt(st.nextToken());\n        }\n\n        private long nextLong() throws IOException {\n            if(st == null) st = new StringTokenizer(br.readLine());\n            return Long.parseLong(st.nextToken());\n        }\n\n        private double nextDouble() throws IOException {\n            if(st == null) st = new StringTokenizer(br.readLine());\n            return Double.parseDouble(st.nextToken());\n        }\n\n        private BigInteger nextBigInteger(int radix) throws IOException {\n            if(st == null) st = new StringTokenizer(br.readLine());\n            return new BigInteger(st.nextToken(), radix);\n        }\n    }\n}\n","from math import ceil, log2, floor,sqrt,gcd\nfrom collections import defaultdict,deque\n\nimport sys\nimport os.path\n\nsys.setrecursionlimit(200000)\nif (os.path.exists('input.txt')):\n    sys.stdin = open(\"input.txt\", \"r+\")\n    sys.stdout = open(\"output.txt\", \"w\")\n\n\n# input = sys.stdin.readline\n# print=sys.stdout.write\ndef MI():\n    return map(int, input().split())\n\ndef bfs(s,adj):\n     \n    V = 10**5+2\n    visited = [False] * V\n    level = [0] * V\n  \n    for i in range(V):\n        visited[i] = False\n        level[i] = 0\n    queue = deque()\n    visited[s] = True\n    queue.append(s)\n    level[s] = 0\n  \n    while (len(queue) > 0):\n\n        s = queue.popleft()\n        for i in adj[s]:\n            if (not visited[i]):\n                level[i] = level[s] + 1\n                visited[i] = True\n                queue.append(i)\n  \n\n    \n             \n    return level\n\ndef dfs(node,tree,d,v):\n    v[node]=1\n    for j in d[node]:\n        if v[j]==0:\n            tree[node].append(j)\n            dfs(j,tree,d,v)\n\nmod=10**9+7\ndef solve(testcase):\n    n = int(input())\n    # x,n=MI()\n    a=list(MI())\n    a.sort()\n    neg=pos=0\n    m=10**10\n    minp=10**10\n    ans=min(a)\n    m1=-10**10\n    maxp=-10**10\n    # print(a)\n    \n    \n    for i in a:\n        ans=max(ans,i-neg)\n        if i-neg>0:\n            pos+=i-neg\n            neg+=i-neg\n        else:\n            neg+=i-neg\n        \n            \n    \n    \n    \n    # ans=max(ans,(a[-1]-neg)-(pos-a[-1]))\n\n\n\n\n\n\n    # a[-1]-(neg)\n    print(ans)\n\n    \n    # # neg=pos=0\n    # if m==10**10:\n    #     print(neg)\n    # else:\n    #     print(m-neg)\n\n    \n\n\n\n\n        \n    \n        \n\n    \n   \n\n\n    \n            \n        \n    \n\n    \n    \n        \n    \n  \n        \n\n\n            \n\n\n\n\n        \n\n\n    \n\n\n\n\n\n\n\n    \n    \n\n    \n\n    \n    \n    \n\n    \n\n\n\n\n    \n\n\n\n\n    \n    \n    \n\nt=int(input())\nfor _ in range(t):\n    solve(_+1)","t = int(input())\na = []\nfor _ in range(t):\n\tn = int(input())\n\ts = list(map(int,input().split()))\n\ts.sort()\n\tminus = 0\n\tans = -10000000000000000000000000000000000000000000\n\tfor i in range(n):\n\t\tans = max(ans, s[i]-minus)\n\t\tminus = s[i]\n\ta.append(ans)\nfor elem in a:\n\tprint(elem)\n","#include <bits\/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx2,fma\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimization(\"unroll-loops\")\n#pragma comment(linker, \"\/STACK: 20000000005\")\nbool tc = 1;\nvoid run_case() {\n  long long int n;\n  cin >> n;\n  vector<long long int> v(n);\n  for (long long int i = 0; i < n; i++) cin >> v[i];\n  if (v.size() == 1) {\n    cout << v[0] << endl;\n    return;\n  }\n  sort(v.rbegin(), v.rend());\n  while (v.back() < 0) {\n    long long int mn = v.back();\n    v.pop_back();\n    for (long long int i = 0; i < n; i++) v[i] -= mn;\n  }\n  long long int ans = v.back();\n  for (long long int i = 0; i < v.size() - 1; i++) {\n    ans = max(ans, v[i] - v[i + 1]);\n  }\n  if (v.size() == 1) ans = v[0];\n  cout << ans << endl;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  if (tc) {\n    int t;\n    cin >> t;\n    while (t--) run_case();\n  } else\n    run_case();\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    long n, i;\n    cin >> n;\n    if (n == 1) {\n      long x;\n      cin >> x;\n      cout << x << endl;\n    } else {\n      long arr[n], arr1[n];\n      for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n        arr1[i] = arr[i];\n      }\n      sort(arr, arr + n);\n      sort(arr1, arr1 + n);\n      for (i = 1; i < n; i++) arr[i] -= arr1[i - 1];\n      long m = arr[0];\n      for (i = 1; i < n; i++) m = max(m, arr[i]);\n      cout << m << endl;\n    }\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n;\n  cin >> n;\n  long long m = 0, mx = -1e18;\n  vector<long long> st(n);\n  for (int i = 0; i < n; i++) {\n    cin >> st[i];\n  }\n  sort(st.begin(), st.end());\n  for (int i = 0; i < n; i++) {\n    long long temp = st[i] - m;\n    mx = max(temp, mx);\n    m += temp;\n  }\n  cout << mx << endl;\n}\nint main() {\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\npublic class Main\n{\n\tstatic String shengxiao[] =\n\t{ \"rat\", \"ox\", \"tiger\", \"rabbit\", \"dragon\", \"snake\", \"horse\", \"goat\", \"monkey\", \"rooster\", \"dog\", \"pig\" };\n\tstatic String shengxiaoo[] =\n\t{ \"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Goat\", \"Monkey\", \"Rooster\", \"Dog\", \"Pig\" };\n\tstatic int month[] =\n\t{ 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\tstatic int zhong[] =\n\t{ -1, 1, 0, 0, -1, -1, 1, 1 };\n\tstatic int heng[] =\n\t{ 0, 0, -1, 1, -1, 1, -1, 1 };\n\tstatic int zhongg[] =\n\t{ -1, -1, 0, 1, 1, 1, 0, -1 };\n\tstatic int hengg[] =\n\t{ 0, 1, 1, 1, 0, -1, -1, -1 };\n\tstatic int inf = Integer.MAX_VALUE;\n\tstatic long inff = Long.MAX_VALUE;\n\n\tstatic int mod = (int) 998244353;\n\tstatic int N = (int) 36 + 10;\n\tstatic int M = (int) 1e6 + 10;\n\n\tstatic void init()\n\t{\n\n\t}\n\n\t\/\/ static boolean is(int x)\n\tstatic boolean is()\n\t{\n\n\t\treturn true;\n\t}\n\n\t\/\/ static void solve(String s)\n\t\/\/ static void solve(int n)\n\t\/\/ static void solve(long n)\n\tstatic void solve()\n\t{\n\t\tint n = sc.nextInt();\n\t\tLong shu[] = new Long[n + 10];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tshu[i] = sc.nextLong();\n\n\t\tlong max = Integer.MIN_VALUE;\n\t\tshu[0] = 0l;\n\t\tArrays.sort(shu, 1, n + 1);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tmax = Math.max(max, shu[i] - shu[i - 1]);\n\t\tout.println(max);\n\n\t}\n\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tinit();\n\n\/\/\t\twhile (sc.hasNext())\n\t\t{\n\/\/\t\t\tint t = 1;\n\t\t\tint t = sc.nextInt();\n\t\t\tfor (int x = 1; x <= t; x++)\n\t\t\t\tsolve();\n\n\t\t\t\/\/ String s = sc.next();\n\t\t\t\/\/ solve(s);\n\n\t\t\tout.flush();\n\t\t}\n\n\t\tout.close();\n\t}\n\n\tstatic InputStream inputStream = System.in;\n\tstatic InputReader sc = new InputReader(inputStream);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic class InputReader\n\t{\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next()\n\t\t{\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tboolean hasNext()\n\t\t{\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (Exception e)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t\t\/\/ TODO: handle exception\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic String nextLine()\n\t\t{\n\t\t\tString str = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstr = reader.readLine();\n\t\t\t} catch (IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tpublic int nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic Double nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic BigInteger nextBigInteger()\n\t\t{\n\t\t\treturn new BigInteger(next());\n\t\t}\n\n\t\tpublic BigDecimal nextBigDecimal()\n\t\t{\n\t\t\treturn new BigDecimal(next());\n\t\t}\n\n\t}\n\n}","from sys import stdin,stdout\ninput = stdin.readline\nfor _ in range(int(input())):\n    n=int(input())\n    li=list(map(int,input().split()))\n    if n==1:\n        print(li[0])\n        continue\n    li.sort()    \n    ans=li[0]\n    for i in range(1,n):\n        ans=max(ans,li[i]-li[i-1])\n    print(ans)","\n\ntestcase=int(input())\n\nfor test in range(testcase):\n    n=int(input())\n    a=list(map(int,input().split()))\n    a.sort()\n    res=a[0]\n    for i in range(1,n):\n        res=max(res,a[i]-a[i-1])\n    print(res)\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t;\n  scanf(\"%lld\", &t);\n  while (t--) {\n    long long n;\n    scanf(\"%lld\", &n);\n    vector<long long> v(n);\n    for (long long i = 0; i < n; i++) {\n      scanf(\"%lld\", &v[i]);\n    }\n    sort(v.begin(), v.end());\n    long long kuota = (-1) * v[0], minim = v[0];\n    priority_queue<long long> pq;\n    pq.push(v[0]);\n    for (long long i = 1; i < n; i++) {\n      if (v[i] + kuota > minim) {\n        pq.push(v[i] + kuota);\n      }\n      minim = v[i] + kuota;\n      kuota -= minim;\n    }\n    printf(\"%lld\\n\", pq.top());\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> v(n);\n    for (long long i = 0; i < n; i++) {\n      cin >> v[i];\n    }\n    if (v.size() == 1)\n      cout << v[0] << endl;\n    else {\n      sort(v.begin(), v.end());\n      long long mi = v[0];\n      long long dif = mi;\n      for (long long i = 1; i < n; i++) {\n        v[i] = v[i] - dif;\n        mi = max(mi, v[i]);\n        dif += v[i];\n      }\n      cout << mi << endl;\n    }\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007;\nlong long mod_expo(long long a, long long b, long long mod) {\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = (res * a) % mod;\n    a = (a * a) % mod;\n    b = b >> 1;\n  }\n  return res;\n}\nlong long mod_add(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a + b) % m) + m) % m;\n}\nlong long mod_mul(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a * b) % m) + m) % m;\n}\nlong long mod_sub(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a - b) % m) + m) % m;\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  sort(arr.begin(), arr.end());\n  long long ans = arr[0], val = arr[0];\n  for (int i = 1; i < n; i++) {\n    ans = max(ans, arr[i] - val);\n    val = arr[i];\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t-- > 0) {\n    solve();\n  }\n  return 0;\n}\n","\/\/package com.company;\n\nimport java.util.*;\n\npublic class C {\n\n    private static Scanner scanner = new Scanner(System.in);\n    public static void main(String[] args) {\n        int t = scanner.nextInt();\n        StringBuilder res = new StringBuilder();\n        while(t-- > 0) {\n            int n = scanner.nextInt();\n            ArrayList<Integer> ar = new ArrayList<Integer>();\n            for (int i = 0; i < n; i++) {\n                ar.add(scanner.nextInt());\n            }\n\n            Collections.sort(ar);\n\/\/            int[] ans = new int[n];\n            int max = ar.get(0);\n            for (int i = 0; i < n-1; i++) {\n                max = Math.max(max, ar.get(i+1) - ar.get(i));\n            }\n\n            res.append(max);\n            res.append(\" \");\n\n        }\n        System.out.println(res);\n    }\n}\n\n\/\/    int[] ans = new int[n];\n\/\/    int size = n-1;\n\/\/            for (int i = 0; i < n - 1; i++) {\n\/\/        int temp = res.get(0);\n\/\/        ans[i] = temp;\n\/\/        res.remove(0);\n\/\/        for (int j = 0; j < size; j++) {\n\/\/        int temp1 = res.get(j) - temp;\n\/\/        res.set(j, temp1);\n\/\/        }\n\/\/        size -= 1;\n\/\/        }\n\/\/\n\/\/        ans[n-1] = res.get(0);\n\/\/        Arrays.sort(ans);\n\/\/        System.out.println(ans[n-1]);\n\n\n","import java.util.*;\nimport java.io.*;\npublic class Main {\n\t\tstatic long mod = 1000000007;\n\t\tstatic long max ;\n\t\tstatic PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\t\tpublic static void main(String[] args) throws IOException  {\n\t\t\tFastReader sc = new FastReader();\n\t\t\tint t = sc.nextInt();\n\t\t\twhile( t-- > 0) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint arr[] = new int[n];\n\t\t\t\tfor( int i = 0 ;i< n; i++) {\n\t\t\t\t\tarr[i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tmySort(arr);\n\t\t\t\tlong ans = arr[0];\n\t\t\t\tfor( int i = 1 ;i < n; i++) {\n\t\t\t\t\tans = Math.max(ans, arr[i] - arr[i-1]);\n\t\t\t\t}\n\t\t\t\tout.println(ans);\n\t\t\t}\n\t\t\tout.flush();\n\t\t}\n\t\n\t\tpublic static boolean ifpowof2(long n ) {\n\t\t\treturn ((n&(n-1)) == 0);\n\t\t}\n\t\t\n\t\tpublic static int[] nextLargerElement(int[] arr, int n)\t{ \n\t\t\tStack<Integer> stack = new Stack<>();\n\t\t\tint rtrn[] = new int[n];\n\t\t\trtrn[n-1] = -1;\n\t        stack.push( n-1);\n\t        for( int i = n-2 ;i >= 0 ; i--){\n\t            int temp = arr[i];\n\t            int lol = -1;\n\t            while( !stack.isEmpty() && arr[stack.peek()] <= temp){\n\t            \tif(arr[stack.peek()] == temp ) {\n\t            \t\tlol = stack.peek();\n\t            \t}\n\t                stack.pop();\n\t            }\n\t            if( stack.isEmpty()){\n\t            \tif( lol != -1) {\n\t            \t\trtrn[i] = lol;\n\t            \t}\n\t            \telse {\n\t            \t\trtrn[i] = -1;\n\t            \t}\n\t            }\n\t            else{\n\t            \trtrn[i] = stack.peek();\n\t            }\n\t            stack.push( i);\n\t        }\n\t        return rtrn;\n\t\t}\n\t\t\n\t\t@SuppressWarnings(\"unused\")\n\t\tprivate static void mySort(int[] arr) {\n\t        for(int i=0;i<arr.length;i++) {\n\t            int rand = (int) (Math.random() * arr.length);\n\t            int loc = arr[rand];\n\t            arr[rand] = arr[i];\n\t            arr[i] = loc;\n\t        }\n\t        Arrays.sort(arr);\n\t    }\n\t\t\n\t\tstatic long gcd(long a, long b)\n\t\t{\n\t\t\tif (a == 0)\n\t\t\t\treturn b;\n\t\t\treturn gcd(b % a, a);\n\t\t}\n\t\t\n\t\t\t   \n\t\t static long lcm(long a, long b)\n\t\t {\n\t\t\t return (a \/ gcd(a, b)) * b;\n\t\t }\n\t\t \n\n\t\t static long rightmostsetbit(long n) {\n\t\t\t return n&-n;\n\t\t }\n\t\t \n\t\t static long leftmostsetbit(long n)\n\t\t    {\n\t\t        long k = (long)(Math.log(n) \/ Math.log(2));\n\t\t        return 1 << k;\n\t\t    }\n\t \n\t\t static HashMap<Long,Long> primefactor( long n){\n\t\t\t HashMap<Long ,Long> hm = new HashMap<>();\n\t\t\t long temp = 0;\n\t\t\t while( n%2 == 0) {\n\t\t\t\t temp++;\n\t\t\t\t n\/=2;\n\t\t\t }\t\n\t\t\t if( temp!= 0) {\n\t\t\t\t hm.put( 2L, temp);\n\t\t\t }\n\t\t\t long c = (long)Math.sqrt(n);\n\t\t\t for( long i = 3 ; i <= c ; i+=2) {\n\t\t\t\t temp = 0;\n\t\t\t\t while( n% i == 0) {\n\t\t\t\t\t temp++;\n\t\t\t\t\t n\/=i;\n\t\t\t\t }\n\t\t\t\t if( temp!= 0) {\n\t\t\t\t\t hm.put( i, temp);\n\t\t\t\t }\n\t \t\t }\n\t \t\t if( n!= 1) {\n\t \t\t\t hm.put( n , 1L);\n\t \t\t }\n\t \t\t return hm;\t\n\t\t }\n\t\t \n\t\t @SuppressWarnings(\"unused\")\n\t\tprivate static ArrayList<Integer> allfactors(int abs) {\n\t\t\t HashMap<Integer,Integer> hm = new HashMap<>();\n\t\t\t ArrayList<Integer> rtrn = new ArrayList<>();\n\t\t\t for( int i = 2 ;i*i <= abs; i++) {\n\t\t\t\t if( abs% i == 0) {\n\t\t\t\t\t hm.put( i , 0);\n\t\t\t\t\t hm.put(abs\/i, 0);\n\t\t\t\t }\n\t\t\t }\n\t\t\t for( int x : hm.keySet()) {\n\t\t\t\t rtrn.add(x);\n\t\t\t }\n\t\t\t \n\t\t\t if( abs != 0) {\n\t\t\t\t rtrn.add(abs);\n\t\t\t }\n\t\t\t \n\t\t\t return rtrn;\n\t\t }\n\t\t\t\n\t \n\t\t static class FastReader {\n\t\t\t BufferedReader br;\n\t\t\t StringTokenizer st;\n\t\t \n\t\t\t public FastReader()\n\t\t\t {\n\t\t\t\t br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t }\n\t\t        \n\t\t\t String next()\n\t\t\t {\n\t\t\t\t while (st == null || !st.hasMoreElements()) {\n\t\t\t\t\t try {\n\t\t\t\t\t\t st = new StringTokenizer(br.readLine());\n\t\t\t\t\t }\n\t\t\t\t\t catch (IOException e) {\n\t\t\t\t\t\t e.printStackTrace();\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t return st.nextToken();\n\t\t\t }\n\t\t \n\t\t\t int nextInt() { return Integer.parseInt(next()); }\n\t\t\t \n\t\t\t long nextLong() { return Long.parseLong(next()); }\n\t\t\t \n\t\t\t double nextDouble()\n\t\t\t {\n\t\t\t\t return Double.parseDouble(next());\n\t\t\t }\t\n\t\t \n\t\t\t String nextLine()\n\t\t\t {\n\t\t\t\t String str = \"\";\n\t\t\t\t try {\n\t\t\t\t\t str = br.readLine();\n\t\t\t\t }\n\t\t\t\t catch (IOException e) {\n\t\t\t\t\t e.printStackTrace();\n\t\t\t\t }\n\t\t\t\t return str;\n\t\t\t }\n\t\t }\t\n}","import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\npublic  class Main{\n    public static String nextLine(){\n        String str=\"\";\n        try{\n            str = input.readLine().trim();\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }\n        return str;\n    }\n    public static String next() {\n        while (!tokenizer.hasMoreTokens())\n            try {\n                tokenizer=new StringTokenizer(input.readLine().trim());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return tokenizer.nextToken();\n        }\n    public static int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public static int[] readArray(int n) {\n        int[] a=new int[n];\n        for (int i=0; i<n; i++) a[i]=nextInt();\n        return a;\n    }\n    public static long nextLong() {\n        return Long.parseLong(next());\n    }\n    static void out(String s){\n        output.append(s);\n    }\n    static void out(int s){\n        output.append(s);\n    }\n    static void out(double s){\n        output.append(s);\n    }\n    static void out(long s){\n        output.append(s);\n    }\n    static void out(int a[]){\n        for(int each:a){\n            output.append(each);\n            output.append(\" \");\n        }\n    }static void out(long a[]){\n        for(long each:a){\n            output.append(each);\n            output.append(\" \");\n        }\n    }\n    static void out(boolean a[]){\n        for(boolean each:a){\n            output.append(each);\n            output.append(\" \");\n        }\n    }\n    static void out(char a[]){\n        for(char each:a){\n            output.append(each);\n            output.append(\" \");\n        }\n    }\n    static void line(){\n        output.append(line);\n    }\n    static void space(){\n        output.append(\" \");\n    }\n    static void out(Object a[]){\n        for(Object each:a){\n            output.append(each.toString());\n            output.append(\" \");\n        }\n    }\n    static void out(Object s){\n        output.append(s.toString());\n    }\n\n    static class pair implements Comparable<pair>{\n        int a,b;\n        pair(int a,int b){\n            this.a=a;\n            this.b=b;\n        }\n        pair(){}\n        public int compareTo(pair p){\n            return this.a-p.a;\n        }\n        public String toString(){\n            return \"{\"+this.a+\",\"+this.b+\"} \";\n        }\n    }\n    static int max(int ...a){\n        int max=a[0];\n        for(int i=1;i<a.length;i++)\n            max=Math.max(max, a[i]);\n        return max;\n    }\n    static int min(int ...a){\n        int min=a[0];\n        for(int i=1;i<a.length;i++)\n            min=Math.min(min, a[i]);\n        return min;\n    }\n    static long max(long ...a){\n        long max=a[0];\n        for(int i=1;i<a.length;i++)\n            max=Math.max(max, a[i]);\n        return max;\n    }\n    static long min(long ...a){\n        long min=a[0];\n        for(int i=1;i<a.length;i++)\n            min=Math.min(min, a[i]);\n        return min;\n    }\n    static int gcd(int a, int b ){\n        if(b==0)return a ;\n        else return gcd(b,a%b) ;\n    }\n    static long gcd(long a, long b ){\n        if(b==0)return a ;\n        else return gcd(b,a%b) ;\n    }\n    static int binarySearch(int a[],int ele,int l,int h){\n        while(l<=h){\n            int mid=(l+h)\/2;\n            if(a[mid]==ele) return mid;\n            if(ele<a[mid]) h=mid-1;\n            else l=mid+1;\n        }\n        return -1;\n    }\n    static int binarySearch(int a[],int ele){\n        return binarySearch(a,ele,0,a.length-1);\n    }\n    static int binarySearch(long a[],long ele,int l,int h){\n        while(l<=h){\n            int mid=(l+h)\/2;\n            if(a[mid]==ele) return mid;\n            if(ele<a[mid]) h=mid-1;\n            else l=mid+1;\n        }\n        return -1;\n    }\n    static int binarySearch(long a[],long ele){\n        return binarySearch(a,ele,0,a.length-1);\n    }\n    static int ceil(int a[],int l,int h,int ele){\n        int ans=-1;\n        while(l<=h){\n            int mid=(l+h)\/2;\n            if(a[mid]>=ele){\n                ans=mid;\n                h=mid-1;\n            }\n            else l=mid+1;\n        }\n        return ans;\n      }\n    static int floor(int a[],int l,int h,int ele){\n        int ans=-1;\n        while(l<=h){\n            int mid=(l+h)\/2;\n            if(a[mid]<=ele){\n                ans=mid;\n                l=mid+1;\n            }\n            else h=mid-1; \n        }\n        return ans;\n      }\n      static int ceil(long a[],int l,int h,long ele){\n        int ans=-1;\n        while(l<=h){\n            int mid=(l+h)\/2;\n            if(a[mid]>=ele){\n                ans=mid;\n                h=mid-1;\n            }\n            else l=mid+1;\n        }\n        return ans;\n      }\n    static int floor(long a[],int l,int h,long ele){\n        int ans=-1;\n        while(l<=h){\n            int mid=(l+h)\/2;\n            if(a[mid]<=ele){\n                ans=mid;\n                l=mid+1;\n            }\n            else h=mid-1; \n        }\n        return ans;\n      }\n    static int floor(int a[],int ele){\n        return floor(a, 0, a.length-1, ele);\n    }\n    static int ceil(int a[],int ele){\n        return ceil(a,0,a.length-1,ele);\n    }\n    static int floor(long a[],long ele){\n        return floor(a, 0, a.length-1, ele);\n    }\n    static int ceil(long a[],long ele){\n        return ceil(a,0,a.length-1,ele);\n    }\n    public static void sort(int a[]){\n        Arrays.sort(a);\n    }\n    public static void sort(long a[]){\n        Arrays.sort(a);\n    }\n    public static void reverse(int a[]){\n        int i=0,j=a.length-1;\n        while(i<j){\n            int temp=a[i];\n            a[i]=a[j];\n            a[j]=temp;\n            i++;\n            j--;\n        }\n    }\n    public static void reverse(long a[]){\n        int i=0,j=a.length-1;\n        while(i<j){\n            long temp=a[i];\n            a[i]=a[j];\n            a[j]=temp;\n            i++;\n            j--;\n        }\n    }\n    static ArrayList<Integer> seive(int n){\n        ArrayList<Integer> l= new ArrayList<Integer>();\n        boolean prime[]=new boolean[n+1];\n        prime[2]=true;\n        for(int i=3;i<=n;i+=2)\n            prime[i]=true;\n        for(int i=3;i*i<=n;i+=2){\n            if(prime[i]){\n            for(int j=i*i;j<=n;j+=2*i)\n                prime[j]=false;\n            }\n        }\n        l.add(2);\n        for(int i=3;i<=n;i+=2)\n            if(prime[i]) l.add(i);\n        return l;\n    }\n    static boolean[] seiveArray(int n){\n        boolean prime[]=new boolean[n+1];\n        prime[2]=true;\n        for(int i=3;i<=n;i+=2)\n            prime[i]=true;\n        for(int i=3;i*i<=n;i+=2){\n            if(prime[i]){\n            for(int j=i*i;j<=n;j+=2*i)\n                prime[j]=false;\n            }\n        }\n       return prime;\n    }\n    static BufferedReader input=new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer tokenizer=new StringTokenizer(\"\");\n    static StringBuilder output=new StringBuilder();\n    static String line=\"\\n\";\n    static void setJudge() throws Exception{\n    boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n    if(oj){\n      input=new BufferedReader(new FileReader(new File(\"input.txt\")));\n      PrintStream out = new PrintStream(new FileOutputStream(\"output.txt\"));\n      System.setOut(out);\n    }\n    else\n      input=new BufferedReader(new InputStreamReader(System.in));\n }\n  public static void main(String args[]) throws Exception{\n    \/\/  setJudge();\n\n     int t=nextInt();\n     \/\/  int t=1;\n      while(t>0){\n        solve();\n        t--;\n      }\n      System.out.print(output);\n  }\n  static void solve() throws Exception {\n      int n=nextInt();\n      PriorityQueue<Long> p = new PriorityQueue<Long>();\n      for(int i=0;i<n;i++)\n        p.add(nextLong());\n      long x=p.poll();\n      long min=x;\n      while(!p.isEmpty()){\n          min=Math.max(min,p.peek()-x);\n          x+=(p.poll()-x);\n  }\n  out(min);\n  line();\n}\n}","    import java.io.BufferedReader;\n    import java.io.FileInputStream;\n    import java.io.FileNotFoundException;\n    import java.io.IOException;\n    import java.io.InputStreamReader;\n    import java.util.*;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.io.PrintStream;\n    import java.io.PrintWriter;\n    import java.io.DataInputStream;\n\n        public class Solution {\n\n            \/\/TEMPLATE -------------------------------------------------------------------------------------\n\n            public static boolean Local(){\n                try{ \n                    return System.getenv(\"LOCAL_SYS\")!=null;\n                }catch(Exception e){\n                    return false;\n                }\n            }   \n\n            public static boolean LOCAL;\n\n            static class FastScanner {\n\n                    BufferedReader br;\n                    StringTokenizer st ;\n\n                    FastScanner(){\n                        br =  new BufferedReader(new InputStreamReader(System.in));\n                        st = new StringTokenizer(\"\");\n                    }\n\n                    FastScanner(String file) {\n\n                        try{\n                            br =  new BufferedReader(new InputStreamReader(new FileInputStream(file)));\n                            st = new StringTokenizer(\"\");\n                        }catch(FileNotFoundException e) {\n                            \/\/ TODO Auto-generated catch block\n                            System.out.println(\"file not found\");\n                            e.printStackTrace();\n                        }\n                        \n                    }\n                    String next() {\n                        while (!st.hasMoreTokens())\n                            try {\n                                st = new StringTokenizer(br.readLine());\n                            } catch (IOException e) {\n                            }\n                        return st.nextToken();\n                    }\n                    int nextInt() {\n                        return Integer.parseInt(next());\n                    }\n                    long nextLong() {\n                        return Long.parseLong(next());\n                    }\n                    String readLine() throws IOException{\n                        return br.readLine();\n                    }\n                }\n                                    \n            static class Pair<T,X> {\n\n                T first;\n                X second;\n                \n                Pair(T first,X second){\n                    this.first = first;\n                    this.second = second;\n                }\n\n                @Override\n                public int hashCode(){\n                    return Objects.hash(first,second);\n                }\n\n                @Override\n                public boolean equals(Object obj){\n                    return obj.hashCode() == this.hashCode();\n                }\n\n            }\n\n        \n        static PrintStream debug = null;\n        \n        \n        static long mod = (long)(Math.pow(10,9) + 7); \n       \/\/TEMPLATE -------------------------------------------------------------------------------------END\/\/\n        public static void main(String[] args) throws Exception {\n            \n            FastScanner s = new FastScanner();\n            LOCAL = Local();\n            \/\/PrintWriter pw = new PrintWriter(System.out);\n            if(LOCAL){\n                s = new FastScanner(\"src\/input.txt\");\n                PrintStream o = new PrintStream(\"src\/sampleout.txt\");\n                debug = new PrintStream(\"src\/debug.txt\");\n                System.setOut(o);\n            \/\/  pw = new PrintWriter(o);\n            } long mod = 1000000007;\n\n        \n            int tcr = s.nextInt();                  \n            \n            StringBuilder sb = new StringBuilder();\n\n            for(int tc=0;tc<tcr;tc++){\n                int n = s.nextInt();\n                long arr[] = new long[n];\n                for(int i=0;i<n;i++){\n                    arr[i] = s.nextLong();\n                }\n                if(n == 1){sb.append(arr[0]+\"\\n\");continue;}\n                sort(arr);\n                long ans = arr[0];\n                for(int i=1;i<n;i++){\n                    ans = Math.max(arr[i] - arr[i-1],ans);\n                }\n                sb.append(ans+\"\\n\");\n                \/\/ long increase_by = 0;\n                \/\/ long ans = arr[0];\n                \/\/ int index = 0;\n                \/\/ for(;index < n - 1;index++){\n                \/\/     if((arr[index] - increase_by) < 0){increase_by += (arr[index]);}\n                \/\/     else{break;}\n                \/\/ }\n                \/\/ increase_by = -(increase_by);\n                \/\/ \/\/println(index+\"--\");\n                \/\/ if(index == (n - 1)){\n                \/\/     ans = arr[n-1] + increase_by;\n                \/\/     sb.append(ans+\"\\n\");\n                \/\/     continue;\n                \/\/ }else{\n                \/\/     long prev_sum = 0;\n                \/\/     for(int i=index;i<n;i++){\n                \/\/         arr[i] += increase_by;\n                \/\/     }\n                \/\/     for(int i = index;i<n;i++){\n                \/\/         ans = Math.max(ans,arr[i] - prev_sum);\n                \/\/         prev_sum += arr[i];\n                \/\/     }\n                  \n                \/\/     sb.append(ans+\"\\n\");\n                \/\/ }\n\n            }    \n\n\n            print(sb.toString());\n        }\n\n        public static void dec(TreeMap<Integer,Integer> map,int n){\n            int cnt = map.get(n);\n            if(cnt == 1){map.remove(n);return;}\n            map.put(n,cnt - 1);\n        }\n \n        \n\n        public static List<int[]> print_prime_factors(int n){\n        \n            List<int[]> list = new ArrayList<>();\n            \n            for(int i=2;i<=(int)(Math.sqrt(n));i++){\n    \n                if(n % i == 0){\n                    \n                    int cnt = 0;\n                    \n                    while( (n % i) == 0){\n                        n = n\/i;\n                        cnt++;\n                    }\n    \n                    list.add(new int[]{i,cnt});\n                }\n            }\n    \n            if(n!=1){\n                list.add(new int[]{n,1});\n            }\n\n            return list;\n        }\n\n        public static List<int[]> prime_factors(int n,List<Integer> sieve){\n            List<int[]> list = new ArrayList<>();\n            int index = 0;\n            while(n > 1 && sieve.get(index) <= Math.sqrt(n)){\n                int curr = sieve.get(index);\n                int cnt = 0;\n                while((n % curr) == 0){\n                    n = n\/curr;\n                    cnt++;\n                }\n                if(cnt >= 1){\n                    list.add(new int[]{curr,cnt});\n                }\n                index++;\n            }\n            if(n > 1){\n                list.add(new int[]{n,1});\n            }\n            return list;\n        }\n\n        public static boolean inRange(int r1,int r2,int val){\n            return ((val >= r1) && (val <= r2));\n        }\n\n        static int len(long num){\n            return Long.toString(num).length();\n        }\n\n        static long mulmod(long a, long b,long mod)\n        {\n            long ans = 0l;\n            \n            while(b > 0){\n                long curr = (b & 1l);\n                if(curr == 1l){\n                    ans = ((ans % mod) + a) % mod;\n                }\n                \n                a = (a + a) % mod;\n\n                b = b >> 1;\n            }\n\n            return ans;\n        }\n\n\n        public static void dbg(PrintStream ps,Object... o) throws Exception{\n            if(ps == null){\n                return;\n            }\n            Debug.dbg(ps,o);\n        }\n\n        public static long modpow(long num,long pow,long mod){\n\n            long val = num;\n            long ans = 1l;\n\n            while(pow > 0l){\n                \n                long bit = pow & 1l;\n\n                if(bit == 1){\n                    ans = (ans * (val%mod))%mod;\n                }\n\n                val = (val * val) % mod;\n                pow = pow >> 1;\n            }\n\n            return ans;\n\n        }\n\n        public static char get(int n){\n            return (char)('a' + n);\n        }\n\n        public static long[] sort(long arr[]){\n            List<Long> list = new ArrayList<>();\n            for(long n : arr){list.add(n);}\n            Collections.sort(list);\n            for(int i=0;i<arr.length;i++){\n                arr[i] = list.get(i);\n            }\n            return arr;\n        }\n\n        public static int[] sort(int arr[]){\n            List<Integer> list = new ArrayList<>();\n            for(int n : arr){list.add(n);}\n            Collections.sort(list);\n            for(int i=0;i<arr.length;i++){\n                arr[i] = list.get(i);\n            }\n            return arr;\n        }\n\n        \/\/ return the (index + 1)\n        \/\/ where index is the pos of just smaller element\n        \/\/ i.e count of elemets strictly less than num\n        public static int justSmaller(long arr[],long num){\n            \/\/  System.out.println(num+\"@\");\n            int st = 0;\n            int e = arr.length - 1;\n\n            int ans = -1;\n\n            while(st <= e){\n\n                int mid = (st + e)\/2;\n\n                if(arr[mid] >= num){\n                    e = mid - 1;\n                }else{\n                    ans = mid;\n                    st = mid + 1;\n                }\n\n            }\n\n\n            return ans + 1;\n\n        }\n        public static int justSmaller(int arr[],int num){\n            \/\/  System.out.println(num+\"@\");\n            int st = 0;\n            int e = arr.length - 1;\n\n            int ans = -1;\n\n            while(st <= e){\n\n                int mid = (st + e)\/2;\n\n                if(arr[mid] >= num){\n                    e = mid - 1;\n                }else{\n                    ans = mid;\n                    st = mid + 1;\n                }\n\n            }\n\n\n            return ans + 1;\n\n        }\n        \n        \/\/return (index of just greater element)\n        \/\/count of elements smaller than or equal to num\n\n        public static int justGreater(long arr[],long num){\n            int st = 0;\n            int e = arr.length - 1;\n\n            int ans = arr.length;\n\n            while(st <= e){\n                \n                int mid = (st + e)\/2;\n\n                if(arr[mid] <= num){\n                    st = mid + 1;\n                }else{\n                    ans = mid;\n                    e = mid - 1;\n                }\n            }\n\n            return ans;\n\n        }\n\n        public static int justGreater(int arr[],int num){\n            int st = 0;\n            int e = arr.length - 1;\n\n            int ans = arr.length;\n\n            while(st <= e){\n                \n                int mid = (st + e)\/2;\n\n                if(arr[mid] <= num){\n                    st = mid + 1;\n                }else{\n                    ans = mid;\n                    e = mid - 1;\n                }\n            }\n\n            return ans;\n\n        }\n\n        \n\n        public static void println(Object obj){\n            System.out.println(obj.toString());\n        }\n\n        public static void print(Object obj){\n            System.out.print(obj.toString());\n        }\n\n        public static int gcd(int a,int b){\n            if(b == 0){return a;}\n            return gcd(b,a%b);\n        }\n\n        public static long gcd(long a,long b){\n            if(b == 0l){\n                return a;\n            }\n\n            return gcd(b,a%b);\n        }\n\n        public static int find(int parent[],int v){\n            if(parent[v] == v){\n                return v;\n            }\n            \n            return parent[v] = find(parent, parent[v]);\n        }\n\n\n\n        public static List<Integer> sieve(){\n        \n                List<Integer> prime = new ArrayList<>();\n\n                int arr[] = new int[100001];\n\n            Arrays.fill(arr,1);\n\n            arr[1] = 0;\n            arr[2] = 1;\n\n            for(int i=2;i<=100000;i++){\n                \n                if(arr[i] == 1){\n                    \n                    prime.add(i);\n\n                    for(long j = (i*1l*i);j<100001;j+=i){\n                        arr[(int)j] = 0;\n                    }\n                }\n            }\n\n            return prime;\n        }\n\n        static boolean isPower(long n,long a){\n            \n            long log = (long)(Math.log(n)\/Math.log(a));\n\n            long power = (long)Math.pow(a,log);\n\n            if(power == n){return true;}\n\n            return false;\n        }\n\n\n        private static int mergeAndCount(int[] arr, int l,int m, int r)\n        {\n            \/\/ Left subarray\n            int[] left =  Arrays.copyOfRange(arr, l, m + 1);\n\n            \/\/ Right subarray\n            int[] right = Arrays.copyOfRange(arr, m + 1, r + 1);\n\n            int i = 0, j = 0, k = l, swaps = 0;\n\n            while (i < left.length && j < right.length) {\n                if (left[i] <= right[j])\n                    arr[k++] = left[i++];\n                else {\n                    arr[k++] = right[j++];\n                    swaps += (m + 1) - (l + i);\n                }\n            }\n            while (i < left.length)\n                arr[k++] = left[i++];\n            while (j < right.length)\n                arr[k++] = right[j++];\n            return swaps;\n        }\n\n        \/\/ Merge sort function\n        private static int mergeSortAndCount(int[] arr, int l,int r)\n        {\n\n            \/\/ Keeps track of the inversion count at a\n            \/\/ particular node of the recursion tree\n            int count = 0;\n\n            if (l < r) {\n                int m = (l + r) \/ 2;\n\n                \/\/ Total inversion count = left subarray count\n                \/\/ + right subarray count + merge count\n\n                \/\/ Left subarray count\n                count += mergeSortAndCount(arr, l, m);\n\n                \/\/ Right subarray count\n                count += mergeSortAndCount(arr, m + 1, r);\n\n                \/\/ Merge count\n                count += mergeAndCount(arr, l, m, r);\n            }\n\n            return count;\n        }\n\n        static class Debug{\n            \/\/change to System.getProperty(\"ONLINE_JUDGE\")==null; for CodeForces\n            public static final boolean LOCAL = System.getProperty(\"ONLINE_JUDGE\")==null;\n\n            \n\n            private static <T> String ts(T t) {\n                if(t==null) {\n                    return \"null\";\n                }\n                try {\n                    return ts((Iterable) t);\n                }catch(ClassCastException e) {\n                    if(t instanceof int[]) {\n                        String s = Arrays.toString((int[]) t);\n                        return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                    }else if(t instanceof long[]) {\n                        String s = Arrays.toString((long[]) t);\n                        return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                    }else if(t instanceof char[]) {\n                        String s = Arrays.toString((char[]) t);\n                        return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                    }else if(t instanceof double[]) {\n                        String s = Arrays.toString((double[]) t);\n                        return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                    }else if(t instanceof boolean[]) {\n                        String s = Arrays.toString((boolean[]) t);\n                        return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                    }\n                    try {\n                        return ts((Object[]) t);\n                    }catch(ClassCastException e1) {\n                        return t.toString();\n                    }\n                }\n            }\n            private static <T> String ts(T[] arr) {\n                StringBuilder ret = new StringBuilder();\n                ret.append(\"{\");\n                boolean first = true;\n                for(T t: arr) {\n                    if(!first) {\n                        ret.append(\", \");\n                    }\n                    first = false;\n                    ret.append(ts(t));\n                }\n                ret.append(\"}\");\n                return ret.toString();\n            }\n            private static <T> String ts(Iterable<T> iter) {\n                StringBuilder ret = new StringBuilder();\n                ret.append(\"{\");\n                boolean first = true;\n                for(T t: iter) {\n                    if(!first) {\n                        ret.append(\", \");\n                    }\n                    first = false;\n                    ret.append(ts(t));\n                }\n                ret.append(\"}\\n\");\n                return ret.toString();\n            }\n            public static void dbg(PrintStream ps,Object... o) throws Exception {\n                if(LOCAL) {\n                    System.setErr(ps);\n                    System.err.print(\"Line #\"+Thread.currentThread().getStackTrace()[2].getLineNumber()+\": [\\n\");\n                    for(int i = 0; i<o.length; i++) {\n                        if(i!=0) {\n                            System.err.print(\", \");\n                        }\n                        System.err.print(ts(o[i]));\n                    }\n                    System.err.println(\"]\");\n                }\n            }\n        }\n\n    }","# cook your dish here\nimport sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_=lambda: sys.stdin.readline().strip(\"\\r\\n\")\nfrom math import log\nfrom math import gcd\nfrom math import atan2,acos\nfrom random import randint\nsa=lambda :input_()\nsb=lambda:int(input_())\nsc=lambda:input_().split()\nsd=lambda:list(map(int,input_().split()))\nsflo=lambda:list(map(float,input_().split()))\nse=lambda:float(input_())\nsf=lambda:list(input_())\nflsh=lambda: sys.stdout.flush()\n#sys.setrecursionlimit(10**7)\nmod=10**9+7\nmod1=998244353\ngp=[]\ncost=[]\ndp=[]\nmx=[]\nans1=[]\nans2=[]\nspecial=[]\nspecnode=[]\na=0\nkthpar=[]\ndef dfs2(root,par):\n    if par!=-1:\n        dp[root]=dp[par]+1\n    for i in range(1,20):\n        if kthpar[root][i-1]!=-1:\n            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]\n    for child in gp[root]:\n        if child==par:continue\n        kthpar[child][0]=root\n        dfs(child,root)\n        \nans=0\na=[]\nn,k=0,0\nb=[]\nvis=[]\ntot=0\ntime=[]\ntime1=[]\nadj=[]\nmx=-1\neps=0.0000001\nx=0\npref=[]\nlvl=[]\n#Fenwick Tree point update range sum\ndef update_it(bit,i,val):\n    n=len(bit)\n    while(i<n):\n        bit[i]+=val\n        i+=i&(-i)\ndef get_ans(bit,i):\n    n=len(bit)\n    tot=0\n    while(i>0):\n        tot+=bit[i]\n        i-=i&(-i)\n    return tot\nprime=[2,3,5,7,11,13,17,19,23,29]\ndef hnbhai(tc):\n    n=sb()\n    a=sd()\n    a.sort()\n    temp=0\n    mx=float(\"-inf\")\n    for i in range(n):\n        mx=max(mx,a[i]-temp)\n        temp+=a[i]-temp\n    print(mx)\nfor _ in range(sb()):\n    hnbhai(_+1)\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int tc, n;\n  array<int, 200010> a;\n  cin >> tc;\n  while (tc--) {\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    priority_queue<long long int, vector<long long int>, greater<long long int>>\n        pq;\n    for (int i = 0; i < n; i++) pq.push(a[i]);\n    long long int total = 0, ans = numeric_limits<long long int>::min();\n    while (!pq.empty()) {\n      long long int mn = pq.top();\n      pq.pop();\n      mn -= total;\n      ans = max(ans, mn);\n      total += mn;\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, psa = 0;\n    cin >> n;\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n      cin >> arr[i];\n    }\n    sort(arr, arr + n);\n    for (int i = 0; i < n; i++) {\n      arr[i] = arr[i] - psa;\n      psa = psa + arr[i];\n    }\n    sort(arr, arr + n);\n    cout << arr[n - 1] << endl;\n  }\n}\n","\/\/package Codeforces;\nimport java.util.*;\n\nimport java.io.*;\npublic  class template{\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\tString next () {\n\t\t\twhile(!st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t}catch(IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tint[] readArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\t\n\tstatic class helper{\n\t\t\n\t\t\/\/reverse 1-d Array\n\t\tpublic static void reverse(int arr[]) {\n\t\t\tint i = 0;\n\t\t\tint j = arr.length - 1;\n\t\t\twhile(i<j) {\n\t\t\t\tint temp = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/gcd of two numbers\n\t\tpublic static int gcd(int a,int b) {\n\t\t\tif(b == 0) {\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\treturn gcd(b,a%b);\n\t\t}\n\t\t\n\t\t\/\/calculate ncr\n\t\tpublic static int ncr(int n,int r) {\n\t\t\tint num = n;\n\t\t\tint deno = r;\n\t\t\tint a1 = 1;\n\t\t\tint a2 = 1;\n\t\t\tfor(int i=0;i<r;i++) {\n\t\t\t\ta1 *= num;\n\t\t\t\ta2 *= deno;\n\t\t\t\tnum--;\n\t\t\t\tdeno--;\n\t\t\t}\n\t\t\tint ans = a1\/a2;\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t\/\/isPalindrome\n\t\tpublic static boolean isPalindrome(String substring){\n\t\t    char ch[] = substring.toCharArray();\n\t\t    int i = 0;\n\t\t    int j = ch.length-1;\n\t\t    while(i<j){\n\t\t        char temp = ch[i];\n\t\t        ch[i] = ch[j];\n\t\t        ch[j] = temp;\n\t\t        i++;\n\t\t        j--;\n\t\t    }\n\t\t    String rev = String.valueOf(ch);\n\t\t    if(rev.equals(substring)){\n\t\t        return true;\n\t\t    }\n\t\t    else{\n\t\t        return false;\n\t\t    }\n\t\t}\n\t\t\n\t\t\/\/isPowerOfTwo\n\t\tpublic static boolean isPowerOfTwo(long x)\n\t    {\n\t        \/* First x in the below expression is\n\t        for the case when x is 0 *\/\n\t        return x != 0 && ((x & (x - 1)) == 0);\n\t    }\n\t\t\n\t\t\/\/nextPowerOfTwo\n\t\tpublic static long nextPowerOfTwo(long n)\n\t    {\n\t        n--;\n\t        n |= n >> 1;\n\t        n |= n >> 2;\n\t        n |= n >> 4;\n\t        n |= n >> 8;\n\t        n |= n >> 16;\n\t        n++;\n\t         \n\t        return n;\n\t    }\n\t}\n\t\n\t public static void ruffleSort(int[] arr) {\n\t        int n = arr.length;\n\t        Random rnd = new Random();\n\t        for (int i = 0; i < n; ++i) {\n\t            int tmp = arr[i];\n\t            int randomPos = i + rnd.nextInt(n - i);\n\t            arr[i] = arr[randomPos];\n\t            arr[randomPos] = tmp;\n\t        }\n\t        Arrays.sort(arr);\n\t    }\n\t\n\tpublic static void main(String[] args) {\n\t\t FastScanner sc = new FastScanner();\n\t\t  PrintWriter out = new PrintWriter(System.out);\n\t\t  helper help = new helper();\n\t\t  long test = sc.nextLong();\n\t\t  while(test-->0) {\n\t\t\t  int n = sc.nextInt();\n\t\t\t  int arr[] = sc.readArray(n);\n\t\t\t  if(n == 1) {\n\t\t\t\t  out.println(arr[0]);\n\t\t\t\t  continue;\n\t\t\t  }\n\t\t\t  ruffleSort(arr);\n\t\t\t  int pre[] = new int[n];\n\t\t\t  pre[0] = arr[0];\n\t\t\t  for(int i=1;i<arr.length;i++) {\n\t\t\t\t  pre[i] = pre[i-1] + arr[i];\n\t\t\t  }\n\t\t\t  int max = pre[0];\n\t\t\t  if(arr[1] - arr[0] > max) {\n\t\t\t\t  max = arr[1]-arr[0];\n\t\t\t  }\n\t\t\t  for(int i=1;i<pre.length-1;i++) {\n\t\t\t\t  int diff = pre[i]-pre[i-1];\n\t\t\t\t  int value = arr[i+1] - diff;\n\t\t\t\t  if(value > max) {\n\t\t\t\t\t  max = value;\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  out.println(max);\n\t\t  }\n\t\t  out.flush();\n\t}\n\t\n}\nclass lavesh {\n\tint value;\n\tString color;\n\tlavesh(int value,String color){\n\t\tthis.value = value;\n\t\tthis.color = color;\n\t}\n\tpublic int getValue() {\n\t\treturn value;\n\t}\n\tpublic void setValue(int value) {\n\t\tthis.value = value;\n\t}\n\tpublic String getColor() {\n\t\treturn color;\n\t}\n\tpublic void setColor(String color) {\n\t\tthis.color = color;\n\t}\n}\nclass pair {\n\tint value;\n\tint index;\n\tpair(int value,int index){\n\t\tthis.value = value;\n\t\tthis.index = index;\n\t}\n\tpublic int getValue() {\n\t\treturn value;\n\t}\n\tpublic void setValue(int value) {\n\t\tthis.value = value;\n\t}\n\tpublic int getIndex() {\n\t\treturn index;\n\t}\n\tpublic void setIndex(int index) {\n\t\tthis.index = index;\n\t}\n}\n","\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class cfContest1607 {\n    \n    public static void main(String args[]) {\n        Scanner scan = new Scanner(System.in);\n        int t = scan.nextInt();\n        while (t-- > 0) {\n            int n = scan.nextInt();\n            ArrayList<Integer> a = new ArrayList<Integer>();\n            for (int i = 0; i < n; i++) {\n                a.add(scan.nextInt());\n            }\n            Collections.sort(a);\n            int res = a.get(0);\n            for (int i = 0; i < n - 1; i++) {\n                res = Math.max(res,a.get(i + 1) - a.get(i));\n            }\n            System.out.println(res);\n        }\n        \n    }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nusing namespace chrono;\nvoid _print(long long t) { cerr << t; }\nvoid _print(int t) { cerr << t; }\nvoid _print(string t) { cerr << t; }\nvoid _print(char t) { cerr << t; }\nvoid _print(long double t) { cerr << t; }\nvoid _print(double t) { cerr << t; }\nvoid _print(unsigned long long t) { cerr << t; }\ntemplate <class T, class V>\nvoid _print(pair<T, V> p);\ntemplate <class T>\nvoid _print(vector<T> v);\ntemplate <class T>\nvoid _print(set<T> v);\ntemplate <class T, class V>\nvoid _print(map<T, V> v);\ntemplate <class T>\nvoid _print(multiset<T> v);\ntemplate <class T, class V>\nvoid _print(pair<T, V> p) {\n  cerr << \"{\";\n  _print(p.first);\n  cerr << \",\";\n  _print(p.second);\n  cerr << \"}\";\n}\ntemplate <class T>\nvoid _print(vector<T> v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T>\nvoid _print(set<T> v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T>\nvoid _print(multiset<T> v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T, class V>\nvoid _print(map<T, V> v) {\n  cerr << \"[ \";\n  for (auto i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\nlong long gcd(long long a, long long b) {\n  if (b > a) {\n    return gcd(b, a);\n  }\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\nlong long expo(long long a, long long b, long long mod) {\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = (res * a) % mod;\n    a = (a * a) % mod;\n    b = b >> 1;\n  }\n  return res;\n}\nvoid extendgcd(long long a, long long b, long long *v) {\n  if (b == 0) {\n    v[0] = 1;\n    v[1] = 0;\n    v[2] = a;\n    return;\n  }\n  extendgcd(b, a % b, v);\n  long long x = v[1];\n  v[1] = v[0] - v[1] * (a \/ b);\n  v[0] = x;\n  return;\n}\nlong long mminv(long long a, long long b) {\n  long long arr[3];\n  extendgcd(a, b, arr);\n  return arr[0];\n}\nlong long mminvprime(long long a, long long b) { return expo(a, b - 2, b); }\nbool revsort(long long a, long long b) { return a > b; }\nvoid swap(int &x, int &y) {\n  int temp = x;\n  x = y;\n  y = temp;\n}\nlong long combination(long long n, long long r, long long m, long long *fact,\n                      long long *ifact) {\n  long long val1 = fact[n];\n  long long val2 = ifact[n - r];\n  long long val3 = ifact[r];\n  return (((val1 * val2) % m) * val3) % m;\n}\nvoid google(int t) { cout << \"Case #\" << t << \": \"; }\nvector<long long> sieve(int n) {\n  int *arr = new int[n + 1]();\n  vector<long long> vect;\n  for (int i = 2; i <= n; i++)\n    if (arr[i] == 0) {\n      vect.push_back(i);\n      for (int j = 2 * i; j <= n; j += i) arr[j] = 1;\n    }\n  return vect;\n}\nlong long mod_add(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a + b) % m) + m) % m;\n}\nlong long mod_mul(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a * b) % m) + m) % m;\n}\nlong long mod_sub(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a - b) % m) + m) % m;\n}\nlong long mod_div(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (mod_mul(a, mminvprime(b, m), m) + m) % m;\n}\nlong long phin(long long n) {\n  long long number = n;\n  if (n % 2 == 0) {\n    number \/= 2;\n    while (n % 2 == 0) n \/= 2;\n  }\n  for (long long i = 3; i <= sqrt(n); i += 2) {\n    if (n % i == 0) {\n      while (n % i == 0) n \/= i;\n      number = (number \/ i * (i - 1));\n    }\n  }\n  if (n > 1) number = (number \/ n * (n - 1));\n  return number;\n}\nvoid solve() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<long long> arr(n);\n    for (int i = 0; i < n; i++) cin >> arr[i];\n    sort((arr).begin(), (arr).end());\n    long long ans = -1e18;\n    long long x = 0;\n    for (int i = 0; i < n; i++) {\n      arr[i] = arr[i] - x;\n      ans = max(ans, arr[i]);\n      x += arr[i];\n    }\n    cout << ans << \"\\n\";\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  auto start1 = high_resolution_clock::now();\n  solve();\n  auto stop1 = high_resolution_clock::now();\n  auto duration = duration_cast<microseconds>(stop1 - start1);\n}\n","import sys\n#sys.setrecursionlimit(20000)\n#from collections import deque #Counter\n#from itertools import accumulate\n#from functools import product\n#import math\n\n\ndef rall():\n    return sys.stdin.readlines()\ndef rl():\n    return sys.stdin.readline().strip()\ndef rl_types(types):\n    str_list = [x for x in sys.stdin.readline().strip().split(' ')]\n    return [types[i](str_list[i]) for i in range(len(str_list))]\n\ndef pr( something='' ):\n    sys.stdout.write( str(something) + '\\n')\ndef pra( array ):\n    sys.stdout.write( ' '.join([str(x) for x in array]) + '\\n')\n\n\ndef solve(array):\n    return array\n\n\nif __name__ == '__main__':\n\n    NT = int( rl() )\n    #a,b = map(int,rl().split(' '))\n\n    for ti in range(NT):\n        _ = int(rl())\n        array = list(map(int, rl().split(' ')))\n        if True:#len(array)==1:\n            #mx = array[0]\n        #else:\n            s = sorted(array)\n            #print(s)\n            l = s[0]\n            mx = s[0]\n            for v in s[1:]:\n                d = v-l\n                mx = max(mx,d)\n                l = v\n\n        #a,b = map(int, rl().split(' '))\n        # vals = rl_types( [str,float,float] )\n        pr(mx)\n\n","import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\npublic class Practice {\n\tstatic Scanner scn = new Scanner(System.in);\n\tstatic StringBuilder sb = new StringBuilder();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tpublic static void main(String[] HastaLaVistaLa) {\n\t\tint t = scn.nextInt();\n\t\t\/\/ int t = 1;\n\t\tfor(int tests = 0; tests < t; tests++) solve();\n\t\tout.println(sb);\n\t\tout.close();\n\t}\n\tpublic static void solve() {\n\t\tint n = scn.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++) a[i] = scn.nextInt();\n\t\tsort(a);\n\t\t\/\/ System.out.println(Arrays.toString(a));\n\t\tlong sum = a[0], res = a[0];\n\t\t\/\/ -5 -2 6 11 100\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tlong get = a[i] - sum;\n\t\t\tres = max(res, (get));\n\t\t\tsum += get;\n\t\t}\n\t\tsb.append(res);\n\t\tsb.append(\"\\n\");\n\t}\n\tpublic static void sort(int[] a) {\n\t\tList<Integer> l = new ArrayList<>();\n\t\tfor(int i : a) l.add(i);\n\t\tCollections.sort(l);\n\t\tint s = 0;\n\t\tfor(int i : l) a[s++] = i;\n\t}\n}","for _ in range(int(input())):\n    N = int(input())\n    arr = list(map(int, input().split()))\n\n    if len(arr) == 1:\n        print(arr[0])\n        continue\n\n    arr.sort()\n\n    for i in range(len(arr)-1, 0, -1):\n        arr[i] -= arr[i-1]\n\n    print(max(arr))\n\n\n\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nint minimum() {\n  long long n, min, integer;\n  cin >> n;\n  vector<long long> arr;\n  for (int i = 0; i < n; i++) {\n    cin >> integer;\n    arr.push_back(integer);\n  }\n  if (n == 1)\n    return arr[0];\n  else {\n    sort(arr.begin(), arr.end());\n    long long min = arr[0];\n    for (int i = 1; i < n; i++) {\n      min = max(min, arr[i] - arr[i - 1]);\n    }\n    return min;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    cout << minimum() << endl;\n  }\n  return 0;\n}\n","import sys,math\n#sys.stdin=open('input.txt','r')\n#sys.stdout=open('output.txt','w')\n\n\n\n\ndef solve():\n    n=int(input())\n    l=list(map(int,input().split()))\n    if(len(l)==1):\n        print(l[0])\n        return\n    l.sort()\n    ans=[]\n    ans.append(l[0])\n    for i in range(len(l)):\n        if(i==0):\n            dec=l[0]\n            continue\n        val=l[i]-dec\n        ans.append(val)\n        dec+=val\n    #print(ans)\n    print(max(ans))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nt=int(input())\nwhile(t!=0):\n    solve()\n    t-=1\n","#include <bits\/stdc++.h>\nusing namespace std;\ninline long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\nlong long qpow(long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans *= a;\n    b >>= 1;\n    a *= a;\n  }\n  return ans;\n}\nlong long qpow(long long a, long long b, long long mod) {\n  long long ans = 1;\n  a %= mod;\n  while (b) {\n    if (b & 1) (ans *= a) %= mod;\n    b >>= 1;\n    (a *= a) %= mod;\n  }\n  return ans % mod;\n}\ninline long long read() {\n  long long s = 0, w = 1;\n  char ch = getchar();\n  while (ch < 48 || ch > 57) {\n    if (ch == '-') w = -1;\n    ch = getchar();\n  }\n  while (ch >= 48 && ch <= 57)\n    s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n  return s * w;\n}\nconst int mod = 1e9 + 7;\nconst int N = 2e5 + 7;\nint n, m;\nint nums[N];\nvoid solve() {\n  cin >> n;\n  int ans = 1e9 + 7;\n  for (int i = 1; i <= n; i++) {\n    cin >> nums[i];\n    ans = min(ans, nums[i]);\n  }\n  if (n == 1) {\n    cout << nums[1] << endl;\n    return;\n  }\n  sort(nums + 1, nums + n + 1);\n  for (int i = 2; i <= n; i++) {\n    ans = max(ans, nums[i] - nums[i - 1]);\n  }\n  cout << ans << endl;\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.PriorityQueue;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.util.AbstractQueue;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Manav\n *\/\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int t = in.nextInt();\n            for (int it = 0; it < t; it++) {\n                int n = in.nextInt();\n                long[] a = in.nextLongArray(n);\n                PriorityQueue<Long> queue = new PriorityQueue<>();\n                for (int i = 0; i < n; i++) {\n                    queue.add(a[i]);\n                }\n                long minMax = Long.MIN_VALUE;\n                long overhead = 0;\n                while (queue.size() > 0) {\n\n                    long current = queue.remove();\n\/\/                out.println(minMax,overhead,current);\n                    minMax = Math.max(minMax, current - overhead);\n                    overhead += (current - overhead);\n\/\/                out.println(minMax,overhead,current);\n                }\n                out.println(minMax);\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] array = new long[n];\n            for (int i = 0; i < n; ++i) array[i] = nextLong();\n            return array;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int maxn = 200010;\nlong long a[maxn], sum[maxn];\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  ;\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n      cin >> a[i];\n    }\n    sort(a + 1, a + 1 + n);\n    long long maxx = a[1];\n    long long sum = a[1];\n    for (int i = 2; i <= n; i++) {\n      a[i] -= sum;\n      maxx = max(maxx, a[i]);\n      sum += a[i];\n    }\n    cout << maxx << '\\n';\n  }\n  return 0;\n}\n","import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class minextraction {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(\n                    new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    public static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n\n\n        long k = gcd(b, a % b);\n        return k;\n    }\n\n    public static void main(String[] args) {\n        FastReader scn = new FastReader();\n        try{\n            int t = scn.nextInt();\n            while(t-- > 0){\n                int n = scn.nextInt();\n                ArrayList<Long> arr = new ArrayList<>();\n\n                for (int i = 0; i < n; i++) {\n                    long x = scn.nextLong();\n                    arr.add(x);\n                }\n                if(n == 1){\n                    System.out.println(arr.get(0));\n                }\n                else{\n                    Collections.sort(arr);\n                    long[] diff = new long[n];\n                    long max = Integer.MIN_VALUE;\n                    for (int i = 0; i < n-1; i++) {\n                        diff[i] = arr.get(i+1) - arr.get(i);\n                        if(diff[i] > max){\n                            max = diff[i];\n                        }\n\n                    }\n\n                    if(n == 2){\n                        if(arr.get(0) > max){\n                            System.out.println(arr.get(0));\n                        }\n                        else{\n                            System.out.println(max);\n                        }\n                    }\n                    else {\n                        if(arr.get(0) > max){\n                            System.out.println(arr.get(0));\n                        }\n                        else {\n                            System.out.println(max);\n                        }\n                    }\n                }\n            }\n\n        }\n        catch (Exception e){\n            return;\n        }\n\n    }\n}\n","for _ in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    l.sort()\n    m=min(l)\n    if n==1:\n        print(l[0])\n    else:\n        for i in range(n-1):\n            m=max(m,l[i+1]-l[i])\n\n        print(m)\n\n    \n\n    ","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long ar[n];\n    for (int i = 0; i < n; i++) cin >> ar[i];\n    sort(ar, ar + n);\n    long long ans = ar[0];\n    for (int i = 1; i < n; i++) {\n      ans = max(ans, ar[i] - ar[i - 1]);\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  size_t t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> a(n);\n    for (size_t i = 0; i < n; ++i) {\n      cin >> a[i];\n    }\n    if (a.size() == 1) {\n      cout << a[0] << endl;\n      continue;\n    }\n    sort(a.begin(), a.end());\n    long long s = 0;\n    long long res = 0;\n    size_t i;\n    for (i = 0; i < n - 1; ++i) {\n      if (a[i] + s <= 0) {\n        s -= a[i] + s;\n        continue;\n      }\n      break;\n    }\n    vector<long long> diffs(n - i + 1);\n    diffs[0] = a[i] + s;\n    for (size_t j = i; j < n - 1; ++j) {\n      diffs[j - i + 1] = a[j + 1] - a[j];\n    }\n    cout << *max_element(diffs.begin(), diffs.end()) << endl;\n  }\n  return 0;\n}\n","\"\"\"\n\/\/ Author : snape_here - Susanta Mukherjee\n     \n \"\"\"\n\nfrom __future__ import division, print_function\n \nimport os,sys\nfrom io import BytesIO, IOBase\n \nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n \ndef ii(): return int(input())\ndef fi(): return float(input())\ndef si(): return input()\ndef msi(): return map(str,input().split())\ndef mi(): return map(int,input().split())\ndef li(): return list(mi())\ndef lsi(): return list(msi())\n \ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n \ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return (x*y)\/\/(gcd(x,y))\n\nmod=1000000007\n\ndef modInverse(b,m): \n    g = gcd(b, m)  \n    if (g != 1):         \n        return -1\n    else:          \n        return pow(b, m - 2, m) \n\ndef ceil2(x,y):\n    if x%y==0:\n        return x\/\/y\n    else:\n        return x\/\/y+1\n\ndef modu(a,b,m): \n\n    a = a % m \n    inv = modInverse(b,m) \n    if(inv == -1): \n        return -999999999\n    else: \n        return (inv*a)%m\n\nfrom math import log,factorial,cos,tan,sin,radians,floor,sqrt,ceil,log2\n\nimport bisect\nimport random\nimport string \n\nfrom decimal import *\n\ngetcontext().prec = 50\n\nabc=\"abcdefghijklmnopqrstuvwxyz\"\n\npi=3.141592653589793238\n\ndef gcd1(a):\n    if len(a) == 1:\n        return a[0]\n    ans = a[0]\n    for i in range(1,len(a)):\n        ans = gcd(ans,a[i])\n    return ans\n\ndef mykey(x):\n    return len(x)\n\ndef main():\n\n    for _ in range(ii()):\n        n=ii()\n        a=li()\n        a.sort()\n        ans = -1e10\n        s = 0\n        for i in range(n):\n            ans = max(ans,a[i]-s)\n            s = a[i]\n        print(ans)\n\n        # print(\"Case #\",end=\"\")\n        # print(_+1,end=\"\")\n        # print(\": \",end=\"\")\n        # print(ans)\n\n\n# region fastio\n\n# template taken from https:\/\/github.com\/cheran-senthil\/PyRival\/blob\/master\/templates\/template.py\n\nBUFSIZE = 8192\n \n\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n \ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n\n \nif __name__ == \"__main__\":\n    #read()\n    main()","import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class C {\n    public static void main(String[] args) {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int t = in.nextInt();\n        for (int tt = 0; tt < t; tt++) {\n            int n = in.nextInt();\n            Long[] a = new Long[n];\n            for (int i = 0; i < n; i++) a[i] = in.nextLong();\n            Arrays.sort(a);\n            long ans = a[0];\n            for(int i = 0; i < n - 1; i++) {\n                ans = Math.max(ans, a[i + 1] - a[i]);\n            }\n            pw.println(ans);\n        }\n        pw.close();\n    }\n\n    static void debug(Object... obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n\n        public FastReader(InputStream is) {\n            this.is = is;\n        }\n\n        public int readByte() {\n            if (lenbuf == -1) throw new InputMismatchException();\n            if (ptrbuf >= lenbuf) {\n                ptrbuf = 0;\n                try {\n                    lenbuf = is.read(inbuf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        public int skip() {\n            int b;\n            while ((b = readByte()) != -1 && isSpaceChar(b)) ;\n            return b;\n        }\n\n        public String next() {\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while (!(isSpaceChar(b))) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n\n        public String nextLine() {\n            int c = skip();\n            StringBuilder sb = new StringBuilder();\n            while (!isEndOfLine(c)) {\n                sb.appendCodePoint(c);\n                c = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            int num = 0, b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = (num << 3) + (num << 1) + (b - '0');\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = (num << 3) + (num << 1) + (b - '0');\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public char[] next(int n) {\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while (p < n && !(isSpaceChar(b))) {\n                buf[p++] = (char) b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        public char readChar() {\n            return (char) skip();\n        }\n    }\n}\n","import sys\nfrom heapq import heappush, heappop\ninput = sys.stdin.readline\n\nt = int(input())\n\n_ans = []\n\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    a.sort()\n\n    heap = []\n    ans = -10e9 - 1\n    if a[0] < 0:\n        ans = max(ans, a[0])\n        for i in range(1, n):\n            heappush(heap, a[i] - a[0])\n    else:\n        for i in range(n):\n            heappush(heap, a[i])\n    \n    p = 0\n    while(len(heap) > 0):\n        v = heappop(heap)\n        ans = max(ans, v - p)\n        p += v - p\n\n    _ans.append(ans)\n\nfor el in _ans:\n    print(el)","def get_ans(n, a):\n\tmax_min = -10000000000\n\talready_deleted_sum = 0\n\ta.sort()\n\tfor _i in range(len(a)):\n\t\ti = a[_i]\n\t\ti -= already_deleted_sum\n\t\tmax_min = max(max_min, i)\n\t\talready_deleted_sum += i\n\treturn max_min\n\n\nanss = []\nt = int(input())\nfor _ in range(t):\n\t_n = int(input())\n\t_a = list(map(int, input().split()))\n\tanss.append(get_ans(_n, _a))\n\nfor ans in anss:\n\tprint(ans)\n","def solve():\n    n = int(input())\n    l = input()\n    l = [int(i) for i in l.split()]\n    try:\n      if (n == 1):\n        print(l[0])\n        return\n      elif(n == 2):\n        a = min(l)\n        l.remove(a)\n        a = max(a, l[0] - a)\n        print(a)\n        return\n      else:\n        l.sort()\n        mx = l[0]\n        for i in range(n - 1):\n          mx = max(mx, l[i + 1] - l[i])\n        print(mx)\n\n    except EOFError as e:\n      print(\"Error\")\n\n\nfor case in range(int(input())):\n  solve()\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long T;\nlong long b[200009];\nvoid solve() {\n  long long n;\n  cin >> n;\n  for (long long i = 1; i <= n; i++) cin >> b[i];\n  sort(b + 1, b + 1 + n);\n  long long cnt = n;\n  long long tot = 0;\n  long long now = 1;\n  long long ans = -1e15;\n  while (cnt != 1) {\n    b[now] += tot;\n    ans = max(ans, b[now]);\n    tot -= b[now];\n    now++;\n    cnt--;\n  }\n  printf(\"%lld\\n\", max(ans, b[now] + tot));\n}\nsigned main() {\n  cin >> T;\n  while (T--) solve();\n}\n","import java.io.*;\nimport java.util.*;\n\npublic class C {\n\tpublic static void main(String args[]){\n\t\tFScanner in = new FScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint t = in.nextInt();\n\t\twhile(t-->0) { \n\t\t\tint n=in.nextInt();\n\t\t\tint arr[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\tarr[i]=in.nextInt();\n\t\t\tsort(arr);\n\t\t\tlong max=arr[0];\n\t\t\tlong prev=0,min=0;\n\t\t\tfor(int i=0;i<arr.length-1;i++)\n\t\t\t{\n\t\t\t\tmin=arr[i];\n\t\t\t\tarr[i+1]+=prev;\n\t\t\t\tarr[i+1]-=(min);\n\t\t\t\tmax=Math.max(max,arr[i+1]);\n\t\t\t\tif(min<0)\n\t\t\t\t\tprev+=(min*-1);\n\t\t\t\telse\n\t\t\t\t\tprev-=min;\n\t\t\t}\n\n\t\t\tout.println(max);\n\t\t}\n\t\tout.close();\n\t}\n\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\n\tstatic boolean checkprime(int n1)\n\t{\n\t\tif(n1%2==0||n1%3==0)\n\t\t\treturn false;\n\t\telse \n\t\t{\n\t\t\tfor(int i=5;i*i<=n1;i+=6)\n\t\t\t{\n\t\t\t\tif(n1%i==0||n1%(i+2)==0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tstatic class FScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer sb = new StringTokenizer(\"\");\n\n\t\tString next(){\n\t\t\twhile(!sb.hasMoreTokens()){\n\t\t\t\ttry{\n\t\t\t\t\tsb = new StringTokenizer(br.readLine());\n\t\t\t\t} catch(IOException e){ }\n\t\t\t}\n\t\t\treturn sb.nextToken();\n\t\t}\n\t\tString nextLine(){\n\t\t\ttry{ return br.readLine(); } \n\t\t\tcatch(IOException e) { } return \"\";\n\t\t}\n\n\t\tint nextInt(){\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tint[] readArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i=0;i<n;i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tfloat nextFloat(){\n\t\treturn Float.parseFloat(next());\n\t\t}\n\t\t\n\t\tdouble nextDouble(){\n\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nclass Offset {\n public:\n  multiset<long long> st;\n  long long delta;\n  long long fetch() { return (*st.begin()) + delta; }\n  void decrease(long long x) { delta -= x; }\n  void add(long long x) { st.insert(x - delta); }\n  void rem() { st.erase(st.begin()); }\n};\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long tt;\n  cin >> tt;\n  while (tt--) {\n    long long n;\n    cin >> n;\n    vector<long long> a(n);\n    for (long long i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    multiset<long long> ms(a.begin(), a.end());\n    Offset obj;\n    for (long long i = 0; i < n; i++) {\n      obj.add(a[i]);\n    }\n    sort(a.begin(), a.end());\n    long long res = a[0];\n    for (long long i = 0; i < n; i++) {\n      long long temp = obj.fetch();\n      res = max(res, temp);\n      obj.decrease(temp);\n      obj.rem();\n    }\n    cout << res << '\\n';\n  }\n  return 0;\n}\n","import java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class minimumextraction {\n\tstatic class Reader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[64]; \/\/ line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1) {\n\t\t\t\tif (c == '\\n') {\n\t\t\t\t\tif (cnt != 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ') {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') \/ (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tReader sc = new Reader();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint t = sc.nextInt();\n\t\twhile(t-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tArrayList<Integer>a = new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta.add(sc.nextInt());\n\t\t\t}\n\t\t\tint ans = Collections.min(a);\n\t\t\tCollections.sort(a);\n\t\t\tfor(int i=1;i<n;i++) {\n\t\t\t\tans = Math.max(ans, a.get(i)-a.get(i-1));\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.close();\n\t}\n}\n","import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        int t=Integer.parseInt(bu.readLine());\n        while(t-->0)\n        {\n            int n=Integer.parseInt(bu.readLine());\n            String s[]=bu.readLine().split(\" \");\n            PriorityQueue<Integer> pq=new PriorityQueue<>();\n            int i,a;\n            long max=Long.MIN_VALUE;\n            for(i=0;i<n;i++)\n            {\n                a=Integer.parseInt(s[i]);\n                pq.add(a);\n            }\n\n            long sum=0;\n            while(!pq.isEmpty())\n            {\n                a=pq.poll();\n                long cur=a-sum;\n                max=Math.max(max,cur);\n                sum+=cur;\n            }\n            sb.append(max+\"\\n\");\n        }\n        System.out.print(sb);\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint a[200002];\nint n;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n      cin >> a[i];\n    }\n    sort(a + 1, a + n + 1);\n    int vmax = -1e9;\n    for (int i = 1; i <= n; i++) {\n      vmax = max(vmax, a[i] - a[i - 1]);\n    }\n    cout << vmax << '\\n';\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long a[n];\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a, a + n);\n    long long MAX = a[0];\n    for (int i = 1; i < n; i++) {\n      MAX = max(a[i] - a[i - 1], MAX);\n    }\n    cout << MAX << endl;\n  }\n}\n","t = int(input())\n\nwhile t>0:\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    min = a[0]\n    minus = a[0]\n    for index in range(1, n):\n        # print(a)\n        a[index]-=minus\n        if min<a[index]:\n            min = a[index]\n        minus+=a[index]\n    print(min)\n    t-=1\n\n# from heapq import heapify, heappush, heappop\n\n# t = int(input())\n\n# while t>0:\n#     n = int(input())\n#     a = list(map(int, input().split()))\n#     heapify(a)\n#     min = a[0]\n#     for i in range(n):\n#         e = heappop(a)\n#         if e>min:\n#             min = e\n#         for j in range(n-i-1):\n#             a[j]-=e\n#         heapify(a)\n#         # print(a)\n#     print(min)\n#     t-=1","# Author - krishnakumar_r\nimport sys\nimport os\nimport math\nimport bisect\nfrom collections import *\nimport heapq\nfrom sys import stdin,stdout\nfrom math import gcd,floor,sqrt,log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl,bisect_right as br\nfrom itertools import *\nfrom functools import *\nimport random\n\nsys.setrecursionlimit(100000000)\n\ninp    =lambda: int(input())\nstrng  =lambda: input().strip()\njn     =lambda x,l: x.join(map(str,l))\nstrl   =lambda: list(input().strip())\nmul    =lambda: map(int,input().strip().split())\nmulf   =lambda: map(float,input().strip().split())\nseq    =lambda: list(map(int,input().strip().split()))\n\nceil   =lambda x: int(x) if(x==int(x)) else int(x)+1\nceildiv=lambda x,d: x\/\/d if(x%d==0) else x\/\/d+1\n\nflush  =lambda: stdout.flush()\nstdstr =lambda: stdin.readline()\nstdint =lambda: int(stdin.readline())\nstdpr  =lambda x: stdout.write(str(x))\nINF = float('inf')\nMOD =1000000007\n\nfrom io import BytesIO, IOBase\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\ndef solve():\n        n = inp()\n        arr = seq()\n        ans = -INF\n        ptr = 0 \n        # heapq.heapify(arr)\n        arr.sort()\n        prev = 0\n        for i in range(n):\n            ans = max(ans , arr[i] -prev)\n            prev += arr[i] - prev\n        print(ans)\n\n\n#main code\nt = 1\nt = inp()\nfor _ in range(t):\n    solve()\n    ","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long MAXN = 2e5 + 10;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e18;\nlong long a[MAXN];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long mx = -INF;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      mx = max(mx, a[i]);\n    }\n    sort(a, a + n);\n    long long ans = a[0];\n    int p = 0;\n    long long s = 0;\n    while (p < n) {\n      ans = max(ans, a[p] - s);\n      s += a[p] - s;\n      p++;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n","import java.util.*;\n\npublic class Main {\n\n\n    public static void main(String[] args) {\n\n        Scanner s=new Scanner(System.in);\n        int t = s.nextInt();\n        try{\n        while (t != 0) {\n           int n=s.nextInt();\n           ArrayList<Integer> arr=new ArrayList<>();\n           for(int i=0;i<n;i++)\n           {\n               int temp=s.nextInt();\n               arr.add(temp);\n           }\n           PriorityQueue<Integer> pq=new PriorityQueue<>(arr);\n           PriorityQueue<Integer> res=new PriorityQueue<>(Collections.reverseOrder());\n           int prev=0;\n           while(pq.size()>=1)\n           {\n               int min=pq.poll();\n               res.add(min-prev);\n               prev=min;\n           }\n\n            if(res.isEmpty())\n                res.add(pq.poll());\n           System.out.println(res.poll());\n           t--;\n        }}catch(Exception e){\n            return;\n        }\n\n\n    }\n\n\n\n}\n\n\n\n\n","t=int(input())\n\nfor t in range(t):\n    n=int(input())\n    a=[int(x) for x in input().split()]\n    a.sort()\n    ans=a[0]\n    for i in range(1,n):\n        if a[i]-a[i-1]>ans:\n            ans=a[i]-a[i-1]\n    print(ans)\n        \n        \n"]},"incorrect_solutions":{"language":[2,3,2,2,2,3,2,2,4,3,4,3,2,2,4,2,3,4,2,2,3,2,3,3,4,4,2,2,3,3,3,3,2,3,2,3,2,3,4,2,3,3,2,2,2,3,3,4,2,2,2,2,2,2,4,3,4,2,3,4,3,3,4,2,3,2,3,3,2,4,3,2,4,3,2,2,3,4,2,2,2,2,3,2,4,3,2,3,4,2,2,3,4,4,2,2,4,3,3,2,4,3,4,2,4,4,3,2,3,3,3,3,4,4,3,2,4,3,4,3,3,2,3,2,4,3,3,2,2,3,2,2,3,3,2,3,3,3,3,4,2,2,2,3,3,3,3,2,4,3,3,4,4,2,2,4,2,4,4,3,3,4,3,3,3,2,3,3,3,3,2,3,2,3,4,2,4,4,3,4,2,2,2,2,3,3,2,3,2,2,2,3,2,2,3,3,2,3,4,3,3,2,3,4,2,3,3,2,2,4,3,3,4,2,3,3,4,2,3,2,2,3,3,2,3,2,2,2,2,2,3,2,4,4,2,4,3,4,2,2,3,4,4,3,3,2,4,2,4,2,2,3,2,3],"solution":["#include <bits\/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nint main() {\n  int tc;\n  cin >> tc;\n  for (; tc--;) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a.rbegin(), a.rend());\n    long long diff = 0;\n    for (; a.size() > 1;) {\n      if (a.back() + diff > 0) break;\n      long long hapus = a.back() + diff;\n      a.pop_back();\n      diff -= hapus;\n    }\n    for (; a.size() > 1;) {\n      long long getA = a[a.size() - 2], getB = a.back();\n      if (getA + diff < 2ll * (getB + diff)) break;\n      long long hapus = a.back() + diff;\n      a.pop_back();\n      diff -= hapus;\n    }\n    cout << a.back() + diff << endl;\n  }\n  return 0;\n}\n","t = int(input())\n\nfor test in range(t):\n    n = int(input())\n    p = list(map(int,input().split()))\n    if(len(p)==1):\n        print(p[0])\n        continue\n    p.sort()\n    print(p[-1]-p[-2])\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  size_t t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> a(n);\n    for (size_t i = 0; i < n; ++i) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    long long s = 0;\n    long long res = 0;\n    size_t i;\n    for (i = 0; i < n - 1; ++i) {\n      if (a[i] + s <= 0) {\n        s -= a[i] + s;\n        continue;\n      }\n      break;\n    }\n    vector<long long> diffs(n - i + 1);\n    diffs[0] = a[i];\n    for (size_t j = i; j < n; ++j) {\n      diffs[j - i + 1] = a[j] - a[j - 1];\n    }\n    cout << *max_element(diffs.begin(), diffs.end()) << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 1000;\nint p[N];\nint main() {\n  int n;\n  cin >> n;\n  while (n--) {\n    memset(p, 0, sizeof p);\n    int a;\n    cin >> a;\n    for (int i = 0; i < a; i++) {\n      cin >> p[i];\n    }\n    sort(p, p + a);\n    int j = 0, s;\n    int max = -1e9 - 1;\n    for (int i = 0; i < a; i++) {\n      if (p[i] + j > max) {\n        max = p[i];\n        s = j;\n      }\n      j -= p[i] + j;\n    }\n    cout << max + s << endl;\n  }\n  return 0;\n}\n","#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits\/stdc++.h>\nusing namespace std;\n #include <ext\/pb_ds\/assoc_container.hpp> \nusing namespace __gnu_pbds;\nusing namespace std;\n#define ll long long int\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\ntypedef tree<long long, null_type, less_equal<>, rb_tree_tag, tree_order_statistics_node_update> indexed_multiset; \n#define sor(vec) sort(vec.begin(), vec.end())\n#define rever(vec) reverse(vec.begin(), vec.end())\n#define trav(x , p) for(auto &x : p)\n#define ull  unsigned long long\n #define MAXN 200005\n #define fi first\n#define se second\nconst ll mod =998244353; \n#define dbg(i,j,k)  cout<<\"(\"<<i<<\",\"<<j<<\")\"<<\" \"<<k<<\" \"\n#define dbgp(i,j)   cout<<i<<\" \"<<j<<endl\n#define print cout<<\"**\"<<endl;\n const int inf=1e9+7;\n void vcin(vector<ll> &n){for(int i=0;i<int(n.size());i++) cin>>n[i];}\n void vcout(vector<ll> &n){for(int i=0;i<int(n.size());i++){cout<<n[i]<<\" \";}cout<<endl;}\nconst ll MOD = 1e9+7;\ndouble eps = 0.0000001;\n#define endl \"\\n\";\n \/\/member functions :\n\/\/1. order_of_key(k) : number of elements strictly lesser than k\n\/\/2. find_by_order(k) : k-th element in the set\n\/\/ cout<<\"Case #\"<<p<<\": \"<<ans<<endl;\n\n\nvoid solve()\n{\n  \n   ll n;\n   cin>>n;\n   multiset<ll> s;\n   vector<ll> v(n);\n   for(int i=0;i<n;i++)\n   {\n      ll x;\n      cin>>x;\n      s.insert(x);\n      v[i]=x;\n   }\n   sor(v);\n   if(n==1)\n   {\n      cout<<v[0]<<endl;\n      return ;\n   }\n   ll ans=*s.begin();\n   s.erase(ans);\n   ll del=0;\n   ll curr=ans;\n  \n   while(!s.empty())\n   {\n         ans=max(ans,*s.begin()-curr);\n            curr+=(*s.begin()-curr);\n         \/\/del+=(*s.begin()-del-curr);\n         \/\/curr=*s.begin();\n         \/\/dbgp(ans,curr);\n         s.erase(*s.begin());\n   }\n   cout<<ans<<endl;\n}\n\n\n\nint32_t main()  \n{\n  \n  \n\t ios::sync_with_stdio(false);\n     std::cin.tie(nullptr);\n     \n         ll t;\n         cin>>t;\n      \n   \n         while(t--)\n         {\n            solve();\n         }\n   \n}\n\n","t = int(input())\n\nfor test in range(t):\n    n = int(input())\n    p = list(map(int,input().split()))\n    if(len(p)==1):\n        print(p[0])\n        continue\n    ans = 0\n    p.sort()\n    for i in range(len(p)-2,0,-1):\n        ans = max(ans,p[i+1]-p[i])\n    print(ans)\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false), cin.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> v(n);\n    for (auto &p : v) {\n      cin >> p;\n    }\n    vector<long long> ans;\n    sort(v.begin(), v.end());\n    reverse(v.begin(), v.end());\n    long long x = v[v.size() - 1];\n    if (x < 0 && v.size() > 1) v.pop_back();\n    ans.push_back(v[v.size() - 1]);\n    if (n > 1) {\n      for (auto &p : v) {\n        p = p - x;\n      }\n    }\n    for (int i = 1; i <= v.size() - 1; i++) {\n      ans.push_back(v[i - 1] - v[i]);\n    }\n    if (v.size() == 1) ans.push_back(v[0]);\n    sort(ans.begin(), ans.end());\n    cout << ans[ans.size() - 1] << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base ::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  int n;\n  vector<int> a;\n  while (t > 0) {\n    cin >> n;\n    int tmp;\n    int maxN;\n    for (int i = 0; i < n; i++) {\n      cin >> tmp;\n      a.push_back(tmp);\n    }\n    if (n == 1) {\n      cout << tmp << endl;\n      t--;\n      continue;\n    }\n    sort(a.begin(), a.end());\n    maxN = a[0];\n    for (int i = 1; i < n; i++) {\n      maxN = max(maxN, a[i] - a[i - 1]);\n    }\n    cout << maxN << endl;\n    a.clear();\n    t--;\n  }\n  return 0;\n}\n","import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n    \/\/ Graph\n    \/\/ prefix sums\n    \/\/inputs\n    public static void main(String args[])throws Exception{\n        Input sc=new Input();\n        precalculates p=new precalculates();\n        StringBuilder sb=new StringBuilder();\n        int t=sc.readInt();\n        for(int f=0;f<t;f++){\n            int n=sc.readInt();\n            long a[]=sc.readArrayLong();\n            HashSet<Long> map=new HashSet<>();\n            for(int i=0;i<n;i++){\n                map.add(a[i]);\n            }\n            n=map.size();\n            a=new long[n];\n            int j=0;\n            for(Long val:map){\n                a[j++]=val;\n            }\n            Arrays.sort(a);\n            long sum=0;\n            long prev=0;long ans=Long.MIN_VALUE;\n            for(int i=0;i<n-1;i++){\n                sum=sum+((a[i])-prev);\n                ans=Math.max(ans,a[i]-prev);\n                prev=sum;\n            }\n            if(a.length>1 && a[0]==0) {\n                ans = Math.max(ans, a[n - 2]);\n            }else if(a.length>1 && a[0]!=0){\n                ans=Math.max(ans,a[n-1]-prev);\n            }\n\n            if(n>0 && a[0]==0)\n            {\n                ans=0;\n            }\n            if(ans!=Long.MIN_VALUE)\n                sb.append(ans+\"\\n\");\n            else\n                sb.append(a[n-1]+\"\\n\");\n\n        }\n        \/\/ 1 2 7 10   1\n        \/\/ 0 1 6 9    2\n        \/\/ 0 0 5 8\n        \/\/ -1 0 2\n        \/\/ 0  1 3\n        \/\/ 0 0 2\n        System.out.print(sb);\n    }\n}\nclass Input{\n    BufferedReader br;\n    StringTokenizer st;\n    Input(){\n        br=new BufferedReader(new InputStreamReader(System.in));\n        st=new StringTokenizer(\"\");\n    }\n    public int[] readArray() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        int a[]=new int[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Integer.parseInt(st.nextToken());\n        }\n        return a;\n    }\n    public long[] readArrayLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        long a[]=new long[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Long.parseLong(st.nextToken());\n        }\n        return a;\n    }\n    public int readInt() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Integer.parseInt(st.nextToken());\n    }\n    public long readLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Long.parseLong(st.nextToken());\n    }\n    public String readString() throws Exception{\n        return br.readLine();\n    }\n    public int[][] read2dArray(int n,int m)throws Exception{\n        int a[][]=new int[n][m];\n        for(int i=0;i<n;i++){\n            st=new StringTokenizer(br.readLine());\n            for(int j=0;j<m;j++){\n                a[i][j]=Integer.parseInt(st.nextToken());\n            }\n        }\n        return a;\n    }\n}\nclass precalculates{\n    public int[] prefixSumOneDimentional(int a[]){\n        int n=a.length;\n        int dp[]=new int[n];\n        for(int i=0;i<n;i++){\n            if(i==0)\n                dp[i]=a[i];\n            else\n                dp[i]=dp[i-1]+a[i];\n        }\n        return dp;\n    }\n    public int[] postSumOneDimentional(int a[]) {\n        int n = a.length;\n        int dp[] = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            if (i == n - 1)\n                dp[i] = a[i];\n            else\n                dp[i] = dp[i + 1] + a[i];\n        }\n        return dp;\n    }\n    public int[][] prefixSum2d(int a[][]){\n        int n=a.length;int m=a[0].length;\n        int dp[][]=new int[n+1][m+1];\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=m;j++){\n                dp[i][j]=a[i-1][j-1]+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];\n            }\n        }\n        return dp;\n    }\n    public long pow(long a,long b){\n        long mod=1000000007;\n        long ans=0;\n        if(b<=0)\n            return 1;\n        if(b%2==0){\n            ans=pow(a,b\/2)%mod;\n            return ((ans%mod)*(ans%mod))%mod;\n        }else{\n            return ((a%mod)*(ans%mod))%mod;\n        }\n    }\n\n}\nclass GraphInteger{\n    HashMap<Integer,vertex> vtces;\n    class vertex{\n        HashMap<Integer,Integer> children;\n        public vertex(){\n            children=new HashMap<>();\n        }\n    }\n    public GraphInteger(){\n        vtces=new HashMap<>();\n    }\n    public void addVertex(int a){\n        vtces.put(a,new vertex());\n    }\n    public void addEdge(int a,int b,int cost){\n        if(!vtces.containsKey(a)){\n            vtces.put(a,new vertex());\n        }\n        if(!vtces.containsKey(b)){\n            vtces.put(b,new vertex());\n        }\n        vtces.get(a).children.put(b,cost);\n\/\/        vtces.get(b).children.put(a,cost);\n    }\n    public boolean isCyclicDirected(){\n        boolean isdone[]=new boolean[vtces.size()+1];\n        boolean check[]=new boolean[vtces.size()+1];\n        for(int i=1;i<=vtces.size();i++) {\n            if (!isdone[i] && isCyclicDirected(i,isdone, check)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private boolean isCyclicDirected(int i,boolean isdone[],boolean check[]){\n        if(check[i])\n            return true;\n        if(isdone[i])\n            return false;\n        check[i]=true;\n        isdone[i]=true;\n        Set<Integer> set=vtces.get(i).children.keySet();\n        for(Integer ii:set){\n            if(isCyclicDirected(ii,isdone,check))\n                return true;\n        }\n        check[i]=false;\n        return false;\n    }\n}","import sys, collections, math, bisect, heapq, random, functools\ninput = sys.stdin.readline\nout = sys.stdout.flush\n\ndef solve():\n      n = int(input())\n      queue = []\n      a = list(map(int,input().split()))\n      for i in range(n):\n            heapq.heappush(queue,a[i])\n      diff = 0\n      k = len(queue)\n      while k > 1 and queue[0] - diff <= 0:\n            cur = heapq.heappop(queue)\n            diff += cur\n            k -= 1\n      #print(diff)\n      while k > 1 and queue[1] - diff - (queue[0] - diff) > queue[0] - diff:\n            cur = heapq.heappop(queue) - diff\n         \n            diff += cur\n            k -= 1\n\n      print(queue[0] - diff)\n\n\n\n\n\n\n\nif __name__ == '__main__':\n      for i in range(int(input())):\n          solve()","\/\/ Working program with FastReader \nimport java.io.*;\nimport java.util.*;\npublic class hh\n{ \n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n\n        public FastReader() \n        { \n            br = new BufferedReader(new\n                InputStreamReader(System.in)); \n        } \n\n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n\n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n\n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n\n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n\n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n\n    static final int MAXN = 100001;\n    \/\/ stores smallest prime factor for every number\n    static int spf[] = new int[MAXN];\n    \/\/ Calculating SPF (Smallest Prime Factor) for every\n    \/\/ number till MAXN.\n    \/\/ Time Complexity : O(nloglogn)\n    static void sieve()\n    {\n        spf[1] = 1;\n        for (int i=2; i<MAXN; i++)\n\n        \/\/ marking smallest prime factor for every\n        \/\/ number to be itself.\n            spf[i] = i;\n\n        \/\/ separately marking spf for every even\n        \/\/ number as 2\n        for (int i=4; i<MAXN; i+=2)\n            spf[i] = 2;\n\n        for (int i=3; i*i<MAXN; i++)\n        {\n            \/\/ checking if i is prime\n            if (spf[i] == i)\n            {\n                \/\/ marking SPF for all numbers divisible by i\n                for (int j=i*i; j<MAXN; j+=i)\n\n                \/\/ marking spf[j] if it is not\n                \/\/ previously marked\n                    if (spf[j]==j)\n                        spf[j] = i;\n            }\n        }\n    }\n    \/\/ A O(log n) function returning primefactorization\n    \/\/ by dividing by smallest prime factor at every step\n    static int getFactorization(int x)\n    {\n        int c=0;\n        while (x != 1)\n        {\n            c++;\n            x = x \/ spf[x];\n        }\n        return c;\n    }\n\n    \/*\n    static int LowerBound(int a[], int x) { \/\/ x is the target value or key\n    int l=-1,r=a.length;\n    while(l+1<r) {\n    int m=(l+r)>>>1;\n    if(a[m]>=x) r=m;\n    else l=m;\n    }\n    return r;\n    }\n\n    static int UpperBound(int a[], int x) {\/\/ x is the key or target value\n    int l=-1,r=a.length;\n    while(l+1<r) {\n    int m=(l+r)>>>1;\n    if(a[m]<=x) l=m;\n    else r=m;\n    }\n    return l+1;\n    }\n     *\/\n    static int gcd(int a, int b)\n    {\n        if (a == 0)\n            return b; \n        return gcd(b % a, a); \n    }\n\n    \/\/ method to return LCM of two numbers\n    static int lcm(int a, int b)\n    {\n        return (a \/ gcd(a, b)) * b;\n    }\n\n    public static int[] swap(int a[], int left, int right)\n    {\n        int temp = a[left];\n        a[left] = a[right];\n        a[right] = temp;\n        return a;\n    }\n\n    public static int[] reverse(int a[], int left, int right)\n    {\n        \/\/ Reverse the sub-array\n        while (left < right) {\n            int temp = a[left];\n            a[left++] = a[right];\n            a[right--] = temp;\n        }\n        return a;\n    }\n\n    public static int[] findNextPermutation(int a[])\n    {\n        int last = a.length - 2;\n\n        \/\/ find the longest non-increasing suffix\n        \/\/ and find the pivot\n        while (last >= 0) {\n            if (a[last] < a[last + 1]) {\n                break;\n            }\n            last--;\n        }\n        \/\/ If there is no increasing pair\n        \/\/ there is no higher order permutation\n        if (last < 0)\n            return a;\n\n        int nextGreater = a.length - 1;\n\n        \/\/ Find the rightmost successor to the pivot\n        for (int i = a.length - 1; i > last; i--) {\n            if (a[i] > a[last]) {\n                nextGreater = i;\n                break;\n            }\n        }\n\n        \/\/ Swap the successor and the pivot\n        a = swap(a, nextGreater, last);\n\n        \/\/ Reverse the suffix\n        a = reverse(a, last + 1, a.length - 1);\n\n        \/\/ Return true as the next_permutation is done\n        return a;\n    }\n\n    static void sort(int[] a) {\n        ArrayList<Integer> l = new ArrayList<>();\n        for (int i : a)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n    static void sort(long[] a) {\n        ArrayList<Long> l = new ArrayList<>();\n        for (long i : a)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n    static double pow(double p,double tt)\n    {\n        double ii,q,r;\n        q=1;\n        r=p;\n        while(tt>1)\n        {\n            for(ii=1;2*ii<=tt;ii*=2)\n                p*=p;\n            tt-=ii;\n            q*=p;\n            p=r;\n        }\n        if(tt==1)\n            q*=r;\n        return q;\n    }\n\n    static long pow(long p,long tt,long mod)\n    {\n        long ii,q,r;\n        q=1l;\n        r=p;\n        while(tt>1)\n        {\n            for(ii=1l;2*ii<=tt;ii*=2l)\n                p=((p%mod)*(p%mod))%mod;\n            tt-=ii;\n            q=((q%mod)*(p%mod))%mod;\n            p=r;\n        }\n        if(tt==1)\n            q=((q%mod)*(r%mod))%mod;\n        return q;\n    }\n\n    static int factorial(int n)\n    {\n        return (n == 1 || n == 0) ? 1 : n * factorial(n - 1);\n    }\n\n    public static long primeFactors(long n)\n    {\n        long c=0l;\n        long max=0l;\n        long z=0l;\n        \/\/ArrayList <Integer> ll=new ArrayList<>();\n        \/\/ Print the number of 2s that divide n\n        while (n%2==0)\n        {\n            c++;\n            n \/= 2l;\n            \/\/ll.add(2);\n        }\n        if(c>max)\n        {\n            max=c;\n            z=2;\n        }\n        \/\/ n must be odd at this point. So we can\n        \/\/ skip one element (Note i = i +2)\n        for (int i = 3; i <= Math.sqrt(n); i+= 2)\n        {\n            \/\/ While i divides n, print i and divide n\n            c=0;\n            while (n%i == 0)\n            {\n                c++;\n                n \/= i;\n                \/\/ll.add(i);\n            }\n            if(c>max)\n            {\n                max=c;\n                z=i;\n            }\n        }\n        c=0;\n        \/\/ This condition is to handle the case whien\n        \/\/ n is a prime number greater than 2\n        if (n > 2)\n        {\n            c++;\n            \/\/ll.add((int)n);\n        }\n        if(c>max)\n        {\n            max=c;\n            z=n;\n        }\n        return z;\n    }\n\n    static void PrimeList(){\n        int i,j;\n        int sieve[]=new int[100001];\n        for(i=2;i*i<=100000;i++)\n        {\n            if(sieve[i]==0)\n            {\n                for(j=i*i;j<=100000;j+=i)\n                    sieve[j]=1;\n            }\n        }\n        ArrayList<Integer> primes=new ArrayList<>();\n        for(i=2;i<=100000;i++)\n        {\n            if(sieve[i]==0)\n                primes.add(i);\n        }\n    }\n\n    static int comp(int a[],int b[],int n)\n    {\n        int z=0;\n        for(int i=0;i<n;i++)\n        {\n            if(a[i]!=b[i])\n            {\n                z=1;\n                break;\n            }\n        }\n        if(z==0)\n            return 1;\n        else\n            return 0;\n    }\n\n    static boolean isPowerOfTwo(int x)\n    {\n        return x!=0 && ((x&(x-1))==0);\n    }\n\n    static long calc (int a[],int b[],int n,int mod)\n    {\n        long sum=0l;\n        int i;\n        HashMap<Long,Long>x=new HashMap<>();\n        HashMap<Long,Long>y=new HashMap<>();\n        for(i=0;i<n;i++)\n        {\n            x.put((long)a[i],(long)i);\n            y.put((long)b[i],(long)i);\n        }\n        for(i=0;i<n;i++)\n        {\n            sum=(sum+Math.abs(x.get((long)i)-y.get((long)i))%mod)%mod;\n        }\n        return sum;\n    }\n\n    static int[] rotate(int arr[])\n    {\n        int x = arr[arr.length-1], i;\n        for (i = arr.length-1; i > 0; i--)\n            arr[i] = arr[i-1];\n        arr[0] = x;\n        return arr;\n    }\n\n    public static void main(String[] args) \n    {\n        \/\/try\n        \/\/{\n        FastReader d=new FastReader();\n        PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        StringBuilder sb=new StringBuilder();\n        int t,i,j,k,l,r,n;\n        int mod = (int) 1e9 + 7;\n\n        int Inf=Integer.MAX_VALUE;\n        int negInf=Integer.MIN_VALUE;\n        t=d.nextInt();\n        \/\/t=1;\n        String s,s1;\n        \/\/char ch1,ch2,ch3,ch4;\n        long ans,c,z;\n\n        while(t-->0)\n        {\n            z=c=0l;\n            ans=0l;\n            n=d.nextInt();\n            long a[]=new long[n];\n            for(i=0;i<n;i++)\n                a[i]=(long)d.nextLong();\n            sort(a);\n            long x=0l;\n            if(n==1)\n                pr.println(a[0]);\n            else\n            {\n                for(i=0;i<n-1;i++)\n                {\n                    if((long)a[i+1]-(long)a[i]-(long)x>=(long)a[i])\n                    {\n                        \n                        a[i+1]=(long)a[i+1]-(long)a[i]-(long)x;\n                        x+=(long)a[i];\n                    }\n                    else\n                    {\n                        pr.println(a[i]);\n                        z=1;\n                        break;\n                    }\n                }\n                if(z==0)\n                pr.println(a[i]);\n            }\n        }\n        \/*\n        }catch(Exception e) {\n        System.out.println(0);\n        }*\/\n        pr.flush();\n    }\n}","for _ in range(int(input())):\n    n = int(input())\n    line = [int(ch) for ch in input().split()]\n    line, k = sorted(line), line[0]\n    for i in range(1, n):\n        k = max(k, line[i] - line[i - 1])\n    print(k)","#include <bits\/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target( \\\n    \"fma,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nconst long long int M = 1000000007;\nlong long int fact[200001] = {};\ninline bool comp(long long int x, long long int y) { return x < y; }\ninline long long int mod(long long int x) {\n  long long int a1 = (x % M);\n  if (a1 < 0) {\n    a1 += M;\n  }\n  return a1;\n}\ninline long long int power(long long int x, unsigned long long int y,\n                           long long int p = LLONG_MAX) {\n  long long int res = 1;\n  x = x % p;\n  if (x == 0) {\n    return 0;\n  }\n  while (y > 0) {\n    if (y & 1) {\n      res = (res * x) % p;\n    }\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\ninline long long int inversePrimeModular(long long int a, long long int p) {\n  return power(a, p - 2, p);\n}\ninline void calcFact(long long int n) {\n  fact[0] = 1;\n  for (long long int i = 1; i <= n; i++) {\n    fact[i] = fact[i - 1] * i;\n    fact[i] = mod(fact[i]);\n  }\n}\ninline long long int ncr(long long int n, long long int r) {\n  if (n < r) return 0;\n  return mod(inversePrimeModular(mod(fact[n - r] * fact[r]), M) * fact[n]);\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int t;\n  cin >> t;\n  while (t--) {\n    long long int n;\n    cin >> n;\n    long long int arr[n];\n    for (long long int indexaa = 0; indexaa < n; indexaa++) cin >> arr[indexaa];\n    ;\n    sort(arr, arr + n);\n    long long int curr = arr[0];\n    long long int mx = arr[0];\n    for (long long int i = 1; i < n; i++) {\n      mx = max(mx, arr[i] - curr);\n      curr += arr[i];\n    }\n    cout << mx << \"\\n\";\n  }\n  cerr << fixed << setprecision(10);\n  cerr << \"time taken : \" << (float)clock() \/ CLOCKS_PER_SEC << \" secs\"\n       << \"\\n\";\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 2e6 + 1000;\nlong long p[N];\nint main() {\n  int n;\n  cin >> n;\n  while (n--) {\n    int a;\n    cin >> a;\n    for (int i = 0; i < a; i++) {\n      cin >> p[i];\n    }\n    sort(p, p + a);\n    long long j = 0, s = 0;\n    long long max = -1e18 - 1;\n    for (int i = 0; i < a; i++) {\n      if (p[i] + j > max) {\n        max = p[i];\n        s = j;\n      }\n      j -= p[i] + j;\n    }\n    cout << max + s << endl;\n  }\n  return 0;\n}\n","import java.io.*;\nimport java.util.*;\n\npublic class CodeForces{\n    \/*-------------------------------------------EDITING CODE STARTS HERE-------------------------------------------*\/\n    public static void main(String[] args) throws IOException{\n        openIO();\n        int testCase = 1;\n        testCase = sc.nextInt();\n        preCompute();\n        for (int i = 1; i <= testCase; i++) solve(i);\n        closeIO();\n    }\n\n    public static void solve(int tCase)throws IOException {\n        int n = sc.nextInt();\n        long[] arr = new long[n];\n        for(int i=0;i<n;i++)arr[i] = sc.nextInt();\n        if(n==1){\n            out.println(arr[0]);\n            return;\n        }\n        Arrays.sort(arr);\n        long adder = 0;\n        long max = arr[0];\n        int i = 0;\n        for(;i<n;i++){\n            long curr = arr[i] + adder;\n            max = Math.max(max, curr);\n            if(curr<=0) {\n                adder += -arr[i];\n            }else break;\n        }\n        if(i<n)max = Math.max(max,arr[i]+adder);\n        i++;\n        for(;i<n;i++){\n            long curr = arr[i] + adder;\n            long prev = arr[i-1]  + adder;\n            max = Math.max(max,curr - prev);\n        }\n        out.println(max);\n    }\n\n\n    private static void  preCompute(){\n\n    }\n    \/*-------------------------------------------EDITING CODE ENDS HERE-------------------------------------------*\/\n    static FastestReader sc;\n    static PrintWriter out;\n    private static void openIO() throws IOException{\n        sc = new FastestReader();\n        out = new PrintWriter(System.out);\n    }\n\n    \/*------------------------------------------HELPER FUNCTION STARTS HERE------------------------------------------*\/\n\n    public static final int mod = (int) 1e9 +7;\n    private static final int mod2 =  998244353;\n    public static final int inf_int = (int) 2e9;\n    public static  final long inf_long = (long) 4e18;\n\n    \/\/ euclidean algorithm time O(max (loga ,logb))\n    public static long _gcd(long a, long b) {\n        if (a == 0)\n            return b;\n        return _gcd(b % a, a);\n    }\n\n    public static long _lcm(long a, long b) {\n        \/\/ lcm(a,b) * gcd(a,b) = a * b\n        return (a \/ _gcd(a, b)) * b;\n    }\n\n\n    \/\/ binary exponentiation time O(logn)\n    public static long _power(long x, long n) {\n        long ans = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ans *= x;\n                ans %= mod;\n                n--;\n            } else {\n                x *= x;\n                x %= mod;\n                n >>= 1;\n            }\n        }\n        return ans;\n    }\n    \/\/sieve\/first divisor time : O(mx * log ( log (mx) ) )\n    public static int[]  _seive(int mx){\n        int[] firstDivisor = new int[mx+1];\n        for(int i=0;i<=mx;i++)firstDivisor[i] = i;\n        for(int i=2;i*i<=mx;i++)\n            if(firstDivisor[i] == i)\n                for(int j = i*i;j<=mx;j+=i)\n                    firstDivisor[j] = i;\n        return firstDivisor;\n    }\n\n    private static boolean _isPrime(long x){\n        for(long i=2;i*i<=x;i++)\n            if(x%i==0)return false;\n        return true;\n    }\n\n\n    \/*------------------------------------------HELPER FUNCTION ENDS HERE-------------------------------------------*\/\n\n    \/*-------------------------------------------FAST INPUT STARTS HERE---------------------------------------------*\/\n\n    public static void closeIO() throws IOException{\n        out.flush();\n        out.close();\n        sc.close();\n    }\n    private static final class FastestReader {\n        private static final int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public FastestReader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public FastestReader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\n        private int skip() throws IOException {\n            int b;\n            \/\/noinspection StatementWithEmptyBody\n            while ((b = read()) != -1 && isSpaceChar(b)) {}\n            return b;\n        }\n\n        public String next() throws IOException {\n            int b = skip();\n            final StringBuilder sb = new StringBuilder();\n            while (!isSpaceChar(b)) { \/\/ when nextLine, (isSpaceChar(b) && b != ' ')\n                sb.appendCodePoint(b);\n                b = read();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) { c = read(); }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') { c = read(); }\n            final boolean neg = c == '-';\n            if (neg) { c = read(); }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') { c = read(); }\n            final boolean neg = c == '-';\n            if (neg) { c = read(); }\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') \/ (div *= 10);\n                }\n            }\n\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) { buffer[0] = -1; }\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) { fillBuffer(); }\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            din.close();\n        }\n    }\n    \/*---------------------------------------------FAST INPUT ENDS HERE ---------------------------------------------*\/\n}","#include <bits\/stdc++.h>\nusing namespace std;\nstruct node {\n  friend bool operator<(node n1, node n2) { return n1.priority < n2.priority; }\n  int priority;\n  int value;\n};\nint main() {\n  int n;\n  cin >> n;\n  while (n--) {\n    priority_queue<int, vector<int>, greater<int> > pq;\n    int a;\n    cin >> a;\n    for (int i = 0; i < a; i++) {\n      int u;\n      cin >> u;\n      pq.push(u);\n    }\n    int j = 0, s;\n    int max = -1e9;\n    while (!pq.empty()) {\n      if (pq.top() + j > max) {\n        max = pq.top();\n        s = j;\n      }\n      j -= pq.top() + j;\n      pq.pop();\n    }\n    cout << max + s << endl;\n  }\n  return 0;\n}\n","\n\ndef solve(a, n):\n    a.sort()\n    a = a[::-1]\n    c = a[-1]\n    #print(a)\n    while True:\n        if len(a) == 1 or (a[0] - a[-1]) < 2*a[-1]:\n            return c\n        else:\n            r = a.pop()\n            c = a[-1] - r\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(a, n))","import java.io.*;\nimport java.util.*;\npublic class MyClass {\n    public static void main(String args[])throws IOException {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int t=Integer.parseInt(br.readLine());\n        while(t-->0){\n            int n=Integer.parseInt(br.readLine());\n            String s[]=br.readLine().split(\" \");\n            int arr[]=new int[n];\n            for(int i=0;i<n;i++){\n                arr[i]=Integer.parseInt(s[i]);\n            }\n            Arrays.sort(arr);\n            if(arr[0]==0){ System.out.println(arr[0]);continue;}\n            int sum=arr[0];\n            int min=arr[0];\n            for(int i=1;i<n;i++){\n                arr[i]-=sum;\n                min=Math.max(min,arr[i]);\n                sum+=arr[i];\n            }\n            System.out.println(min);\n        }\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> a(n, 0);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    long long ans = a[0];\n    long long b = 0;\n    long long bans = ans;\n    for (int i = 0; i < n - 1; i++) {\n      a[i + 1] -= b;\n      if (a[i] == a[i + 1]) {\n        break;\n      }\n      b += a[i];\n      a[i + 1] -= a[i];\n      ans = a[i + 1];\n      bans = max(bans, ans);\n    }\n    cout << bans << endl;\n  }\n}\n","#include <bits\/stdc++.h>\nconst int N = 1e5;\nconst int inf = 1e9 + 10;\nusing namespace std;\nvoid yes() { cout << \"YES\" << endl; }\nvoid no() { cout << \"NO\" << endl; }\nmap<long long int, long long int> cnt;\nvoid prime_factorization(long long int n) {\n  for (long long int i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      n \/= i;\n      ++cnt[i];\n    }\n  }\n  if (n > 1) ++cnt[n];\n}\nvoid solve() {\n  long long int x, y, a, b;\n  cin >> x >> y;\n  a = x, b = y;\n  if (x > y) {\n    cout << x + y;\n    return;\n  }\n  if (x == y) {\n    cout << x;\n    return;\n  }\n  if (y % x == 0) {\n    cout << x;\n    return;\n  }\n  cout << (y \/ x) * x + (y % x) \/ 2;\n  return;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int a[n + 1];\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    if (n == 1)\n      cout << a[1] << endl;\n    else {\n      long long int cross = 0, mn = a[1], second = 0;\n      sort(a + 1, a + n + 1);\n      for (int i = 2; i <= n; i++) {\n        second += mn;\n        mn = a[i] - second;\n        a[i] = mn;\n        ++cross;\n      }\n      sort(a + 1, a + n + 1);\n      cout << a[n];\n      cout << endl;\n    }\n  }\n}\n","t=int(input())\nfor i in range(t):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    list_min=[]\n    if(len(arr)==1):\n        list_min.append(arr[0])\n    while(len(arr)>1):\n        mini=min(arr)\n        list_min.append(mini)\n        del(arr[arr.index(mini)])\n        arr=[x-mini for x in arr]\n    print(\"gg: \")\n    print(max(list_min))","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> a(n);\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  sort(a.begin(), a.end());\n  long long change = 0;\n  long long ans = a[0];\n  for (int i = 0; i < n - 1; ++i) {\n    if (2 * (a[i] - change) <= (a[i + 1] - change)) {\n      a[i] -= change;\n      change += a[i];\n      ans = a[i + 1] - change;\n    } else {\n      ans = a[i] - change;\n      break;\n    }\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; ++i) solve();\n  return 0;\n}\n","n = int(input())\n\nfor _ in range(0, n):\n    input()\n    line = [int(i) for i in input().split()]\n    line.sort()\n    res = line[0]\n    for i in range(0, len(line)-1):\n        diff = line[i+1] - line[i]\n        res = max(res, diff)\n\n    print(\"ANS: \", res)","import sys\nimport math\n# input= sys.stdin.buffer.readline\nfor _ in range(int(input())):\n    n = int(input())\n    arr=[int(c) for c in input().split()]\n    if n <=2:\n        a = max(arr)\n        b = min(arr)\n        c = 0\n    else:\n        a,b,c = float(\"-inf\"),float(\"-inf\"),float(\"-inf\")\n        for i in arr:\n            if i >= a:\n                c = b\n                b = a\n                a = i\n                continue\n            if i >= b:\n                c = b\n                b = i \n                continue\n            if i>= c :\n                c = i\n    \n    a-=c\n    b-=c \n\n    if n == 1:\n        print(arr[0])\n    elif a-b>b:\n        print(a-b)\n    else:\n        print(b)","\/\/ Working program with FastReader \nimport java.io.*;\nimport java.util.*;\npublic class hh\n{ \n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n\n        public FastReader() \n        { \n            br = new BufferedReader(new\n                InputStreamReader(System.in)); \n        } \n\n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n\n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n\n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n\n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n\n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n\n    static final int MAXN = 100001;\n    \/\/ stores smallest prime factor for every number\n    static int spf[] = new int[MAXN];\n    \/\/ Calculating SPF (Smallest Prime Factor) for every\n    \/\/ number till MAXN.\n    \/\/ Time Complexity : O(nloglogn)\n    static void sieve()\n    {\n        spf[1] = 1;\n        for (int i=2; i<MAXN; i++)\n\n        \/\/ marking smallest prime factor for every\n        \/\/ number to be itself.\n            spf[i] = i;\n\n        \/\/ separately marking spf for every even\n        \/\/ number as 2\n        for (int i=4; i<MAXN; i+=2)\n            spf[i] = 2;\n\n        for (int i=3; i*i<MAXN; i++)\n        {\n            \/\/ checking if i is prime\n            if (spf[i] == i)\n            {\n                \/\/ marking SPF for all numbers divisible by i\n                for (int j=i*i; j<MAXN; j+=i)\n\n                \/\/ marking spf[j] if it is not\n                \/\/ previously marked\n                    if (spf[j]==j)\n                        spf[j] = i;\n            }\n        }\n    }\n    \/\/ A O(log n) function returning primefactorization\n    \/\/ by dividing by smallest prime factor at every step\n    static int getFactorization(int x)\n    {\n        int c=0;\n        while (x != 1)\n        {\n            c++;\n            x = x \/ spf[x];\n        }\n        return c;\n    }\n\n    \/*\n    static int LowerBound(int a[], int x) { \/\/ x is the target value or key\n    int l=-1,r=a.length;\n    while(l+1<r) {\n    int m=(l+r)>>>1;\n    if(a[m]>=x) r=m;\n    else l=m;\n    }\n    return r;\n    }\n\n    static int UpperBound(int a[], int x) {\/\/ x is the key or target value\n    int l=-1,r=a.length;\n    while(l+1<r) {\n    int m=(l+r)>>>1;\n    if(a[m]<=x) l=m;\n    else r=m;\n    }\n    return l+1;\n    }\n     *\/\n    static int gcd(int a, int b)\n    {\n        if (a == 0)\n            return b; \n        return gcd(b % a, a); \n    }\n\n    \/\/ method to return LCM of two numbers\n    static int lcm(int a, int b)\n    {\n        return (a \/ gcd(a, b)) * b;\n    }\n\n    public static int[] swap(int a[], int left, int right)\n    {\n        int temp = a[left];\n        a[left] = a[right];\n        a[right] = temp;\n        return a;\n    }\n\n    public static int[] reverse(int a[], int left, int right)\n    {\n        \/\/ Reverse the sub-array\n        while (left < right) {\n            int temp = a[left];\n            a[left++] = a[right];\n            a[right--] = temp;\n        }\n        return a;\n    }\n\n    public static int[] findNextPermutation(int a[])\n    {\n        int last = a.length - 2;\n\n        \/\/ find the longest non-increasing suffix\n        \/\/ and find the pivot\n        while (last >= 0) {\n            if (a[last] < a[last + 1]) {\n                break;\n            }\n            last--;\n        }\n        \/\/ If there is no increasing pair\n        \/\/ there is no higher order permutation\n        if (last < 0)\n            return a;\n\n        int nextGreater = a.length - 1;\n\n        \/\/ Find the rightmost successor to the pivot\n        for (int i = a.length - 1; i > last; i--) {\n            if (a[i] > a[last]) {\n                nextGreater = i;\n                break;\n            }\n        }\n\n        \/\/ Swap the successor and the pivot\n        a = swap(a, nextGreater, last);\n\n        \/\/ Reverse the suffix\n        a = reverse(a, last + 1, a.length - 1);\n\n        \/\/ Return true as the next_permutation is done\n        return a;\n    }\n\n    static void sort(int[] a) {\n        ArrayList<Integer> l = new ArrayList<>();\n        for (int i : a)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n    static void sort(long[] a) {\n        ArrayList<Long> l = new ArrayList<>();\n        for (long i : a)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n    static double pow(double p,double tt)\n    {\n        double ii,q,r;\n        q=1;\n        r=p;\n        while(tt>1)\n        {\n            for(ii=1;2*ii<=tt;ii*=2)\n                p*=p;\n            tt-=ii;\n            q*=p;\n            p=r;\n        }\n        if(tt==1)\n            q*=r;\n        return q;\n    }\n\n    static long pow(long p,long tt,long mod)\n    {\n        long ii,q,r;\n        q=1l;\n        r=p;\n        while(tt>1)\n        {\n            for(ii=1l;2*ii<=tt;ii*=2l)\n                p=((p%mod)*(p%mod))%mod;\n            tt-=ii;\n            q=((q%mod)*(p%mod))%mod;\n            p=r;\n        }\n        if(tt==1)\n            q=((q%mod)*(r%mod))%mod;\n        return q;\n    }\n\n    static int factorial(int n)\n    {\n        return (n == 1 || n == 0) ? 1 : n * factorial(n - 1);\n    }\n\n    public static long primeFactors(long n)\n    {\n        long c=0l;\n        long max=0l;\n        long z=0l;\n        \/\/ArrayList <Integer> ll=new ArrayList<>();\n        \/\/ Print the number of 2s that divide n\n        while (n%2==0)\n        {\n            c++;\n            n \/= 2l;\n            \/\/ll.add(2);\n        }\n        if(c>max)\n        {\n            max=c;\n            z=2;\n        }\n        \/\/ n must be odd at this point. So we can\n        \/\/ skip one element (Note i = i +2)\n        for (int i = 3; i <= Math.sqrt(n); i+= 2)\n        {\n            \/\/ While i divides n, print i and divide n\n            c=0;\n            while (n%i == 0)\n            {\n                c++;\n                n \/= i;\n                \/\/ll.add(i);\n            }\n            if(c>max)\n            {\n                max=c;\n                z=i;\n            }\n        }\n        c=0;\n        \/\/ This condition is to handle the case whien\n        \/\/ n is a prime number greater than 2\n        if (n > 2)\n        {\n            c++;\n            \/\/ll.add((int)n);\n        }\n        if(c>max)\n        {\n            max=c;\n            z=n;\n        }\n        return z;\n    }\n\n    static void PrimeList(){\n        int i,j;\n        int sieve[]=new int[100001];\n        for(i=2;i*i<=100000;i++)\n        {\n            if(sieve[i]==0)\n            {\n                for(j=i*i;j<=100000;j+=i)\n                    sieve[j]=1;\n            }\n        }\n        ArrayList<Integer> primes=new ArrayList<>();\n        for(i=2;i<=100000;i++)\n        {\n            if(sieve[i]==0)\n                primes.add(i);\n        }\n    }\n\n    static int comp(int a[],int b[],int n)\n    {\n        int z=0;\n        for(int i=0;i<n;i++)\n        {\n            if(a[i]!=b[i])\n            {\n                z=1;\n                break;\n            }\n        }\n        if(z==0)\n            return 1;\n        else\n            return 0;\n    }\n\n    static boolean isPowerOfTwo(int x)\n    {\n        return x!=0 && ((x&(x-1))==0);\n    }\n\n    static long calc (int a[],int b[],int n,int mod)\n    {\n        long sum=0l;\n        int i;\n        HashMap<Long,Long>x=new HashMap<>();\n        HashMap<Long,Long>y=new HashMap<>();\n        for(i=0;i<n;i++)\n        {\n            x.put((long)a[i],(long)i);\n            y.put((long)b[i],(long)i);\n        }\n        for(i=0;i<n;i++)\n        {\n            sum=(sum+Math.abs(x.get((long)i)-y.get((long)i))%mod)%mod;\n        }\n        return sum;\n    }\n\n    static int[] rotate(int arr[])\n    {\n        int x = arr[arr.length-1], i;\n        for (i = arr.length-1; i > 0; i--)\n            arr[i] = arr[i-1];\n        arr[0] = x;\n        return arr;\n    }\n\n    public static void main(String[] args) \n    {\n        \/\/try\n        \/\/{\n        FastReader d=new FastReader();\n        PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        StringBuilder sb=new StringBuilder();\n        int t,i,j,k,l,r,n;\n        int mod = (int) 1e9 + 7;\n\n        int Inf=Integer.MAX_VALUE;\n        int negInf=Integer.MIN_VALUE;\n        t=d.nextInt();\n        \/\/t=1;\n        String s,s1;\n        \/\/char ch1,ch2,ch3,ch4;\n        long ans,c,z;\n\n        while(t-->0)\n        {\n            z=c=0l;\n            ans=0l;\n            n=d.nextInt();\n            long a[]=new long[n];\n            for(i=0;i<n;i++)\n                a[i]=d.nextLong();\n            sort(a);\n            long x=0l;\n            if(n==1)\n                pr.println(a[0]);\n            else\n            {\n                for(i=0;i<n-1;i++)\n                {\n                    if((long)a[i+1]-a[i]-(long)x>=(long)a[i])\n                    {\n                        \n                        a[i+1]=(long)a[i+1]-a[i]-(long)x;\n                        x+=(long)a[i];\n                    }\n                    else\n                    {\n                        pr.println(a[i]);\n                        z=1;\n                        break;\n                    }\n                }\n                if(z==0)\n                pr.println(a[i]);\n            }\n        }\n        \/*\n        }catch(Exception e) {\n        System.out.println(0);\n        }*\/\n        pr.flush();\n    }\n}","import java.io.*;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class codeforces_753_C {\n    private static void solve(FastIOAdapter io) {\n        int n = io.nextInt();\n        int[] a = io.readArray(n);\n\n        ruffleSort(a);\n        long minus = 0;\n        long min = a[0];\n        for (int i = 1; i < n; i++) {\n            if (a[i] - (minus + min) >= min) {\n                minus += min;\n                min = a[i] - minus;\n            } else break;\n        }\n\n        io.out.println(min);\n    }\n\n    public static void main(String[] args) throws Exception {\n        try (FastIOAdapter ioAdapter = new FastIOAdapter()) {\n            int count = 1;\n            count = ioAdapter.nextInt();\n            while (count-- > 0) {\n                solve(ioAdapter);\n            }\n        }\n    }\n\n    static void ruffleSort(int[] arr) {\n        int n = arr.length;\n        Random rnd = new Random();\n        for (int i = 0; i < n; ++i) {\n            int tmp = arr[i];\n            int randomPos = i + rnd.nextInt(n - i);\n            arr[i] = arr[randomPos];\n            arr[randomPos] = tmp;\n        }\n        Arrays.sort(arr);\n    }\n\n    static class FastIOAdapter implements AutoCloseable {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        public PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter((System.out))));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        String nextLine() {\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long[] readArrayLong(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        @Override\n        public void close() throws Exception {\n            out.flush();\n            out.close();\n            br.close();\n        }\n    }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  long long t, n, sum, min;\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    sum = 0;\n    vector<long long> a(n);\n    for (long long i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    min = a[0];\n    sum = a[0];\n    for (long long i = 1; i < n; i++) {\n      a[i] -= sum;\n      if (min <= (a[i])) {\n        min = a[i];\n      } else {\n        break;\n      }\n      sum += a[i];\n    }\n    cout << min << '\\n';\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    long long x0, n;\n    cin >> n;\n    vector<long long> a(n, 0);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    long long ans = a[0];\n    long long b = 0;\n    for (int i = 0; i < n - 1; i++) {\n      a[i + 1] -= b;\n      if (a[i] == a[i + 1]) {\n        break;\n      }\n      if (a[i + 1] - a[i] >= a[i]) {\n        b += a[i];\n        a[i + 1] -= a[i];\n        ans = a[i + 1];\n      }\n    }\n    cout << ans << endl;\n  }\n}\n","for _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    if(n==1 or len(set(a))==1):\n        print(a[0])\n        continue\n    else:\n        a.sort()\n        s=a[0]\n        for i in range(1,n):\n            a[i]-=s\n            s+=a[i]\n        print(max(a))\n    ","t=int(input())\nfor i in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    a.sort()\n    k=1\n    b=[0]*n\n    for j in range(1,n):\n        b[j]=-a[j-1]\n    for j in range(1,n):\n        b[j]+=b[j-1]\n        a[j]+=b[j]\n    print(max(a))","from heapq import heapify,heappush,heappop,heappushpop\nfrom collections import defaultdict as dd, deque as dq,Counter as C\nfrom math import factorial as f ,ceil,gcd,sqrt,log\nfrom bisect import bisect_left as bl ,bisect_right as br\nfrom itertools import combinations as c,permutations as p\nfrom math import factorial as f ,ceil,gcd,sqrt,log\nfrom sys import stdin\ninput = stdin.readline\nmp = lambda : map(int,input().split())\nit = lambda: int(input())\nls = lambda : list(input().strip().split())\nmt = lambda  r : [ ls() for _ in range(r)]\nlcm = lambda a,b : (a*b)\/\/gcd(a,b)\n\nfor _ in range(it()):\n\ta = it()\n\tb = list(mp())\n\tb.sort()\n\tif len(b)==1:\n\t\tprint(b[0])\n\t\tcontinue\n\tcur =b[0]\n\tprev = b[0]\n\tans =None\n\tfor i in range(1,a):\n\t\tif b[i]-cur >=prev:\n\t\t\tb[i]-=cur \n\t\t\tprev = b[i]\n\t\t\tcur+=b[i]\n\t\telse:\n\t\t\tans = prev\n\t\t\tbreak\n\tif ans ==None:\n\t\tans =b[-1]\n\tprint(ans)","T = int(input())\nwhile T>0:\n    T -= 1\n    n = int(input())\n    array = sorted([int(x) for x in input().split()])\n    ans = 0\n    if n == 1:\n        print(array[0])\n        continue\n    for i in range(len(array) - 1):\n        ans = max(ans, array[i+1] - array[i])\n    print(ans)","#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits\/stdc++.h>\nusing namespace std;\n #include <ext\/pb_ds\/assoc_container.hpp> \nusing namespace __gnu_pbds;\nusing namespace std;\n#define ll long long int\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\ntypedef tree<long long, null_type, less_equal<>, rb_tree_tag, tree_order_statistics_node_update> indexed_multiset; \n#define sor(vec) sort(vec.begin(), vec.end())\n#define rever(vec) reverse(vec.begin(), vec.end())\n#define trav(x , p) for(auto &x : p)\n#define ull  unsigned long long\n #define MAXN 200005\n #define fi first\n#define se second\nconst ll mod =998244353; \n#define dbg(i,j,k)  cout<<\"(\"<<i<<\",\"<<j<<\")\"<<\" \"<<k<<\" \"\n#define dbgp(i,j)   cout<<i<<\" \"<<j<<endl\n#define print cout<<\"**\"<<endl;\n const int inf=1e9+7;\n void vcin(vector<ll> &n){for(int i=0;i<int(n.size());i++) cin>>n[i];}\n void vcout(vector<ll> &n){for(int i=0;i<int(n.size());i++){cout<<n[i]<<\" \";}cout<<endl;}\nconst ll MOD = 1e9+7;\ndouble eps = 0.0000001;\n#define endl \"\\n\";\n \/\/member functions :\n\/\/1. order_of_key(k) : number of elements strictly lesser than k\n\/\/2. find_by_order(k) : k-th element in the set\n\/\/ cout<<\"Case #\"<<p<<\": \"<<ans<<endl;\n\n\nvoid solve()\n{\n  \n   ll n;\n   cin>>n;\n   set<ll> s;\n   for(int i=0;i<n;i++)\n   {\n      ll x;\n      cin>>x;\n      s.insert(x);\n   }\n   if(s.size()==1)\n   {\n      cout<<*s.begin()<<endl;\n      return ;\n   }\n   ll ans=*s.begin();\n   s.erase(ans);\n   ll del=0;\n   ll curr=ans;\n  \n   while(!s.empty())\n   {\n         ans=max(ans,*s.begin()-curr);\n            curr+=(*s.begin()-curr);\n         \/\/del+=(*s.begin()-del-curr);\n         \/\/curr=*s.begin();\n         s.erase(*s.begin());\n   }\n   cout<<ans<<endl;\n}\n\n\n\nint32_t main()  \n{\n  \n  \n\t ios::sync_with_stdio(false);\n     std::cin.tie(nullptr);\n     \n         ll t;\n         cin>>t;\n      \n   \n         while(t--)\n         {\n            solve();\n         }\n   \n}\n\n","for _ in range(int(input())):\n    n = int(input())\n    x = list(map(int, input().split()))\n    if n == 1: ans = x[0]\n    else:\n        x = sorted(x)\n        ans = 0\n        for i in range(1, n):\n            xd = x[i] - x[i-1]\n            if xd > ans : ans = xd\n    print(ans)","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long MAX_N = 1e5 + 5;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long double EPS = 1e-9;\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> v(n);\n  for (auto &i : v) {\n    cin >> i;\n  }\n  sort(v.begin(), v.end());\n  if (n == 1)\n    cout << v[0] << \"\\n\";\n  else {\n    long long sum = 0;\n    long long mx = INT_MIN;\n    for (long long i = 1; i < n; i++) {\n      sum += v[i] - (sum + v[i - 1]);\n      mx = max(mx, sum);\n    }\n    cout << mx << \"\\n\";\n  }\n}\nint32_t main() {\n  long long tc = 1;\n  cin >> tc;\n  for (long long t = 1; t <= tc; t++) {\n    solve();\n  }\n  return 0;\n}\n","t = int(input())\n\nfor test in range(t):\n    n = int(input())\n    p = list(map(int,input().split()))\n    if(len(p)==1):\n        print(p[0])\n        continue\n    elif(len(p)==2):\n        print(min(p[0],p[1]))\n        continue\n    ans = 0\n    p.sort()\n    for i in range(len(p)-2,0,-1):\n        ans = max(ans,p[i+1]-p[i])\n    print(ans)\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint p[N];\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> p[i];\n    sort(p, p + n);\n    int ans = p[0];\n    for (int i = 2; i <= n; i++) ans = max(p[i] - p[i - 1], ans);\n    cout << ans << endl;\n  }\n  return 0;\n}\n","import sys, collections, math, bisect, heapq, random, functools\n\ninput = sys.stdin.readline\nout = sys.stdout.flush\n\n\ndef solve():\n    n = int(input())\n    queue = []\n    a = list(map(int, input().split()))\n    va = collections.Counter(a)\n    for v in va:\n        heapq.heappush(queue,[v,va[v]])\n    diff = 0\n    k = len(queue)\n    while k > 1 and queue[0][0] - diff <= 0:\n        cur,cnt = heapq.heappop(queue)\n        cur -= diff\n        diff += cur\n        k -= 1\n    \n    while k > 1 and queue[1][0] - queue[0][0] >= queue[0][0] - diff:\n        cur,cnt = heapq.heappop(queue)\n\n        cur -= diff\n        diff += cur\n        k -= 1\n\n    if queue[0][0] < 0:\n        if queue[0][1] > 1:\n            print(0)\n        else:\n            print(queue[0][0])\n    else:\n        print(queue[0][0] - diff)\n\n\n\n\n\n\nif __name__ == '__main__':\n    for i in range(int(input())):\n        solve()","import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n    \/\/ Graph\n    \/\/ prefix sums\n    \/\/inputs\n    public static void main(String args[])throws Exception{\n        Input sc=new Input();\n        precalculates p=new precalculates();\n        StringBuilder sb=new StringBuilder();\n        int t=sc.readInt();\n        for(int f=0;f<t;f++){\n            int n=sc.readInt();\n            long a[]=sc.readArrayLong();\n            HashSet<Long> map=new HashSet<>();\n            for(int i=0;i<n;i++){\n                map.add(a[i]);\n            }\n            n=map.size();\n            a=new long[n];\n            int j=0;\n            for(Long val:map){\n                a[j++]=val;\n            }\n            Arrays.sort(a);\n            long sum=0;\n            long prev=0;long ans=Long.MIN_VALUE;\n            for(int i=0;i<n-1;i++){\n                sum=sum+((a[i])-prev);\n                ans=Math.max(ans,a[i]-prev);\n                prev=sum;\n            }\n            if(a.length==1)\n                ans=Math.max(ans,a[n-1]-prev);\n\n            if(ans!=Long.MIN_VALUE)\n            sb.append(ans+\"\\n\");\n            else\n                sb.append(a[n-1]+\"\\n\");\n\n        }\n        \/\/ 1 2 7 10   1\n        \/\/ 0 1 6 9    2\n        \/\/ 0 0 5 8\n        \/\/ -1 0 2\n        \/\/ 0  1 3\n        \/\/ 0 0 2\n        System.out.print(sb);\n    }\n}\nclass Input{\n    BufferedReader br;\n    StringTokenizer st;\n    Input(){\n        br=new BufferedReader(new InputStreamReader(System.in));\n        st=new StringTokenizer(\"\");\n    }\n    public int[] readArray() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        int a[]=new int[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Integer.parseInt(st.nextToken());\n        }\n        return a;\n    }\n    public long[] readArrayLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        long a[]=new long[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Long.parseLong(st.nextToken());\n        }\n        return a;\n    }\n    public int readInt() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Integer.parseInt(st.nextToken());\n    }\n    public long readLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Long.parseLong(st.nextToken());\n    }\n    public String readString() throws Exception{\n        return br.readLine();\n    }\n    public int[][] read2dArray(int n,int m)throws Exception{\n        int a[][]=new int[n][m];\n        for(int i=0;i<n;i++){\n            st=new StringTokenizer(br.readLine());\n            for(int j=0;j<m;j++){\n                a[i][j]=Integer.parseInt(st.nextToken());\n            }\n        }\n        return a;\n    }\n}\nclass precalculates{\n    public int[] prefixSumOneDimentional(int a[]){\n        int n=a.length;\n        int dp[]=new int[n];\n        for(int i=0;i<n;i++){\n            if(i==0)\n                dp[i]=a[i];\n            else\n                dp[i]=dp[i-1]+a[i];\n        }\n        return dp;\n    }\n    public int[] postSumOneDimentional(int a[]) {\n        int n = a.length;\n        int dp[] = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            if (i == n - 1)\n                dp[i] = a[i];\n            else\n                dp[i] = dp[i + 1] + a[i];\n        }\n        return dp;\n    }\n    public int[][] prefixSum2d(int a[][]){\n        int n=a.length;int m=a[0].length;\n        int dp[][]=new int[n+1][m+1];\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=m;j++){\n                dp[i][j]=a[i-1][j-1]+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];\n            }\n        }\n        return dp;\n    }\n    public long pow(long a,long b){\n        long mod=1000000007;\n        long ans=0;\n        if(b<=0)\n            return 1;\n        if(b%2==0){\n            ans=pow(a,b\/2)%mod;\n            return ((ans%mod)*(ans%mod))%mod;\n        }else{\n            return ((a%mod)*(ans%mod))%mod;\n        }\n    }\n\n}\nclass GraphInteger{\n    HashMap<Integer,vertex> vtces;\n    class vertex{\n        HashMap<Integer,Integer> children;\n        public vertex(){\n            children=new HashMap<>();\n        }\n    }\n    public GraphInteger(){\n        vtces=new HashMap<>();\n    }\n    public void addVertex(int a){\n        vtces.put(a,new vertex());\n    }\n    public void addEdge(int a,int b,int cost){\n        if(!vtces.containsKey(a)){\n            vtces.put(a,new vertex());\n        }\n        if(!vtces.containsKey(b)){\n            vtces.put(b,new vertex());\n        }\n        vtces.get(a).children.put(b,cost);\n\/\/        vtces.get(b).children.put(a,cost);\n    }\n    public boolean isCyclicDirected(){\n        boolean isdone[]=new boolean[vtces.size()+1];\n        boolean check[]=new boolean[vtces.size()+1];\n        for(int i=1;i<=vtces.size();i++) {\n            if (!isdone[i] && isCyclicDirected(i,isdone, check)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private boolean isCyclicDirected(int i,boolean isdone[],boolean check[]){\n        if(check[i])\n            return true;\n        if(isdone[i])\n            return false;\n        check[i]=true;\n        isdone[i]=true;\n        Set<Integer> set=vtces.get(i).children.keySet();\n        for(Integer ii:set){\n            if(isCyclicDirected(ii,isdone,check))\n                return true;\n        }\n        check[i]=false;\n        return false;\n    }\n}\n\n\n\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nsigned main() {\n  long long test;\n  cin >> test;\n  while (test--) {\n    long long n;\n    cin >> n;\n    vector<long long> a(n);\n    for (long long &x : a) {\n      cin >> x;\n    }\n    sort(a.begin(), a.end());\n    long long sum = 0;\n    long long i = 0;\n    while (i < n - 1 && a[i + 1] >= 2 * a[i] - sum) {\n      sum = a[i];\n      i++;\n    }\n    cout << a[i] - sum << '\\n';\n  }\n  return 0;\n}\n","for _ in range(int(input())):\n  n=int(input())\n  l=list(map(int,input().split()))\n  l.sort()\n  max_min=-99999999\n  s=0\n  for i in range(n):\n    #print(l)\n    x=l.pop(0)-s\n    m=x\n    s+=x\n    max_min=max(max_min,m)\n\n  print(max_min)\n\n\n","for _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    if(n==1 or len(set(a))==1):\n        print(a[0])\n        continue\n    else:\n        a=list(set(a))\n        a.sort()\n        s=a[0]\n        for i in range(1,len(a)):\n            a[i]-=s\n            s+=a[i]\n        print(max(a))","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> list;\n    int max_value = -1;\n    for (int i = 0; i < n; i++) {\n      int temp;\n      cin >> temp;\n      list.push_back(temp);\n    }\n    sort((list).begin(), (list).end());\n    int change = 0;\n    for (int i = 0; i < list.size(); i++) {\n      list[i] = list[i] - change;\n      max_value = max(list[i], max_value);\n      change += list[i];\n    }\n    cout << max_value << '\\n';\n    ;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long a[n];\n    vector<long long> p;\n    for (int i = 0; i <= n - 1; i += 1) {\n      cin >> a[i];\n    }\n    sort(a, a + n);\n    long long k = 0, x = (-1) * 1000000007;\n    for (int i = 0; i <= n - 1; i += 1) {\n      p.push_back(a[i] - k);\n      x = max(x, k);\n      k += a[i];\n    }\n    cout << x << \"\\n\";\n  }\n}\n","#include <bits\/stdc++.h>\n#include <ext\/pb_ds\/assoc_container.hpp>\n#define ll long long\n#define endl '\\n'\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<typename T>\nusing ordered_set =\ntree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\nconst int mod=1e9+7;\n\n\nint main() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin>>t;\n    while(t--){\n        int n;\n        cin>>n;\n        multiset<int>se;\n        for(int i=0;i<n;i++){\n            int x;\n            cin>>x;\n            se.insert(x);\n        }\n        if(n==1){\n            cout<<*se.begin()<<endl;\n            continue;\n        }\n        ll sum=0;\n        ll mi =-2e9;\n        while(!se.empty() && (*se.begin()-sum)>=mi){\n            mi=*se.begin()-sum;\n            sum+=(*se.begin()-sum);\n            se.erase(se.find(*se.begin()));\n        }\n        cout<<mi<<endl;\n    }\n}\n","t = int(input())\nres = []\nfor j in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  minA = [0] * n\n  newA = a.copy()\n  x = 0\n  minA[n - 1] = min(a)\n  x = minA[n - 1]\n  del newA[newA.index(x)]\n  newA = list(map(lambda y: y - x, newA))\n  for i in range(n - 1):\n    minA[n - 2 - i] = max(minA[n - 2 - i + 1], min(newA))\n    if minA[n - 2 - i + 1] <= minA[n - 2 - i]:\n      x = minA[n - 2 - i]\n      if x in newA:\n        del newA[newA.index(x)]\n      newA = list(map(lambda y: y - x, newA))\n    else:\n      break\n  res.append(x)\n\nfor index in range(t):\n  print(res[index])","for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print(a[0])\n    elif a[-1] < 0:\n        print(a[-1] - sum(a[:-1]))\n    else:\n        a.sort()\n        plus = 0\n        for i in range(n):\n            if a[i] < 0:\n                plus -= a[i]\n            else:\n                break\n        a = a[i:]\n        if len(a) == 1:\n            print(a[0] + plus)\n        else:\n            ans1 = min(a)\n            ans = min(a)\n            for i in range(len(a) - 1, -1, -1):\n                ans = max(ans, a[i] - a[i - 1])\n            if ans == ans1:\n                print(ans + plus)\n            else:\n                print(ans)","import java.util.*;\n\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while(t-- >0)\n        {\n            long n = sc.nextLong();\n            TreeSet<Long> s = new TreeSet<>();\n            for (long i = 0; i < n; i++)\n            {\n                s.add(sc.nextLong());\n            }\n            long newn = s.size();\n            long[] ar = new long[(int) newn];\n            long a=0;\n            for(Long val : s)\n            {\n                ar[(int) a++] = val;\n            }\n            long ans = ar[0];\n            for(long i=1; i<newn; i++)\n            {\n                ans = Math.max(ans,ar[(int) i]-ar[(int) (i-1)]);\n            }\n            System.out.println(ans);\n        }\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    long long a;\n    vector<long long> p;\n    for (int i = 0; i <= n - 1; i += 1) {\n      cin >> a;\n      p.push_back(a);\n    }\n    if (p.size() == 1) {\n      cout << p[0] << \"\\n\";\n    } else {\n      sort(p.begin(), p.end());\n      for (int i = 0; i <= n - 2; i += 1) {\n        for (int j = i + 1; j <= n - 1; j += 1) {\n          p[j] -= p[i];\n        }\n      }\n      cout << max(p[n - 2], p[n - 1]) << \"\\n\";\n    }\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nint main() {\n  int tc;\n  cin >> tc;\n  for (; tc--;) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a.rbegin(), a.rend());\n    long long diff = 0;\n    for (; a.size() > 1;) {\n      long long getA = a[a.size() - 2], getB = a.back();\n      if (getA + diff < 2ll * (getB + diff)) break;\n      long long hapus = a.back() + diff;\n      a.pop_back();\n      diff -= hapus;\n    }\n    cout << a.back() + diff << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int maxn = 2 * 1e5 + 10;\nint T;\nint a[maxn], n, ans;\nint main() {\n  cin >> T;\n  for (int i = 1; i <= T; i++) {\n    memset(a, 0, sizeof(a));\n    ans = -1e8;\n    cin >> n;\n    for (int j = 1; j <= n; j++) scanf(\"%d\", &a[j]);\n    sort(a + 1, a + n + 1);\n    for (int j = 1; j <= n; j++) ans = max(a[j] - a[j - 1], ans);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long log_a_to_base_b(long long a, long long b) { return log(a) \/ log(b); }\nbool isPrime(long long n) {\n  if (n == 1) {\n    return false;\n  }\n  long long i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      return false;\n    }\n    i += 1;\n  }\n  return true;\n}\nvector<long long> prime_fact(long long n) {\n  vector<long long> v;\n  for (long long i = 2; i * i <= n; i++)\n    if (n % i == 0) {\n      while (n % i == 0) n \/= i;\n      v.push_back(i);\n    }\n  if (n > 1) v.push_back(n);\n  return v;\n}\nlong long power(long long a, long long n) {\n  long long res = 1;\n  while (n) {\n    if (n % 2)\n      res *= a, n--;\n    else\n      a *= a, n \/= 2;\n  }\n  return res;\n}\nlong long euler_totient(long long n) {\n  long long res = n;\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      res \/= i;\n      res *= (i - 1);\n      while (n % i == 0) n \/= i;\n    }\n  }\n  if (n > 1) res \/= n, res *= (n - 1);\n  return res;\n}\nbool isKthBitSet(long long n, long long k) {\n  if (n & (1 << k))\n    return true;\n  else\n    return false;\n}\nlong long no_of_set_bits(long long n) {\n  long long cnt = 0;\n  while (n > 0) {\n    cnt++;\n    n = n & (n - 1);\n  }\n  return cnt;\n}\nvoid init() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nsigned main() {\n  init();\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> v(n);\n    for (auto &i : v) cin >> i;\n    sort(v.begin(), v.end());\n    if (n == 1) {\n      cout << v[0] << \"\\n\";\n      continue;\n    }\n    if (n == 2) {\n      cout << max(v[0], (v[1] - v[0])) << \"\\n\";\n      continue;\n    }\n    long long ans = 0ll;\n    long long i = 0ll;\n    if (v[0ll] < 0ll) {\n      for (i = 1ll; i < n; i++)\n        if (v[i] < 0ll)\n          continue;\n        else\n          break;\n      i--;\n      ans = (long long)(v[i] - v[0]);\n      i++;\n    }\n    for (; i < n - 1ll; i++) ans = max(ans, (long long)(v[i + 1] - v[i]));\n    cout << (long long)ans << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long int a[n];\n    for (int i = 0; i < n; i++) cin >> a[i];\n    int max;\n    if (n != 1) {\n      sort(a, a + n);\n      max = a[1] - a[0];\n      for (int i = 2; i < n; i++) {\n        if (a[i] - a[i - 1] > max) max = a[i] - a[i - 1];\n      }\n      if (n == 2) {\n        if (a[0] > max) max = a[0];\n      }\n    }\n    if (n == 1) max = a[0];\n    cout << max << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; ++i) cin >> a[i];\n    sort(a, a + n);\n    int ans = 0;\n    for (int i = 1; i < n; ++i) ans = max(ans, a[i] - a[i - 1]);\n    cout << ans << \"\\n\";\n  }\n}\n","import java.util.*;\nimport java.io.*;\n\npublic class C {\n    static StringBuilder sb;\n    static long fact[];\n    static long mod = (long) (1e9 + 7);\n    static int[] arr = { 0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111 };\n\n    static void solve(int[] arr) {\n        if (arr.length == 1) {\n            sb.append(arr[0] + \"\\n\");\n            return;\n        }\n\n        HashSet<Integer> visited = new HashSet<>();\n        ArrayList<Integer> uniqueElements = new ArrayList<>();\n        for (int ele : arr) {\n            if (!visited.contains(ele)) {\n                uniqueElements.add(ele);\n                visited.add(ele);\n            }\n        }\n\n        Collections.sort(uniqueElements);\n\n        long ans = uniqueElements.get(0);\n        for (int i = 0; i < uniqueElements.size() - 1; i++) {\n            long diff = uniqueElements.get(i + 1) - uniqueElements.get(i);\n            ans = Math.max(ans, diff);\n        }\n        sb.append(ans + \"\\n\");\n    }\n\n    public static void main(String[] args) {\n        sb = new StringBuilder();\n        int test = i();\n        while (test-- > 0) {\n            int n = i();\n            int[] arr = readArray(n);\n            solve(arr);\n        }\n        out.printLine(sb);\n        out.flush();\n        out.close();\n\n    }\n\n    \/*\n     * fact=new long[(int)1e6+10]; fact[0]=fact[1]=1; for(int i=2;i<fact.length;i++)\n     * { fact[i]=((long)(i%mod)1L(long)(fact[i-1]%mod))%mod; }\n     *\/\n    \/\/ **************NCR%P******************\n\n    static long p(long x, long y)\/\/ POWER FXN \/\/\n    {\n        if (y == 0)\n            return 1;\n\n        long res = 1;\n        while (y > 0) {\n            if (y % 2 == 1) {\n                res = (res * x) % mod;\n                y--;\n            }\n\n            x = (x * x) % mod;\n            y = y \/ 2;\n\n        }\n        return res;\n    }\n\n    static long ncr(int n, int r) {\n        if (r > n)\n            return (long) 0;\n\n        long res = fact[n] % mod;\n        \/\/ System.out.println(res);\n        res = ((long) (res % mod) * (long) (p(fact[r], mod - 2) % mod)) % mod;\n        res = ((long) (res % mod) * (long) (p(fact[n - r], mod - 2) % mod)) % mod;\n        \/\/ System.out.println(res);\n        return res;\n\n    }\n\n    \/\/ **************END******************\n\n    \/\/ *************Disjoint set\n    \/\/ union*********\/\/\n\n    \/\/ ***************PRIME FACTORIZE\n    \/\/ ***********************************\/\/\n    static TreeMap<Integer, Integer> prime(long n) {\n        TreeMap<Integer, Integer> h = new TreeMap<>();\n        long num = n;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (n % i == 0) {\n                int nt = 0;\n                while (n % i == 0) {\n                    n = n \/ i;\n                    nt++;\n                }\n                h.put(i, nt);\n            }\n        }\n        if (n != 1)\n            h.put((int) n, 1);\n        return h;\n\n    }\n\n    \/\/ *****CLASS PAIR\n    \/\/ *************************************************\n    static class Pair implements Comparable<Pair> {\n        int x;\n        long y;\n\n        Pair(int x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Pair o) {\n            return (int) (this.y - o.y);\n\n        }\n\n    }\n    \/\/ *****CLASS PAIR\n    \/\/ ***************************************************\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int Int() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String String() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return String();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void flush() {\n            writer.flush();\n        }\n    }\n\n    static InputReader in = new InputReader(System.in);\n    static OutputWriter out = new OutputWriter(System.out);\n\n    public static long[] sortlong(long[] a2) {\n        int n = a2.length;\n        ArrayList<Long> l = new ArrayList<>();\n        for (long i : a2)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < l.size(); i++)\n            a2[i] = l.get(i);\n        return a2;\n    }\n\n    public static int[] sortint(int[] a2) {\n        int n = a2.length;\n        ArrayList<Integer> l = new ArrayList<>();\n        for (int i : a2)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < l.size(); i++)\n            a2[i] = l.get(i);\n        return a2;\n    }\n\n    public static long pow(long x, long y) {\n        long res = 1;\n        while (y > 0) {\n            if (y % 2 != 0) {\n                res = (res * x);\/\/ % modulus;\n                y--;\n\n            }\n            x = (x * x);\/\/ % modulus;\n            y = y \/ 2;\n        }\n        return res;\n    }\n\n    \/\/ GCD___+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n    public static long gcd(long x, long y) {\n        if (x == 0)\n            return y;\n        else\n            return gcd(y % x, x);\n    }\n    \/\/ ******LOWEST COMMON MULTIPLE\n    \/\/ *********************************************\n\n    public static long lcm(long x, long y) {\n        return (x * (y \/ gcd(x, y)));\n    }\n\n    \/\/ INPUT\n    \/\/ PATTERN********************************************************\n    public static int i() {\n        return in.Int();\n    }\n\n    public static long l() {\n        String s = in.String();\n        return Long.parseLong(s);\n    }\n\n    public static String s() {\n        return in.String();\n    }\n\n    public static int[] readArray(int n) {\n        int A[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            A[i] = i();\n        }\n        return A;\n    }\n\n    public static long[] readArray(long n) {\n        long A[] = new long[(int) n];\n        for (int i = 0; i < n; i++) {\n            A[i] = l();\n        }\n        return A;\n    }\n\n}","t=int(input())\nfor i in range(t) :\n    n=int(input())\n    araye=input().split()\n    for ii in range(n) :\n        araye[ii]=int(araye[ii])\n    araye.sort()\n    mini=araye[0]\n    while (len(araye) > 1) :\n        if (mini >(araye[1]-araye[0])) and araye[0] >= 0:\n            break\n        adad=araye[0]\n        for j in range (len(araye)) :\n            araye[j]= araye[j] - adad\n        araye.pop(0)\n        araye.sort()\n        if mini< araye[0] :\n            mini=araye[0]    \n    if mini< araye[0] :\n            mini=araye[0]\n    print(mini)\n\n","import java.io.*;\nimport java.util.*;\n\npublic class CodeForces{\n    \/*-------------------------------------------EDITING CODE STARTS HERE-------------------------------------------*\/\n    public static void main(String[] args) throws IOException{\n        openIO();\n        int testCase = 1;\n        testCase = sc.nextInt();\n        preCompute();\n        for (int i = 1; i <= testCase; i++) solve(i);\n        closeIO();\n    }\n\n    public static void solve(int tCase)throws IOException {\n        int n = sc.nextInt();\n        long[] arr = new long[n];\n        for(int i=0;i<n;i++)arr[i] = sc.nextInt();\n        if(n==1){\n            out.println(arr[0]);\n            return;\n        }\n        Arrays.sort(arr);\n        long adder = 0;\n        long max = -inf_long;\n        int i = 0;\n        for(;i<n;i++){\n            long curr = arr[i] + adder;\n            if(curr<=0) {\n                max = Math.max(max, curr);\n                adder += -arr[i];\n            }else break;\n        }\n        if(i<n)max = Math.max(max,arr[i]+adder);\n        i++;\n        for(;i<n;i++){\n            long curr = arr[i] + adder;\n            long prev = arr[i-1]  + adder;\n            if(curr - prev>=prev)max = Math.max(max,curr - prev);\n            else break;\n        }\n        out.println(max);\n    }\n\n\n    private static void  preCompute(){\n\n    }\n    \/*-------------------------------------------EDITING CODE ENDS HERE-------------------------------------------*\/\n    static FastestReader sc;\n    static PrintWriter out;\n    private static void openIO() throws IOException{\n        sc = new FastestReader();\n        out = new PrintWriter(System.out);\n    }\n\n    \/*------------------------------------------HELPER FUNCTION STARTS HERE------------------------------------------*\/\n\n    public static final int mod = (int) 1e9 +7;\n    private static final int mod2 =  998244353;\n    public static final int inf_int = (int) 2e9;\n    public static  final long inf_long = (long) 4e18;\n\n    \/\/ euclidean algorithm time O(max (loga ,logb))\n    public static long _gcd(long a, long b) {\n        if (a == 0)\n            return b;\n        return _gcd(b % a, a);\n    }\n\n    public static long _lcm(long a, long b) {\n        \/\/ lcm(a,b) * gcd(a,b) = a * b\n        return (a \/ _gcd(a, b)) * b;\n    }\n\n\n    \/\/ binary exponentiation time O(logn)\n    public static long _power(long x, long n) {\n        long ans = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ans *= x;\n                ans %= mod;\n                n--;\n            } else {\n                x *= x;\n                x %= mod;\n                n >>= 1;\n            }\n        }\n        return ans;\n    }\n    \/\/sieve\/first divisor time : O(mx * log ( log (mx) ) )\n    public static int[]  _seive(int mx){\n        int[] firstDivisor = new int[mx+1];\n        for(int i=0;i<=mx;i++)firstDivisor[i] = i;\n        for(int i=2;i*i<=mx;i++)\n            if(firstDivisor[i] == i)\n                for(int j = i*i;j<=mx;j+=i)\n                    firstDivisor[j] = i;\n        return firstDivisor;\n    }\n\n    private static boolean _isPrime(long x){\n        for(long i=2;i*i<=x;i++)\n            if(x%i==0)return false;\n        return true;\n    }\n\n\n    \/*------------------------------------------HELPER FUNCTION ENDS HERE-------------------------------------------*\/\n\n    \/*-------------------------------------------FAST INPUT STARTS HERE---------------------------------------------*\/\n\n    public static void closeIO() throws IOException{\n        out.flush();\n        out.close();\n        sc.close();\n    }\n    private static final class FastestReader {\n        private static final int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public FastestReader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public FastestReader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\n        private int skip() throws IOException {\n            int b;\n            \/\/noinspection StatementWithEmptyBody\n            while ((b = read()) != -1 && isSpaceChar(b)) {}\n            return b;\n        }\n\n        public String next() throws IOException {\n            int b = skip();\n            final StringBuilder sb = new StringBuilder();\n            while (!isSpaceChar(b)) { \/\/ when nextLine, (isSpaceChar(b) && b != ' ')\n                sb.appendCodePoint(b);\n                b = read();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) { c = read(); }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') { c = read(); }\n            final boolean neg = c == '-';\n            if (neg) { c = read(); }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') { c = read(); }\n            final boolean neg = c == '-';\n            if (neg) { c = read(); }\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') \/ (div *= 10);\n                }\n            }\n\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) { buffer[0] = -1; }\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) { fillBuffer(); }\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            din.close();\n        }\n    }\n    \/*---------------------------------------------FAST INPUT ENDS HERE ---------------------------------------------*\/\n}","#include <bits\/stdc++.h>\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define drep(i,j,n) for(int i=0;i<(int)(n-1);i++)for(int j=i+1;j<(int)(n);j++)\n#define trep(i,j,k,n) for(int i=0;i<(int)(n-2);i++)for(int j=i+1;j<(int)(n-1);j++)for(int k=j+1;k<(int)(n);k++)\n#define codefor int test;scanf(\"%d\",&test);while(test--)\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define yes(ans) if(ans)printf(\"yes\\n\");else printf(\"no\\n\")\n#define Yes(ans) if(ans)printf(\"Yes\\n\");else printf(\"No\\n\")\n#define YES(ans) if(ans)printf(\"YES\\n\");else printf(\"NO\\n\")\n#define popcount(v) __builtin_popcount(v)\n#define vector1d(type,name,...) vector<type>name(__VA_ARGS__)\n#define vector2d(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define vector3d(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\nusing namespace std;\nusing ll = long long;\ntemplate<class T>using rpriority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD=1000000007;\nconst int MOD2=998244353;\nconst int INF=1<<30;\nconst ll INF2=(ll)1<<60;\n\/\/\u5165\u529b\u7cfb\nvoid scan(int& a){scanf(\"%d\",&a);}\nvoid scan(long long& a){scanf(\"%lld\",&a);}\ntemplate<class T,class L>void scan(pair<T, L>& p){scan(p.first);scan(p.second);}\ntemplate<class T> void scan(T& a){cin>>a;}\ntemplate<class T> void scan(vector<T>& vec){for(auto&& it:vec)scan(it);}\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){scan(head);in(tail...);}\n\/\/\u51fa\u529b\u7cfb\nvoid print(const int& a){printf(\"%d\",a);}\nvoid print(const long long& a){printf(\"%lld\",a);}\nvoid print(const double& a){printf(\"%.15lf\",a);}\ntemplate<class T,class L>void print(const pair<T, L>& p){print(p.first);putchar(' ');print(p.second);}\ntemplate<class T> void print(const T& a){cout<<a;}\ntemplate<class T> void print(const vector<T>& vec){if(vec.empty())return;print(vec[0]);for(auto it=vec.begin();++it!= vec.end();){putchar(' ');print(*it);}}\nvoid out(){putchar('\\n');}\ntemplate<class T> void out(const T& t){print(t);putchar('\\n');}\ntemplate <class Head, class... Tail> void out(const Head& head,const Tail&... tail){print(head);putchar(' ');out(tail...);}\n\/\/\u30c7\u30d0\u30c3\u30b0\u7cfb\ntemplate<class T> void dprint(const T& a){cerr<<a;}\ntemplate<class T> void dprint(const vector<T>& vec){if(vec.empty())return;cerr<<vec[0];for(auto it=vec.begin();++it!= vec.end();){cerr<<\" \"<<*it;}}\nvoid debug(){cerr<<endl;}\ntemplate<class T> void debug(const T& t){dprint(t);cerr<<endl;}\ntemplate <class Head, class... Tail> void debug(const Head& head, const Tail&... tail){dprint(head);cerr<<\" \";debug(tail...);}\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b \/= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b \/= 2; } return ans; }\nll modinv(ll a, ll m) {ll b = m, u = 1, v = 0;while (b) {ll t = a \/ b;a -= t * b; swap(a, b);u -= t * v; swap(u, v);}u %= m;if (u < 0) u += m;return u;}\nll updivide(ll a,ll b){if(a%b==0) return a\/b;else return (a\/b)+1;}\ntemplate<class T> void chmax(T &a,const T b){if(b>a)a=b;}\ntemplate<class T> void chmin(T &a,const T b){if(b<a)a=b;}\n\nnamespace internal {\nconstexpr long long safe_mod(long long x, long long m) {x %= m;if (x < 0) x += m;return x;}\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n    explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) \/ m + 1) {}\n    unsigned int umod() const { return _m; }\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned long long)(z)*im));\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d \/= 2;\n    constexpr long long bases[3] = {2, 7, 61};\n    for (long long a : bases) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {y = y * y % n;t <<= 1;}\n        if (y != n - 1 && t % 2 == 0) {return false;}\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n    while (t) {long long u = s \/ t;s -= t * u;m0 -= m1 * u;auto tmp = s;s = t;t = tmp;tmp = m0;m0 = m1;m1 = tmp;}\n    if (m0 < 0) m0 += b \/ s;\n    return {s, m0};\n}\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) \/ 2;\n    while (x % 2 == 0) x \/= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {divs[cnt++] = i;while (x % i == 0) {x \/= i;}}\n    }\n    if (x > 1) {divs[cnt++] = x;}\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) \/ divs[i], m) == 1) {ok = false;break;}\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\nunsigned long long floor_sum_unsigned(unsigned long long n,unsigned long long m,unsigned long long a,unsigned long long b) {\n    unsigned long long ans = 0;\n    while (true) {\n        if (a >= m) {ans += n * (n - 1) \/ 2 * (a \/ m);a %= m;}\n        if (b >= m) {ans += n * (b \/ m);b %= m;}\n        unsigned long long y_max = a * n + b;\n        if (y_max < m) break;\n        n = (unsigned long long)(y_max \/ m);\n        b = (unsigned long long)(y_max % m);\n        std::swap(m, a);\n    }\n    return ans;\n}\ntemplate <class T> using is_integral = typename std::is_integral<T>;\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\ntemplate <class T> using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\ntemplate <class T> using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n}  \/\/ namespace internal\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {mint x;x._v = v;return x;}\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();_v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {_v = (unsigned int)(v % umod());}\n    unsigned int val() const { return _v; }\n    mint& operator++() {_v++;if (_v == umod()) _v = 0;return *this;}\n    mint& operator--() {if (_v == 0) _v = umod();_v--;return *this;}\n    mint operator++(int) {mint result = *this;++*this;return result;}\n    mint operator--(int) {mint result = *this;--*this;return result;}\n    mint& operator+=(const mint& rhs) {_v += rhs._v;if (_v >= umod()) _v -= umod();return *this;}\n    mint& operator-=(const mint& rhs) {_v -= rhs._v;if (_v >= umod()) _v += umod();return *this;}\n    mint& operator*=(const mint& rhs) {unsigned long long z = _v;z *= rhs._v;_v = (unsigned int)(z % umod());return *this;}\n    mint& operator\/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {assert(0 <= n);mint x = *this, r = 1;while (n) {if (n & 1) r *= x;x *= x;n >>= 1;}return r;}\n    mint inv() const {if (prime) {assert(_v);return pow(umod() - 2);} else {auto eg = internal::inv_gcd(_v, m);assert(eg.first == 1);return eg.second;}}\n    friend mint operator+(const mint& lhs, const mint& rhs) {return mint(lhs) += rhs;}\n    friend mint operator-(const mint& lhs, const mint& rhs) {return mint(lhs) -= rhs;}\n    friend mint operator*(const mint& lhs, const mint& rhs) {return mint(lhs) *= rhs;}\n    friend mint operator\/(const mint& lhs, const mint& rhs) {return mint(lhs) \/= rhs;}\n    friend bool operator==(const mint& lhs, const mint& rhs) {return lhs._v == rhs._v;}\n    friend bool operator!=(const mint& lhs, const mint& rhs) {return lhs._v != rhs._v;}\n    \/\/\u81ea\u5206\u3067\u52a0\u3048\u305f\u3082\u306e\n    friend istream& operator>>(istream& os,mint& rhs) noexcept {\n        long long v;\n        rhs = mint{(os >> v, v)};\n        return os;\n    }\n    friend constexpr ostream& operator << (ostream &os, const mint& rhs) noexcept {\n        return os << rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\nusing mint=static_modint<1000000007>;\nusing mint2=static_modint<998244353>;\n\nint main(){\n    codefor{\n        INT(n);\n        deque<ll> a(n);\n        rep(i,n)in(a[i]);\n        sort(all(a));\n        ll sumv=0;\n        \/*rep(i,n){\n            if(i)cerr<<' ';\n            cerr<<a[i];\n        }\n        cerr<<endl;*\/\n        while(a.size()>=2){\n            \/*rep(i,a.size()){\n                if(i)cerr<<' ';\n                cerr<<sumv+a[i];\n            }\n            cerr<<endl;*\/\n            if(sumv+a[1]-(sumv+a[0])>=sumv+a[0]){\n                sumv-=sumv+a[0];\n                a.pop_front();\n            }else break;\n        }\n        ll ans=sumv+a[0];\n        for(int i=1;i<a.size();i++){\n            chmax(ans,sumv+a[0]-(sumv+a[1]));\n        }\n        out(ans);\n    }\n}","t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input().split()\n    for j in range(n):\n        s[j] = int(s[j])\n    s.sort()\n    hieu = 0\n    res = s[0]\n    for i in range(1,n):\n        if (s[i-1]<0) or (s[i]-hieu-s[i-1]>=s[i-1]):\n            s[i] = s[i] - hieu -s[i-1]\n            hieu+=s[i-1]\n            res =  s[i]\n        else:\n            break\n    print(res)","import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.lang.*;\nimport static java.lang.Math.*;\n\n\/\/ Sachin_2961 submission \/\/\npublic class Codeforces {\n\n    static void solve(){\n        int n = fs.nInt();\n        int[]ar = new int[n];\n        for(int i=0;i<n;i++)\n            ar[i] = fs.nInt();\n\n        Arrays.sort(ar);\n        long d = ar[0];\n        long ans = ar[0];\n        for(int i=1;i<n;i++){\n\n            if( ar[i] - d < ans ){\n                break;\n            }\n            ans = ar[i] - d;\n            d = d + (ar[i] - d);\n        }\n        out.println(ans);\n    }\n    \n    static class Pair{\n        int f,s;\n        Pair(int f,int s){\n            this.f = f;\n            this.s = s;\n        }\n    }\n    static boolean multipleTestCase = true;\n    static FastScanner fs;\n    static PrintWriter out;\n    public static void main(String[]args){\n       try{\n           out = new PrintWriter(System.out);\n           fs = new FastScanner();\n           int tc = multipleTestCase?fs.nInt():1;\n           while (tc-->0)solve();\n           out.flush();\n           out.close();\n       }catch (Exception e){\n           e.printStackTrace();\n       }\n    }\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String n() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        String Line()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        int nInt() {return Integer.parseInt(n()); }\n        long nLong() {return Long.parseLong(n());}\n        double nDouble(){return Double.parseDouble(n());}\n        int[]aI(int n){\n            int[]ar = new int[n];\n            for(int i=0;i<n;i++)\n                ar[i] = nInt();\n            return ar;\n        }\n    }\n    public static void sort(int[] arr){\n        ArrayList<Integer> ls = new ArrayList<Integer>();\n        for(int x: arr)\n            ls.add(x);\n        Collections.sort(ls);\n        for(int i=0; i < arr.length; i++)\n            arr[i] = ls.get(i);\n    }\n    public static void sort(long[] arr){\n        ArrayList<Long> ls = new ArrayList<>();\n        for(long x: arr)\n            ls.add(x);\n        Collections.sort(ls);\n        for(int i=0; i < arr.length; i++)\n            arr[i] = ls.get(i);\n    }\n}","from heapq import heapify,heappush,heappop,heappushpop\nfrom collections import defaultdict as dd, deque as dq,Counter as C\nfrom math import factorial as f ,ceil,gcd,sqrt,log\nfrom bisect import bisect_left as bl ,bisect_right as br\nfrom itertools import combinations as c,permutations as p\nfrom math import factorial as f ,ceil,gcd,sqrt,log\nfrom sys import stdin\ninput = stdin.readline\nmp = lambda : map(int,input().split())\nit = lambda: int(input())\nls = lambda : list(input().strip().split())\nmt = lambda  r : [ ls() for _ in range(r)]\nlcm = lambda a,b : (a*b)\/\/gcd(a,b)\n\nfor _ in range(it()):\n\ta = it()\n\tb = list(mp())\n\tb.sort()\n\tif len(b)==1:\n\t\tprint(b[0])\n\t\tcontinue\n\tprev = 0\n\tans =None\n\tfor i in range(a):\n\t\tprev+=b[i]\n\t\tif i!=a-1:\n\t\t\tif (b[i+1]-prev)<b[i]:\n\t\t\t\tans = b[i]\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tb[i+1]-=prev\n\n\tif ans ==None :\n\t\tprint(b[-1])\n\telse:\n\t\tprint(ans)","\n\ndef solve(a, n):\n    a.sort()\n    a = a[::-1]\n    c = a[-1]\n    #print(a)\n    while True:\n        if len(a) == 1 or (a[0] - a[-1]) < a[-1]:\n            return c\n        else:\n            r = a.pop()\n            c = a[-1] - r\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(a, n))","\/\/ package MyPackage;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br=new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next(){\n            while(st==null || !st.hasMoreTokens()){\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt(){\n            return Integer.parseInt(next());\n        }\n        long nextLong(){\n            return Long.parseLong(next());\n        }\n        double nextDouble(){\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String str=\"\";\n            try {\n                str=br.readLine().trim();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static class FastWriter {\n\t\tprivate final BufferedWriter bw;\n\n\t\tpublic FastWriter() {\n\t\t\tthis.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t}\n\n\t\tpublic void print(Object object) throws IOException {\n\t\t\tbw.append(\"\" + object);\n\t\t}\n\n\t\tpublic void println(Object object) throws IOException {\n\t\t\tprint(object);\n\t\t\tbw.append(\"\\n\");\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbw.close();\n\t\t}\n\t}\n    public static void main(String[] args)\n    {\n        try {\n            FastReader in=new FastReader();\n            FastWriter out = new FastWriter();\n            StringBuilder sb = new StringBuilder();\n            int testCases=in.nextInt();\n            while(testCases-- > 0) {\n                \/\/ write code here\n            \tint n = in.nextInt();\n            \tArrayList<Long> a = new ArrayList<>();\n            \tfor(int i = 0; i < n; i++)\n            \t{\n            \t\ta.add(in.nextLong());\n            \t}\n            \tlong ans = 0;\n            \tif(a.size() == 1)\n            \t\tans = a.get(0);\n            \telse\n            \t{\n\t            \tCollections.sort(a);\n\t            \tlong min = 0;\n\t            \twhile(a.size() > 1)\n\t            \t{\n\t            \t\tmin = a.remove(0);\n\t\t            \tfor(int i = 0; i < a.size() ; i++)\n\t\t            \t{\n\t\t            \t\tlong val = a.get(i);\n\t\t            \t\tval = val - min;\n\t\t            \t\ta.set(i, val);\n\t\t            \t}\n\t            \t}\n\t            \tans = Math.max(min, a.get(0));\n            \t}\n        \t\tsb.append(ans + \"\\n\");\n            }\n            out.println(sb);\n            out.close();\n        } catch (Exception e) {\n            return;\n        }\n    }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t;\n  scanf(\"%lld\", &t);\n  while (t--) {\n    long long n;\n    scanf(\"%lld\", &n);\n    vector<long long> v(n);\n    for (long long i = 0; i < n; i++) {\n      scanf(\"%lld\", &v[i]);\n    }\n    sort(v.begin(), v.end());\n    long long kuota = (-1) * v[0], minim = v[0];\n    for (long long i = 1; i < n; i++) {\n      if (v[i] + kuota >= minim) {\n        minim = v[i] + kuota;\n        kuota -= minim;\n      }\n    }\n    printf(\"%lld\\n\", minim);\n  }\n  return 0;\n}\n","# t = int(input())\n\n# while t>0:\n#     n = int(input())\n#     a = list(map(int, input().split()))\n#     a.sort()\n#     for index in range(n-1):\n#         print(a)\n#         a[index+1]-=(a[index]*(n-index-1-1))\n#     print(a)\n#     print(a[-1])\n#     t-=1\n\nfrom heapq import heapify, heappush, heappop\n\nt = int(input())\n\nwhile t>0:\n    n = int(input())\n    a = list(map(int, input().split()))\n    heapify(a)\n    min = a[0]\n    for i in range(n-1):\n        e = heappop(a)\n        if e>min:\n            min = e\n        for j in range(n-i-1):\n            a[j]-=e\n        heapify(a)\n    print(min)\n    t-=1","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long MAXN = 2e5 + 10;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e18;\nlong long a[MAXN];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long mx = 0;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      mx = max(mx, a[i]);\n    }\n    sort(a, a + n);\n    int p = 0;\n    if (a[0] < 0 && p < n - 1) {\n      for (int i = 1; i < n; i++) a[i] -= a[0];\n      p++;\n    }\n    mx -= a[0];\n    long long s = 0;\n    while (p < n - 1 && a[p] - s < mx - s - a[p]) {\n      s += a[p] - s;\n      p++;\n    }\n    cout << a[p] - s << endl;\n  }\n  return 0;\n}\n","import sys, collections, math, bisect, heapq, random, functools\n\ninput = sys.stdin.readline\nout = sys.stdout.flush\n\n\ndef solve():\n    n = int(input())\n    queue = []\n    a = list(map(int, input().split()))\n    va = collections.Counter(a)\n    for v in va:\n        heapq.heappush(queue,[v,va[v]])\n    diff = 0\n    k = len(queue)\n    while k > 1 and queue[0][0] - diff <= 0:\n        cur,cnt = heapq.heappop(queue)\n        cur -= diff\n        diff += cur\n        k -= 1\n\n    flag = 1\n    ans = -1\n    while k > 1:\n        minv,cnt = heapq.heappop(queue)\n        k -= 1\n        if queue[0][0] - minv >= minv - diff:\n            cur,cnt1 = queue[0][0],queue[0][1]\n            cur -= diff\n            diff += minv - diff\n        else:\n            flag = 0\n            ans = minv - diff\n            break\n\n    if not flag:\n        print(ans)\n    else:\n        if queue[0][0] - diff < 0:\n           if queue[0][1] > 1:\n              print(0)\n           else:\n              print(queue[0][0])\n        else:\n           print(queue[0][0] - diff)\n\n\n\n\n\n\nif __name__ == '__main__':\n    for i in range(int(input())):\n        solve()","import sys\ninput = lambda: sys.stdin.readline().rstrip()\nsys.setrecursionlimit(10**5)\nINF = 10**18\n\nimport heapq  # heapq\u30e9\u30a4\u30d6\u30e9\u30ea\u306eimport\ndef solve():\n    N = int(input())\n    A = list(map(int,input().split()))\n    if N == 1:\n        print(A[0])\n        return\n\n    heapq.heapify(A)\n    cnt = 1\n    ans = heapq.heappop(A)\n    add = ans\n    while cnt < N+1:\n        n = heapq.heappop(A)        \n        cnt += 1\n        ans = max(ans, n-add)\n        add += n-add\n        cnt += 1\n        # print(n,add,ans)\n    \n    print(ans)\n\nQ = int(input())\nfor _ in range(Q):\n    solve()\n\n","\/\/ Author - Vedant Valsangkar\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits\/stdc++.h>\n#include<ext\/pb_ds\/assoc_container.hpp>\n#include<ext\/pb_ds\/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate<class T> using ordered_set = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long              ll;\ntypedef long double            ld;\n#define int                    long long\n#define rep(i,s,e)             for(ll i=s; i<e; i++)\n#define repr(i,s,e)            for(ll i=s; i>=e; i--)\n#define in(a)                  for(auto &i : a) cin>>i\n#define out(a)                 for(auto &i : a) cout<<i<<\" \"; cout<<endl\n#define uniq(a)                a.erase(unique(all(a)),a.end())\n#define all(a)                 a.begin(),a.end()\n#define allr(a)                a.rbegin(),a.rend()\n#define endl                   '\\n'\n\nbool per_square(ld a) { if(a<0) return 0; ll sr = sqrt(a); return (sr*sr == a); }\nbool is_prime(ll x) { rep(i,2,sqrt(x)+1) if(x%i == 0) return 0; return 1; }\nint xor_1ton(int n){ int a[4] = {n,1,n+1,0}; return a[n%4];}\ntemplate<typename T>bool is_pali(T a){ int n=a.size(); rep(i,0,n\/2) { if(a[i]!=a[n-i-1])return 0;} return 1;}\n\nvoid solve()\n{\n    int n,x; cin>>n; deque<int> a; rep(i,0,n) {cin>>x; a.push_back(x);}\n    sort(all(a)); n=a.size();\n    int cur=0,ans=INT_MIN;\n    while(a.size()>1 and a.front()!=a.back()) {\n        x=a.front(); a.pop_front();\n        int y=x-cur; ans=max(ans,y);\n        cur+=y;\n    }\n    cout<<max(ans,a[0]-cur)<<endl;\n}   \n\nsigned main()\n{\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    \/\/ sieve();\n    int tc = 1;\n    cin>>tc;\n    for(int t=1;t<=tc;t++)\n    {\n        \/\/ cout << \"Case #\" << t << \": \";\n        solve();\n    }\n    return 0;\n}","import java.io.*;\nimport java.util.*;\n\n\/**\n * -----------------|___________|---------------------\n * CCCCCCCCC   OOOOOOOOOO   DDDDDDDD      EEEEEEEEE\n * CCCC        OOO    OOO   DD    DDD     EEEE\n * CCCC        OOO    OOO   DD     DDD    EEEEEEEEEE\n * CCCC        OOO    OOO   DD     DDDD   EEEE\n * CCCCCCCCC   OOOOOOOOOO   DDDDDDDDDDDD  EEEEEEEEEE\n * -----------------|___________|---------------------\n *\/\n\npublic class Main {\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter sout = new PrintWriter(outputStream);\n\n        int t = in.nextInt();\n        while (t-- > 0) {\n            int n = in.nextInt();\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = in.nextLong();\n            }\n            Arrays.sort(arr);\n            long max = arr[0];\n            if (arr.length > 1) {\n                for (int i = 1; i < n - 1; i++) {\n                    long var = arr[i + 1] - arr[i];\n                    if (max < var) {\n                        max = var;\n                    }\n                }\n            }\n            sout.println(max);\n        }\n        sout.close();\n    }\n\n    private static boolean checkPrime(long n) {\n        for (long i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return n >= 2;\n    }\n\n    public static List<Integer> getPrimesList(int N) {\n        boolean[] isComposite = new boolean[N + 1];\n        for (int i = 2; i <= N; i++) {\n            if (isComposite[i])\n                continue;\n            for (int j = i * 2; j <= N; j += i)\n                isComposite[j] = true;\n        }\n        List<Integer> numbers = new ArrayList<>();\n        for (int i = 2; i <= N; i++)\n            if (!isComposite[i])\n                numbers.add(i);\n        return numbers;\n    }\n\n    static class Node {\n        int value;\n        \/\/List<Town> edges = new ArrayList<>();\n\n        public Node(int value) {\n            this.value = value;\n        }\n    }\n\n    public static int binarySearch(long[] array, long value) {\n        int left = 0, right = array.length - 1;\n        while (left <= right) {\n            int m = (left + right) \/ 2;\n            if (array[m] == value)\n                return m;\n            else if (array[m] < value)\n                left = m + 1;\n            else\n                right = m - 1;\n        }\n        return -1;\n    }\n\n    public static int gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static void sort(int[] a) {\n        ArrayList<Integer> l = new ArrayList<>();\n        for (int i : a)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n\n    private static int upperBound(int[] a, int low, int high, int element) {\n        while (low < high) {\n            int middle = low + (high - low) \/ 2;\n            if (a[middle] > element)\n                high = middle;\n            else\n                low = middle + 1;\n        }\n        return low;\n    }\n\n    public static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String nextToken() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}","for _ in range(int(input())):\n    l = int(input())\n    a = input().split()\n    t = 0\n    for i in range(len(a)):\n        a[i] = int(a[i])\n    if len(a) == 1:\n        print(a[0])\n        continue\n\n    a.sort()\n\n    if a[0] <= 0:\n        t -= a[0]\n        del a[0]\n\n    if len(a) == 1:\n        print(a[0] + t)\n        continue\n    m = a[0]\n    for i in range(len(a) - 1):\n        m = max(m,a[i+1] - a[i])\n\n    print(m)\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint p[N];\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> p[i];\n    sort(p, p + n);\n    int ans = p[1];\n    for (int i = 2; i <= n; i++) ans = max(p[i] - p[i - 1], ans);\n    cout << ans << endl;\n  }\n  return 0;\n}\n","import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\npublic class Main\n{\n\tstatic String shengxiao[] =\n\t{ \"rat\", \"ox\", \"tiger\", \"rabbit\", \"dragon\", \"snake\", \"horse\", \"goat\", \"monkey\", \"rooster\", \"dog\", \"pig\" };\n\tstatic String shengxiaoo[] =\n\t{ \"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Goat\", \"Monkey\", \"Rooster\", \"Dog\", \"Pig\" };\n\tstatic int month[] =\n\t{ 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\tstatic int zhong[] =\n\t{ -1, 1, 0, 0, -1, -1, 1, 1 };\n\tstatic int heng[] =\n\t{ 0, 0, -1, 1, -1, 1, -1, 1 };\n\tstatic int zhongg[] =\n\t{ -1, -1, 0, 1, 1, 1, 0, -1 };\n\tstatic int hengg[] =\n\t{ 0, 1, 1, 1, 0, -1, -1, -1 };\n\tstatic int inf = Integer.MAX_VALUE;\n\tstatic long inff = Long.MAX_VALUE;\n\n\tstatic int mod = (int) 998244353;\n\tstatic int N = (int) 36 + 10;\n\tstatic int M = (int) 1e6 + 10;\n\n\tstatic void init()\n\t{\n\n\t}\n\n\t\/\/ static boolean is(int x)\n\tstatic boolean is()\n\t{\n\n\t\treturn true;\n\t}\n\n\t\/\/ static void solve(String s)\n\t\/\/ static void solve(int n)\n\t\/\/ static void solve(long n)\n\tstatic void solve()\n\t{\n\t\tint n = sc.nextInt();\n\t\tlong shu[] = new long[n + 10];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tshu[i] = sc.nextLong();\n\t\tif (n == 1)\n\t\t{\n\t\t\tout.println(shu[1]);\n\t\t\treturn;\n\t\t}\n\n\t\tlong max = Integer.MIN_VALUE;\n\n\t\tArrays.sort(shu, 1, n + 1);\n\t\tlong yuan = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tlong a = shu[i] - yuan;\n\t\t\tmax = Math.max(max, a);\n\t\t\tyuan += a;\n\t\t}\n\t\tout.println(max);\n\n\t}\n\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tinit();\n\n\/\/\t\twhile (sc.hasNext())\n\t\t{\n\t\t\tint t = 1;\n\/\/\t\t\tint t = sc.nextInt();\n\t\t\tfor (int x = 1; x <= t; x++)\n\/\/\t\t\t\tsolve();\n\t\t\t{\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tLong[] a = new Long[n];\n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\ta[i] = sc.nextLong();\n\t\t\t\tif (n == 1)\n\t\t\t\t\tout.println(a[0]);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tArrays.sort(a);\n\t\t\t\t\tlong ans = a[1] - a[0];\n\t\t\t\t\tfor (int i = 2; i < n; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tans = Math.max(ans, a[i] - a[i - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tout.println(Math.max(ans, a[0]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/\/ String s = sc.next();\n\t\t\t\/\/ solve(s);\n\n\t\t\tout.flush();\n\t\t}\n\n\t\tout.close();\n\t}\n\n\tstatic InputStream inputStream = System.in;\n\tstatic InputReader sc = new InputReader(inputStream);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic class InputReader\n\t{\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next()\n\t\t{\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tboolean hasNext()\n\t\t{\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (Exception e)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t\t\/\/ TODO: handle exception\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic String nextLine()\n\t\t{\n\t\t\tString str = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstr = reader.readLine();\n\t\t\t} catch (IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tpublic int nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic Double nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic BigInteger nextBigInteger()\n\t\t{\n\t\t\treturn new BigInteger(next());\n\t\t}\n\n\t\tpublic BigDecimal nextBigDecimal()\n\t\t{\n\t\t\treturn new BigDecimal(next());\n\t\t}\n\n\t}\n\n}","for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print(a[0])\n    else:\n        a.sort()\n        plus = 0\n        for i in range(n):\n            if a[i] < 0:\n                plus -= a[i]\n            else:\n                break\n        a = a[i:]\n        if len(a) == 1:\n            print(a[0] + plus)\n        else:\n            ans = min(a)\n            for i in range(len(a) - 1, -1, -1):\n                ans = max(ans, a[i] - a[i - 1])\n            print(ans)","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int tc;\n  cin >> tc;\n  while (tc--) {\n    int n;\n    cin >> n;\n    int arr[n];\n    for (int &x : arr) cin >> x;\n    sort(arr, arr + n);\n    int maximal_min = arr[0], decr = arr[0];\n    for (int i = 1; i < n; i++) {\n      arr[i] -= decr;\n      decr += arr[i];\n      maximal_min = max(arr[i - 1], arr[i]);\n    }\n    cout << maximal_min << '\\n';\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> v(n);\n    long long mi = INT_MAX;\n    long long ma = INT_MIN;\n    priority_queue<long long, vector<long long>> q;\n    priority_queue<long long, vector<long long>, greater<long long>> p;\n    for (long long i = 0; i < n; i++) {\n      cin >> v[i];\n    }\n    if (v.size() == 1)\n      cout << v[0] << endl;\n    else {\n      sort(v.begin(), v.end());\n      long long mi = v[0];\n      long long dif = mi;\n      for (long long i = 1; i < n; i++) {\n        v[i] = v[i] - dif;\n        if (v[i] < mi) {\n          break;\n        }\n        mi = v[i];\n        dif += v[i];\n      }\n      cout << mi << endl;\n    }\n  }\n  return 0;\n}\n","def solve():\n    n = int(input())\n    l = input()\n    l = [int(i) for i in l.split()]\n    try:\n      if (n == 1):\n        print(l[0])\n        return\n      elif(n == 2):\n        a = min(l)\n        l.remove(a)\n        a = max(a, l[0] - a)\n        print(a)\n        return\n      else:\n        l.remove(min(l))\n        a = min(l)\n        l.remove(a)\n        b = min(l)\n        print(b - a)\n        return\n\n    except EOFError as e:\n      print(\"Error\")\n\n\nfor case in range(int(input())):\n  solve()\n","import java.io.*;\nimport java.util.*;\n\npublic class CodeForces{\n    \/*-------------------------------------------EDITING CODE STARTS HERE-------------------------------------------*\/\n    public static void main(String[] args) throws IOException{\n        openIO();\n        int testCase = 1;\n        testCase = sc.nextInt();\n        preCompute();\n        for (int i = 1; i <= testCase; i++) solve(i);\n        closeIO();\n    }\n\n    public static void solve(int tCase)throws IOException {\n        int n = sc.nextInt();\n        long[] arr = new long[n];\n        for(int i=0;i<n;i++)arr[i] = sc.nextInt();\n        if(n==1){\n            out.println(arr[0]);\n            return;\n        }\n        Arrays.sort(arr);\n        long adder = 0;\n        long max = -inf_long;\n        int i = 0;\n        for(;i<n;i++){\n            long curr = arr[i] + adder;\n            max = Math.max(max, curr);\n            if(curr<=0) {\n                adder += -arr[i];\n            }else break;\n        }\n        if(i<n)max = Math.max(max,arr[i]+adder);\n        i++;\n        for(;i<n;i++){\n            long curr = arr[i] + adder;\n            long prev = arr[i-1]  + adder;\n            if(curr - prev>=prev)max = Math.max(max,curr - prev);\n            else break;\n        }\n        out.println(max);\n    }\n\n\n    private static void  preCompute(){\n\n    }\n    \/*-------------------------------------------EDITING CODE ENDS HERE-------------------------------------------*\/\n    static FastestReader sc;\n    static PrintWriter out;\n    private static void openIO() throws IOException{\n        sc = new FastestReader();\n        out = new PrintWriter(System.out);\n    }\n\n    \/*------------------------------------------HELPER FUNCTION STARTS HERE------------------------------------------*\/\n\n    public static final int mod = (int) 1e9 +7;\n    private static final int mod2 =  998244353;\n    public static final int inf_int = (int) 2e9;\n    public static  final long inf_long = (long) 4e18;\n\n    \/\/ euclidean algorithm time O(max (loga ,logb))\n    public static long _gcd(long a, long b) {\n        if (a == 0)\n            return b;\n        return _gcd(b % a, a);\n    }\n\n    public static long _lcm(long a, long b) {\n        \/\/ lcm(a,b) * gcd(a,b) = a * b\n        return (a \/ _gcd(a, b)) * b;\n    }\n\n\n    \/\/ binary exponentiation time O(logn)\n    public static long _power(long x, long n) {\n        long ans = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ans *= x;\n                ans %= mod;\n                n--;\n            } else {\n                x *= x;\n                x %= mod;\n                n >>= 1;\n            }\n        }\n        return ans;\n    }\n    \/\/sieve\/first divisor time : O(mx * log ( log (mx) ) )\n    public static int[]  _seive(int mx){\n        int[] firstDivisor = new int[mx+1];\n        for(int i=0;i<=mx;i++)firstDivisor[i] = i;\n        for(int i=2;i*i<=mx;i++)\n            if(firstDivisor[i] == i)\n                for(int j = i*i;j<=mx;j+=i)\n                    firstDivisor[j] = i;\n        return firstDivisor;\n    }\n\n    private static boolean _isPrime(long x){\n        for(long i=2;i*i<=x;i++)\n            if(x%i==0)return false;\n        return true;\n    }\n\n\n    \/*------------------------------------------HELPER FUNCTION ENDS HERE-------------------------------------------*\/\n\n    \/*-------------------------------------------FAST INPUT STARTS HERE---------------------------------------------*\/\n\n    public static void closeIO() throws IOException{\n        out.flush();\n        out.close();\n        sc.close();\n    }\n    private static final class FastestReader {\n        private static final int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public FastestReader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public FastestReader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\n        private int skip() throws IOException {\n            int b;\n            \/\/noinspection StatementWithEmptyBody\n            while ((b = read()) != -1 && isSpaceChar(b)) {}\n            return b;\n        }\n\n        public String next() throws IOException {\n            int b = skip();\n            final StringBuilder sb = new StringBuilder();\n            while (!isSpaceChar(b)) { \/\/ when nextLine, (isSpaceChar(b) && b != ' ')\n                sb.appendCodePoint(b);\n                b = read();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) { c = read(); }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') { c = read(); }\n            final boolean neg = c == '-';\n            if (neg) { c = read(); }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') { c = read(); }\n            final boolean neg = c == '-';\n            if (neg) { c = read(); }\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') \/ (div *= 10);\n                }\n            }\n\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) { buffer[0] = -1; }\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) { fillBuffer(); }\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            din.close();\n        }\n    }\n    \/*---------------------------------------------FAST INPUT ENDS HERE ---------------------------------------------*\/\n}","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long MAXN = 2e5 + 10;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e18;\nlong long a[MAXN];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long mx = -INF;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      mx = max(mx, a[i]);\n    }\n    sort(a, a + n);\n    int p = 0;\n    if (a[0] < 0 && p < n - 1) {\n      for (int i = 1; i < n; i++) a[i] -= a[0];\n      p++;\n    }\n    mx -= a[0];\n    long long s = 0;\n    while (p < n - 1 && a[p] - s < mx - s - a[p]) {\n      s += a[p] - s;\n      p++;\n    }\n    cout << a[p] - s << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\n\nusing namespace std;\n\nvoid setI(string name)\n{\n    freopen((name + \".in\").c_str(), \"r\", stdin);\n}\n\nvoid setO(string name)\n{\n    freopen((name + \".out\").c_str(), \"w\", stdout);\n}\n\n#define IOS ios::sync_with_stdio(false), cin.tie(NULL)\n\n#define ff first\n#define ss second\n#define ef emplace_front\n#define eb emplace_back\n#define pf pop_front\n#define pb pop_back\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n\n#define FI(idx, start, end) for (ll idx{(start)}; idx <= (end); ++idx)\n#define FD(idx, start, end) for (ll idx{(start)}; idx >= (end); --idx)\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ld EPS = 1e-9;\nconst ld PIE = asin(1) * 2;\nconst ll MAX = 100'000 + 1;\nconst ll MOD = 1'000'000'007;\n\/\/ const ll MOD = 998'244'353;\n\nvoid solve_test_case()\n{\n    int n;\n    cin >> n;\n\n    vector<int> a(n);\n    FI(i, 0, n - 1)\n    {\n        cin >> a[i];\n    }\n    sort(all(a));\n\n    ll p{0}, sum{0};\n    FI(i, 0, n - 2)\n    {\n        if (a[i + 1] - a[i] >= a[i])\n        {\n            p++, sum += (a[i] - sum);\n        }\n        else\n        {\n            break;\n        }\n    }\n    cout << a[p] - sum << \"\\n\";\n    return;\n}\n\nint main()\n{\n    IOS;\n\n    \/\/ setI(\"\");\n    \/\/ setO(\"\");\n\n    int number_of_test_cases{1};\n    cin >> number_of_test_cases;\n\n    \/\/ cout.fixed, cout.precision(12); \/\/ Precision\n    \/\/ cout.flush(); \/\/ Interactive\n\n    for (int test_case_number{1}; test_case_number <= number_of_test_cases; ++test_case_number)\n    {\n        \/\/ cout << \"Case : #\" << test_case_number << \"\\n\";\n        solve_test_case();\n    }\n\n    return 0;\n}","#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits\/stdc++.h>\nusing namespace std;\n #include <ext\/pb_ds\/assoc_container.hpp> \nusing namespace __gnu_pbds;\nusing namespace std;\n#define ll long long int\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\ntypedef tree<long long, null_type, less_equal<>, rb_tree_tag, tree_order_statistics_node_update> indexed_multiset; \n#define sor(vec) sort(vec.begin(), vec.end())\n#define rever(vec) reverse(vec.begin(), vec.end())\n#define trav(x , p) for(auto &x : p)\n#define ull  unsigned long long\n #define MAXN 200005\n #define fi first\n#define se second\nconst ll mod =998244353; \n#define dbg(i,j,k)  cout<<\"(\"<<i<<\",\"<<j<<\")\"<<\" \"<<k<<\" \"\n#define dbgp(i,j)   cout<<i<<\" \"<<j<<endl\n#define print cout<<\"**\"<<endl;\n const int inf=1e9+7;\n void vcin(vector<ll> &n){for(int i=0;i<int(n.size());i++) cin>>n[i];}\n void vcout(vector<ll> &n){for(int i=0;i<int(n.size());i++){cout<<n[i]<<\" \";}cout<<endl;}\nconst ll MOD = 1e9+7;\ndouble eps = 0.0000001;\n#define endl \"\\n\";\n \/\/member functions :\n\/\/1. order_of_key(k) : number of elements strictly lesser than k\n\/\/2. find_by_order(k) : k-th element in the set\n\/\/ cout<<\"Case #\"<<p<<\": \"<<ans<<endl;\n\n\nvoid solve()\n{\n  \n   ll n;\n   cin>>n;\n   multiset<ll> s;\n   for(int i=0;i<n;i++)\n   {\n      ll x;\n      cin>>x;\n      s.insert(x);\n   }\n   if(s.size()==1 || n==1)\n   {\n      cout<<*s.begin()<<endl;\n      return ;\n   }\n   ll ans=*s.begin();\n   s.erase(ans);\n   ll del=0;\n   ll curr=ans;\n  \n   while(!s.empty())\n   {\n         ans=max(ans,*s.begin()-curr);\n            curr+=(*s.begin()-curr);\n         \/\/del+=(*s.begin()-del-curr);\n         \/\/curr=*s.begin();\n         s.erase(*s.begin());\n   }\n   cout<<ans<<endl;\n}\n\n\n\nint32_t main()  \n{\n  \n  \n\t ios::sync_with_stdio(false);\n     std::cin.tie(nullptr);\n     \n         ll t;\n         cin>>t;\n      \n   \n         while(t--)\n         {\n            solve();\n         }\n   \n}\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    long long ans = 0;\n    int idx = 0;\n    while (idx < n - 1 && ((a[idx] - ans) <= 0 || a[idx + 1] >= 2 * a[idx])) {\n      ans += a[idx] - ans;\n      idx++;\n    }\n    cout << a[idx] - ans << '\\n';\n    ;\n  }\n  return 0;\n}\n","for _ in range(int(input())):\n    n=int(input())\n    s=sorted(list(map(int,input().split()))[:n])\n    m=s[0]\n    while min(s)!=max(s):\n        s=[i-s[0] for i in s[1:]]\n        if s[0]>m:m=s[0]\n    print(m)","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  long long t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<long long> vi(n);\n    for (int i = 0; i < n; i++) {\n      cin >> vi[i];\n    }\n    long long mx = 2 * 10e-5;\n    if (n == 1) {\n      mx = vi[0];\n    } else if (n == 2) {\n      mx = max(vi[0], abs(vi[1] - vi[0]));\n    } else {\n      sort(vi.begin(), vi.end());\n      for (int j = 1; j < n; j++) {\n        mx = max(mx, abs(vi[j] - vi[j - 1]));\n      }\n    }\n    cout << mx << \"\\n\";\n  }\n  return 0;\n}\n","import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic long[]fac=new long[200100];\n\tstatic long[] two= new long[200100] ;\n\tstatic long mod=((long)1e18)+7;\n\tstatic String[]pow=new String[63];\n\tstatic int n;\n\tstatic int x=0;\n\tstatic int[][]perm,b;\n\tstatic int[]pe,aa,a;\n\tpublic static void main(String[] args) throws IOException, InterruptedException{\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tint n=sc.nextInt();\n\t\t\tLong[]a=new Long[n];\n\t\t\tlong min=Long.MAX_VALUE;\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextLong();\n\t\t\t\tmin=Math.min(min, a[i]);\n\t\t\t}\n\t\t\tif(n==1) {\n\t\t\t\tpw.println(min);\n\t\t\t}else {\n\t\t\t\tif(min<0) {\n\t\t\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\t\t\ta[i]-=min;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tArrays.sort(a);\n\t\t\t\tlong o=a[0];\n\t\t\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\t\t\tif(a[i]>=2*a[i-1]) {\n\t\t\t\t\t\to=a[i]-a[i-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpw.println(o);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tpw.close();\n\t}\t\n\t\n\tpublic static long[] Extended(long p, long q) {\n\t      if (q == 0)\n\t         return new long[] { p, 1, 0 };\n\n\t      long[] vals = Extended(q, p % q);\n\t      long d = vals[0];\n\t      long a = vals[2];\n\t      long b = vals[1] - (p \/ q) * vals[2];\n\t      return new long[] { d, a, b };\n\t   }\n\t\n\tstatic class STree{\n\t\tint N;\n\t\tlong[]arr;\n\t\tlong[]tree;\n\t\tint[]lazy;\n\t\tlong id;\n\t\tpublic static long operation(long x,long y) {\n\t\t\treturn x^y;\n\t\t}\n\t\t\n\t\tpublic STree(int[]a,long id) {\n\t\t\tthis.id=id;\n\t\t\tN=1;\n\t\t\tint n=a.length;\n\t\t\twhile(N<n) {\n\t\t\t\tN*=2;\n\t\t\t}\n\t\t\tarr=new long[N+1];\n\t\t\tArrays.fill(arr, id);\n\t\t\tfor (int i = 1; i <= a.length; i++) {\n\t\t\t\tarr[i]=a[i-1];\n\t\t\t}\n\t\t\ttree=new long[2*N];\n\t\t\tArrays.fill(tree, id);\n\t\t\tbuild(1,N,1);\n\t\t\tlazy=new int[2*N];\n\t\t}\n\t\t\n\t\tpublic void build(int l,int r,int node) {\n\t\t\tif(l==r) {\n\t\t\t\ttree[node]=arr[l];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mid=(l+r)\/2;\n\t\t\tbuild(l,mid,node*2);\n\t\t\tbuild(mid+1,r,node*2+1);\n\t\t\ttree[node]=operation(tree[node*2],tree[node*2+1]);\n\t\t}\n\t\t\n\/\/\t\tpublic void update(int node,int value) {\n\/\/\t\t\tint i=node+N-1;\n\/\/\t\t\ttree[i]=value;\n\/\/\t\t\ti\/=2;\n\/\/\t\t\twhile(i>0) {\n\/\/\t\t\t\ttree[i]=operation(tree[i*2], tree[i*2+1]);\n\/\/\t\t\t\ti\/=2;\n\/\/\t\t\t}\n\/\/\t\t}\n\/\/\t\t\n\/\/\t\tpublic void updateRange(int l,int r,int v) {\n\/\/\t\t\tupdateRange(1, N, l, r, 1,v);\n\/\/\t\t}\n\/\/\t\t\n\/\/\t\tpublic void updateRange(int s,int e,int l,int r,int node,int v) {\n\/\/\t\t\tif(s>=l&&e<=r) {\n\/\/\t\t\t\tlazy[node]^=v;\n\/\/\t\t\t\ttree[node]=propagate(tree[node],lazy[node],e-s+1);\n\/\/\/\/\t\t\t\tlazy[node]=0;\n\/\/\t\t\t\treturn;\n\/\/\t\t\t}\n\/\/\t\t\tif(s>r||e<l)return;\n\/\/\t\t\tint mid=(s+e)\/2;\n\/\/\t\t\tlazy[node*2] ^= lazy[node];\n\/\/\t\t\tlazy[node*2+1] ^= lazy[node];\n\/\/\t\t\ttree[node*2] = propagate(tree[node*2], v, (e-s+1)\/2);\n\/\/\t\t\ttree[node*2+1] =  propagate(tree[node*2+1], v, (e-s+1)\/2);\n\/\/\t\t\tlazy[node] = 0;\n\/\/\t\t\tupdateRange(s, mid, l, r, node*2, v);\n\/\/\t\t\tupdateRange(mid+1, e, l, r, node*2+1, v);\n\/\/\t\t\ttree[node]=operation(tree[node*2], tree[node*2+1]);\n\/\/\t\t\treturn;\n\/\/\t\t}\n\/\/\t\t\n\t\tpublic long q(int l,int r) {\n\t\t\treturn q(1,N,l,r,1);\n\t\t}\n\t\t\n\t\tpublic long q(int s,int e,int l,int r,int node) {\n\t\t\tif(s>=l&&r>=e) {\n\t\t\t\treturn tree[node];\n\t\t\t}\n\t\t\tif(s>r||e<l)\n\t\t\t\treturn id;\n\t\t\tint mid=(s+e)\/2;\n\t\t\t\n\t\t\treturn operation(q(s,mid,l,r,node*2), q(mid+1,e,l,r,node*2+1));\n\t\t}\n\/\/\t\tpublic static segment propagate(segment x,int v,int length) {\n\/\/\t\t\tint[]bit=x.bit.clone();\n\/\/\t\t\tlong sum=x.sum;\n\/\/\t\t\tfor (int i = 0; i < bit.length; i++) {\n\/\/\t\t\t\tif((v&1<<i)!=0) {\n\/\/\t\t\t\t\tsum-=(1<<i)*(bit[i]);\n\/\/\t\t\t\t\tsum+=(1<<i)*(length-bit[i]);\n\/\/\t\t\t\t\tbit[i]=length-bit[i];\n\/\/\t\t\t\t}\n\/\/\t\t\t}\n\/\/\t\t\treturn new segment(sum, bit);\n\/\/\t\t}\n\t}\n\n\tpublic static class segment{\n\t\tlong sum;\n\t\tint[] bit;\n\t\t\n\t\tpublic segment (long sum,int[]bit) {\n\t\t\tthis.sum=sum;\n\t\t\tthis.bit=bit.clone();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn sum+\" \"+Arrays.toString(bit);\n\t\t}\n\t}\n\t\n\tpublic static int LIS(int[] a) {\n\n\t\tint n = a.length;\n\t\tint[] ser = new int[n];\n\t\tint[]ser1=new int[n];\n\t\tArrays.fill(ser1, Integer.MAX_VALUE);\n\t\tArrays.fill(ser, Integer.MAX_VALUE);\n\t\tint cur = -1;\n\t\tint[]inc=new int[n];\n\t\tint[]dec=new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint low = 0;\n\t\t\tint high = n - 1;\n\t\t\tint mid = (low + high) \/ 2;\n\t\t\twhile (low <= high) {\n\t\t\t\tif (ser[mid] < a[i]) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}\n\t\t\t\tmid = (low + high) \/ 2;\n\t\t\t}\n\t\t\tinc[i]=high+2;\n\t\t\tcur = Math.max(cur, high + 1);\n\t\t\tser[high + 1] = Math.min(ser[high + 1], a[i]);\n\t\t}\n\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\tint low = 0;\n\t\t\tint high = n - 1;\n\t\t\tint mid = (low + high) \/ 2;\n\t\t\twhile (low <= high) {\n\t\t\t\tif (ser1[mid] < a[i]) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}\n\t\t\t\tmid = (low + high) \/ 2;\n\t\t\t}\n\t\t\tdec[i]=high+2;\n\t\t\tcur = Math.max(cur, high + 1);\n\t\t\tser1[high + 1] = Math.min(ser1[high + 1], a[i]);\n\t\t}\n\t\tint ans=1;\n\t\tfor (int i = 0; i < dec.length; i++) {\n\t\t\tans=Math.max(ans, 2*Math.min(inc[i], dec[i])-1);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tpublic static void permutation(int idx,int v) {\n\t\tif(v==(1<<n)-1) {\n\t\t\tperm[x++]=pe.clone();\n\t\t\treturn ;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif((v&1<<i)==0) {\n\t\t\t\tpe[idx]=aa[i];\n\t\t\t\tpermutation(idx+1, v|1<<i);\n\t\t\t}\n\t\t}\n\t\treturn ;\n\t}\n\t\n\tpublic static void pre2() {\n\t\tfor (int i = 0; i < pow.length; i++) {\n\t\t\tlong x=1l<<i;\n\t\t\tpow[i]=x+\"\";\n\t\t}\n\t}\n\t\t\n\tpublic static void sort(int[]a) {\n\t\tmergesort(a, 0, a.length-1);\n\t}\n\t\n\tpublic static void sortIdx(long[]a,long[]idx) {\n\t\tmergesortidx(a, idx, 0, a.length-1);\n\t}\n\t\n\tpublic static long C(int a,int b) {\n\t\tlong x=fac[a];\n\t\tlong y=fac[a-b]*fac[b];\n\t\treturn x*pow(y,mod-2)%mod;\n\t}\n\t\n\tpublic static long pow(long a,long b) {\n\t\tlong ans=1;a%=mod;\n\t\tfor(long i=b;i>0;i\/=2) {\n\t\t\tif((i&1)!=0)\n\t\t\t\tans=ans*a%mod;\n\t\t\ta=a*a%mod;\n\t\t }    \n\t\t    \n\t\t return ans;\n\t}\n\t\n\tpublic static void pre(){\n\t\tfac[0]=1;\n\t\tfac[1]=1;\n\t\tfac[2]=1;\n\t\tfor (int i = 3; i < fac.length; i++) {\n\t\t\tfac[i]=((fac[i-1]*2*i)\/2)%mod;\n\t\t}\n\t}\n\t\n\tpublic static long eval(String s) {\n\t\tlong p=1;\n\t\tlong res=0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tres+=p*(s.charAt(s.length()-1-i)=='1'?1:0);\n\t\t\tp*=2;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static String binary(long x) {\n\t\tString s=\"\";\n\t\twhile(x!=0) {\n\t\t\ts=(x%2)+s;\n\t\t\tx\/=2;\n\t\t}\n\t\treturn s;\n\t}\n\t\n\tpublic static boolean allSame(String s) {\n\t\tchar x=s.charAt(0);\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif(s.charAt(i)!=x)return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isPalindrom(String s) {\n\t\tint l=0;\n\t\tint r=s.length()-1;\n\t\twhile(l<r) {\n\t\t\tif(s.charAt(r--)!=s.charAt(l++))return false;\n\t\t\t\n\t\t}\n\t\treturn true;\n\t}\n\t \n\t\n\tpublic static boolean isSubString(String s,String t) {\n\t\tint ls=s.length();\n\t\tint lt=t.length();\n\t\tboolean res=false;\n\t\tfor (int i = 0; i <=lt-ls; i++) {\n\t\t\tif(t.substring(i, i+ls).equals(s)) {\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static boolean isSorted(long[]a) {\n\t\tfor (int i = 0; i < a.length-1; i++) {\n\t\t\tif(a[i]>a[i+1])return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isPrime(long n)\n    {\n \n        \/\/ Check if number is less than\n        \/\/ equal to 1\n        if (n <= 1)\n            return false;\n \n        \/\/ Check if number is 2\n        else if (n == 2)\n            return true;\n \n        \/\/ Check if n is a multiple of 2\n        else if (n % 2 == 0)\n            return false;\n \n        \/\/ If not, then just check the odds\n        for (int i = 3; i <= Math.sqrt(n); i += 2)\n        {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\tpublic static int whichPower(int x) {\n\t\tint res=0;\n\t\tfor (int j = 0; j < 31; j++) {\n\t\t\tif((1<<j&x)!=0) {\n\t\t\t\tres=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n \n\tpublic static long evaln(String x,int n) {\n\t\tlong res=0;\n\t\tfor (int i = 0; i < x.length(); i++) {\n\t\t\tres+=Long.parseLong(x.charAt(x.length()-1-i)+\"\")*Math.pow(n, i);\n\t\t}\n\t\treturn res;\n\t}\n\tstatic void merge(int[] arr,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tint[] l=new int[len1];\n\t\tint[] r=new int[len2];\n\t\tfor(int i=0;i<len1;i++)l[i]=arr[b+i];\n\t\tfor(int i=0;i<len2;i++)r[i]=arr[m+1+i];\n\t\tint i=0,j=0,k=b;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<r[j])arr[k++]=l[i++];\n\t\t\telse arr[k++]=r[j++];\n\t\t}\n\t\twhile(i<len1)arr[k++]=l[i++];\n\t\twhile(j<len2)arr[k++]=r[j++];\n\t\treturn;\n\t}\n\tstatic void mergesortidx(long[] arr,long[]idx,int b,int e) {\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tmergesortidx(arr,idx,b,m);\n\t\t\tmergesortidx(arr,idx,m+1,e);\n\t\t\tmergeidx(arr,idx,b,m,e);\n\t\t}\n\t\treturn;\n\t\t\n\t}\n\tstatic void mergeidx(long[] arr,long[]idx,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tlong[] l=new long[len1];\n\t\tlong[] lidx=new long[len1];\n\t\tlong[] r=new long[len2];\n\t\tlong[] ridx=new long[len2];\n\t\tfor(int i=0;i<len1;i++) {\n\t\t\tl[i]=arr[b+i];\n\t\t\tlidx[i]=idx[b+i];\n\t\t}\n\t\tfor(int i=0;i<len2;i++) {\n\t\t\tr[i]=arr[m+1+i];\n\t\t\tridx[i]=idx[m+1+i];\n\t\t}\n\t\tint i=0,j=0,k=b;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<=r[j]) {\n\t\t\t\tarr[k++]=l[i++];\n\t\t\t\tidx[k-1]=lidx[i-1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarr[k++]=r[j++];\n\t\t\t\tidx[k-1]=ridx[j-1];\n\t\t\t}\n\t\t}\n\t\twhile(i<len1) {\n\t\t\tidx[k]=lidx[i];\n\t\t\tarr[k++]=l[i++];\n\t\t}\n\t\twhile(j<len2) {\n\t\t\tidx[k]=ridx[j];\n\t\t\tarr[k++]=r[j++];\n\t\t}\n\t\treturn;\n\t}\n\tstatic void mergesort(int[] arr,int b,int e) {\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tmergesort(arr,b,m);\n\t\t\tmergesort(arr,m+1,e);\n\t\t\tmerge(arr,b,m,e);\n\t\t}\n\t\treturn;\n\t\t\n\t}\n\t\n\tstatic long mergen(int[] arr,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tint[] l=new int[len1];\n\t\tint[] r=new int[len2];\n\t\tfor(int i=0;i<len1;i++)l[i]=arr[b+i];\n\t\tfor(int i=0;i<len2;i++)r[i]=arr[m+1+i];\n\t\tint i=0,j=0,k=b;\n\t\tlong c=0;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<r[j])arr[k++]=l[i++];\n\t\t\telse {\n\t\t\t\tarr[k++]=r[j++];\n\t\t\t\tc=c+(long)(len1-i);\n\t\t\t}\n\t\t}\n\t\twhile(i<len1)arr[k++]=l[i++];\n\t\twhile(j<len2)arr[k++]=r[j++];\n\t\treturn c;\n\t}\n\tstatic long mergesortn(int[] arr,int b,int e) {\n\t\tlong c=0;\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tc=c+(long)mergesortn(arr,b,m);\n\t\t\tc=c+(long)mergesortn(arr,m+1,e);\n\t\t\tc=c+(long)mergen(arr,b,m,e);\n\t\t}\n\t\treturn c;\n\t\t\n\t}\n\tpublic static long fac(int n) {\n\t\tif(n==0)return 1;\n\t\treturn n*fac(n-1);\n\t}\n\tpublic static long gcd(long a, long b)\n    {\n      if (b == 0)\n        return a;\n      return gcd(b, a % b);\n    }\n     \n\tpublic static long summ(long x) {\n\t\tlong sum=0;\n\t\twhile(x!=0) {\n\t\t\tsum+=x%10;\n\t\t\tx=x\/10;\n\t\t}\n\t\treturn sum;\n\t\t\t\t\n\t}\n\t\n\tpublic  static ArrayList<Integer> findDivisors(int n){\n\t        ArrayList<Integer>res=new ArrayList<Integer>();\n\t        for (int i=1; i<=Math.sqrt(n); i++)\n\t        {\n\t            if (n%i==0)\n\t            {\n\t                \/\/ If divisors are equal, print only one\n\t                if (n\/i == i)\n\t                \tres.add(i);\n\t                else {\n\t                \tres.add(i);\n\t                \tres.add(n\/i);\n\t                }\t\n\t            }\n\t        }\n\t        return res;\n\t    }\n\n\t\n\tpublic static void sort2darray(Integer[][]a){\n\t\tArrays.sort(a,Comparator.<Integer[]>comparingInt(x -> x[0]).thenComparingInt(x -> x[1]));\n \n\t}\n\t\n\t\n\t\n\t\t\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\t\tpublic Scanner(String file) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t\tpublic int[] nextArrint(int size) throws IOException {\n\t\t\tint[] a=new int[size];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic long[] nextArrlong(int size) throws IOException {\n\t\t\tlong[] a=new long[size];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextLong();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic int[][] next2dArrint(int rows,int columns) throws IOException{\n\t\t\tint[][]a=new int[rows][columns];\n\t\t\tfor (int i = 0; i < rows; i++) {\n\t\t\t\tfor (int j = 0; j < columns; j++) {\n\t\t\t\t\ta[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic long[][] next2dArrlong(int rows,int columns) throws IOException{\n\t\t\tlong[][]a=new long[rows][columns];\n\t\t\tfor (int i = 0; i < rows; i++) {\n\t\t\t\tfor (int j = 0; j < columns; j++) {\n\t\t\t\t\ta[i][j]=sc.nextLong();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}\n\t\n\tstatic class Side{\n\t\tPoint a;\n\t\tPoint b;\n\t\tpublic Side(Point a,Point b) {\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tSide s=(Side)obj;\n\t\t\treturn (s.a.equals(a)&&s.b.equals(b))||(s.b.equals(a)&&s.a.equals(b));\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\n\t\t\treturn \"(\"+a.toString()+\",\"+b.toString()+\")\";\n\t\t}\n\t}\n\tstatic class Point{\n\t\tint x;\n\t\tint y;\n\t\tint z;\n\t\tpublic Point(int x,int y,int z) {\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.z=z;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tPoint p=(Point)obj;\n\t\t\treturn x==p.x&&y==p.y&&z==p.z;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\"+x+\",\"+y+\",\"+z+\")\";\n\t\t}\n\t}\n\tstatic class Pair implements Comparable{\n\t\tlong x;\n\t\tlong y;\n\t\tpublic Pair(long x,long y) {\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tPair p=(Pair)obj;\n\t\t\treturn x==p.x&&y==p.y;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\/\/ TODO Auto-generated method stub\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Object o) {\n\t\t\tPair p=(Pair)o;\n\t\t\treturn x>p.x?1:x==p.x?0:-1;\n\t\t}\n\t}\n\tstatic class sPair{\n\t\tString s;\n\t\tPair p;\n\t\tpublic sPair(String s,Pair p) {\n\t\t\tthis.p=p;\n\t\t\tthis.s=s;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\/\/ TODO Auto-generated method stub\n\t\t\treturn s+\" \"+p;\n\t\t}\n\t}\n\tstatic Scanner sc=new Scanner(System.in);\n\tstatic PrintWriter pw=new PrintWriter(System.out);\n}","t = int(input())\n\nfor test in range(t):\n    n = int(input())\n    p = list(map(int,input().split()))\n    if(len(p)==1):\n        print(p[0])\n        continue\n    elif(len(p)==2):\n        print(abs(p[0]-p[1]))\n        continue\n    ans = 0\n    p.sort()\n    for i in range(len(p)-2,0,-1):\n        ans = max(ans,p[i+1]-p[i])\n    print(ans)\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false), cin.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> v(n);\n    for (auto &p : v) {\n      cin >> p;\n    }\n    vector<long long> ans;\n    sort(v.begin(), v.end());\n    reverse(v.begin(), v.end());\n    long long x = v[v.size() - 1];\n    if (x < 0 && v.size() > 1) v.pop_back();\n    ans.push_back(x);\n    if (n > 1) {\n      for (auto &p : v) {\n        p = p - x;\n      }\n    }\n    for (int i = 1; i <= v.size() - 1; i++) {\n      ans.push_back(v[i - 1] - v[i]);\n    }\n    if (v.size() == 1) ans.push_back(v[0]);\n    sort(ans.begin(), ans.end());\n    cout << ans[ans.size() - 1] << endl;\n  }\n  return 0;\n}\n","import sys\nimport heapq\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\ndef get_int(): return int(sys.stdin.readline().strip())\ndef get_list_strings(): return list(map(str, sys.stdin.readline().strip().split()))\n\n\n# Output for list\n# sys.stdout.write(\" \".join(map(str, final)) + \"\\n\")\n\n# Output for int or str\n# sys.stdout.write(str(best) + \"\\n\")\n\n\n\ndef solve(n, arr):\n  ans = min(arr)\n\n  c = 0\n\n  heapq.heapify(arr)\n\n  while n > 1:\n    temp = heapq.heappop(arr)\n    n -= 1\n\n    temp1 = temp - c\n\n    ans = max(ans, temp1)\n\n    c += temp\n  \n  print(ans)\n\n    \n\n\n\n\n\n\n\nT = get_int()\nwhile T:\n  n = get_int()\n  arr = get_list()\n  solve(n, arr)\n  T -= 1\n","import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n    \/\/ Graph\n    \/\/ prefix sums\n    \/\/inputs\n    public static void main(String args[])throws Exception{\n        Input sc=new Input();\n        precalculates p=new precalculates();\n        StringBuilder sb=new StringBuilder();\n        int t=sc.readInt();\n        for(int f=0;f<t;f++){\n            int n=sc.readInt();\n            long a[]=sc.readArrayLong();\n            HashSet<Long> map=new HashSet<>();\n            for(int i=0;i<n;i++){\n                map.add(a[i]);\n            }\n            n=map.size();\n            a=new long[n];\n            int j=0;\n            for(Long val:map){\n                a[j++]=val;\n            }\n            Arrays.sort(a);\n            long sum=0;\n            long prev=0;long ans=Long.MIN_VALUE;\n            for(int i=0;i<n;i++){\n                sum=sum+((a[i])-prev);\n                ans=Math.max(ans,a[i]-prev);\n                prev=sum;\n            }\n            \/*if(a.length>1 && a[0]==0) {\n                ans = Math.max(ans, a[n - 2]);\n            }else*\/ if(a.length>0 && a[n-1]!=0){\n                ans=Math.max(ans,a[n-1]-prev);\n            }\n\n\/\/            if(n>0 && a[0]==0)\n\/\/            {\n\/\/                ans=0;\n\/\/            }\n            if(ans!=Long.MIN_VALUE)\n                sb.append(ans+\"\\n\");\n            else\n                sb.append(a[n-1]+\"\\n\");\n\n        }\n        \/\/ 1 2 7 10   1\n        \/\/ 0 1 6 9    2\n        \/\/ 0 0 5 8\n        \/\/ -1 0 2\n        \/\/ 0  1 3\n        \/\/ 0 0 2\n        System.out.print(sb);\n    }\n}\nclass Input{\n    BufferedReader br;\n    StringTokenizer st;\n    Input(){\n        br=new BufferedReader(new InputStreamReader(System.in));\n        st=new StringTokenizer(\"\");\n    }\n    public int[] readArray() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        int a[]=new int[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Integer.parseInt(st.nextToken());\n        }\n        return a;\n    }\n    public long[] readArrayLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        long a[]=new long[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Long.parseLong(st.nextToken());\n        }\n        return a;\n    }\n    public int readInt() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Integer.parseInt(st.nextToken());\n    }\n    public long readLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Long.parseLong(st.nextToken());\n    }\n    public String readString() throws Exception{\n        return br.readLine();\n    }\n    public int[][] read2dArray(int n,int m)throws Exception{\n        int a[][]=new int[n][m];\n        for(int i=0;i<n;i++){\n            st=new StringTokenizer(br.readLine());\n            for(int j=0;j<m;j++){\n                a[i][j]=Integer.parseInt(st.nextToken());\n            }\n        }\n        return a;\n    }\n}\nclass precalculates{\n    public int[] prefixSumOneDimentional(int a[]){\n        int n=a.length;\n        int dp[]=new int[n];\n        for(int i=0;i<n;i++){\n            if(i==0)\n                dp[i]=a[i];\n            else\n                dp[i]=dp[i-1]+a[i];\n        }\n        return dp;\n    }\n    public int[] postSumOneDimentional(int a[]) {\n        int n = a.length;\n        int dp[] = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            if (i == n - 1)\n                dp[i] = a[i];\n            else\n                dp[i] = dp[i + 1] + a[i];\n        }\n        return dp;\n    }\n    public int[][] prefixSum2d(int a[][]){\n        int n=a.length;int m=a[0].length;\n        int dp[][]=new int[n+1][m+1];\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=m;j++){\n                dp[i][j]=a[i-1][j-1]+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];\n            }\n        }\n        return dp;\n    }\n    public long pow(long a,long b){\n        long mod=1000000007;\n        long ans=0;\n        if(b<=0)\n            return 1;\n        if(b%2==0){\n            ans=pow(a,b\/2)%mod;\n            return ((ans%mod)*(ans%mod))%mod;\n        }else{\n            return ((a%mod)*(ans%mod))%mod;\n        }\n    }\n\n}\nclass GraphInteger{\n    HashMap<Integer,vertex> vtces;\n    class vertex{\n        HashMap<Integer,Integer> children;\n        public vertex(){\n            children=new HashMap<>();\n        }\n    }\n    public GraphInteger(){\n        vtces=new HashMap<>();\n    }\n    public void addVertex(int a){\n        vtces.put(a,new vertex());\n    }\n    public void addEdge(int a,int b,int cost){\n        if(!vtces.containsKey(a)){\n            vtces.put(a,new vertex());\n        }\n        if(!vtces.containsKey(b)){\n            vtces.put(b,new vertex());\n        }\n        vtces.get(a).children.put(b,cost);\n\/\/        vtces.get(b).children.put(a,cost);\n    }\n    public boolean isCyclicDirected(){\n        boolean isdone[]=new boolean[vtces.size()+1];\n        boolean check[]=new boolean[vtces.size()+1];\n        for(int i=1;i<=vtces.size();i++) {\n            if (!isdone[i] && isCyclicDirected(i,isdone, check)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private boolean isCyclicDirected(int i,boolean isdone[],boolean check[]){\n        if(check[i])\n            return true;\n        if(isdone[i])\n            return false;\n        check[i]=true;\n        isdone[i]=true;\n        Set<Integer> set=vtces.get(i).children.keySet();\n        for(Integer ii:set){\n            if(isCyclicDirected(ii,isdone,check))\n                return true;\n        }\n        check[i]=false;\n        return false;\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++) {\n    int n, mn = 1000000001, y = 0;\n    cin >> n;\n    vector<int> v(n);\n    if (n == 1) {\n      int a;\n      cin >> a;\n      cout << a << '\\n';\n    } else {\n      for (int j = 0; j < n; j++) {\n        cin >> v[j];\n        if (v[j] < mn) mn = v[j];\n      }\n      int x = mn;\n      for (int k = 0; k < n - 1; k++) {\n        int mnn = 1000000001, cnt = 0;\n        for (int j = 0; j < n - k - 1; j++) {\n          v[j] -= x;\n          if (v[j] == 0 && cnt == 0) {\n            v.erase(v.begin() + j);\n            j--;\n            cnt++;\n          } else if (v[j] < mnn)\n            mnn = v[j];\n        }\n        y = max({y, mnn, x});\n        x = mnn;\n      }\n      cout << y << '\\n';\n    }\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  for (int i = 0; i < t; i++) {\n    long long x, n;\n    scanf(\"%lld%lld\", &x, &n);\n    if (!n) {\n      printf(\"%d\\n\", x);\n      continue;\n    }\n    long long ans = x;\n    if ((n - 1) % 2 == 0) {\n      if ((n - 1) % 4 == 0) {\n        if (x % 2 == 0) {\n          ans -= 1;\n          ans -= (n \/ 4) * 4;\n        } else {\n          ans += 1;\n          ans += (n \/ 4) * 4;\n        }\n      } else {\n        if (x % 2 == 0) {\n          ans -= 1;\n          ans -= ((n - 2) \/ 4) * 4;\n          ans += 2 * n - 1;\n        } else {\n          ans += 1;\n          ans += ((n - 2) \/ 4) * 4;\n          ans -= 2 * n - 1;\n        }\n      }\n    } else {\n      n--;\n      if ((n - 1) % 4 == 0) {\n        if (x % 2 == 0) {\n          ans -= 1;\n          ans -= (n \/ 4) * 4;\n        } else {\n          ans += 1;\n          ans += (n \/ 4) * 4;\n        }\n      } else {\n        if (x % 2 == 0) {\n          ans -= 1;\n          ans -= ((n - 2) \/ 4) * 4;\n          ans += 2 * n - 1;\n        } else {\n          ans += 1;\n          ans += ((n - 2) \/ 4) * 4;\n          ans -= 2 * n - 1;\n        }\n      }\n      if (ans % 2)\n        ans += n + 1;\n      else\n        ans -= n + 1;\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n","for _ in range(int(input())):\n    n=int(input())\n    ans=-1e10\n    if(n==1):\n        ans=input()\n    else:\n        arr=list(map(int, input().split()))\n        #print(arr)\n        arr.sort()\n        #print(arr)\n        \n        for i in range(1,n):\n            h=arr[i]-arr[i-1]\n            if ans<=h:\n                #print(\"debug\",h, ans)\n                ans=h\n    print(ans)","\/*Everything is Hard \n * Before Easy \n * Jai Mata Dii \n *\/ \n \nimport java.util.*;\nimport java.io.*; \n  \npublic class Main {\n\tstatic class FastReader{ BufferedReader br;StringTokenizer st;public FastReader(){br = new BufferedReader(new InputStreamReader(System.in));}String next(){while (st == null || !st.hasMoreElements()){try{st = new StringTokenizer(br.readLine());}catch (IOException  e){e.printStackTrace();}}return st.nextToken();}int nextInt(){ return Integer.parseInt(next());}long nextLong(){return Long.parseLong(next());}double nextDouble(){return Double.parseDouble(next());}String nextLine(){String str = \"\"; try{str = br.readLine(); } catch (IOException e) {e.printStackTrace();} return str; }} \n\tstatic long mod = (long)(1e9+7); \n\/\/\t static long mod = 998244353; \n\/\/\t static Scanner sc = new Scanner(System.in); \n\tstatic FastReader sc = new FastReader(); \n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tpublic static void main (String[] args) {\n\t\tint ttt = 1;\n\t\tttt = sc.nextInt();\n\t\tz :for(int tc=1;tc<=ttt;tc++){\n\t\t\tint n = sc.nextInt();\n\t\t\tlong a[] = new long[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i] = sc.nextLong();\n\t\t\t}\n\t\t\tsort(a);\n\t\t\tlong l = 1, h = n-1;\n\t\t\tlong ans = a[0];\n\t\t\twhile(l<=h) {\n\t\t\t\tlong mid = (l+h)\/2;\n\t\t\t\tlong cur = 0;\n\t\t\t\tfor(int i=0;i<mid;i++) {\n\t\t\t\t\tcur = cur + (a[i]-cur);\n\t\t\t\t}\n\t\t\t\tif(ans>a[(int) mid]-cur) {\n\t\t\t\t\th = mid-1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans = a[(int) mid]-cur;\n\t\t\t\t\tl = mid+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.write(ans+\"\\n\");\n\t\t}\n\t\tout.close();\n\t}\n\tstatic long pow(long a, long b){long ret = 1;while(b>0){if(b%2 == 0){a = (a*a)%mod;b \/= 2;}else{ret = (ret*a)%mod;b--;}}return ret%mod;}\n\tstatic long gcd(long a,long b){if(b==0) return  a; return gcd(b,a%b); } \n\tprivate static void sort(int[] a) {List<Integer> k = new ArrayList<>();for(int val : a) k.add(val);Collections.sort(k);for(int i=0;i<a.length;i++) a[i] = k.get(i);} \n\tprivate static void ini(List<Integer>[] tre2){for(int i=0;i<tre2.length;i++){tre2[i] = new ArrayList<>();}} \n\tprivate static void init(List<int[]>[] tre2){for(int i=0;i<tre2.length;i++){tre2[i] = new ArrayList<>();}} \n\tprivate static void sort(long[] a) {List<Long> k = new ArrayList<>();for(long val : a) k.add(val);Collections.sort(k);for(int i=0;i<a.length;i++) a[i] = k.get(i);} \n}","import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n    static long mod = (int)1e9 + 7;\n    \/\/ static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tFastReader sc =new FastReader();\n\t\t\n\t    int t=sc.nextInt();\n\t    \n\t   \/\/ int t=1;\n\t    \n\t    while(t-->0)\n\t    {\n\t        int n = sc.nextInt();\n\t        int arr[] = sc.readArray(n);\n\t        \n\t        radixSort2(arr);\n\t        \n\t        if(n == 1)\n\t        {\n\t            System.out.println(arr[0]);\n\t            continue;\n\t        }\n\t        \n\t        long ans = Long.MIN_VALUE;\n\t        int stored = arr[0];\n\t        int sub = 0;\n\t        \n\t        for(int i=1;i<n;i++)\n\t        {\n\t            sub = arr[i] - stored;\n\t            stored += sub;\n\t            ans = Math.max(ans , sub);\n\t        }\n\t        System.out.println(ans);\n\t    }\n\t    \n\t}\n\t\n\t\n\t\n\t\n\tstatic class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(\n                new InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() { return Integer.parseInt(next()); }\n \n        long nextLong() { return Long.parseLong(next()); }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n        \n        float nextFloat()\n        {\n            return Float.parseFloat(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tlong[] readArrayLong(int n) {\n\t\t\tlong[] a=new long[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextLong();\n\t\t\treturn a;\n\t\t}\n\t\t\n    }\n    \n    \n    \n    public static int[] radixSort2(int[] a)\n\t{\n\t\tint n = a.length;\n\t\tint[] c0 = new int[0x101];\n\t\tint[] c1 = new int[0x101];\n\t\tint[] c2 = new int[0x101];\n\t\tint[] c3 = new int[0x101];\n\t\tfor(int v : a) {\n\t\t\tc0[(v&0xff)+1]++;\n\t\t\tc1[(v>>>8&0xff)+1]++;\n\t\t\tc2[(v>>>16&0xff)+1]++;\n\t\t\tc3[(v>>>24^0x80)+1]++;\n\t\t}\n\t\tfor(int i = 0;i < 0xff;i++) {\n\t\t\tc0[i+1] += c0[i];\n\t\t\tc1[i+1] += c1[i];\n\t\t\tc2[i+1] += c2[i];\n\t\t\tc3[i+1] += c3[i];\n\t\t}\n\t\tint[] t = new int[n];\n\t\tfor(int v : a)t[c0[v&0xff]++] = v;\n\t\tfor(int v : t)a[c1[v>>>8&0xff]++] = v;\n\t\tfor(int v : a)t[c2[v>>>16&0xff]++] = v;\n\t\tfor(int v : t)a[c3[v>>>24^0x80]++] = v;\n\t\treturn a;\n\t}\n\t\n\tstatic void reverse_sorted(int[] arr)\n\t{\n\t    ArrayList<Integer> list = new ArrayList<>();\n\t    for(int i=0;i<arr.length;i++)\n\t    {\n\t        list.add(arr[i]);\n\t    }\n\t    Collections.sort(list , Collections.reverseOrder());\n\t    for(int i=0;i<arr.length;i++)\n\t    {\n\t        arr[i] = list.get(i);\n\t    }\n\t}\n\t\n\tstatic int LowerBound(int a[], int x) { \/\/ x is the target value or key\n        int l=-1,r=a.length;\n        while(l+1<r) {\n            int m=(l+r)>>>1;\n            if(a[m]>=x) r=m;\n            else l=m;\n        }\n        return r;\n    }\n    \n    static int UpperBound(ArrayList<Integer> list, int x) {\/\/ x is the key or target value\n        int l=-1,r=list.size();\n        while(l+1<r) {\n            int m=(l+r)>>>1;\n            if(list.get(m)<=x) l=m;\n            else r=m;\n        }\n        return l+1;\n    }\n    \n    public static HashMap<String, Integer> sortByValue(HashMap<String, Integer> hm)\n    {\n        \/\/ Create a list from elements of HashMap\n        List<Map.Entry<String, Integer> > list =\n               new LinkedList<Map.Entry<String, Integer> >(hm.entrySet());\n \n        \/\/ Sort the list\n        Collections.sort(list, new Comparator<Map.Entry<String, Integer> >() {\n            public int compare(Map.Entry<String, Integer> o1,\n                               Map.Entry<String, Integer> o2)\n            {\n                return (o1.getValue()).compareTo(o2.getValue());\n            }\n        });\n         \n        \/\/ put data from sorted list to hashmap\n        HashMap<String, Integer> temp = new LinkedHashMap<String, Integer>();\n        for (Map.Entry<String, Integer> aa : list) {\n            temp.put(aa.getKey(), aa.getValue());\n        }\n        return temp;\n    }\n    \n    static class Queue_Pair implements Comparable<Queue_Pair> {\n\t\tint first , second;\n\t\tpublic Queue_Pair(int first, int second) {\n\t\t\tthis.first=first;\n\t\t\tthis.second=second;\n\t\t}\n\t\tpublic int compareTo(Queue_Pair o) {\n\t\t\treturn Integer.compare(o.first, first);\n\t\t}\n\t}\n    \n    static void leftRotate(char arr[], int d, int n)\n    {\n        for (int i = 0; i < d; i++)\n            leftRotatebyOne(arr, n);\n    }\n \n    static void leftRotatebyOne(char arr[], int n)\n    {\n        int i;\n        char temp = arr[0];\n        for (i = 0; i < n - 1; i++)\n            arr[i] = arr[i + 1];\n        arr[n-1] = temp;\n        \n    }\n    \n    static void rightRotate(char arr[], int d, int n)\n    {\n        for (int i = 0; i < d; i++)\n            rightRotatebyOne(arr, n);\n    }\n \n    static void rightRotatebyOne(char arr[], int n)\n    {\n        int i;\n        char temp = arr[n - 1];\n        for (i = n - 1; i > 0; i--)\n            arr[i] = arr[i - 1];\n        arr[0] = temp;\n        \n    }\n    \n    static boolean isPalindrome(String str)\n    {\n \n        \/\/ Pointers pointing to the beginning\n        \/\/ and the end of the string\n        int i = 0, j = str.length() - 1;\n \n        \/\/ While there are characters to compare\n        while (i < j) {\n \n            \/\/ If there is a mismatch\n            if (str.charAt(i) != str.charAt(j))\n                return false;\n \n            \/\/ Increment first pointer and\n            \/\/ decrement the other\n            i++;\n            j--;\n        }\n \n        \/\/ Given string is a palindrome\n        return true;\n    }\n    \n    static boolean palindrome_array(char arr[], int n)\n    {\n        \/\/ Initialise flag to zero.\n        int flag = 0;\n \n        \/\/ Loop till array size n\/2.\n        for (int i = 0; i <= n \/ 2 && n != 0; i++) {\n \n            \/\/ Check if first and last element are different\n            \/\/ Then set flag to 1.\n            if (arr[i] != arr[n - i - 1]) {\n                flag = 1;\n                break;\n            }\n        }\n \n        \/\/ If flag is set then print Not Palindrome\n        \/\/ else print Palindrome.\n        if (flag == 1)\n            return false;\n        else\n            return true;\n    }\n    \n\tstatic boolean allElementsEqual(long[] arr,int n)\n\t{\n\t    int z=0;\n\t        for(int i=0;i<n-1;i++)\n\t\t    {\n\t\t        if(arr[i]==arr[i+1])\n\t\t        {\n\t\t            z++;\n\t\t        }\n\t\t    }\n\t\t    if(z==n-1)\n\t\t    {\n\t\t        return true;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t        return false;\n\t\t    }\n\t\t    \n\t}\n\t\n\tstatic boolean allElementsDistinct(int[] arr,int n)\n\t{\n\t    int z=0;\n\t        for(int i=0;i<n-1;i++)\n\t\t    {\n\t\t        if(arr[i]!=arr[i+1])\n\t\t        {\n\t\t            z++;\n\t\t        }\n\t\t    }\n\t\t    if(z==n-1)\n\t\t    {\n\t\t        return true;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t        return false;\n\t\t    }\n\t\t    \n\t\t    \n\t}\n\t\n\tpublic static void reverse(int[] array)\n    {\n  \n        \/\/ Length of the array\n        int n = array.length;\n  \n        \/\/ Swaping the first half elements with last half\n        \/\/ elements\n        for (int i = 0; i < n \/ 2; i++) {\n  \n            \/\/ Storing the first half elements temporarily\n            int temp = array[i];\n  \n            \/\/ Assigning the first half to the last half\n            array[i] = array[n - i - 1];\n  \n            \/\/ Assigning the last half to the first half\n            array[n - i - 1] = temp;\n        }\n    }\n    \n    public static void reverse_Long(long[] array)\n    {\n  \n        \/\/ Length of the array\n        int n = array.length;\n  \n        \/\/ Swaping the first half elements with last half\n        \/\/ elements\n        for (int i = 0; i < n \/ 2; i++) {\n  \n            \/\/ Storing the first half elements temporarily\n            long temp = array[i];\n  \n            \/\/ Assigning the first half to the last half\n            array[i] = array[n - i - 1];\n  \n            \/\/ Assigning the last half to the first half\n            array[n - i - 1] = temp;\n        }\n    }\n\t\n\tstatic boolean isSorted(int[] a)\n    {\n        for (int i = 0; i < a.length - 1; i++)\n        {\n            if (a[i] > a[i + 1]) {\n                return false;\n            }\n        }\n \n        return true;\n    }\n    \n    \n    \n    static boolean isReverseSorted(int[] a)\n    {\n        for (int i = 0; i < a.length - 1; i++)\n        {\n            if (a[i] < a[i + 1]) {\n                return false;\n            }\n        }\n \n        return true;\n    }\n    \n    static int[] rearrangeEvenAndOdd(int arr[], int n)\n    {\n        ArrayList<Integer> list = new ArrayList<>();\n\t\t    \n\t\t    for(int i=0;i<n;i++)\n\t\t    {\n\t\t        if(arr[i]%2==0)\n\t\t        {\n\t\t            list.add(arr[i]);\n\t\t        }\n\t\t    }\n\t\t    \n\t\t    for(int i=0;i<n;i++)\n\t\t    {\n\t\t        if(arr[i]%2!=0)\n\t\t        {\n\t\t            list.add(arr[i]);\n\t\t        }\n\t\t    }\n\t\t    int len = list.size();\n\t\t    int[] array = list.stream().mapToInt(i->i).toArray();\n\t\t    return array;\n    }\n    \n    static long[] rearrangeEvenAndOddLong(long arr[], int n)\n    {\n        ArrayList<Long> list = new ArrayList<>();\n\t\t    \n\t\t    for(int i=0;i<n;i++)\n\t\t    {\n\t\t        if(arr[i]%2==0)\n\t\t        {\n\t\t            list.add(arr[i]);\n\t\t        }\n\t\t    }\n\t\t    \n\t\t    for(int i=0;i<n;i++)\n\t\t    {\n\t\t        if(arr[i]%2!=0)\n\t\t        {\n\t\t            list.add(arr[i]);\n\t\t        }\n\t\t    }\n\t\t    int len = list.size();\n\t\t    long[] array = list.stream().mapToLong(i->i).toArray();\n\t\t    return array;\n    }\n\t\n\t\n    \n    static boolean isPrime(long n)\n    {\n \n        \/\/ Check if number is less than\n        \/\/ equal to 1\n        if (n <= 1)\n            return false;\n \n        \/\/ Check if number is 2\n        else if (n == 2)\n            return true;\n \n        \/\/ Check if n is a multiple of 2\n        else if (n % 2 == 0)\n            return false;\n \n        \/\/ If not, then just check the odds\n        for (long i = 3; i <= Math.sqrt(n); i += 2)\n        {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n    \n    static long getSum(long n)\n    {    \n        long sum = 0;\n          \n        while (n != 0)\n        {\n            sum = sum + n % 10;\n            n = n\/10;\n        }\n      \n    return sum;\n    }\n    \n    static int gcd(int a, int b)\n    {\n      if (b == 0)\n        return a;\n      return gcd(b, a % b);\n    }\n     \n    static long gcdLong(long a, long b)\n    {\n        if (b == 0)\n        return a;\n      return gcdLong(b, a % b);\n    }\n    \n    static void swap(int i, int j)\n    {\n        int temp = i;\n        i = j;\n        j = temp;\n    }\n\t\n\tstatic int countDigit(int n)\n    {\n        return (int)Math.floor(Math.log10(n) + 1);\n    }\n\t\n}\n\nclass Pair\n{\n    int first , second;\n    Pair(int first , int second)\n    {\n        this.first = first;\n        this.second = second;\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\nvoid precision(int a) { cout << setprecision(a) << fixed; }\nvector<string> compositeDp = {\n    \"1\",   \"4\",   \"6\",   \"8\",    \"9\",    \"22\",   \"33\",  \"55\",  \"77\",\n    \"25\",  \"27\",  \"35\",  \"57\",   \"75\",   \"235\",  \"237\", \"357\", \"573\",\n    \"537\", \"735\", \"753\", \"2375\", \"2537\", \"2573\", \"2735\"};\nvector<long long> factors(long long n) {\n  vector<long long> first;\n  long long tem = 1;\n  for (long long x = 2; x * x <= n; x++) {\n    while (n % x == 0) {\n      first.push_back(x);\n      n \/= x;\n    }\n  }\n  if (n > 1) first.push_back(n);\n  return first;\n}\nbool marked[200000 + 100];\nbool isPrime(int n) {\n  if (n < 2) return false;\n  if (n == 2) return true;\n  if (n % 2 == 0) return false;\n  return marked[n] == false;\n}\nvoid sieve(int n) {\n  for (int i = 3; i * i <= n; i += 2) {\n    if (marked[i] == false) {\n      for (int j = i * i; j <= n; j += i + i) {\n        marked[j] = true;\n      }\n    }\n  }\n}\nlong long stringToint(string str) {\n  int num = stoi(str);\n  return num;\n}\nint bin_search(int arr[], int target, int n) {\n  int l = 0, r = n - 1, mid = 0;\n  while (l <= r) {\n    mid = l + ((r - l) \/ 2);\n    if (arr[mid] == target)\n      return mid;\n    else if (arr[mid] < target)\n      l = mid + 1;\n    else\n      r = mid - 1;\n  }\n  return -1;\n}\nvector<int> computeLPSArray(string str) {\n  int n = str.size(), i = 0, j = 1;\n  vector<int> a(n, 0);\n  while (j < n) {\n    if (str[i] != str[j]) {\n      while (str[i] != str[j] && i > 0) i = a[i - 1];\n      if (str[i] == str[j])\n        a[j++] = ++i;\n      else\n        a[j++] = 0;\n    } else\n      a[j++] = ++i;\n  }\n  return a;\n}\nint hamming(int a, int b) { return __builtin_popcount(a ^ b); }\nbool cmp(int a, int b) { return a > b; }\nvoid reset() {\n  for (int i = 0; i < 200000 + 100; i++) {\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    long long n, ans, sum = 0;\n    cin >> n;\n    vector<long long> arr(n);\n    for (auto &x : arr) cin >> x;\n    sort((arr).begin(), (arr).end());\n    sum = -arr[0];\n    ans = arr[0];\n    for (int i = 1; i < n; i++) {\n      ans = max(ans, arr[i] + sum);\n      if (ans < 0)\n        sum += ans;\n      else\n        sum -= ans;\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nsigned main() {\n  long long test;\n  cin >> test;\n  while (test--) {\n    long long n;\n    cin >> n;\n    vector<long long> a(n);\n    for (long long &x : a) {\n      cin >> x;\n    }\n    sort(a.begin(), a.end());\n    long long i = 0;\n    while (i < n - 1 && a[i + 1] >= 2 * a[i]) {\n      i++;\n    }\n    if (i == 0) {\n      cout << a[0] << '\\n';\n    } else {\n      cout << a[i] - a[i - 1] << '\\n';\n    }\n  }\n  return 0;\n}\n","    import java.io.BufferedReader;\n    import java.io.FileInputStream;\n    import java.io.FileNotFoundException;\n    import java.io.IOException;\n    import java.io.InputStreamReader;\n    import java.util.*;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.io.PrintStream;\n    import java.io.PrintWriter;\n    import java.io.DataInputStream;\n\n        public class Solution {\n\n            \/\/TEMPLATE -------------------------------------------------------------------------------------\n\n            public static boolean Local(){\n                try{ \n                    return System.getenv(\"LOCAL_SYS\")!=null;\n                }catch(Exception e){\n                    return false;\n                }\n            }   \n\n            public static boolean LOCAL;\n\n            static class FastScanner {\n\n                    BufferedReader br;\n                    StringTokenizer st ;\n\n                    FastScanner(){\n                        br =  new BufferedReader(new InputStreamReader(System.in));\n                        st = new StringTokenizer(\"\");\n                    }\n\n                    FastScanner(String file) {\n\n                        try{\n                            br =  new BufferedReader(new InputStreamReader(new FileInputStream(file)));\n                            st = new StringTokenizer(\"\");\n                        }catch(FileNotFoundException e) {\n                            \/\/ TODO Auto-generated catch block\n                            System.out.println(\"file not found\");\n                            e.printStackTrace();\n                        }\n                        \n                    }\n                    String next() {\n                        while (!st.hasMoreTokens())\n                            try {\n                                st = new StringTokenizer(br.readLine());\n                            } catch (IOException e) {\n                            }\n                        return st.nextToken();\n                    }\n                    int nextInt() {\n                        return Integer.parseInt(next());\n                    }\n                    long nextLong() {\n                        return Long.parseLong(next());\n                    }\n                    String readLine() throws IOException{\n                        return br.readLine();\n                    }\n                }\n                                    \n            static class Pair<T,X> {\n\n                T first;\n                X second;\n                \n                Pair(T first,X second){\n                    this.first = first;\n                    this.second = second;\n                }\n\n                @Override\n                public int hashCode(){\n                    return Objects.hash(first,second);\n                }\n\n                @Override\n                public boolean equals(Object obj){\n                    return obj.hashCode() == this.hashCode();\n                }\n\n            }\n\n        \n        static PrintStream debug = null;\n        \n        \n        static long mod = (long)(Math.pow(10,9) + 7); \n       \/\/TEMPLATE -------------------------------------------------------------------------------------END\/\/\n        public static void main(String[] args) throws Exception {\n            \n            FastScanner s = new FastScanner();\n            LOCAL = Local();\n            \/\/PrintWriter pw = new PrintWriter(System.out);\n            if(LOCAL){\n                s = new FastScanner(\"src\/input.txt\");\n                PrintStream o = new PrintStream(\"src\/sampleout.txt\");\n                debug = new PrintStream(\"src\/debug.txt\");\n                System.setOut(o);\n            \/\/  pw = new PrintWriter(o);\n            } long mod = 1000000007;\n\n        \n            int tcr = s.nextInt();                  \n            \n            StringBuilder sb = new StringBuilder();\n\n            for(int tc=0;tc<tcr;tc++){\n                int n = s.nextInt();\n                long arr[] = new long[n];\n                for(int i=0;i<n;i++){\n                    arr[i] = s.nextLong();\n                }\n                sort(arr);\n                long increase_by = 0;\n                long ans = arr[0];\n                int index = 0;\n                for(;index < n - 1;index++){\n                    if((arr[index] - increase_by) < 0){increase_by += (arr[index]);}\n                    else{break;}\n                }\n                increase_by = -(increase_by);\n                \/\/println(index+\"--\");\n                if(index == n - 1){\n                    ans = arr[n-1] + increase_by;\n                    sb.append(ans+\"\\n\");\n                    continue;\n                }else{\n                    for(int i=index;i<n;i++){\n                        arr[i] += increase_by;\n                    }\n                    ans = arr[index];\n                  \/\/  println(ans+\"--\");\n                    for(int i=index;i<n-1;i++){\n                        \/\/println(arr[i+1] - arr[i]+\"--\");\n                        if(arr[i + 1] - arr[i] >= ans){\n                            ans = arr[i + 1] - arr[i];\n                        }else{break;}\n                    }\n                    sb.append(ans+\"\\n\");\n                }\n\n            }    \n\n\n            print(sb.toString());\n        }\n\n        public static void dec(TreeMap<Integer,Integer> map,int n){\n            int cnt = map.get(n);\n            if(cnt == 1){map.remove(n);return;}\n            map.put(n,cnt - 1);\n        }\n \n        \n\n        public static List<int[]> print_prime_factors(int n){\n        \n            List<int[]> list = new ArrayList<>();\n            \n            for(int i=2;i<=(int)(Math.sqrt(n));i++){\n    \n                if(n % i == 0){\n                    \n                    int cnt = 0;\n                    \n                    while( (n % i) == 0){\n                        n = n\/i;\n                        cnt++;\n                    }\n    \n                    list.add(new int[]{i,cnt});\n                }\n            }\n    \n            if(n!=1){\n                list.add(new int[]{n,1});\n            }\n\n            return list;\n        }\n\n        public static List<int[]> prime_factors(int n,List<Integer> sieve){\n            List<int[]> list = new ArrayList<>();\n            int index = 0;\n            while(n > 1 && sieve.get(index) <= Math.sqrt(n)){\n                int curr = sieve.get(index);\n                int cnt = 0;\n                while((n % curr) == 0){\n                    n = n\/curr;\n                    cnt++;\n                }\n                if(cnt >= 1){\n                    list.add(new int[]{curr,cnt});\n                }\n                index++;\n            }\n            if(n > 1){\n                list.add(new int[]{n,1});\n            }\n            return list;\n        }\n\n        public static boolean inRange(int r1,int r2,int val){\n            return ((val >= r1) && (val <= r2));\n        }\n\n        static int len(long num){\n            return Long.toString(num).length();\n        }\n\n        static long mulmod(long a, long b,long mod)\n        {\n            long ans = 0l;\n            \n            while(b > 0){\n                long curr = (b & 1l);\n                if(curr == 1l){\n                    ans = ((ans % mod) + a) % mod;\n                }\n                \n                a = (a + a) % mod;\n\n                b = b >> 1;\n            }\n\n            return ans;\n        }\n\n\n        public static void dbg(PrintStream ps,Object... o) throws Exception{\n            if(ps == null){\n                return;\n            }\n            Debug.dbg(ps,o);\n        }\n\n        public static long modpow(long num,long pow,long mod){\n\n            long val = num;\n            long ans = 1l;\n\n            while(pow > 0l){\n                \n                long bit = pow & 1l;\n\n                if(bit == 1){\n                    ans = (ans * (val%mod))%mod;\n                }\n\n                val = (val * val) % mod;\n                pow = pow >> 1;\n            }\n\n            return ans;\n\n        }\n\n        public static char get(int n){\n            return (char)('a' + n);\n        }\n\n        public static long[] sort(long arr[]){\n            List<Long> list = new ArrayList<>();\n            for(long n : arr){list.add(n);}\n            Collections.sort(list);\n            for(int i=0;i<arr.length;i++){\n                arr[i] = list.get(i);\n            }\n            return arr;\n        }\n\n        public static int[] sort(int arr[]){\n            List<Integer> list = new ArrayList<>();\n            for(int n : arr){list.add(n);}\n            Collections.sort(list);\n            for(int i=0;i<arr.length;i++){\n                arr[i] = list.get(i);\n            }\n            return arr;\n        }\n\n        \/\/ return the (index + 1)\n        \/\/ where index is the pos of just smaller element\n        \/\/ i.e count of elemets strictly less than num\n        public static int justSmaller(long arr[],long num){\n            \/\/  System.out.println(num+\"@\");\n            int st = 0;\n            int e = arr.length - 1;\n\n            int ans = -1;\n\n            while(st <= e){\n\n                int mid = (st + e)\/2;\n\n                if(arr[mid] >= num){\n                    e = mid - 1;\n                }else{\n                    ans = mid;\n                    st = mid + 1;\n                }\n\n            }\n\n\n            return ans + 1;\n\n        }\n        public static int justSmaller(int arr[],int num){\n            \/\/  System.out.println(num+\"@\");\n            int st = 0;\n            int e = arr.length - 1;\n\n            int ans = -1;\n\n            while(st <= e){\n\n                int mid = (st + e)\/2;\n\n                if(arr[mid] >= num){\n                    e = mid - 1;\n                }else{\n                    ans = mid;\n                    st = mid + 1;\n                }\n\n            }\n\n\n            return ans + 1;\n\n        }\n        \n        \/\/return (index of just greater element)\n        \/\/count of elements smaller than or equal to num\n\n        public static int justGreater(long arr[],long num){\n            int st = 0;\n            int e = arr.length - 1;\n\n            int ans = arr.length;\n\n            while(st <= e){\n                \n                int mid = (st + e)\/2;\n\n                if(arr[mid] <= num){\n                    st = mid + 1;\n                }else{\n                    ans = mid;\n                    e = mid - 1;\n                }\n            }\n\n            return ans;\n\n        }\n\n        public static int justGreater(int arr[],int num){\n            int st = 0;\n            int e = arr.length - 1;\n\n            int ans = arr.length;\n\n            while(st <= e){\n                \n                int mid = (st + e)\/2;\n\n                if(arr[mid] <= num){\n                    st = mid + 1;\n                }else{\n                    ans = mid;\n                    e = mid - 1;\n                }\n            }\n\n            return ans;\n\n        }\n\n        \n\n        public static void println(Object obj){\n            System.out.println(obj.toString());\n        }\n\n        public static void print(Object obj){\n            System.out.print(obj.toString());\n        }\n\n        public static int gcd(int a,int b){\n            if(b == 0){return a;}\n            return gcd(b,a%b);\n        }\n\n        public static long gcd(long a,long b){\n            if(b == 0l){\n                return a;\n            }\n\n            return gcd(b,a%b);\n        }\n\n        public static int find(int parent[],int v){\n            if(parent[v] == v){\n                return v;\n            }\n            \n            return parent[v] = find(parent, parent[v]);\n        }\n\n\n\n        public static List<Integer> sieve(){\n        \n                List<Integer> prime = new ArrayList<>();\n\n                int arr[] = new int[100001];\n\n            Arrays.fill(arr,1);\n\n            arr[1] = 0;\n            arr[2] = 1;\n\n            for(int i=2;i<=100000;i++){\n                \n                if(arr[i] == 1){\n                    \n                    prime.add(i);\n\n                    for(long j = (i*1l*i);j<100001;j+=i){\n                        arr[(int)j] = 0;\n                    }\n                }\n            }\n\n            return prime;\n        }\n\n        static boolean isPower(long n,long a){\n            \n            long log = (long)(Math.log(n)\/Math.log(a));\n\n            long power = (long)Math.pow(a,log);\n\n            if(power == n){return true;}\n\n            return false;\n        }\n\n\n        private static int mergeAndCount(int[] arr, int l,int m, int r)\n        {\n            \/\/ Left subarray\n            int[] left =  Arrays.copyOfRange(arr, l, m + 1);\n\n            \/\/ Right subarray\n            int[] right = Arrays.copyOfRange(arr, m + 1, r + 1);\n\n            int i = 0, j = 0, k = l, swaps = 0;\n\n            while (i < left.length && j < right.length) {\n                if (left[i] <= right[j])\n                    arr[k++] = left[i++];\n                else {\n                    arr[k++] = right[j++];\n                    swaps += (m + 1) - (l + i);\n                }\n            }\n            while (i < left.length)\n                arr[k++] = left[i++];\n            while (j < right.length)\n                arr[k++] = right[j++];\n            return swaps;\n        }\n\n        \/\/ Merge sort function\n        private static int mergeSortAndCount(int[] arr, int l,int r)\n        {\n\n            \/\/ Keeps track of the inversion count at a\n            \/\/ particular node of the recursion tree\n            int count = 0;\n\n            if (l < r) {\n                int m = (l + r) \/ 2;\n\n                \/\/ Total inversion count = left subarray count\n                \/\/ + right subarray count + merge count\n\n                \/\/ Left subarray count\n                count += mergeSortAndCount(arr, l, m);\n\n                \/\/ Right subarray count\n                count += mergeSortAndCount(arr, m + 1, r);\n\n                \/\/ Merge count\n                count += mergeAndCount(arr, l, m, r);\n            }\n\n            return count;\n        }\n\n        static class Debug{\n            \/\/change to System.getProperty(\"ONLINE_JUDGE\")==null; for CodeForces\n            public static final boolean LOCAL = System.getProperty(\"ONLINE_JUDGE\")==null;\n\n            \n\n            private static <T> String ts(T t) {\n                if(t==null) {\n                    return \"null\";\n                }\n                try {\n                    return ts((Iterable) t);\n                }catch(ClassCastException e) {\n                    if(t instanceof int[]) {\n                        String s = Arrays.toString((int[]) t);\n                        return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                    }else if(t instanceof long[]) {\n                        String s = Arrays.toString((long[]) t);\n                        return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                    }else if(t instanceof char[]) {\n                        String s = Arrays.toString((char[]) t);\n                        return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                    }else if(t instanceof double[]) {\n                        String s = Arrays.toString((double[]) t);\n                        return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                    }else if(t instanceof boolean[]) {\n                        String s = Arrays.toString((boolean[]) t);\n                        return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                    }\n                    try {\n                        return ts((Object[]) t);\n                    }catch(ClassCastException e1) {\n                        return t.toString();\n                    }\n                }\n            }\n            private static <T> String ts(T[] arr) {\n                StringBuilder ret = new StringBuilder();\n                ret.append(\"{\");\n                boolean first = true;\n                for(T t: arr) {\n                    if(!first) {\n                        ret.append(\", \");\n                    }\n                    first = false;\n                    ret.append(ts(t));\n                }\n                ret.append(\"}\");\n                return ret.toString();\n            }\n            private static <T> String ts(Iterable<T> iter) {\n                StringBuilder ret = new StringBuilder();\n                ret.append(\"{\");\n                boolean first = true;\n                for(T t: iter) {\n                    if(!first) {\n                        ret.append(\", \");\n                    }\n                    first = false;\n                    ret.append(ts(t));\n                }\n                ret.append(\"}\\n\");\n                return ret.toString();\n            }\n            public static void dbg(PrintStream ps,Object... o) throws Exception {\n                if(LOCAL) {\n                    System.setErr(ps);\n                    System.err.print(\"Line #\"+Thread.currentThread().getStackTrace()[2].getLineNumber()+\": [\\n\");\n                    for(int i = 0; i<o.length; i++) {\n                        if(i!=0) {\n                            System.err.print(\", \");\n                        }\n                        System.err.print(ts(o[i]));\n                    }\n                    System.err.println(\"]\");\n                }\n            }\n        }\n\n    }","import sys\nreadline = sys.stdin.readline\n\nT = int(readline())\n\nfor t in range(T):\n  N = int(readline())\n  A = list(map(int,readline().split()))\n  A = sorted(A)\n  \n  minus_sum = 0\n  best = A[0]\n  \n  for i in range(N - 1):\n    minus_sum += A[i]\n    A[i + 1] -= minus_sum\n    if A[i + 1] < best:\n      break\n    else:\n      best = A[i + 1]\n  print(best)\n","t = int(input())\n\nfor test in range(t):\n    n = int(input())\n    p = list(map(int,input().split()))\n    if(len(p)==1):\n        print(p[0])\n        continue\n    elif(len(p)==2):\n        print(max(min(p[0],p[1]),abs(p[0]-p[1])))\n        continue\n    ans = 0\n    p.sort()\n    for i in range(len(p)-2,0,-1):\n        ans = max(ans,p[i+1]-p[i])\n    print(ans)\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int tc;\n  cin >> tc;\n  while (tc--) {\n    int n;\n    cin >> n;\n    long long arr[n];\n    for (long long &x : arr) cin >> x;\n    sort(arr, arr + n);\n    long long maximal_min = arr[0], decr = arr[0];\n    for (int i = 1; i < n; i++) {\n      arr[i] -= decr;\n      decr += arr[i];\n      maximal_min = max(arr[i - 1], arr[i]);\n    }\n    cout << maximal_min << '\\n';\n  }\n}\n","import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n    \/\/ Graph\n    \/\/ prefix sums\n    \/\/inputs\n    public static void main(String args[])throws Exception{\n        Input sc=new Input();\n        precalculates p=new precalculates();\n        StringBuilder sb=new StringBuilder();\n        int t=sc.readInt();\n        for(int f=0;f<t;f++){\n            int n=sc.readInt();\n            long a[]=sc.readArrayLong();\n            HashSet<Long> map=new HashSet<>();\n            for(int i=0;i<n;i++){\n                map.add(a[i]);\n            }\n            n=map.size();\n            a=new long[n];\n            int j=0;\n            for(Long val:map){\n                a[j++]=val;\n            }\n            Arrays.sort(a);\n            long sum=0;\n            long prev=0;long ans=Long.MIN_VALUE;\n            for(int i=0;i<n-1;i++){\n                sum=sum+((a[i])-prev);\n                ans=Math.max(ans,a[i]-prev);\n                prev=sum;\n            }\n            if(a.length>1 && a[0]==0) {\n                ans = Math.max(ans, a[n - 2]);\n            }else if(a.length>1 && a[0]!=0){\n                ans=Math.max(ans,a[n-1]-prev);\n            }\n\n\n            if(ans!=Long.MIN_VALUE)\n            sb.append(ans+\"\\n\");\n            else\n                sb.append(a[n-1]+\"\\n\");\n\n        }\n        \/\/ 1 2 7 10   1\n        \/\/ 0 1 6 9    2\n        \/\/ 0 0 5 8\n        \/\/ -1 0 2\n        \/\/ 0  1 3\n        \/\/ 0 0 2\n        System.out.print(sb);\n    }\n}\nclass Input{\n    BufferedReader br;\n    StringTokenizer st;\n    Input(){\n        br=new BufferedReader(new InputStreamReader(System.in));\n        st=new StringTokenizer(\"\");\n    }\n    public int[] readArray() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        int a[]=new int[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Integer.parseInt(st.nextToken());\n        }\n        return a;\n    }\n    public long[] readArrayLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        long a[]=new long[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Long.parseLong(st.nextToken());\n        }\n        return a;\n    }\n    public int readInt() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Integer.parseInt(st.nextToken());\n    }\n    public long readLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Long.parseLong(st.nextToken());\n    }\n    public String readString() throws Exception{\n        return br.readLine();\n    }\n    public int[][] read2dArray(int n,int m)throws Exception{\n        int a[][]=new int[n][m];\n        for(int i=0;i<n;i++){\n            st=new StringTokenizer(br.readLine());\n            for(int j=0;j<m;j++){\n                a[i][j]=Integer.parseInt(st.nextToken());\n            }\n        }\n        return a;\n    }\n}\nclass precalculates{\n    public int[] prefixSumOneDimentional(int a[]){\n        int n=a.length;\n        int dp[]=new int[n];\n        for(int i=0;i<n;i++){\n            if(i==0)\n                dp[i]=a[i];\n            else\n                dp[i]=dp[i-1]+a[i];\n        }\n        return dp;\n    }\n    public int[] postSumOneDimentional(int a[]) {\n        int n = a.length;\n        int dp[] = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            if (i == n - 1)\n                dp[i] = a[i];\n            else\n                dp[i] = dp[i + 1] + a[i];\n        }\n        return dp;\n    }\n    public int[][] prefixSum2d(int a[][]){\n        int n=a.length;int m=a[0].length;\n        int dp[][]=new int[n+1][m+1];\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=m;j++){\n                dp[i][j]=a[i-1][j-1]+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];\n            }\n        }\n        return dp;\n    }\n    public long pow(long a,long b){\n        long mod=1000000007;\n        long ans=0;\n        if(b<=0)\n            return 1;\n        if(b%2==0){\n            ans=pow(a,b\/2)%mod;\n            return ((ans%mod)*(ans%mod))%mod;\n        }else{\n            return ((a%mod)*(ans%mod))%mod;\n        }\n    }\n\n}\nclass GraphInteger{\n    HashMap<Integer,vertex> vtces;\n    class vertex{\n        HashMap<Integer,Integer> children;\n        public vertex(){\n            children=new HashMap<>();\n        }\n    }\n    public GraphInteger(){\n        vtces=new HashMap<>();\n    }\n    public void addVertex(int a){\n        vtces.put(a,new vertex());\n    }\n    public void addEdge(int a,int b,int cost){\n        if(!vtces.containsKey(a)){\n            vtces.put(a,new vertex());\n        }\n        if(!vtces.containsKey(b)){\n            vtces.put(b,new vertex());\n        }\n        vtces.get(a).children.put(b,cost);\n\/\/        vtces.get(b).children.put(a,cost);\n    }\n    public boolean isCyclicDirected(){\n        boolean isdone[]=new boolean[vtces.size()+1];\n        boolean check[]=new boolean[vtces.size()+1];\n        for(int i=1;i<=vtces.size();i++) {\n            if (!isdone[i] && isCyclicDirected(i,isdone, check)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private boolean isCyclicDirected(int i,boolean isdone[],boolean check[]){\n        if(check[i])\n            return true;\n        if(isdone[i])\n            return false;\n        check[i]=true;\n        isdone[i]=true;\n        Set<Integer> set=vtces.get(i).children.keySet();\n        for(Integer ii:set){\n            if(isCyclicDirected(ii,isdone,check))\n                return true;\n        }\n        check[i]=false;\n        return false;\n    }\n}\n\n\n\n\n","import sys, collections, math, bisect, heapq, random, functools\n\ninput = sys.stdin.readline\nout = sys.stdout.flush\n\n\ndef solve():\n    n = int(input())\n    queue = []\n    a = list(map(int, input().split()))\n    for i in range(n):\n        heapq.heappush(queue, a[i])\n    diff = 0\n    k = len(queue)\n    while k > 1 and queue[0] - diff <= 0:\n        cur = heapq.heappop(queue) - diff\n        diff += cur\n        k -= 1\n\n    ans = -float('inf')\n    while k > 1:\n        minv = heapq.heappop(queue)\n        k -= 1\n        while k > 1 and queue[0] - diff == minv - diff:\n            heapq.heappop(queue)\n            k -= 1\n\n        two = queue[0]\n        if two - diff - (minv - diff) >= minv - diff:\n           cur = minv - diff\n           diff += cur\n        else:\n            ans = minv - diff\n            break\n\n    if ans == -float('inf'):\n        print(queue[0] - diff)\n    else:\n        print(ans)\n\n\n\nif __name__ == '__main__':\n    for i in range(int(input())):\n        solve()","import java.util.*;\n\n\/\/CODE FORCES\n\npublic class anshulvmc {\n\n    \n    public static void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n    \n    \n    \n    \n    public static int gcd(int a, int b) {\n\t\tif (b==0) return a;\n\t\treturn gcd(b, a%b);\n\t}\n    \n    public static void google(int t) {\n    \tSystem.out.println(\"Case #\"+t+\": \");\n    }\n    \n    \n\/\/    public static void gt(int[][] arr,int k) {\n\/\/    \tint n = arr.length+1;\n\/\/    \tk = Math.min(k,n+1);\n\/\/    \t\n\/\/    \tNode[] nodes = new Node[n];\n\/\/    \tfor(int i=0;i<n;i++) nodes[i] = new Node();\n\/\/    \tfor(int i=0;i<n-1;i++) {\n\/\/    \t\tint a = arr[i][0];\n\/\/    \t\tint b = arr[i][1];\n\/\/    \t\tSystem.out.println(a+\" \"+b);\n\/\/    \t\tnodes[a].adj.add(nodes[b]);\n\/\/    \t\tnodes[b].adj.add(nodes[a]);\n\/\/    \t}\n\/\/    \t\n\/\/    \tArrayDeque<Node> bfs = new ArrayDeque<>();\n\/\/    \tfor(Node nn:nodes) {\n\/\/    \t\tif(nn.adj.size()<2) {\n\/\/    \t\t\tbfs.addLast(nn);\n\/\/    \t\t\tnn.dist=0;\n\/\/    \t\t}\n\/\/    \t}\n\/\/    \t\n\/\/    \twhile(bfs.size()>0) {\n\/\/    \t\tNode nn = bfs.removeFirst();\n\/\/    \t\tfor(Node a : nn.adj) {\n\/\/    \t\t\tif(a.dist!=-1) continue;\n\/\/    \t\t\ta.usedDegree++;\n\/\/    \t\t\tif(a.adj.size() - a.usedDegree <= 1) {\n\/\/    \t\t\t\ta.dist = nn.dist+1;\n\/\/    \t\t\t\tbfs.addLast(a);\n\/\/    \t\t\t}\n\/\/    \t\t}\n\/\/    \t}\n\/\/    \t\n\/\/    \tint[] cs = new int[n+1];\n\/\/    \tfor(Node nn:nodes) {\n\/\/    \t\tcs[nn.dist]++;\n\/\/    \t}\n\/\/    \tfor(int i=1;i<cs.length;i++) cs[i]+=cs[i-1];\n\/\/    \tSystem.out.println(n-cs[k-1]);\n\/\/    }\n    \n    public static class Node{\n    \tArrayList<Node> adj = new ArrayList<>();\n    \tint dist = -1;\n    \tint usedDegree = 0;\n    }\n    \n    \n    public static void cat_mice(int dest,int[] arr) {\n    \tsort(arr);\n    \tint time = dest;\n\t\tint timeleft = dest-1;\n\t\tint counter=0;\n\t\tfor(int i=arr.length-1;i>=0;i--) {\n\t\t\tint val = arr[i];\n\t\t\tint takes = time - val;\n\t\t\tif(takes <= timeleft) {\n\t\t\t\ttimeleft -= takes;\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n    \tSystem.out.println(counter);\n    }\n    \n    \n\tpublic static void minex(int n,int[] arr) {\n    \tsort(arr);\n    \t\n    \tint ans = Integer.MIN_VALUE;\n    \tint size = n;\n    \twhile(size-->0) {\n    \t\tint temp = arr[0];\n    \t\tans = Math.max(ans,temp);\n    \t\tfor(int j=0;j<arr.length;j++) {\n    \t\t\tarr[j] -= temp;\n    \t\t\t\n    \t\t\tif(arr[j] == 0) {\n    \t\t\t\tarr[j] = Integer.MAX_VALUE;\n    \t\t\t}\n    \t\t}\n    \t\tsort(arr);\n    \t}\n    \tif(ans == Integer.MAX_VALUE || ans == Integer.MIN_VALUE) {\n    \t\tSystem.out.println(0);\n    \t}\n    \telse {\n    \t\tSystem.out.println(ans);\n    \t}\n    \t\n    }\n\t\n    public static void main(String args[])\n    \n    \n    {\t\n    \tScanner scn = new Scanner(System.in);\n    \tint test = scn.nextInt();\n    \tfor(int i=0;i<test;i++) {\n    \t\tint n = scn.nextInt();\n    \t\tint[] arr = new int[n];\n    \t\tfor(int j=0;j<n;j++) {\n    \t\t\tarr[j] = scn.nextInt();\n    \t\t}\n    \t\t\n    \t\tminex(n,arr);\n    \t}\n\/\/    \tint n = 1;\n\/\/    \tint[] dp = new int[2];\n\/\/    \tSystem.out.println(fact(n,dp));\n    \t\t\t\n    }\n\n}","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 9, M = 1e5 + 9, mod = 1e9 + 7, inf = 0x3f3f3f;\nint32_t main() {\n  std::ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n, a = 0;\n    cin >> n;\n    if (n == 1) {\n      cin >> n;\n      cout << n << '\\n';\n      continue;\n    }\n    vector<long long> vec(n);\n    for (long long i = 0; i < n; i++) cin >> vec[i];\n    sort(vec.begin(), vec.end());\n    long long mn = 0, mx = vec.back(), nn = 0;\n    while (vec[mn] < mx - vec[mn]) {\n      mx -= vec[mn];\n      nn += vec[mn];\n      if (mn >= vec.size() - 1) break;\n      mn++;\n      vec[mn] -= nn;\n    }\n    cout << min(vec[mn], mx) << '\\n';\n  }\n}\n","import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\n\/**\n *\n * @author Acer\n *\/\npublic class MaximumExtraction_c {\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int T = sc.nextInt();\n        while(T-- > 0){\n            int n = sc.nextInt();\n            ArrayList<Integer> arr = new ArrayList<Integer>();           \n            for (int i = 0; i < n; i++) {\n                arr.add(sc.nextInt());\n            }\n            \n            if(n == 1){\n                System.out.println(arr.get(0));\n                continue;\n            }\n            \n            Collections.sort(arr);\n            \n            long prev = arr.get(0);\n            long max = arr.get(0);\n            long ans = 0;\n            for (int i = 1; i < n; i++) {\n                ans = arr.get(0)-prev;\n                prev = prev+ans;\n                max = Math.max(max, ans);\n            }\n            System.out.println(max);\n        }\n    }\n    \n}","import java.util.*;\nimport java.io.*;\n\/\/ import java.lang.*;\n\/\/ import java.math.*;\n\npublic class Codeforces {\n    static FastReader sc=new FastReader();\n\tstatic PrintWriter out=new PrintWriter(System.out);\n\tstatic long mod=1000000007;\n\t\/\/ static long mod=998244353;\n\tstatic int MAX=Integer.MAX_VALUE;\n\tstatic int MIN=Integer.MIN_VALUE;\n\tstatic long MAXL=Long.MAX_VALUE;\n\tstatic long MINL=Long.MIN_VALUE;\n\tstatic ArrayList<Integer> graph[];\n\tstatic long fact[];\n\tstatic StringBuffer sb;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t\/\/ code goes here\n\t\tint t=I();\n\t\touter:while(t-->0)\n\t\t{\n\t\t\tint n=I();\n\t\t\tlong a[]=new long[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ta[i]=L();\n\t\t\t}\n\t\t\tsort(a);\n\t\t\tlong p=a[0],sml=a[0];\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tif(a[i]-p>=sml){\n\t\t\t\t\tsml=a[i]-p;\n\t\t\t\t\tp+=a[i]-p;\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(sml);\n\t\t}\n\t\tout.close();\n\t}\n\tpublic static class pair\n    {\n    \tlong a;\n    \tlong b;\n    \tpublic pair(long val,long index)\n    \t{\n    \t    a=val;\n    \t    b=index;\n    \t}\n    }\n\tpublic static class myComp implements Comparator<pair>\n\t{\n\t\t\/\/sort in ascending order.\n\t\t\/\/ public int compare(pair p1,pair p2)\n\t\t\/\/ {\n\t\t\/\/ \tif(p1.a==p2.a)\n    \t\/\/     return 0;\n    \t\/\/     else if(p1.a<p2.a)\n    \t\/\/     return -1;\n    \t\/\/     else\n    \t\/\/     return 1;\n\t\t\/\/ }\n\t\t\/\/sort in descending order.\n\t\tpublic int compare(pair p1,pair p2)\n    \t{\n    \t    if(p1.a==p2.a)\n    \t    return 0;\n    \t    else if(p1.a<p2.a)\n    \t    return 1;\n    \t    else\n    \t    return -1;\n    \t}\n\t}\n\tpublic static long nPr(int n,int r)\n\t{\n\t\tlong ans=divide(fact(n),fact(n-r),mod);\n\t\treturn ans;\n\t}\n\tpublic static long nCr(int n,int r)\n\t{\n\t\tlong ans=divide(fact[n],mul(fact[n-r],fact[r]),mod);\n\t\treturn ans;\n\t}\n\tpublic static long kadane(long a[],int n)  \/\/largest sum subarray\n\t{\n\t\tlong max_sum=Long.MIN_VALUE,max_end=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tmax_end+=a[i];\n\t\t\tif(max_sum<max_end){max_sum=max_end;}\n\t\t\tif(max_end<0){max_end=0;}\n\t\t}\n\t\treturn max_sum;\n\t}\n\tpublic static void DFS(int s,boolean visited[])\n\t{\n\t\tvisited[s]=true;\n\t\tfor(int i:graph[s]){\n\t\t\tif(!visited[i]){\n\t\t\t\tDFS(i,visited);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void setGraph(int n,int m)\n\t{\n\t\tgraph=new ArrayList[n+1];\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tgraph[i]=new ArrayList<>();\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u=I(),v=I();\n\t\t\tgraph[u].add(v);\n\t\t\tgraph[v].add(u);\n\t\t}\n\t}\n\tpublic static int BS(long a[],long x,int ii,int jj)\n\t{\n\t\t\/\/ int n=a.length;\n\t\tint mid=0;\n\t\tint i=ii,j=jj;\n\t\twhile(i<=j)\n\t\t{\n\t\t\tmid=(i+j)\/2;\n\t\t\tif(a[mid]<x){\n\t\t\t\ti=mid+1;\n\t\t\t}else if(a[mid]>x){\n\t\t\t\tj=mid-1;\n\t\t\t}else{\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t\/\/LOWER_BOUND and UPPER_BOUND functions\n\n\tpublic static int lower_bound(long arr[],int start, int end, long X)   \/\/start=0,end=n-1\n\t{\n\t\tif(arr[arr.length-1]<X)return end;\n\t\tif(arr[0]>X)return -1;\n\t\tint left=start,right=end;\n\t\twhile(left<right){\n\t\t\tint mid=(left+right)\/2;\n\t\t\tif(arr[mid]==X){                                      \/\/Returns last index of lower bound value.\n\t\t\t\tif(mid<end && arr[mid+1]==X){\n\t\t\t\t\tleft=mid+1;\n\t\t\t\t}else{\n\t\t\t\t\treturn mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ if(arr[mid]==X){                                   \/\/Returns first index of lower bound value.\n\t\t\t\/\/ \tif(mid>start && arr[mid-1]==X){\n\t\t\t\/\/ \t\tright=mid-1;\n\t\t\t\/\/ \t}else{\n\t\t\t\/\/ \t\treturn mid;\n\t\t\t\/\/ \t}\n\t\t\t\/\/ }\n\t\t\telse if(arr[mid]>X){\n\t\t\t\tif(mid>start && arr[mid-1]<X){\n\t\t\t\t\treturn mid-1;\n\t\t\t\t}else{\n\t\t\t\t\tright=mid-1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(mid<end && arr[mid+1]>X){\n\t\t\t\t\treturn mid;\n\t\t\t\t}else{\n\t\t\t\t\tleft=mid+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\tpublic static int upper_bound(long arr[],int start,int end,long X)\t\t\t\/\/start=0,end=n-1\n\t{\n\t\tif(arr[0]>=X)return start;\n\t\tif(arr[arr.length-1]<X)return -1;\n\t\tint left=start,right=end;\n\t\twhile(left<right){\n\t\t\tint mid=(left+right)\/2;\n\t\t\tif(arr[mid]==X){                                   \/\/returns first index of upper bound value.\n\t\t\t\tif(mid>start && arr[mid-1]==X){\n\t\t\t\t\tright=mid-1;\n\t\t\t\t}else{\n\t\t\t\t\treturn mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ if(arr[mid]==X){\t\t\t\t\t\t\t\t\t\/\/returns last index of upper bound value.\n\t\t\t\/\/ \tif(mid<end && arr[mid+1]==X){\n\t\t\t\/\/ \t\tleft=mid+1;\n\t\t\t\/\/ \t}else{\n\t\t\t\/\/ \t\treturn mid;\n\t\t\t\/\/ \t}\n\t\t\t\/\/ }\n\t\t\telse if(arr[mid]>X){\n\t\t\t\tif(mid>start && arr[mid-1]<X){\n\t\t\t\t\treturn mid;\n\t\t\t\t}else{\n\t\t\t\t\tright=mid-1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(mid<end && arr[mid+1]>X){\n\t\t\t\t\treturn mid+1;\n\t\t\t\t}else{\n\t\t\t\t\tleft=mid+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\n\t\/\/END\n\n\tpublic static boolean isSorted(int a[])\n\t{\n\t\tint n=a.length;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tif(a[i]>a[i+1])return false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static boolean isSorted(long a[])\n\t{\n\t\tint n=a.length;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tif(a[i]>a[i+1])return false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static int computeXOR(int n) \/\/compute XOR of all numbers between 1 to n.\n    {\n        if (n % 4 == 0)\n            return n;\n        if (n % 4 == 1)\n            return 1;\n        if (n % 4 == 2)\n            return n + 1;\n        return 0;\n    }\n\tpublic static ArrayList<Integer> primeSieve(int n)\n\t{\n\t    ArrayList<Integer> arr=new ArrayList<>();\n\t    boolean prime[] = new boolean[n + 1];\n        for (int i = 0; i <= n; i++)\n        prime[i] = true;\n        for (int p = 2; p * p <= n; p++)\n        {\n            if (prime[p] == true)\n            {\n                for (int i = p * p; i <= n; i += p)\n                prime[i] = false;\n            }\n        }\n        for (int i = 2; i <= n; i++)\n        {\n            if (prime[i] == true)\n            arr.add(i);\n        }\n        return arr;\n\t}\n\n\t\/\/ Fenwick \/ BinaryIndexed  Tree  USE IT - FenwickTree ft1=new FenwickTree(n);\n\tpublic static class FenwickTree\n\t{\n\t\tint farr[];\n\t\tint n;\n\t\tpublic FenwickTree(int c)\n\t\t{\n\t\t\tn=c+1;\n\t\t\tfarr=new int[n];\n\t\t}\n\t\t\/\/ public void update_range(int l,int r,long p)\n\t\t\/\/ {\n\t\t\/\/ \tupdate(l,p);\n\t\t\/\/ \tupdate(r+1,(-1)*p);\n\t\t\/\/ }\n\t\tpublic void update(int x,int p)\n\t\t{\n\t\t\tfor(;x<n;x+=x&(-x))\n\t\t\t{\n\t\t\t\tfarr[x]+=p;\n\t\t\t}\n\t\t}\n\t\tpublic long get(int x)\n\t\t{\n\t\t\tlong ans=0;\n\t\t\tfor(;x>0;x-=x&(-x))\n\t\t\t{\n\t\t\t\tans=ans+farr[x];\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\t\/\/Disjoint Set Union\n\tpublic static class DSU\n\t{\n\t    int par[],rank[];\n\t    public DSU(int c)\n\t    {\n\t        par=new int[c+1];\n\t        rank=new int[c+1];\n\t        for(int i=0;i<=c;i++)\n\t        {\n\t            par[i]=i;\n\t            rank[i]=0;\n\t        }\n\t    }\n\t    public int find(int a)\n\t    {\n\t        if(a==par[a])\n\t        return a;\n\t        return par[a]=find(par[a]);\n\t    }\n\t    public void union(int a,int b)\n\t    {\n\t        int a_rep=find(a),b_rep=find(b);\n\t        if(a_rep==b_rep)\n\t        return;\n\t        if(rank[a_rep]<rank[b_rep])\n\t        par[a_rep]=b_rep;\n\t        else if(rank[a_rep]>rank[b_rep])\n\t        par[b_rep]=a_rep;\n\t        else\n\t        {\n\t            par[b_rep]=a_rep;\n\t            rank[a_rep]++;\n\t        }\n\t    }\n\t}\n\t\n    public static class myComp1 implements Comparator<pair1>\n    {\n\t\t\/\/sort in ascending order.\n    \tpublic int compare(pair1 p1,pair1 p2)\n    \t{\n    \t    if(p1.a==p2.a)\n    \t    return 0;\n    \t    else if(p1.a<p2.a)\n    \t    return -1;\n    \t    else\n    \t    return 1;\n    \t}\n\t\t\/\/sort in descending order.\n\t\t\/\/ public int compare(pair p1,pair p2)\n    \t\/\/ {\n    \t\/\/     if(p1.a==p2.a)\n    \t\/\/     return 0;\n    \t\/\/     else if(p1.a<p2.a)\n    \t\/\/     return 1;\n    \t\/\/     else\n    \t\/\/     return -1;\n    \t\/\/ }\n    }\n\tpublic static class pair1\n    {\n    \tlong a;\n    \tlong b;\n    \tpublic pair1(long val,long index)\n    \t{\n    \t    a=val;\n    \t    b=index;\n    \t}\n    }\n    public static ArrayList<pair1> mergeIntervals(ArrayList<pair1> arr)\n\t{\n\t    \/\/****************use this in main function-Collections.sort(arr,new myComp1());\n\t    ArrayList<pair1> a1=new ArrayList<>();\n\t    if(arr.size()<=1)\n\t    return arr;\n\t    a1.add(arr.get(0));\n\t    int i=1,j=0;\n\t    while(i<arr.size())\n\t    {\n\t        if(a1.get(j).b<arr.get(i).a)\n\t        {\n\t           a1.add(arr.get(i));\n\t           i++;\n\t           j++;\n\t        }\n\t        else if(a1.get(j).b>arr.get(i).a && a1.get(j).b>=arr.get(i).b)\n\t        {\n\t            i++;\n\t        }\n\t        else if(a1.get(j).b>=arr.get(i).a)\n\t        {\n\t            long a=a1.get(j).a;\n\t            long b=arr.get(i).b;\n\t            a1.remove(j);\n\t            a1.add(new pair1(a,b));\n\t            i++;\n\t        }\n\t    }\n\t    return a1;\n\t}\n\tpublic static ArrayList<Long> primeFact(long a)\n\t{\n\t    ArrayList<Long> arr=new ArrayList<>();\n\t    while(a%2==0){\n\t        arr.add(2L);\n\t        a=a\/2;\n\t    }\n\t    for(long i=3;i*i<=a;i+=2){\n\t        while(a%i==0){\n\t            arr.add(i);\n\t            a=a\/i;\n\t        }\n\t    }\n\t    if(a>2)arr.add(a);\n\t    return arr;\n\t}\n\tpublic static boolean isInteger(double N)\n\t{\n\t\tint X = (int)N;\n\t\tdouble temp2 = N - X;\n\t\tif (temp2 > 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static boolean isPalindrome(String s,int n)\n\t{\n\t\tfor(int i=0;i<=n\/2;i++){\n\t\t\tif(s.charAt(i)!=s.charAt(n-i-1)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static int gcd(int a,int b)\n\t{\n\t    if(b==0)\n\t    return a;\n\t    else\n\t    return gcd(b,a%b);\n\t}\n\tpublic static long gcd(long a,long b)\n\t{\n\t    if(b==0)\n\t    return a;\n\t    else\n\t    return gcd(b,a%b);\n\t}\n\tpublic static long fact(long n)\n\t{\n\t\tlong fact=1;\n\t\tfor(long i=2;i<=n;i++){\n\t\t\tfact=((fact%mod)*(i%mod))%mod;\n\t\t}\n\t\treturn fact;\n\t}\n\tpublic static long fact(int n)\n\t{\n\t\tlong fact=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tfact=((fact%mod)*(i%mod))%mod;\n\t\t}\n\t\treturn fact;\n\t} \n\tpublic static boolean isPrime(int n) \n\t{ \n\t    if (n <= 1) \n\t        return false; \n\t    if (n <= 3) \n\t        return true; \n\t    if (n % 2 == 0 || n % 3 == 0) \n\t        return false; \n\t    double sq=Math.sqrt(n);\n\t  \n\t    for (int i = 5; i <= sq; i = i + 6) \n\t        if (n % i == 0 || n % (i + 2) == 0) \n\t            return false; \n\t    return true; \n\t} \n    public static boolean isPrime(long n) \n\t{ \n\t    if (n <= 1) \n\t        return false; \n\t    if (n <= 3) \n\t        return true; \n\t    if (n % 2 == 0 || n % 3 == 0) \n\t        return false; \n\t    double sq=Math.sqrt(n);\n\t\n\t    for (int i = 5; i <= sq; i = i + 6) \n\t        if (n % i == 0 || n % (i + 2) == 0) \n\t            return false; \n\t    return true; \n\t}\n\tpublic static void printArray(long a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(int a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(char a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]);\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(String a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(boolean a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(pair a[])\n\t{\n\t\tfor(pair p:a){\n\t\t\tout.println(p.a+\"->\"+p.b);\n\t\t}\n\t}\n\tpublic static void printArray(int a[][])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tfor(int j=0;j<a[i].length;j++){\n\t\t\t\tout.print(a[i][j]+\" \");\n\t\t\t}out.println();\n\t\t}\n\t}\n\tpublic static void printArray(long a[][])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tfor(int j=0;j<a[i].length;j++){\n\t\t\t\tout.print(a[i][j]+\" \");\n\t\t\t}out.println();\n\t\t}\n\t}\n\tpublic static void printArray(char a[][])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tfor(int j=0;j<a[i].length;j++){\n\t\t\t\tout.print(a[i][j]+\" \");\n\t\t\t}out.println();\n\t\t}\n\t}\n\tpublic static void printArrayL(ArrayList<Long> arr)\n\t{\n\t\tfor(int i=0;i<arr.size();i++){\n\t\t\tout.print(arr.get(i)+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArrayI(ArrayList<Integer> arr)\n\t{\n\t\tfor(int i=0;i<arr.size();i++){\n\t\t\tout.print(arr.get(i)+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArrayS(ArrayList<String> arr)\n\t{\n\t\tfor(int i=0;i<arr.size();i++){\n\t\t\tout.print(arr.get(i)+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printMapInt(HashMap<Integer,Integer> hm){\n\t\tfor(Map.Entry<Integer,Integer> e:hm.entrySet()){\n\t\t\tout.println(e.getKey()+\"->\"+e.getValue());\n\t\t}out.println();\n\t}\n\tpublic static void printMapLong(HashMap<Long,Long> hm){\n\t\tfor(Map.Entry<Long,Long> e:hm.entrySet()){\n\t\t\tout.println(e.getKey()+\"->\"+e.getValue());\n\t\t}out.println();\n\t}\n\n\t\/\/Modular Arithmetic\n\n\tpublic static long add(long a,long b)\n\t{\n\t\ta+=b;\n\t\tif(a>=mod)a-=mod;\n\t\treturn a;\n\t}\n\tpublic static long sub(long a,long b)\n\t{\n\t\ta-=b;\n\t\tif(a<0)a+=mod;\n\t\treturn a;\n\t}\n\tpublic static long mul(long a,long b)\n\t{\n\t\treturn ((a%mod)*(b%mod))%mod;\n\t}\n\tpublic static long divide(long a,long b,long m)\n\t{\n\t\ta=mul(a,modInverse(b,m));\n\t\treturn a;\n\t}\n\tpublic static long modInverse(long a,long m)\n\t{\n\t\tint x=0,y=0;\n\t\town p=new own(x,y);\n\t\tlong g=gcdExt(a,m,p);\n\t\tif(g!=1){\n\t\t\tout.println(\"inverse does not exists\");\n\t\t\treturn -1;\n\t\t}else{\n\t\t\tlong res=((p.a%m)+m)%m;\n\t\t\treturn res;\n\t\t}\n\t}\n\tpublic static long gcdExt(long a,long b,own p)\n\t{\n\t\tif(b==0){\n\t\t\tp.a=1;\n\t\t\tp.b=0;\n\t\t\treturn a;\n\t\t}\n\t\tint x1=0,y1=0;\n\t\town p1=new own(x1,y1);\n\t\tlong gcd=gcdExt(b,a%b,p1);\n\t\tp.b=p1.a - (a\/b) * p1.b;\n\t\tp.a=p1.b;\n\t\treturn gcd;\n\t}\n\tpublic static long pwr(long m,long n)\n\t{\n\t\tlong res=1;\n\t\tif(m==0)\n\t\treturn 0;\n\t\twhile(n>0)\n\t\t{\n\t\t\tif((n&1)!=0)\n\t\t\t{\n\t\t\t\tres=(res*m);\n\t\t\t}\n\t\t\tn=n>>1;\n\t\t\tm=(m*m);\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static long modpwr(long m,long n)\n\t{\n\t\tlong res=1;\n\t\tm=m%mod;\n\t\tif(m==0)\n\t\treturn 0;\n\t\twhile(n>0)\n\t\t{\n\t\t\tif((n&1)!=0)\n\t\t\t{\n\t\t\t\tres=(res*m)%mod;\n\t\t\t}\n\t\t\tn=n>>1;\n\t\t\tm=(m*m)%mod;\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static class own\n    {\n    \tlong a;\n    \tlong b;\n    \tpublic own(long val,long index)\n    \t{\n    \t    a=val;\n    \t    b=index;\n    \t}\n    }\n\n\t\/\/Modular Airthmetic\n\n\tpublic static void sort(int[] A)\n\t{\n        int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i)\n\t\t{\n            int tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n        Arrays.sort(A);\n    }\n\tpublic static void sort(char[] A)\n\t{\n        int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i)\n\t\t{\n            char tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n        Arrays.sort(A);\n    }\n    public static void sort(long[] A)\n\t{\n\t    int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i)\n\t\t{\n            long tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n\t    Arrays.sort(A);\n\t}\n\tpublic static int I(){return sc.I();}\n    public static long L(){return sc.L();}\n    public static String S(){return sc.S();}\n    public static double D(){return sc.D();}\n}\nclass FastReader {  \n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader(){\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n    String next(){\n        while (st == null || !st.hasMoreElements()){\n            try {\n                st = new StringTokenizer(br.readLine());\n            }\n            catch (IOException e){\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    int I(){ \n        return Integer.parseInt(next());\n    }\n    long L(){ \n        return Long.parseLong(next());\n    }\n    double D(){\n         return Double.parseDouble(next());\n    }\n    String S(){\n        String str = \"\";\n        try \n        {\n            str = br.readLine();\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}\n","t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    mx = 0\n    while True:\n        l = len(a)\n        mn = min(a)\n        mx = max(mn,mx)\n        if l == 1:\n            break\n        if a.count(mn) == l:\n            break\n        else:\n            a.remove(mn)\n        for x in range(l-1):\n            a[x] -= mn\n    print(mx)\n    \n        \n\n    ","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t;\n  scanf(\"%lld\", &t);\n  while (t--) {\n    long long n;\n    scanf(\"%lld\", &n);\n    vector<long long> v(n);\n    for (long long i = 0; i < n; i++) {\n      scanf(\"%lld\", &v[i]);\n    }\n    sort(v.begin(), v.end());\n    long long kuota = (-1) * v[0], minim = v[0];\n    priority_queue<long long> pq;\n    for (long long i = 1; i < n; i++) {\n      if (v[i] + kuota > minim) {\n        pq.push(v[i] + kuota);\n      }\n      minim = v[i] + kuota;\n      kuota -= minim;\n    }\n    if (!pq.empty())\n      printf(\"%lld\\n\", pq.top());\n    else\n      printf(\"%lld\\n\", v[0]);\n  }\n  return 0;\n}\n","t = int(input())\nfor case in range(t):\n  n = int(input())\n  a = list(map(int,input().split()))\n  a.sort()\n  ans = 0\n  count = 0\n  for i in range(n):\n      a[i]-=count\n      ans = max(ans,a[i])\n      count+=a[i]\n  print(ans)","t=int(input())\n\nfor t in range(t):\n    n=int(input())\n    a=[int(x) for x in input().split()]\n    a.sort()\n    while len(a)>1 and 2*a[0]<=a[1] :\n        x=a.pop(0)\n        a=[y-x for y in a]\n        \n        \n    print(a[0])\n        \n        ","def get_new_numbers(numbers, mn):\n    s = [numbers[i] - mn for i in range(len(numbers) - 1) if numbers[i] != mn]\n    if len(s) > 0:\n        mn = max(mn, s[-1])\n    if len(numbers) > 1 and numbers[-2] == mn:\n        mn = max(mn, 0)\n    return s, mn\n\n\ndef main():\n    _ = int(input())\n    numbers = sorted([int(x) for x in input().split()], reverse=True)\n    mn = numbers[-1]\n    while len(numbers) > 1:\n        numbers, mt = get_new_numbers(numbers, numbers[-1])\n        if mn > mt:\n            break\n        mn = max(mt, mn)\n    print(mn)\n\n\nif __name__ == '__main__':\n    # tests = 1\n    tests = int(input())\n    while tests > 0:\n        tests -= 1\n        main()\n","t = int(input())\nd = []\nfor i in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    mx = -10000000000\n    while True:\n        l = len(a)\n        mn = min(a)\n        mx = max(mn,mx)\n        if l == 1:\n            break\n        if a.count(mn) == l:\n            break\n        else:\n            a.remove(mn)\n        for x in range(l-1):\n            a[x] -= mn\n    print(mx)\n\n    \n        \n\n    ","import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n    \/\/ Graph\n    \/\/ prefix sums\n    \/\/inputs\n    public static void main(String args[])throws Exception{\n        Input sc=new Input();\n        precalculates p=new precalculates();\n        StringBuilder sb=new StringBuilder();\n        int t=sc.readInt();\n        for(int f=0;f<t;f++){\n            int n=sc.readInt();\n            long a[]=sc.readArrayLong();\n            HashSet<Long> map=new HashSet<>();\n            for(int i=0;i<n;i++){\n                map.add(a[i]);\n            }\n            int previous=a.length;\n            n=map.size();\n            a=new long[n];\n            int j=0;\n            for(Long val:map){\n                a[j++]=val;\n            }\n            Arrays.sort(a);\n            long sum=0;\n            long prev=0;long ans=Long.MIN_VALUE;\n            for(int i=0;i<n && n!=1;i++){\n                sum=sum+((a[i])-prev);\n                ans=Math.max(ans,a[i]-prev);\n                prev=sum;\n                \/\/System.out.println(sum+\"%%\");\n            }\n            \/*if(a.length>1 && a[0]==0) {\n                ans = Math.max(ans, a[n - 2]);\n            }else*\/ if(a.length>0 && a[n-1]!=0){\n                ans=Math.max(ans,a[n-1]-prev);\n            }\n\n\/\/            if(n>0 && a[0]==0)\n\/\/            {\n\/\/                ans=0;\n\/\/            }\n            if(n==1 && previous!=1){\n                ans=0;\n            }\n            if(ans!=Long.MIN_VALUE)\n                sb.append(ans+\"\\n\");\n            else\n                sb.append(a[n-1]+\"\\n\");\n\n        }\n        \/\/ 1 2 7 10   1\n        \/\/ 0 1 6 9    2\n        \/\/ 0 0 5 8\n        \/\/ -1 0 2\n        \/\/ 0  1 3\n        \/\/ 0 0 2\n        System.out.print(sb);\n    }\n}\nclass Input{\n    BufferedReader br;\n    StringTokenizer st;\n    Input(){\n        br=new BufferedReader(new InputStreamReader(System.in));\n        st=new StringTokenizer(\"\");\n    }\n    public int[] readArray() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        int a[]=new int[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Integer.parseInt(st.nextToken());\n        }\n        return a;\n    }\n    public long[] readArrayLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        long a[]=new long[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Long.parseLong(st.nextToken());\n        }\n        return a;\n    }\n    public int readInt() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Integer.parseInt(st.nextToken());\n    }\n    public long readLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Long.parseLong(st.nextToken());\n    }\n    public String readString() throws Exception{\n        return br.readLine();\n    }\n    public int[][] read2dArray(int n,int m)throws Exception{\n        int a[][]=new int[n][m];\n        for(int i=0;i<n;i++){\n            st=new StringTokenizer(br.readLine());\n            for(int j=0;j<m;j++){\n                a[i][j]=Integer.parseInt(st.nextToken());\n            }\n        }\n        return a;\n    }\n}\nclass precalculates{\n    public int[] prefixSumOneDimentional(int a[]){\n        int n=a.length;\n        int dp[]=new int[n];\n        for(int i=0;i<n;i++){\n            if(i==0)\n                dp[i]=a[i];\n            else\n                dp[i]=dp[i-1]+a[i];\n        }\n        return dp;\n    }\n    public int[] postSumOneDimentional(int a[]) {\n        int n = a.length;\n        int dp[] = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            if (i == n - 1)\n                dp[i] = a[i];\n            else\n                dp[i] = dp[i + 1] + a[i];\n        }\n        return dp;\n    }\n    public int[][] prefixSum2d(int a[][]){\n        int n=a.length;int m=a[0].length;\n        int dp[][]=new int[n+1][m+1];\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=m;j++){\n                dp[i][j]=a[i-1][j-1]+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];\n            }\n        }\n        return dp;\n    }\n    public long pow(long a,long b){\n        long mod=1000000007;\n        long ans=0;\n        if(b<=0)\n            return 1;\n        if(b%2==0){\n            ans=pow(a,b\/2)%mod;\n            return ((ans%mod)*(ans%mod))%mod;\n        }else{\n            return ((a%mod)*(ans%mod))%mod;\n        }\n    }\n\n}\nclass GraphInteger{\n    HashMap<Integer,vertex> vtces;\n    class vertex{\n        HashMap<Integer,Integer> children;\n        public vertex(){\n            children=new HashMap<>();\n        }\n    }\n    public GraphInteger(){\n        vtces=new HashMap<>();\n    }\n    public void addVertex(int a){\n        vtces.put(a,new vertex());\n    }\n    public void addEdge(int a,int b,int cost){\n        if(!vtces.containsKey(a)){\n            vtces.put(a,new vertex());\n        }\n        if(!vtces.containsKey(b)){\n            vtces.put(b,new vertex());\n        }\n        vtces.get(a).children.put(b,cost);\n\/\/        vtces.get(b).children.put(a,cost);\n    }\n    public boolean isCyclicDirected(){\n        boolean isdone[]=new boolean[vtces.size()+1];\n        boolean check[]=new boolean[vtces.size()+1];\n        for(int i=1;i<=vtces.size();i++) {\n            if (!isdone[i] && isCyclicDirected(i,isdone, check)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private boolean isCyclicDirected(int i,boolean isdone[],boolean check[]){\n        if(check[i])\n            return true;\n        if(isdone[i])\n            return false;\n        check[i]=true;\n        isdone[i]=true;\n        Set<Integer> set=vtces.get(i).children.keySet();\n        for(Integer ii:set){\n            if(isCyclicDirected(ii,isdone,check))\n                return true;\n        }\n        check[i]=false;\n        return false;\n    }\n}","import java.util.*;\n\n\/\/CODE FORCES\n\npublic class anshulvmc {\n\n    \n    public static void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n    \n    \n    \n    \n    public static int gcd(int a, int b) {\n\t\tif (b==0) return a;\n\t\treturn gcd(b, a%b);\n\t}\n    \n    public static void google(int t) {\n    \tSystem.out.println(\"Case #\"+t+\": \");\n    }\n    \n    \n\/\/    public static void gt(int[][] arr,int k) {\n\/\/    \tint n = arr.length+1;\n\/\/    \tk = Math.min(k,n+1);\n\/\/    \t\n\/\/    \tNode[] nodes = new Node[n];\n\/\/    \tfor(int i=0;i<n;i++) nodes[i] = new Node();\n\/\/    \tfor(int i=0;i<n-1;i++) {\n\/\/    \t\tint a = arr[i][0];\n\/\/    \t\tint b = arr[i][1];\n\/\/    \t\tSystem.out.println(a+\" \"+b);\n\/\/    \t\tnodes[a].adj.add(nodes[b]);\n\/\/    \t\tnodes[b].adj.add(nodes[a]);\n\/\/    \t}\n\/\/    \t\n\/\/    \tArrayDeque<Node> bfs = new ArrayDeque<>();\n\/\/    \tfor(Node nn:nodes) {\n\/\/    \t\tif(nn.adj.size()<2) {\n\/\/    \t\t\tbfs.addLast(nn);\n\/\/    \t\t\tnn.dist=0;\n\/\/    \t\t}\n\/\/    \t}\n\/\/    \t\n\/\/    \twhile(bfs.size()>0) {\n\/\/    \t\tNode nn = bfs.removeFirst();\n\/\/    \t\tfor(Node a : nn.adj) {\n\/\/    \t\t\tif(a.dist!=-1) continue;\n\/\/    \t\t\ta.usedDegree++;\n\/\/    \t\t\tif(a.adj.size() - a.usedDegree <= 1) {\n\/\/    \t\t\t\ta.dist = nn.dist+1;\n\/\/    \t\t\t\tbfs.addLast(a);\n\/\/    \t\t\t}\n\/\/    \t\t}\n\/\/    \t}\n\/\/    \t\n\/\/    \tint[] cs = new int[n+1];\n\/\/    \tfor(Node nn:nodes) {\n\/\/    \t\tcs[nn.dist]++;\n\/\/    \t}\n\/\/    \tfor(int i=1;i<cs.length;i++) cs[i]+=cs[i-1];\n\/\/    \tSystem.out.println(n-cs[k-1]);\n\/\/    }\n    \n    public static class Node{\n    \tArrayList<Node> adj = new ArrayList<>();\n    \tint dist = -1;\n    \tint usedDegree = 0;\n    }\n    \n    \n    public static void cat_mice(int dest,int[] arr) {\n    \tsort(arr);\n    \tint time = dest;\n\t\tint timeleft = dest-1;\n\t\tint counter=0;\n\t\tfor(int i=arr.length-1;i>=0;i--) {\n\t\t\tint val = arr[i];\n\t\t\tint takes = time - val;\n\t\t\tif(takes <= timeleft) {\n\t\t\t\ttimeleft -= takes;\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n    \tSystem.out.println(counter);\n    }\n    \n    \n\tpublic static void minex(int n,int[] arr) {\n    \tsort(arr);\n    \t\n    \tint ans = Integer.MIN_VALUE;\n    \tint size = n;\n    \twhile(size-->0) {\n    \t\tint temp = arr[0];\n\t\t\tif(temp==Integer.MAX_VALUE-10) {\n\t\t\t\tbreak;\n\t\t\t}\n    \t\tans = Math.max(ans,temp);\n    \t\tfor(int j=0;j<arr.length;j++) {\n    \t\t\tarr[j] -= temp;\n    \t\t\t\n    \t\t\tif(arr[j] == 0) {\n    \t\t\t\tarr[j] = Integer.MAX_VALUE;\n    \t\t\t}\n    \t\t}\n    \t\tsort(arr);\n    \t}\n    \tif(ans == Integer.MAX_VALUE || ans == Integer.MIN_VALUE) {\n    \t\tSystem.out.println(0);\n    \t}\n    \telse {\n    \t\tSystem.out.println(ans);\n    \t}\n    \t\n    }\n\t\n    public static void main(String args[])\n    \n    \n    {\t\n    \tScanner scn = new Scanner(System.in);\n    \tint test = scn.nextInt();\n    \tfor(int i=0;i<test;i++) {\n    \t\tint n = scn.nextInt();\n    \t\tint[] arr = new int[n];\n    \t\tfor(int j=0;j<n;j++) {\n    \t\t\tarr[j] = scn.nextInt();\n    \t\t}\n    \t\t\n    \t\tminex(n,arr);\n    \t}\n\/\/    \tint n = 1;\n\/\/    \tint[] dp = new int[2];\n\/\/    \tSystem.out.println(fact(n,dp));\n    \t\t\t\n    }\n\n}","t = int(input())\na = []\nfor _ in range(t):\n\tn = int(input())\n\ts = list(map(int,input().split()))\n\ts.sort()\n\tminus = s[0]\n\tans = -10000000000000000000000000000000000000000000\n\tfor i in range(n):\n\t\tans = max(ans, s[i]-minus)\n\t\tminus = s[i]\n\ta.append(ans)\nfor elem in a:\n\tprint(elem)\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t, y;\n  cin >> t;\n  for (int i = 0; i < t; i++) {\n    int n, mn = 1000000001;\n    cin >> n;\n    vector<int> v(n);\n    if (n == 1) {\n      int a;\n      cin >> a;\n      cout << a;\n      exit(0);\n    }\n    for (int j = 0; j < n; j++) {\n      cin >> v[j];\n      if (v[j] < mn) mn = v[j];\n    }\n    int x = mn;\n    for (int k = 0; k < n - 1; k++) {\n      int mnn = 1000000001, cnt = 0;\n      for (int j = 0; j < n - k - 1; j++) {\n        v[j] -= x;\n        if (v[j] == 0 && cnt == 0) {\n          v.erase(v.begin() + j);\n          j--;\n          cnt++;\n        } else if (v[j] < mnn)\n          mnn = v[j];\n      }\n      y = max(x, mnn);\n      x = mnn;\n    }\n    cout << y << '\\n';\n  }\n}\n","import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\npublic class Main\n{\n\tstatic String shengxiao[] =\n\t{ \"ox\", \"tiger\", \"rabbit\", \"dragon\", \"snake\", \"horse\", \"goat\", \"monkey\", \"rooster\", \"dog\", \"pig\", \"rat\" };\n\tstatic String shengxiaoo[] =\n\t{ \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Goat\", \"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\" };\n\tstatic int zhong[] =\n\t{ -1, 1, 0, 0, -1, -1, 1, 1 };\n\tstatic int heng[] =\n\t{ 0, 0, -1, 1, -1, 1, -1, 1 };\n\tstatic int zhongg[] =\n\t{ -1, -1, 0, 1, 1, 1, 0, -1 };\n\tstatic int hengg[] =\n\t{ 0, 1, 1, 1, 0, -1, -1, -1 };\n\tstatic int month[] =\n\t{ 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\tstatic int inf = Integer.MAX_VALUE;\n\tstatic long inff = Long.MAX_VALUE;\n\n\tstatic int N = (int) 5e1;\n\tstatic int M = (int) 1e5;\n\tstatic int mod = 19990920;\n\n\/\/\t \u63d0\u4ea4\u65f6\u6ce8\u610f\u9700\u8981\u6ce8\u91ca\u6389\u9996\u884cpackage\n\/\/\t \u57fa\u7840\u7c7b\u578b\u6570\u7ec4\u4f8b\u5982long[]\u4f7f\u7528Arrays\u6392\u5e8f\u5bb9\u6613TLE,\u53ef\u4ee5\u66ff\u6362\u6210Long[]\n\/\/\t int \u6700\u5927\u503c 2^31 - 1 , 2147483647;\n\/\/\t \u5c3d\u91cf\u4f7f\u7528long\u7c7b\u578b,\u907f\u514dint\u8ba1\u7b97\u7684\u6570\u636e\u6ea2\u51fa\n\n\tstatic void init()\n\t{\n\n\t}\n\n\/\/\tstatic void solve(String s)\n\/\/\tstatic void solve(int n)\n\/\/\tstatic void solve(long n)\n\tstatic void solve() throws FileNotFoundException\n\t{\n\t\tint n = sc.readInt();\n\t\tlong shu[] = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tshu[i] = sc.readLong();\n\n\t\tArrays.sort(shu);\n\t\tlong max = shu[0];\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tmax = Math.max(max, shu[i] - shu[i - 1]);\n\t\t}\n\t\tout.printLine(max);\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException\n\t{\n\/\/\t\tinit();\n\/\/\n\t\tint t = 1;\n\/\/\t\tint t = sc.readInt();\n\t\tfor (int i = 1; i <= t; i++)\n\t\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tstatic InputStream inputStream = System.in;\n\tstatic OutputStream outputStream = System.out;\n\tstatic InputReader sc = new InputReader(inputStream);\n\tstatic OutputWriter out = new OutputWriter(outputStream);\n\n\/\/\tSystem.setIn(new FileInputStream(\"copycat.in\"));\/\/ \u8bfb\u5165\u6587\u4ef6\n\/\/\tSystem.setOut(new PrintStream(new FileOutputStream(\"copycat.out\")));\/\/ \u8f93\u51fa\u5230\u6587\u4ef6\n\/\/\tlong startTime = System.currentTimeMillis(); \/\/ \u83b7\u53d6\u5f00\u59cb\u65f6\u95f4\n\/\/\tlong endTime = System.currentTimeMillis(); \/\/ \u83b7\u53d6\u7ed3\u675f\u65f6\u95f4\n\/\/\tSystem.out.println(\"\u7a0b\u5e8f\u8fd0\u884c\u65f6\u95f4\uff1a\" + (endTime - startTime) + \"ms\"); \/\/ \u8f93\u51fa\u7a0b\u5e8f\u8fd0\u884c\u65f6\u95f4\n\n\/\/\tint a = sc.readInt();\/\/ \u6574\u578b\n\/\/\tlong b = sc.readLong();\/\/ \u957f\u6574\u578b\n\/\/\tdouble c = sc.readDouble();\/\/ \u53cc\u7cbe\u5ea6\n\/\/\tString d = sc.readString(); \/\/ \u4e00\u4e2a\u5b57\u7b26\u4e32\n\/\/\tString e = sc.readStringLine();\/\/ \u4e00\u884c\u5b57\u7b26\u4e32\n\/\/\tchar f = sc.readCharacter();\/\/ \u5355\u4e2a\u5b57\u7b26\n\/\/\tout.print();\n\/\/\tout.printLine();\n\/\/\tout.close();\n\n\t\/\/ \u5c01\u88c5\u57fa\u4e8e\u5b57\u8282\u6d41\u8bfb\u53d6\u7684\u9ad8\u6548\u8f93\u5165\u7c7bInputReader\uff0c\u907f\u514dScanner\u7684\u4f4e\u6548\u7387\uff0c\u6bd4streamTokenizer\u5feb\u8bfb\u8fd8\u5feb\uff1b\n\tstatic class InputReader\n\t{\n\t\t\/\/ java.io.InputStream \u6240\u6709\u5b57\u8282\u8f93\u5165\u6d41\u7684\u7236\u7c7b\n\t\tprivate InputStream stream;\n\t\t\/\/ \u8f93\u5165\u7f13\u5b58byte\u6570\u7ec4\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\/\/ \u5f53\u524d\u5b57\u7b26\n\t\tprivate int numChars;\/\/ \u603b\u8f93\u5165\u5b57\u7b26\n\t\t\/\/ \u81ea\u5b9a\u4e49\u63a5\u53e3\n\t\tprivate SpaceCharFilter filter;\n\n\t\t\/\/ \u6784\u9020\u51fd\u6570\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\t\/\/ \u5c1d\u8bd5\u81f3\u5c11\u8bfb\u53d6\u4e00\u4e2a\u5b57\u8282\u5e76\u5b58\u50a8\u5230\u7f13\u51b2\u6570\u7ec4buf\u4e2d\n\t\tpublic int read()\n\t\t{\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t\/\/ \u65e2\u7136\u662f\u7f13\u51b2\u8bfb\u53d6\uff0c\u5982\u679c1\u6b21\u8bfb\u53d61024\u4e2a\uff0c\u90a3\u4e48\u6bcf\u6b21\u76f4\u63a5\u7f13\u51b2\u533a\u8bfb\u53d6 \u5982\u679ccurChar<numChar \u90a3\u4e48\u8bc1\u660e\u7f13\u51b2\u533a\u7684\u8fd8\u6ca1\u6709\u7528\u5b8c\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\/\/ \u7f13\u51b2\u533a\u7684\u6570\u636e\u7528\u5b8c\u4e86\uff0c\u90a3\u4e48\u4ece0\u5f00\u59cb\uff0c\u518d\u53bb\u4e00\u6b21\u6027\u8bfb\u53d6\u82e5\u5e72\u4e2a\u653e\u5230\u7f13\u51b2\u6570\u7ec4\u91cc\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t\/\/ \u4ece\u8f93\u5165\u6d41\u4e2d\u8bfb\u53d6\u4e00\u5b9a\u6570\u91cf\u7684\u5b57\u8282\uff0c\u5e76\u5c06\u5176\u5b58\u50a8\u5728\u7f13\u51b2\u533a\u6570\u7ec4buf\u4e2d\uff0cnumChar\u7b49\u4e8e\u5b9e\u9645\u8bfb\u53d6\u7684\u5b57\u8282\u6570\u91cf\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\/\/ \u5982\u679c\u8bfb\u53d6\u7684\u6709\u6548\u6570\u91cf\u4e3a0\uff0c\u90a3\u4e48\u8fd4\u56de-1\uff0c\u5de7\u5999\u7684\u907f\u5f00\u4e86\u5408\u6cd5\u7684ASCII\u7801\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\/\/ \u7b49\u4ef7\u4e8eelse (curChar<numChar),\u5982\u679c\u7f13\u51b2\u533a\u6ca1\u6709\u7528\u5b8c\uff0c\u76f4\u63a5\u8fd4\u56de\u7f13\u51b2\u533a\u5f53\u524d\u7b2ccurChar\u5b57\u7b26\uff0c\u6307\u9488\u540e\u79fb\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\t\/\/ \u8bfb\u5165\u4e00\u4e2a\u4e00\u4e2a\u5b57\u8282\uff0c\u624b\u5de5\u6784\u9020int\n\t\tpublic int readInt()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\/\/ \u5ffd\u7565>=1\u7684\u6240\u6709\u7a7a\u683c\u7b26\u6216\u8005\u81ea\u5df1\u5b9a\u4e49\u7684\u4e0d\u80fd\u6784\u6210\u6574\u6570\u7684\u65e0\u610f\u4e49\u7b26\u53f7\u5165\\n\\r\\t\u7b49\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\/\/ \u8bc6\u522b\u7b2c\u4e00\u7b26\u53f7\u4f4d\uff0c\u5224\u5b9a\u662f\u6b63\u6570\u8fd8\u662f\u8d1f\u6570\n\t\t\tif (c == '-')\n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t\/\/ \u4e0d\u65ad\u7684*10+\u5f53\u524d\u6570\u6784\u6210int\u7684\u5224\u65ad\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\t\/\/ \u8bfb\u5165\u4e00\u4e2a\u4e00\u4e2a\u5b57\u8282\uff0c\u624b\u5de5\u6784\u9020long\n\t\tpublic long readLong()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-')\n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\t\/\/ \u9ad8\u6548\u7684\u8bfb\u53d6\u5b57\u7b26\u4e32\n\t\tpublic String readString()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo\n\t\t\t{\n\t\t\t\t\/\/ \u786e\u5b9a\u6307\u5b9a\u7684\u4ee3\u7801\u70b9\u662f\u5426\u662f\u4e00\u4e2a\u6709\u6548\u7684Unicode\u4ee3\u7801\u70b9\u503c\n\t\t\t\tif (Character.isValidCodePoint(c))\n\t\t\t\t\tres.appendCodePoint(c);\/\/ \u8ffd\u52a0Unicode\u4ee3\u7801\u70b9\u503c\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\t\/\/ \u7edf\u4e00Scanner\u7684\u8bed\u6cd5\u4e60\u60ef\n\t\tpublic String next()\n\t\t{\n\t\t\treturn readString();\n\t\t}\n\n\t\t\/\/ \u8bfb\u5165\u4e00\u884c\u5b57\u7b26\u4e32\u6570\u7ec4\n\t\tpublic static String[] readStringArray(InputReader in, int size)\n\t\t{\n\t\t\tString[] array = new String[size];\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tarray[i] = in.readString();\n\t\t\treturn array;\n\t\t}\n\n\t\t\/\/ \u8bfb\u5165\u4e8c\u7ef4\u5b57\u7b26\u6570\u7ec4\n\t\tpublic static String[][] readStringTable(InputReader in, int rowCount, int columnCount)\n\t\t{\n\t\t\tString[][] table = new String[rowCount][];\n\t\t\tfor (int i = 0; i < rowCount; i++)\n\t\t\t\ttable[i] = readStringArray(in, columnCount);\n\t\t\treturn table;\n\t\t}\n\n\t\t\/\/ \u8bfb\u5165char\n\t\tpublic char readCharacter()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\treturn (char) c;\n\t\t}\n\n\t\t\/\/ \u8bfb\u5165\u4e00\u884c\u5b57\u7b26\u4e32\n\t\tpublic String readStringLine()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar2(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo\n\t\t\t{\n\t\t\t\t\/\/ \u786e\u5b9a\u6307\u5b9a\u7684\u4ee3\u7801\u70b9\u662f\u5426\u662f\u4e00\u4e2a\u6709\u6548\u7684Unicode\u4ee3\u7801\u70b9\u503c\n\t\t\t\tif (Character.isValidCodePoint(c))\n\t\t\t\t\tres.appendCodePoint(c);\/\/ \u8ffd\u52a0Unicode\u4ee3\u7801\u70b9\u503c\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar2(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\t\/\/ \u8bfb\u5165double\n\t\tpublic double readDouble()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-')\n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.')\n\t\t\t{\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.')\n\t\t\t{\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c))\n\t\t\t\t{\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm \/= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c)\n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn isWhitespace(c);\n\t\t}\n\n\t\tpublic boolean isSpaceChar2(int c)\n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar2(c);\n\t\t\treturn isWhitespace2(c);\n\t\t}\n\n\t\t\/\/ \u53ef\u4ee5\u8f93\u5165\u7a7a\u683c\u7684\u4e00\u884c\n\t\tpublic static boolean isWhitespace2(int c)\n\t\t{\n\t\t\treturn c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic static boolean isWhitespace(int c)\n\t\t{\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\t\/\/ \u81ea\u5b9a\u4e49\u63a5\u53e3\uff0c\u5b9a\u4e86\u4e00\u4e2a\u62bd\u8c61\u65b9\u6cd5\u5224\u65ad\u662f\u5426\u662f\u7a7a\u683c\u7b26\n\t\tpublic interface SpaceCharFilter\n\t\t{\n\t\t\tpublic boolean isSpaceChar(int ch);\n\n\t\t\tpublic boolean isSpaceChar2(int ch);\n\t\t}\n\t}\n\n\tstatic class OutputWriter\n\t{\n\t\t\/\/ \u5411\u6587\u672c\u8f93\u51fa\u6d41\u6253\u5370\u5bf9\u8c61\u7684\u683c\u5f0f\u5316\u8868\u73b0\u5f62\u5f0f extends java.io.Writer\n\t\tprivate final PrintWriter writer;\n\n\t\tpublic OutputWriter(OutputStream outputStream)\n\t\t{\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t\t}\n\n\t\t\/\/ \u6253\u5370\u6570\u7ec4\u7528\u7a7a\u683c\u5206\u9694\n\t\tpublic void print(int[] array)\n\t\t{\n\t\t\tfor (int i = 0; i < array.length; i++)\n\t\t\t{\n\t\t\t\tif (i != 0)\n\t\t\t\t\twriter.print(' ');\n\t\t\t\twriter.print(array[i]);\n\t\t\t}\n\t\t}\n\n\t\t\/\/ \u5e26\u6362\u884c\u7684\u6570\u7ec4\u6253\u5370\n\t\tpublic void printLine(int[] array)\n\t\t{\n\t\t\tprint(array);\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void print(Object... objects)\n\t\t{\n\t\t\tfor (int i = 0; i < objects.length; i++)\n\t\t\t{\n\t\t\t\tif (i != 0)\n\t\t\t\t\twriter.print(' ');\n\t\t\t\twriter.print(objects[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void printLine(Object... objects)\n\t\t{\n\t\t\tprint(objects);\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void close()\n\t\t{\n\t\t\twriter.close();\n\t\t}\n\n\t\tpublic void print(int i)\n\t\t{\n\t\t\twriter.print(i);\n\t\t}\n\n\t\tpublic void print(String i)\n\t\t{\n\t\t\twriter.print(i);\n\t\t}\n\n\t\tpublic void print(long i)\n\t\t{\n\t\t\twriter.print(i);\n\t\t}\n\n\t\tpublic void print(char i)\n\t\t{\n\t\t\twriter.print(i);\n\t\t}\n\n\t\tpublic void printf(String format, Object... x)\n\t\t{\n\t\t\twriter.printf(format, x);\n\t\t}\n\n\t\t\/\/ \u6253\u5370\u5e26\u6362\u884c\u7684\u6574\u6570i\n\t\tpublic void printLine(int i)\n\t\t{\n\t\t\twriter.println(i);\n\t\t}\n\n\t\tpublic void printLine(long i)\n\t\t{\n\t\t\twriter.println(i);\n\t\t}\n\t}\n\n\tstatic class IOUtils\n\t{\n\t\t\/\/ \u9ad8\u6548\u8bfb\u5165\u6574\u578b\u4e00\u7ef4\u6570\u7ec4\n\t\tpublic static int[] readIntArray(InputReader in, int size)\n\t\t{\n\t\t\tint[] array = new int[size];\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tarray[i] = in.readInt();\n\t\t\treturn array;\n\t\t}\n\n\t\t\/\/ \u8c03\u7528\u4e0a\u9762\u7684\u8bfb\u5165\u4e00\u7ef4\u6570\u7ec4\u7684\u5feb\u901f\u8bfb\u53d6\u4e8c\u7ef4\u6570\u7ec4\n\t\tpublic static int[][] readIntTable(InputReader in, int rowCount, int columnCount)\n\t\t{\n\t\t\tint[][] table = new int[rowCount][];\n\t\t\tfor (int i = 0; i < rowCount; i++)\n\t\t\t\ttable[i] = readIntArray(in, columnCount);\n\t\t\treturn table;\n\t\t}\n\n\t\t\/\/ \u76f8\u5f53\u4e8e\u4e8c\u7ef4\u6570\u7ec4\uff08\u591a\u5173\u952e\u5b57\u53c2\u6570\u7684\u53e6\u5916\u4e00\u79cd\u5199\u6cd5\uff09\n\t\tpublic static void readIntArrays(InputReader in, int[]... arrays)\n\t\t{\n\t\t\tfor (int i = 0; i < arrays[0].length; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < arrays.length; j++)\n\t\t\t\t\tarrays[j][i] = in.readInt();\n\t\t\t}\n\t\t}\n\n\t\tpublic static char[] readCharArray(InputReader in, int size)\n\t\t{\n\t\t\tchar[] array = new char[size];\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tarray[i] = in.readCharacter();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic static char[][] readTable(InputReader in, int rowCount, int columnCount)\n\t\t{\n\t\t\tchar[][] table = new char[rowCount][];\n\t\t\tfor (int i = 0; i < rowCount; i++)\n\t\t\t\ttable[i] = readCharArray(in, columnCount);\n\t\t\treturn table;\n\t\t}\n\n\t}\n\n\tstatic class MiscUtils\n\t{\n\t\tpublic static void decreaseByOne(int[]... arrays)\n\t\t{\n\t\t\tfor (int[] array : arrays)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < array.length; i++)\n\t\t\t\t\tarray[i]--;\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n","t=int(input())\nfor i in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    a.sort()\n    k=1\n    b=[0]*n\n    for j in range(1,n):\n        b[j]=b[j-1]-a[j-1]\n    for j in range(1,n):\n        b[j]+=b[j-1]\n        a[j]+=b[j]\n    print(max(a))","import java.io.*;\nimport java.util.*;\npublic class GFG {\n\tpublic static void main (String[] args)throws IOException {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tint t=Integer.parseInt(br.readLine());\n\t\twhile(t-->0)\n\t\t{\n\t\t    int n=Integer.parseInt(br.readLine());\n\t\t    String s[]=br.readLine().split(\" \");\n\t\t    if(n==1)\n\t\t    {\n\t\t        bw.write((Integer.parseInt(s[0]))+\"\\n\");\n\t\t    }\n\t\t    else \n\t\t    {\n\t\t        ArrayList<Integer> pos=new ArrayList<>();\n\t\t        ArrayList<Integer> neg=new ArrayList<>();\n\t\t        for(int i=0;i<n;i++)\n\t\t        {\n\t\t            int temp=Integer.parseInt(s[i]);\n\t\t            if(temp>=0)\n\t\t                pos.add(temp);\n\t\t            else \n\t\t                neg.add(temp);\n\t\t        }\n\t\t        if(pos.size()==0)\n\t\t        {\n\t\t            Collections.sort(neg);\n\t\t            bw.write((neg.get(neg.size()-1)-neg.get(neg.size()-2))+\"\\n\");\n\t\t        }\n\t\t        else if(pos.size()==1)\n\t\t        {\n\t\t            Collections.sort(neg);\n\t\t            bw.write((pos.get(0)-(neg.get(neg.size()-1)))+\"\\n\");\n\t\t        }\n\t\t        else if(neg.size()!=0)\n\t\t        {\n\t\t            int max=0;\n\t\t             Collections.sort(pos);\n\t\t            for(int i=1;i<pos.size();i++)\n\t\t            {\n\t\t                if(pos.get(i)-pos.get(i-1)>max)\n\t\t                max=pos.get(i)-pos.get(i-1);\n\t\t            }\n\t\t            bw.write(max+\"\\n\");\n\t\t            \n\t\t        }\n\t\t        else \n\t\t        {\n\t\t            int max=pos.get(0);\n\t\t            Collections.sort(pos);\n\t\t            for(int i=1;i<pos.size();i++)\n\t\t            {\n\t\t                if(pos.get(i)-pos.get(i-1)>max)\n\t\t                max=pos.get(i)-pos.get(i-1);\n\t\t            }\n\t\t            bw.write(max+\"\\n\");\n\t\t        }\n\t\t        \n\t\t    }\n\t\t}\n\t\tbw.flush();\n\t\t\n\t}\n}","t = int(input())\nres = []\nfor j in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  minA = [0] * n\n  newA = a.copy()\n  x = 0\n  minA[n - 1] = min(a)\n  x = minA[n - 1]\n  del newA[newA.index(x)]\n  newA = list(filter(lambda y: y != 0, list(map(lambda y: y - x, newA))))\n  for i in range(n - 1):\n    if len(newA) == 0:\n      break\n    val = max(minA[n - 2 - i + 1], min(newA))\n    if minA[n - 2 - i + 1] <= val:\n      minA[n - 2 - i] = val\n      x = minA[n - 2 - i]\n      if x in newA:\n        del newA[newA.index(x)]\n      newA = list(filter(lambda y: y != 0, list(map(lambda y: y - x, newA))))\n    else:\n      break\n  res.append(x)\n\nfor index in range(t):\n  print(res[index])","for _ in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    l.sort()\n    m=-10**9+7\n    if n==1:\n        print(l[0])\n    else:\n        for i in range(n-1):\n            m=max(m,l[i+1]-l[i])\n\n        print(m)\n\n    \n\n    ","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    long long arr[n];\n    set<long long> s;\n    for (long long i = 0; i < n; i++) {\n      cin >> arr[i];\n      s.insert(arr[i]);\n    }\n    if (n == 1) {\n      cout << arr[0] << endl;\n      continue;\n    } else {\n      sort(arr, arr + n);\n      long long maxi = INT_MIN;\n      for (long long i = 0; i < n - 1; i++) {\n        maxi = max(maxi, arr[i + 1] - arr[i]);\n      }\n      if (n == 2) {\n        cout << max(maxi, arr[0]) << endl;\n        continue;\n      }\n      long long p = 0;\n      if (s.size() != n) {\n        maxi = max(maxi, p);\n      }\n      cout << maxi << endl;\n    }\n  }\n}\n","    #from _typeshed import SupportsKeysAndGetItem\nimport sys\nfrom collections import deque\nimport heapq\nimport bisect\nimport copy\n# sys.stdin=open(\"input.txt\",\"r\");\n# sys.stdout=open(\"output.txt\",\"w\")\n####### GLOBAL ###############\nMOD=1000000007\nNO=lambda:print(\"NO\")\nYES=lambda:print(\"YES\")\n_1=lambda:print(-1)\nari=lambda:[int(_) for _ in input().split()]\ncin=lambda:int(input())\ncis=lambda:input()\nshow=lambda x: print(x)\nfast= lambda:sys.stdin.readline()\n\n########### END #########\n######\ntest_case=1\ntest_case=int(input())\n######\nsys.setrecursionlimit(10**6)\n    \ndef ans():\n    n=cin()\n    arr=ari()\n    maxi=-float('inf')\n    arr.sort()\n    arr.append(0)\n    for i in range(len(arr)-1):\n        maxi=max(maxi,abs(arr[i+1]-arr[i]))\n    print(maxi)\n    return\nfor _ in range(test_case):\n    ans()\n    ","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> x(n);\n    for (int i = 0; i < n; i++) cin >> x[i];\n    sort(x.begin(), x.end());\n    int maxi = x[0];\n    for (int i = 1; i < n; i++) {\n      if (x[i] - x[i - 1] > maxi) maxi = x[i] - x[i - 1];\n    }\n    cout << maxi;\n    cout << '\\n';\n  }\n  return 0;\n}\n","import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n    \/\/ Graph\n    \/\/ prefix sums\n    \/\/inputs\n    public static void main(String args[])throws Exception{\n        Input sc=new Input();\n        precalculates p=new precalculates();\n        StringBuilder sb=new StringBuilder();\n        int t=sc.readInt();\n        for(int f=0;f<t;f++){\n            int n=sc.readInt();\n            long a[]=sc.readArrayLong();\n            HashSet<Long> map=new HashSet<>();\n            for(int i=0;i<n;i++){\n                map.add(a[i]);\n            }\n            n=map.size();\n            a=new long[n];\n            int j=0;\n            for(Long val:map){\n                a[j++]=val;\n            }\n            Arrays.sort(a);\n            long sum=0;\n            long prev=0;long ans=Long.MIN_VALUE;\n            for(int i=0;i<n && n!=1;i++){\n                sum=sum+((a[i])-prev);\n                ans=Math.max(ans,a[i]-prev);\n                prev=sum;\n            }\n            \/*if(a.length>1 && a[0]==0) {\n                ans = Math.max(ans, a[n - 2]);\n            }else*\/ if(a.length>0 && a[n-1]!=0){\n                ans=Math.max(ans,a[n-1]-prev);\n            }\n\n\/\/            if(n>0 && a[0]==0)\n\/\/            {\n\/\/                ans=0;\n\/\/            }\n            if(ans!=Long.MIN_VALUE)\n                sb.append(ans+\"\\n\");\n            else\n                sb.append(a[n-1]+\"\\n\");\n\n        }\n        \/\/ 1 2 7 10   1\n        \/\/ 0 1 6 9    2\n        \/\/ 0 0 5 8\n        \/\/ -1 0 2\n        \/\/ 0  1 3\n        \/\/ 0 0 2\n        System.out.print(sb);\n    }\n}\nclass Input{\n    BufferedReader br;\n    StringTokenizer st;\n    Input(){\n        br=new BufferedReader(new InputStreamReader(System.in));\n        st=new StringTokenizer(\"\");\n    }\n    public int[] readArray() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        int a[]=new int[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Integer.parseInt(st.nextToken());\n        }\n        return a;\n    }\n    public long[] readArrayLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        long a[]=new long[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Long.parseLong(st.nextToken());\n        }\n        return a;\n    }\n    public int readInt() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Integer.parseInt(st.nextToken());\n    }\n    public long readLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Long.parseLong(st.nextToken());\n    }\n    public String readString() throws Exception{\n        return br.readLine();\n    }\n    public int[][] read2dArray(int n,int m)throws Exception{\n        int a[][]=new int[n][m];\n        for(int i=0;i<n;i++){\n            st=new StringTokenizer(br.readLine());\n            for(int j=0;j<m;j++){\n                a[i][j]=Integer.parseInt(st.nextToken());\n            }\n        }\n        return a;\n    }\n}\nclass precalculates{\n    public int[] prefixSumOneDimentional(int a[]){\n        int n=a.length;\n        int dp[]=new int[n];\n        for(int i=0;i<n;i++){\n            if(i==0)\n                dp[i]=a[i];\n            else\n                dp[i]=dp[i-1]+a[i];\n        }\n        return dp;\n    }\n    public int[] postSumOneDimentional(int a[]) {\n        int n = a.length;\n        int dp[] = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            if (i == n - 1)\n                dp[i] = a[i];\n            else\n                dp[i] = dp[i + 1] + a[i];\n        }\n        return dp;\n    }\n    public int[][] prefixSum2d(int a[][]){\n        int n=a.length;int m=a[0].length;\n        int dp[][]=new int[n+1][m+1];\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=m;j++){\n                dp[i][j]=a[i-1][j-1]+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];\n            }\n        }\n        return dp;\n    }\n    public long pow(long a,long b){\n        long mod=1000000007;\n        long ans=0;\n        if(b<=0)\n            return 1;\n        if(b%2==0){\n            ans=pow(a,b\/2)%mod;\n            return ((ans%mod)*(ans%mod))%mod;\n        }else{\n            return ((a%mod)*(ans%mod))%mod;\n        }\n    }\n\n}\nclass GraphInteger{\n    HashMap<Integer,vertex> vtces;\n    class vertex{\n        HashMap<Integer,Integer> children;\n        public vertex(){\n            children=new HashMap<>();\n        }\n    }\n    public GraphInteger(){\n        vtces=new HashMap<>();\n    }\n    public void addVertex(int a){\n        vtces.put(a,new vertex());\n    }\n    public void addEdge(int a,int b,int cost){\n        if(!vtces.containsKey(a)){\n            vtces.put(a,new vertex());\n        }\n        if(!vtces.containsKey(b)){\n            vtces.put(b,new vertex());\n        }\n        vtces.get(a).children.put(b,cost);\n\/\/        vtces.get(b).children.put(a,cost);\n    }\n    public boolean isCyclicDirected(){\n        boolean isdone[]=new boolean[vtces.size()+1];\n        boolean check[]=new boolean[vtces.size()+1];\n        for(int i=1;i<=vtces.size();i++) {\n            if (!isdone[i] && isCyclicDirected(i,isdone, check)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private boolean isCyclicDirected(int i,boolean isdone[],boolean check[]){\n        if(check[i])\n            return true;\n        if(isdone[i])\n            return false;\n        check[i]=true;\n        isdone[i]=true;\n        Set<Integer> set=vtces.get(i).children.keySet();\n        for(Integer ii:set){\n            if(isCyclicDirected(ii,isdone,check))\n                return true;\n        }\n        check[i]=false;\n        return false;\n    }\n}","t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    mx = -100000000000000\n    while True:\n        l = len(a)\n        mn = min(a)\n        mx = max(mn,mx)\n        if l == 1:\n            break\n        if a.count(mn) == l:\n            break\n        else:\n            a.remove(mn)\n            for x in range(l-1):\n                a[x] -= mn\n    print(mx)\n ","t=int(input())\nfor o in range(t):\n    n = int(input())\n    l= list(map(int , input().split()))\n    \n    arr=[]\n    for i in range(n-1):\n        arr+=[l[i+1]-l[i]]\n    if(arr==[]):\n        print(l[0])\n    else:\n        r=max(arr)\n        print(r)\n","#include <bits\/stdc++.h>\nusing namespace std;\nint32_t main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long n, k, sum = 0, c = 0, mn = INT_MIN, m;\n    cin >> n;\n    long long a[n];\n    for (long long i = 0; i < n; i++) cin >> a[i];\n    sort(a, a + n);\n    if (n == 2) {\n      cout << max(a[0], a[1] - a[0]) << endl;\n    } else {\n      for (long long i = 1; i < n - 1; i++) {\n        m = a[i + 1] - a[i];\n        mn = max(m, mn);\n      }\n      mn = max(mn, a[0]);\n      cout << mn << endl;\n    }\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nint main() {\n  int tc;\n  cin >> tc;\n  for (; tc--;) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a.rbegin(), a.rend());\n    int diff = 0;\n    for (; a.size() > 1;) {\n      if (a.back() + diff > 0) break;\n      long long hapus = a.back() + diff;\n      a.pop_back();\n      diff -= hapus;\n    }\n    for (; a.size() > 1;) {\n      long long getA = a[a.size() - 2], getB = a.back();\n      if (getA + diff < 2ll * (getB + diff)) break;\n      long long hapus = a.back() + diff;\n      a.pop_back();\n      diff -= hapus;\n    }\n    cout << a.back() + diff << endl;\n  }\n  return 0;\n}\n","import sys, collections, math, bisect, heapq, random, functools\ninput = sys.stdin.readline\nout = sys.stdout.flush\n\ndef solve():\n      n = int(input())\n      queue = []\n      a = list(map(int,input().split()))\n      for i in range(n):\n            heapq.heappush(queue,a[i])\n      diff = 0\n      k = len(queue)\n      while k > 1 and queue[0] - diff <= 0:\n            cur = heapq.heappop(queue)\n            diff += cur\n            k -= 1\n      while k > 1 and queue[1] - diff - queue[0] > queue[0]:\n            cur = heapq.heappop(queue) - diff\n            diff += cur\n\n            k -= 1\n\n      print(queue[0] - diff)\n\n\n\n\n\n\n\nif __name__ == '__main__':\n      for i in range(int(input())):\n          solve()","#include <bits\/stdc++.h>\nconst int N = 1e5;\nconst int inf = 1e9 + 10;\nusing namespace std;\nvoid yes() { cout << \"YES\" << endl; }\nvoid no() { cout << \"NO\" << endl; }\nmap<long long int, long long int> cnt;\nvoid prime_factorization(long long int n) {\n  for (long long int i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      n \/= i;\n      ++cnt[i];\n    }\n  }\n  if (n > 1) ++cnt[n];\n}\nvoid solve() {\n  long long int x, y, a, b;\n  cin >> x >> y;\n  a = x, b = y;\n  if (x > y) {\n    cout << x + y;\n    return;\n  }\n  if (x == y) {\n    cout << x;\n    return;\n  }\n  if (y % x == 0) {\n    cout << x;\n    return;\n  }\n  cout << (y \/ x) * x + (y % x) \/ 2;\n  return;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long int a[n + 1];\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    if (n == 1)\n      cout << a[1] << endl;\n    else {\n      long long int cross = 0, mn = a[1], second = 0, ans = a[1];\n      sort(a + 1, a + n + 1);\n      for (int i = 2; i <= n; i++) {\n        second += mn;\n        mn = a[i] - second;\n        a[i] = mn;\n        ans = max(mn, ans);\n      }\n      sort(a + 1, a + n + 1);\n      cout << ans;\n      cout << endl;\n    }\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint result() {\n  int result = 0, len, i;\n  string keyboard, word;\n  cin >> keyboard >> word;\n  len = word.length();\n  i = len - 1;\n  for (int i = len - 1; i > 0; i--) {\n    int f = keyboard.find(word[i]) + 1;\n    int g = keyboard.find(word[i - 1]) + 1;\n    result += abs(f - g);\n  }\n  return result;\n}\nint minimum() {\n  long long n, min, maxmin, integer;\n  cin >> n;\n  vector<long long> arr;\n  for (int i = 0; i < n; i++) {\n    cin >> integer;\n    arr.push_back(integer);\n  }\n  if (n == 1)\n    return arr[n - 1];\n  else {\n    min = *min_element(arr.begin(), arr.end());\n    while (arr.size() >= 1) {\n      maxmin = min;\n      min = *min_element(arr.begin(), arr.end());\n      if (maxmin < min) maxmin = min;\n      arr.erase(find(arr.begin(), arr.end(), min));\n      for (int i = 0; i < arr.size(); i++) {\n        arr[i] = arr[i] - min;\n        if (arr[i] < min) min = arr[i];\n      }\n    }\n    return maxmin;\n  }\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    cout << minimum() << endl;\n  }\n  return 0;\n}\n","t=int(input())\nfor i in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    if n==1:\n        print(a[0])\n    elif n==2:\n        print(max(min(a),max(a)-min(a)))\n    else:\n        a.sort()\n        s=-float(\"inf\")\n        for i in range(len(a)-1):\n            s=max(s,a[i+1]-a[i])\n        print(s)\n\n","t=int(input())\n\nfor t in range(t):\n    n=int(input())\n    a=[int(x) for x in input().split()]\n    a.sort()\n    ans=a[0]\n    while len(a)>1 and 2*a[0]<=a[1] :\n        x=a.pop(0)\n        a=[y-x for y in a]\n        if ans<a[0]:\n            ans=a[0]\n        \n        \n    print(ans)\n        \n        \n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long log_a_to_base_b(long long a, long long b) { return log(a) \/ log(b); }\nbool isPrime(long long n) {\n  if (n == 1) {\n    return false;\n  }\n  long long i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      return false;\n    }\n    i += 1;\n  }\n  return true;\n}\nvector<long long> prime_fact(long long n) {\n  vector<long long> v;\n  for (long long i = 2; i * i <= n; i++)\n    if (n % i == 0) {\n      while (n % i == 0) n \/= i;\n      v.push_back(i);\n    }\n  if (n > 1) v.push_back(n);\n  return v;\n}\nlong long power(long long a, long long n) {\n  long long res = 1;\n  while (n) {\n    if (n % 2)\n      res *= a, n--;\n    else\n      a *= a, n \/= 2;\n  }\n  return res;\n}\nlong long euler_totient(long long n) {\n  long long res = n;\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      res \/= i;\n      res *= (i - 1);\n      while (n % i == 0) n \/= i;\n    }\n  }\n  if (n > 1) res \/= n, res *= (n - 1);\n  return res;\n}\nbool isKthBitSet(long long n, long long k) {\n  if (n & (1 << k))\n    return true;\n  else\n    return false;\n}\nlong long no_of_set_bits(long long n) {\n  long long cnt = 0;\n  while (n > 0) {\n    cnt++;\n    n = n & (n - 1);\n  }\n  return cnt;\n}\nvoid init() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nsigned main() {\n  init();\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> v(n);\n    for (auto &i : v) cin >> i;\n    sort(v.begin(), v.end());\n    if (n == 1) {\n      cout << v[0] << \"\\n\";\n      continue;\n    }\n    if (n == 2) {\n      cout << max(v[0], (v[1] - v[0])) << \"\\n\";\n      continue;\n    }\n    long long ans = v[0];\n    long long i = 0ll;\n    if (v[0ll] < 0ll) {\n      for (i = 1ll; i < n; i++)\n        if (v[i] < 0ll)\n          continue;\n        else\n          break;\n      i--;\n      ans = (long long)v[i] - v[0];\n      i++;\n    }\n    for (; i < n - 1ll; i++) ans = max(ans, (long long)(v[i + 1] - v[i]));\n    cout << (long long)ans << \"\\n\";\n  }\n  return 0;\n}\n","import sys \nfor _ in range(int(sys.stdin.readline())):\n    n=int(sys.stdin.readline())\n    l=list(map(int,sys.stdin.readline().split()))\n    if n<=1:\n        print(l[0])\n    else:\n        x=list(set(l))\n        x.sort()\n        s=x[0]\n        v=[x[0]]\n        for i in range(1,len(x)):\n            v.append(x[i]-s)\n            s=s+v[i]\n        print(max(v))","\nfor _ in range(int(input())):\n    x=int(input())\n    s=sorted(list(set(map(int,input().split()))))\n    m=s[0]\n    while len(s)!=1:\n        s=[i-s[0] for i in s[1:]]\n        if s[0]>m:m=s[0]\n    print(m)\n\n","t = int(input())\n\nfor test in range(t):\n    n = int(input())\n    p = list(map(int,input().split()))\n    if(len(p)==1):\n        print(p[0])\n        continue\n    elif(len(p)==2):\n        print(min(min(p[0],p[1]),abs(p[0]-p[1])))\n        continue\n    ans = 0\n    p.sort()\n    for i in range(len(p)-2,0,-1):\n        ans = max(ans,p[i+1]-p[i])\n    print(ans)\n","'''Author- Akshit Monga'''\nfrom sys import stdin, stdout\ninput = stdin.readline\n\ndef ceil(a,b):\n    return (a+b-1)\/\/b\n\nt = int(input())\nfor _ in range(t):\n    n=int(input())\n    a=[int(x) for x in input().split()]\n    if n==1:\n        print(a[0])\n        continue\n    if sum(a)==0:\n        print(0)\n        continue\n    ans=0\n    for i in a:\n        if i<0:\n            ans+=abs(i)\n    m=float('inf')\n    for i in a:\n        if i>0:\n            m=min(m,i+ans)\n    print(m)","import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic long[]fac=new long[200100];\n\tstatic long[] two= new long[200100] ;\n\tstatic long mod=((long)1e18)+7;\n\tstatic String[]pow=new String[63];\n\tstatic int n;\n\tstatic int x=0;\n\tstatic int[][]perm,b;\n\tstatic int[]pe,aa,a;\n\tpublic static void main(String[] args) throws IOException, InterruptedException{\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tint n=sc.nextInt();\n\t\t\tLong[]a=new Long[n];\n\t\t\tlong min=Long.MAX_VALUE;\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextLong();\n\t\t\t\tmin=Math.min(min, a[i]);\n\t\t\t}\n\t\t\tif(n==1) {\n\t\t\t\tpw.println(min);\n\t\t\t}else {\n\t\t\t\tif(min<0) {\n\t\t\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\t\t\ta[i]-=min;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tArrays.sort(a);\n\t\t\t\tlong o=a[0];\n\t\t\t\tlong sub=0;\n\t\t\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\t\t\tif(a[i]-sub>=2*(a[i-1]-sub)) {\n\t\t\t\t\t\to=a[i]-a[i-1];\n\t\t\t\t\t\tsub+=a[i-1]-sub;\n\t\t\t\t\t}else break;\n\t\t\t\t}\n\t\t\t\tpw.println(o);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tpw.close();\n\t}\t\n\t\n\tpublic static long[] Extended(long p, long q) {\n\t      if (q == 0)\n\t         return new long[] { p, 1, 0 };\n\n\t      long[] vals = Extended(q, p % q);\n\t      long d = vals[0];\n\t      long a = vals[2];\n\t      long b = vals[1] - (p \/ q) * vals[2];\n\t      return new long[] { d, a, b };\n\t   }\n\t\n\tstatic class STree{\n\t\tint N;\n\t\tlong[]arr;\n\t\tlong[]tree;\n\t\tint[]lazy;\n\t\tlong id;\n\t\tpublic static long operation(long x,long y) {\n\t\t\treturn x^y;\n\t\t}\n\t\t\n\t\tpublic STree(int[]a,long id) {\n\t\t\tthis.id=id;\n\t\t\tN=1;\n\t\t\tint n=a.length;\n\t\t\twhile(N<n) {\n\t\t\t\tN*=2;\n\t\t\t}\n\t\t\tarr=new long[N+1];\n\t\t\tArrays.fill(arr, id);\n\t\t\tfor (int i = 1; i <= a.length; i++) {\n\t\t\t\tarr[i]=a[i-1];\n\t\t\t}\n\t\t\ttree=new long[2*N];\n\t\t\tArrays.fill(tree, id);\n\t\t\tbuild(1,N,1);\n\t\t\tlazy=new int[2*N];\n\t\t}\n\t\t\n\t\tpublic void build(int l,int r,int node) {\n\t\t\tif(l==r) {\n\t\t\t\ttree[node]=arr[l];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mid=(l+r)\/2;\n\t\t\tbuild(l,mid,node*2);\n\t\t\tbuild(mid+1,r,node*2+1);\n\t\t\ttree[node]=operation(tree[node*2],tree[node*2+1]);\n\t\t}\n\t\t\n\/\/\t\tpublic void update(int node,int value) {\n\/\/\t\t\tint i=node+N-1;\n\/\/\t\t\ttree[i]=value;\n\/\/\t\t\ti\/=2;\n\/\/\t\t\twhile(i>0) {\n\/\/\t\t\t\ttree[i]=operation(tree[i*2], tree[i*2+1]);\n\/\/\t\t\t\ti\/=2;\n\/\/\t\t\t}\n\/\/\t\t}\n\/\/\t\t\n\/\/\t\tpublic void updateRange(int l,int r,int v) {\n\/\/\t\t\tupdateRange(1, N, l, r, 1,v);\n\/\/\t\t}\n\/\/\t\t\n\/\/\t\tpublic void updateRange(int s,int e,int l,int r,int node,int v) {\n\/\/\t\t\tif(s>=l&&e<=r) {\n\/\/\t\t\t\tlazy[node]^=v;\n\/\/\t\t\t\ttree[node]=propagate(tree[node],lazy[node],e-s+1);\n\/\/\/\/\t\t\t\tlazy[node]=0;\n\/\/\t\t\t\treturn;\n\/\/\t\t\t}\n\/\/\t\t\tif(s>r||e<l)return;\n\/\/\t\t\tint mid=(s+e)\/2;\n\/\/\t\t\tlazy[node*2] ^= lazy[node];\n\/\/\t\t\tlazy[node*2+1] ^= lazy[node];\n\/\/\t\t\ttree[node*2] = propagate(tree[node*2], v, (e-s+1)\/2);\n\/\/\t\t\ttree[node*2+1] =  propagate(tree[node*2+1], v, (e-s+1)\/2);\n\/\/\t\t\tlazy[node] = 0;\n\/\/\t\t\tupdateRange(s, mid, l, r, node*2, v);\n\/\/\t\t\tupdateRange(mid+1, e, l, r, node*2+1, v);\n\/\/\t\t\ttree[node]=operation(tree[node*2], tree[node*2+1]);\n\/\/\t\t\treturn;\n\/\/\t\t}\n\/\/\t\t\n\t\tpublic long q(int l,int r) {\n\t\t\treturn q(1,N,l,r,1);\n\t\t}\n\t\t\n\t\tpublic long q(int s,int e,int l,int r,int node) {\n\t\t\tif(s>=l&&r>=e) {\n\t\t\t\treturn tree[node];\n\t\t\t}\n\t\t\tif(s>r||e<l)\n\t\t\t\treturn id;\n\t\t\tint mid=(s+e)\/2;\n\t\t\t\n\t\t\treturn operation(q(s,mid,l,r,node*2), q(mid+1,e,l,r,node*2+1));\n\t\t}\n\/\/\t\tpublic static segment propagate(segment x,int v,int length) {\n\/\/\t\t\tint[]bit=x.bit.clone();\n\/\/\t\t\tlong sum=x.sum;\n\/\/\t\t\tfor (int i = 0; i < bit.length; i++) {\n\/\/\t\t\t\tif((v&1<<i)!=0) {\n\/\/\t\t\t\t\tsum-=(1<<i)*(bit[i]);\n\/\/\t\t\t\t\tsum+=(1<<i)*(length-bit[i]);\n\/\/\t\t\t\t\tbit[i]=length-bit[i];\n\/\/\t\t\t\t}\n\/\/\t\t\t}\n\/\/\t\t\treturn new segment(sum, bit);\n\/\/\t\t}\n\t}\n\n\tpublic static class segment{\n\t\tlong sum;\n\t\tint[] bit;\n\t\t\n\t\tpublic segment (long sum,int[]bit) {\n\t\t\tthis.sum=sum;\n\t\t\tthis.bit=bit.clone();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn sum+\" \"+Arrays.toString(bit);\n\t\t}\n\t}\n\t\n\tpublic static int LIS(int[] a) {\n\n\t\tint n = a.length;\n\t\tint[] ser = new int[n];\n\t\tint[]ser1=new int[n];\n\t\tArrays.fill(ser1, Integer.MAX_VALUE);\n\t\tArrays.fill(ser, Integer.MAX_VALUE);\n\t\tint cur = -1;\n\t\tint[]inc=new int[n];\n\t\tint[]dec=new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint low = 0;\n\t\t\tint high = n - 1;\n\t\t\tint mid = (low + high) \/ 2;\n\t\t\twhile (low <= high) {\n\t\t\t\tif (ser[mid] < a[i]) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}\n\t\t\t\tmid = (low + high) \/ 2;\n\t\t\t}\n\t\t\tinc[i]=high+2;\n\t\t\tcur = Math.max(cur, high + 1);\n\t\t\tser[high + 1] = Math.min(ser[high + 1], a[i]);\n\t\t}\n\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\tint low = 0;\n\t\t\tint high = n - 1;\n\t\t\tint mid = (low + high) \/ 2;\n\t\t\twhile (low <= high) {\n\t\t\t\tif (ser1[mid] < a[i]) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}\n\t\t\t\tmid = (low + high) \/ 2;\n\t\t\t}\n\t\t\tdec[i]=high+2;\n\t\t\tcur = Math.max(cur, high + 1);\n\t\t\tser1[high + 1] = Math.min(ser1[high + 1], a[i]);\n\t\t}\n\t\tint ans=1;\n\t\tfor (int i = 0; i < dec.length; i++) {\n\t\t\tans=Math.max(ans, 2*Math.min(inc[i], dec[i])-1);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tpublic static void permutation(int idx,int v) {\n\t\tif(v==(1<<n)-1) {\n\t\t\tperm[x++]=pe.clone();\n\t\t\treturn ;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif((v&1<<i)==0) {\n\t\t\t\tpe[idx]=aa[i];\n\t\t\t\tpermutation(idx+1, v|1<<i);\n\t\t\t}\n\t\t}\n\t\treturn ;\n\t}\n\t\n\tpublic static void pre2() {\n\t\tfor (int i = 0; i < pow.length; i++) {\n\t\t\tlong x=1l<<i;\n\t\t\tpow[i]=x+\"\";\n\t\t}\n\t}\n\t\t\n\tpublic static void sort(int[]a) {\n\t\tmergesort(a, 0, a.length-1);\n\t}\n\t\n\tpublic static void sortIdx(long[]a,long[]idx) {\n\t\tmergesortidx(a, idx, 0, a.length-1);\n\t}\n\t\n\tpublic static long C(int a,int b) {\n\t\tlong x=fac[a];\n\t\tlong y=fac[a-b]*fac[b];\n\t\treturn x*pow(y,mod-2)%mod;\n\t}\n\t\n\tpublic static long pow(long a,long b) {\n\t\tlong ans=1;a%=mod;\n\t\tfor(long i=b;i>0;i\/=2) {\n\t\t\tif((i&1)!=0)\n\t\t\t\tans=ans*a%mod;\n\t\t\ta=a*a%mod;\n\t\t }    \n\t\t    \n\t\t return ans;\n\t}\n\t\n\tpublic static void pre(){\n\t\tfac[0]=1;\n\t\tfac[1]=1;\n\t\tfac[2]=1;\n\t\tfor (int i = 3; i < fac.length; i++) {\n\t\t\tfac[i]=((fac[i-1]*2*i)\/2)%mod;\n\t\t}\n\t}\n\t\n\tpublic static long eval(String s) {\n\t\tlong p=1;\n\t\tlong res=0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tres+=p*(s.charAt(s.length()-1-i)=='1'?1:0);\n\t\t\tp*=2;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static String binary(long x) {\n\t\tString s=\"\";\n\t\twhile(x!=0) {\n\t\t\ts=(x%2)+s;\n\t\t\tx\/=2;\n\t\t}\n\t\treturn s;\n\t}\n\t\n\tpublic static boolean allSame(String s) {\n\t\tchar x=s.charAt(0);\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif(s.charAt(i)!=x)return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isPalindrom(String s) {\n\t\tint l=0;\n\t\tint r=s.length()-1;\n\t\twhile(l<r) {\n\t\t\tif(s.charAt(r--)!=s.charAt(l++))return false;\n\t\t\t\n\t\t}\n\t\treturn true;\n\t}\n\t \n\t\n\tpublic static boolean isSubString(String s,String t) {\n\t\tint ls=s.length();\n\t\tint lt=t.length();\n\t\tboolean res=false;\n\t\tfor (int i = 0; i <=lt-ls; i++) {\n\t\t\tif(t.substring(i, i+ls).equals(s)) {\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static boolean isSorted(long[]a) {\n\t\tfor (int i = 0; i < a.length-1; i++) {\n\t\t\tif(a[i]>a[i+1])return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isPrime(long n)\n    {\n \n        \/\/ Check if number is less than\n        \/\/ equal to 1\n        if (n <= 1)\n            return false;\n \n        \/\/ Check if number is 2\n        else if (n == 2)\n            return true;\n \n        \/\/ Check if n is a multiple of 2\n        else if (n % 2 == 0)\n            return false;\n \n        \/\/ If not, then just check the odds\n        for (int i = 3; i <= Math.sqrt(n); i += 2)\n        {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\tpublic static int whichPower(int x) {\n\t\tint res=0;\n\t\tfor (int j = 0; j < 31; j++) {\n\t\t\tif((1<<j&x)!=0) {\n\t\t\t\tres=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n \n\tpublic static long evaln(String x,int n) {\n\t\tlong res=0;\n\t\tfor (int i = 0; i < x.length(); i++) {\n\t\t\tres+=Long.parseLong(x.charAt(x.length()-1-i)+\"\")*Math.pow(n, i);\n\t\t}\n\t\treturn res;\n\t}\n\tstatic void merge(int[] arr,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tint[] l=new int[len1];\n\t\tint[] r=new int[len2];\n\t\tfor(int i=0;i<len1;i++)l[i]=arr[b+i];\n\t\tfor(int i=0;i<len2;i++)r[i]=arr[m+1+i];\n\t\tint i=0,j=0,k=b;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<r[j])arr[k++]=l[i++];\n\t\t\telse arr[k++]=r[j++];\n\t\t}\n\t\twhile(i<len1)arr[k++]=l[i++];\n\t\twhile(j<len2)arr[k++]=r[j++];\n\t\treturn;\n\t}\n\tstatic void mergesortidx(long[] arr,long[]idx,int b,int e) {\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tmergesortidx(arr,idx,b,m);\n\t\t\tmergesortidx(arr,idx,m+1,e);\n\t\t\tmergeidx(arr,idx,b,m,e);\n\t\t}\n\t\treturn;\n\t\t\n\t}\n\tstatic void mergeidx(long[] arr,long[]idx,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tlong[] l=new long[len1];\n\t\tlong[] lidx=new long[len1];\n\t\tlong[] r=new long[len2];\n\t\tlong[] ridx=new long[len2];\n\t\tfor(int i=0;i<len1;i++) {\n\t\t\tl[i]=arr[b+i];\n\t\t\tlidx[i]=idx[b+i];\n\t\t}\n\t\tfor(int i=0;i<len2;i++) {\n\t\t\tr[i]=arr[m+1+i];\n\t\t\tridx[i]=idx[m+1+i];\n\t\t}\n\t\tint i=0,j=0,k=b;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<=r[j]) {\n\t\t\t\tarr[k++]=l[i++];\n\t\t\t\tidx[k-1]=lidx[i-1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarr[k++]=r[j++];\n\t\t\t\tidx[k-1]=ridx[j-1];\n\t\t\t}\n\t\t}\n\t\twhile(i<len1) {\n\t\t\tidx[k]=lidx[i];\n\t\t\tarr[k++]=l[i++];\n\t\t}\n\t\twhile(j<len2) {\n\t\t\tidx[k]=ridx[j];\n\t\t\tarr[k++]=r[j++];\n\t\t}\n\t\treturn;\n\t}\n\tstatic void mergesort(int[] arr,int b,int e) {\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tmergesort(arr,b,m);\n\t\t\tmergesort(arr,m+1,e);\n\t\t\tmerge(arr,b,m,e);\n\t\t}\n\t\treturn;\n\t\t\n\t}\n\t\n\tstatic long mergen(int[] arr,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tint[] l=new int[len1];\n\t\tint[] r=new int[len2];\n\t\tfor(int i=0;i<len1;i++)l[i]=arr[b+i];\n\t\tfor(int i=0;i<len2;i++)r[i]=arr[m+1+i];\n\t\tint i=0,j=0,k=b;\n\t\tlong c=0;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<r[j])arr[k++]=l[i++];\n\t\t\telse {\n\t\t\t\tarr[k++]=r[j++];\n\t\t\t\tc=c+(long)(len1-i);\n\t\t\t}\n\t\t}\n\t\twhile(i<len1)arr[k++]=l[i++];\n\t\twhile(j<len2)arr[k++]=r[j++];\n\t\treturn c;\n\t}\n\tstatic long mergesortn(int[] arr,int b,int e) {\n\t\tlong c=0;\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tc=c+(long)mergesortn(arr,b,m);\n\t\t\tc=c+(long)mergesortn(arr,m+1,e);\n\t\t\tc=c+(long)mergen(arr,b,m,e);\n\t\t}\n\t\treturn c;\n\t\t\n\t}\n\tpublic static long fac(int n) {\n\t\tif(n==0)return 1;\n\t\treturn n*fac(n-1);\n\t}\n\tpublic static long gcd(long a, long b)\n    {\n      if (b == 0)\n        return a;\n      return gcd(b, a % b);\n    }\n     \n\tpublic static long summ(long x) {\n\t\tlong sum=0;\n\t\twhile(x!=0) {\n\t\t\tsum+=x%10;\n\t\t\tx=x\/10;\n\t\t}\n\t\treturn sum;\n\t\t\t\t\n\t}\n\t\n\tpublic  static ArrayList<Integer> findDivisors(int n){\n\t        ArrayList<Integer>res=new ArrayList<Integer>();\n\t        for (int i=1; i<=Math.sqrt(n); i++)\n\t        {\n\t            if (n%i==0)\n\t            {\n\t                \/\/ If divisors are equal, print only one\n\t                if (n\/i == i)\n\t                \tres.add(i);\n\t                else {\n\t                \tres.add(i);\n\t                \tres.add(n\/i);\n\t                }\t\n\t            }\n\t        }\n\t        return res;\n\t    }\n\n\t\n\tpublic static void sort2darray(Integer[][]a){\n\t\tArrays.sort(a,Comparator.<Integer[]>comparingInt(x -> x[0]).thenComparingInt(x -> x[1]));\n \n\t}\n\t\n\t\n\t\n\t\t\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\t\tpublic Scanner(String file) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t\tpublic int[] nextArrint(int size) throws IOException {\n\t\t\tint[] a=new int[size];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic long[] nextArrlong(int size) throws IOException {\n\t\t\tlong[] a=new long[size];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextLong();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic int[][] next2dArrint(int rows,int columns) throws IOException{\n\t\t\tint[][]a=new int[rows][columns];\n\t\t\tfor (int i = 0; i < rows; i++) {\n\t\t\t\tfor (int j = 0; j < columns; j++) {\n\t\t\t\t\ta[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic long[][] next2dArrlong(int rows,int columns) throws IOException{\n\t\t\tlong[][]a=new long[rows][columns];\n\t\t\tfor (int i = 0; i < rows; i++) {\n\t\t\t\tfor (int j = 0; j < columns; j++) {\n\t\t\t\t\ta[i][j]=sc.nextLong();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}\n\t\n\tstatic class Side{\n\t\tPoint a;\n\t\tPoint b;\n\t\tpublic Side(Point a,Point b) {\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tSide s=(Side)obj;\n\t\t\treturn (s.a.equals(a)&&s.b.equals(b))||(s.b.equals(a)&&s.a.equals(b));\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\n\t\t\treturn \"(\"+a.toString()+\",\"+b.toString()+\")\";\n\t\t}\n\t}\n\tstatic class Point{\n\t\tint x;\n\t\tint y;\n\t\tint z;\n\t\tpublic Point(int x,int y,int z) {\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.z=z;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tPoint p=(Point)obj;\n\t\t\treturn x==p.x&&y==p.y&&z==p.z;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\"+x+\",\"+y+\",\"+z+\")\";\n\t\t}\n\t}\n\tstatic class Pair implements Comparable{\n\t\tlong x;\n\t\tlong y;\n\t\tpublic Pair(long x,long y) {\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tPair p=(Pair)obj;\n\t\t\treturn x==p.x&&y==p.y;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\/\/ TODO Auto-generated method stub\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Object o) {\n\t\t\tPair p=(Pair)o;\n\t\t\treturn x>p.x?1:x==p.x?0:-1;\n\t\t}\n\t}\n\tstatic class sPair{\n\t\tString s;\n\t\tPair p;\n\t\tpublic sPair(String s,Pair p) {\n\t\t\tthis.p=p;\n\t\t\tthis.s=s;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\/\/ TODO Auto-generated method stub\n\t\t\treturn s+\" \"+p;\n\t\t}\n\t}\n\tstatic Scanner sc=new Scanner(System.in);\n\tstatic PrintWriter pw=new PrintWriter(System.out);\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    if (n <= 1) {\n      cout << a[0] << endl;\n    } else {\n      sort(a, a + n);\n      int mx = a[1] - a[0];\n      for (int i = 1; i < n - 1; i++) {\n        mx = max(a[i + 1] - a[i], mx);\n      }\n      cout << mx << endl;\n    }\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long log_a_to_base_b(long long a, long long b) { return log(a) \/ log(b); }\nbool isPrime(long long n) {\n  if (n == 1) {\n    return false;\n  }\n  long long i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      return false;\n    }\n    i += 1;\n  }\n  return true;\n}\nvector<long long> prime_fact(long long n) {\n  vector<long long> v;\n  for (long long i = 2; i * i <= n; i++)\n    if (n % i == 0) {\n      while (n % i == 0) n \/= i;\n      v.push_back(i);\n    }\n  if (n > 1) v.push_back(n);\n  return v;\n}\nlong long power(long long a, long long n) {\n  long long res = 1;\n  while (n) {\n    if (n % 2)\n      res *= a, n--;\n    else\n      a *= a, n \/= 2;\n  }\n  return res;\n}\nlong long euler_totient(long long n) {\n  long long res = n;\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      res \/= i;\n      res *= (i - 1);\n      while (n % i == 0) n \/= i;\n    }\n  }\n  if (n > 1) res \/= n, res *= (n - 1);\n  return res;\n}\nbool isKthBitSet(long long n, long long k) {\n  if (n & (1 << k))\n    return true;\n  else\n    return false;\n}\nlong long no_of_set_bits(long long n) {\n  long long cnt = 0;\n  while (n > 0) {\n    cnt++;\n    n = n & (n - 1);\n  }\n  return cnt;\n}\nvoid init() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nsigned main() {\n  init();\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> v(n);\n    for (auto &i : v) cin >> i;\n    sort(v.begin(), v.end());\n    if (n == 1) {\n      cout << v[0] << \"\\n\";\n      continue;\n    }\n    if (n == 2) {\n      cout << max(v[0], (v[1] - v[0])) << \"\\n\";\n      continue;\n    }\n    long long ans = 0ll;\n    long long i = 0ll;\n    if (v[0ll] < 0ll) {\n      for (i = 1ll; i < n; i++)\n        if (v[i] < 0ll)\n          continue;\n        else\n          break;\n      i--;\n      ans = (long long)v[i] - v[0];\n      i++;\n    }\n    for (; i < n - 1ll; i++) ans = max(ans, (long long)(v[i + 1] - v[i]));\n    cout << (long long)ans << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx2,fma\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimization(\"unroll-loops\")\n#pragma comment(linker, \"\/STACK: 20000000005\")\nbool tc = 1;\nvoid run_case() {\n  long long int n;\n  cin >> n;\n  vector<long long int> v(n);\n  for (long long int i = 0; i < n; i++) cin >> v[i];\n  long long int ans = v[0];\n  sort(v.rbegin(), v.rend());\n  while (v.size() > 1) {\n    if (v[v.size() - 1] > (v[v.size() - 2] - v[v.size() - 1])) {\n      ans = v[v.size() - 1];\n      break;\n    }\n    long long int mn = v.back();\n    v.pop_back();\n    for (long long int i = 0; i < v.size(); i++) v[i] -= mn;\n  }\n  if (v.size() == 1) ans = v[0];\n  cout << ans << endl;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  if (tc) {\n    int t;\n    cin >> t;\n    while (t--) run_case();\n  } else\n    run_case();\n  return 0;\n}\n","t=int(input())\nfor i in range(t):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    list_min=[]\n    if(len(arr)==1):\n        list_min.append(arr[0])\n    while(len(arr)>1):\n        mini=min(arr)\n        list_min.append(mini)\n        del(arr[arr.index(mini)])\n        arr=[x-mini for x in arr]\n   \n    print(max(list_min))","t = int(input())\nres = []\nfor j in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  minA = [0] * n\n  newA = a.copy()\n  x = 0\n  minA[n - 1] = min(a)\n  x = minA[n - 1]\n  del newA[newA.index(x)]\n  newA = list(map(lambda y: y - x, newA))\n  for i in range(n - 1):\n    val = max(minA[n - 2 - i + 1], min(newA))\n    if minA[n - 2 - i + 1] <= val:\n      minA[n - 2 - i] = val\n      x = minA[n - 2 - i]\n      if x in newA:\n        del newA[newA.index(x)]\n      newA = list(map(lambda y: y - x, newA))\n    else:\n      break\n  res.append(x)\n\nfor index in range(t):\n  print(res[index])","t=int(input())\nfor i in range(t):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    list_min=[]\n    arr=sorted(arr)\n    maxi=arr[0]\n    mini=arr[0]\n    #while(len(arr)>1):\n    for i in range(n-1):\n        mini+=arr[0]\n        arr=arr[1:]\n        arr[0]-=mini\n        if maxi<arr[0]:\n            maxi=arr[0]\n        \n    arr[0]-=mini\n    if maxi<arr[0]:\n            maxi=arr[0]\n    if(len(arr)==1 and maxi<arr[0]):\n        \n        maxi=arr[0]\n    #list_min.append(mini)\n    #print(\"gg: \")\n    print(maxi)","t = int(input())\nd = []\nfor i in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    mx = -10000000000\n    while True:\n        l = len(a)\n        mn = min(a)\n        mx = max(mn,mx)\n        if mx > max(a):\n            break\n        if l == 1:\n            break\n        if a.count(mn) == l:\n            break\n        else:\n            a.remove(mn)\n            for x in range(l-1):\n                a[x] -= mn\n    print(mx)\n ","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  long long t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<long long> vi(n);\n    for (int i = 0; i < n; i++) {\n      cin >> vi[i];\n    }\n    long long mx = 2 * 10e-5;\n    if (n == 1) {\n      mx = vi[0];\n    } else if (n == 2) {\n      mx = max(vi[0], abs(vi[1] - vi[0]));\n    } else {\n      sort(vi.begin(), vi.end());\n      for (int j = 1; j < n; j++) {\n        mx = max(mx, abs(vi[j] - vi[j - 1]));\n      }\n      mx = (mx, vi[0]);\n    }\n    cout << mx << \"\\n\";\n  }\n  return 0;\n}\n","\/\/ package MyPackage;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br=new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next(){\n            while(st==null || !st.hasMoreTokens()){\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt(){\n            return Integer.parseInt(next());\n        }\n        long nextLong(){\n            return Long.parseLong(next());\n        }\n        double nextDouble(){\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String str=\"\";\n            try {\n                str=br.readLine().trim();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static class FastWriter {\n\t\tprivate final BufferedWriter bw;\n\n\t\tpublic FastWriter() {\n\t\t\tthis.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t}\n\n\t\tpublic void print(Object object) throws IOException {\n\t\t\tbw.append(\"\" + object);\n\t\t}\n\n\t\tpublic void println(Object object) throws IOException {\n\t\t\tprint(object);\n\t\t\tbw.append(\"\\n\");\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbw.close();\n\t\t}\n\t}\n    public static void main(String[] args)\n    {\n        try {\n            FastReader in=new FastReader();\n            FastWriter out = new FastWriter();\n            StringBuilder sb = new StringBuilder();\n            int testCases=in.nextInt();\n            while(testCases-- > 0) {\n                \/\/ write code here\n            \tint n = in.nextInt();\n            \tArrayList<Long> a = new ArrayList<>();\n            \tfor(int i = 0; i < n; i++)\n            \t{\n            \t\ta.add(in.nextLong());\n            \t}\n            \tlong ans = 0;\n            \tif(a.size() == 1)\n            \t\tans = a.get(0);\n            \telse\n            \t{\n\t            \tCollections.sort(a);\n\t            \tlong min = 0;\n\t            \twhile(a.size() > 1)\n\t            \t{\n\t            \t\tmin = a.remove(0);\n\t\t            \tfor(int i = 0; i < a.size() ; i++)\n\t\t            \t{\n\t\t            \t\tlong val = a.get(i);\n\t\t            \t\tval = val - min;\n\t\t            \t\ta.set(i, val);\n\t\t            \t}\n\t\t            \tans = Math.max(min, a.get(0));\n\t            \t}\n            \t}\n        \t\tsb.append(ans + \"\\n\");\n            }\n            out.println(sb);\n            out.close();\n        } catch (Exception e) {\n            return;\n        }\n    }\n}\n","\"\"\"\n\/\/ Author : snape_here - Susanta Mukherjee\n     \n \"\"\"\n\nfrom __future__ import division, print_function\n \nimport os,sys\nfrom io import BytesIO, IOBase\n \nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n \ndef ii(): return int(input())\ndef fi(): return float(input())\ndef si(): return input()\ndef msi(): return map(str,input().split())\ndef mi(): return map(int,input().split())\ndef li(): return list(mi())\ndef lsi(): return list(msi())\n \ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n \ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return (x*y)\/\/(gcd(x,y))\n\nmod=1000000007\n\ndef modInverse(b,m): \n    g = gcd(b, m)  \n    if (g != 1):         \n        return -1\n    else:          \n        return pow(b, m - 2, m) \n\ndef ceil2(x,y):\n    if x%y==0:\n        return x\/\/y\n    else:\n        return x\/\/y+1\n\ndef modu(a,b,m): \n\n    a = a % m \n    inv = modInverse(b,m) \n    if(inv == -1): \n        return -999999999\n    else: \n        return (inv*a)%m\n\nfrom math import log,factorial,cos,tan,sin,radians,floor,sqrt,ceil,log2\n\nimport bisect\nimport random\nimport string \n\nfrom decimal import *\n\ngetcontext().prec = 50\n\nabc=\"abcdefghijklmnopqrstuvwxyz\"\n\npi=3.141592653589793238\n\ndef gcd1(a):\n    if len(a) == 1:\n        return a[0]\n    ans = a[0]\n    for i in range(1,len(a)):\n        ans = gcd(ans,a[i])\n    return ans\n\ndef mykey(x):\n    return len(x)\n\ndef main():\n\n    for _ in range(ii()):\n        n=ii()\n        a=li()\n        a.sort()\n        ans = -1e9\n        s = 0\n        for i in range(n):\n            ans = max(ans,a[i]-s)\n            s = a[i]\n        print(ans)\n\n        # print(\"Case #\",end=\"\")\n        # print(_+1,end=\"\")\n        # print(\": \",end=\"\")\n        # print(ans)\n\n\n# region fastio\n\n# template taken from https:\/\/github.com\/cheran-senthil\/PyRival\/blob\/master\/templates\/template.py\n\nBUFSIZE = 8192\n \n\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n \ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n\n \nif __name__ == \"__main__\":\n    #read()\n    main()","for t in range(int(input())):\n    n= int(input())\n    lis = list(map(int, input().split()))\n    if len(lis)==1:\n        print(lis[0])\n    else:\n        lis.sort()\n        maximum=lis[-1]\n        count=index=0\n        for i in range(n):\n            if lis[i]<0:\n                count+=1\n                index=i\n        lis=lis[index:]\n        for i in range(len(lis)):\n            lis[i]+=count\n        count=0\n        res=lis[0]\n        for i in range(len(lis)):\n            val=lis[i]-count\n            if val>res:\n                res=val\n            count+=val\n        print(res)","import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n    static long mod = (int)1e9+7;\n    public static void main (String[] args) throws java.lang.Exception\n    {\n        FastReader sc =new FastReader();\n\n        int t=sc.nextInt();\n   \n    \/\/   int t=1;\n   \n        while(t-->0)\n        {\n            int n=sc.nextInt();\n            int a[]=sc.readArray(n);\n            if(n==1)\n            {\n                System.out.println(a[0]);\n                continue;\n            }\n            if(n==2)\n            {\n                radixSort2(a);\n                int m=a[n-1]-a[n-2];\n                if(m>a[n-2])\n                {\n                    System.out.println(m);\n                }\n                else\n                {\n                    System.out.println(a[n-2]);\n                }\n                continue;\n            }\n            radixSort2(a);\n            int m=a[n-1]-a[n-2];\n            a[n-2]-=a[n-3];\n            if(m>a[n-2])\n            {\n                System.out.println(m);\n            }\n            else\n            {\n                System.out.println(a[n-2]);\n            }\n        }\n    }\n\nstatic int findfrequencies(int a[],int n)\n{\n    int count=0;\n    for(int i=0;i<a.length;i++)\n    {\n        if(a[i]==n)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nstatic class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(\n                new InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() { return Integer.parseInt(next()); }\n \n        long nextLong() { return Long.parseLong(next()); }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n       \n        float nextFloat()\n        {\n            return Float.parseFloat(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n       \n        int[] readArray(int n) {\nint[] a=new int[n];\nfor (int i=0; i<n; i++) a[i]=nextInt();\nreturn a;\n}\n\nlong[] readArrayLong(int n) {\nlong[] a=new long[n];\nfor (int i=0; i<n; i++) a[i]=nextLong();\nreturn a;\n}\n\n    }\n   \n    public static int[] radixSort2(int[] a)\n{\nint n = a.length;\nint[] c0 = new int[0x101];\nint[] c1 = new int[0x101];\nint[] c2 = new int[0x101];\nint[] c3 = new int[0x101];\nfor(int v : a) {\nc0[(v&0xff)+1]++;\nc1[(v>>>8&0xff)+1]++;\nc2[(v>>>16&0xff)+1]++;\nc3[(v>>>24^0x80)+1]++;\n}\nfor(int i = 0;i < 0xff;i++) {\nc0[i+1] += c0[i];\nc1[i+1] += c1[i];\nc2[i+1] += c2[i];\nc3[i+1] += c3[i];\n}\nint[] t = new int[n];\nfor(int v : a)t[c0[v&0xff]++] = v;\nfor(int v : t)a[c1[v>>>8&0xff]++] = v;\nfor(int v : a)t[c2[v>>>16&0xff]++] = v;\nfor(int v : t)a[c3[v>>>24^0x80]++] = v;\nreturn a;\n}\n\nstatic int[] EvenOddArragement(int a[])\n{\n    ArrayList<Integer> list=new ArrayList<>();\n    for(int i=0;i<a.length;i++)\n    {\n        if(a[i]%2==0)\n        {\n            list.add(a[i]);\n        }\n    }\n    for(int i=0;i<a.length;i++)\n    {\n        if(a[i]%2!=0)\n        {\n            list.add(a[i]);\n        }\n    }\n    for(int i=0;i<a.length;i++)\n    {\n        a[i]=list.get(i);\n    }\n    return a;\n}\nstatic int gcd(int a, int b) {\n    while (b != 0) {\n        int t = a;\n        a = b;\n        b = t % b;\n    }\n    return a;\n}\n   \n    public static HashMap<Integer, Integer> sortByValue(HashMap<Integer, Integer> hm)\n    {\n        \/\/ Create a list from elements of HashMap\n        List<Map.Entry<Integer, Integer> > list =\n               new LinkedList<Map.Entry<Integer, Integer> >(hm.entrySet());\n \n        \/\/ Sort the list\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer> >() {\n            public int compare(Map.Entry<Integer, Integer> o1,\n                               Map.Entry<Integer, Integer> o2)\n            {\n                return (o1.getValue()).compareTo(o2.getValue());\n            }\n        });\n         \n        \/\/ put data from sorted list to hashmap\n        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();\n        for (Map.Entry<Integer, Integer> aa : list) {\n            temp.put(aa.getKey(), aa.getValue());\n        }\n        return temp;\n    }\n    static int DigitSum(int n)\n    {\n        int r=0,sum=0;\n        while(n>=0)\n        {\n            r=n%10;\n            sum=sum+r;\n            n=n\/10;\n        }\n        return sum;\n    }\n}","import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n    \/\/ Graph\n    \/\/ prefix sums\n    \/\/inputs\n    public static void main(String args[])throws Exception{\n        Input sc=new Input();\n        precalculates p=new precalculates();\n        StringBuilder sb=new StringBuilder();\n        int t=sc.readInt();\n        for(int f=0;f<t;f++){\n            int n=sc.readInt();\n            long a[]=sc.readArrayLong();\n            HashSet<Long> map=new HashSet<>();\n            for(int i=0;i<n;i++){\n                map.add(a[i]);\n            }\n            n=map.size();\n            a=new long[n];\n            int j=0;\n            for(Long val:map){\n                a[j++]=val;\n            }\n            Arrays.sort(a);\n            long sum=0;\n            long prev=0;long ans=Long.MIN_VALUE;\n            for(int i=0;i<n-1;i++){\n                sum=sum+((a[i])-prev);\n                ans=Math.max(ans,a[i]-prev);\n                prev=sum;\n            }\n            \/*if(a.length>1 && a[0]==0) {\n                ans = Math.max(ans, a[n - 2]);\n            }else*\/ if(a.length>1 && a[n-1]!=0){\n                ans=Math.max(ans,a[n-1]-prev);\n            }\n\n\/\/            if(n>0 && a[0]==0)\n\/\/            {\n\/\/                ans=0;\n\/\/            }\n            if(ans!=Long.MIN_VALUE)\n                sb.append(ans+\"\\n\");\n            else\n                sb.append(a[n-1]+\"\\n\");\n\n        }\n        \/\/ 1 2 7 10   1\n        \/\/ 0 1 6 9    2\n        \/\/ 0 0 5 8\n        \/\/ -1 0 2\n        \/\/ 0  1 3\n        \/\/ 0 0 2\n        System.out.print(sb);\n    }\n}\nclass Input{\n    BufferedReader br;\n    StringTokenizer st;\n    Input(){\n        br=new BufferedReader(new InputStreamReader(System.in));\n        st=new StringTokenizer(\"\");\n    }\n    public int[] readArray() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        int a[]=new int[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Integer.parseInt(st.nextToken());\n        }\n        return a;\n    }\n    public long[] readArrayLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        long a[]=new long[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Long.parseLong(st.nextToken());\n        }\n        return a;\n    }\n    public int readInt() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Integer.parseInt(st.nextToken());\n    }\n    public long readLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Long.parseLong(st.nextToken());\n    }\n    public String readString() throws Exception{\n        return br.readLine();\n    }\n    public int[][] read2dArray(int n,int m)throws Exception{\n        int a[][]=new int[n][m];\n        for(int i=0;i<n;i++){\n            st=new StringTokenizer(br.readLine());\n            for(int j=0;j<m;j++){\n                a[i][j]=Integer.parseInt(st.nextToken());\n            }\n        }\n        return a;\n    }\n}\nclass precalculates{\n    public int[] prefixSumOneDimentional(int a[]){\n        int n=a.length;\n        int dp[]=new int[n];\n        for(int i=0;i<n;i++){\n            if(i==0)\n                dp[i]=a[i];\n            else\n                dp[i]=dp[i-1]+a[i];\n        }\n        return dp;\n    }\n    public int[] postSumOneDimentional(int a[]) {\n        int n = a.length;\n        int dp[] = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            if (i == n - 1)\n                dp[i] = a[i];\n            else\n                dp[i] = dp[i + 1] + a[i];\n        }\n        return dp;\n    }\n    public int[][] prefixSum2d(int a[][]){\n        int n=a.length;int m=a[0].length;\n        int dp[][]=new int[n+1][m+1];\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=m;j++){\n                dp[i][j]=a[i-1][j-1]+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];\n            }\n        }\n        return dp;\n    }\n    public long pow(long a,long b){\n        long mod=1000000007;\n        long ans=0;\n        if(b<=0)\n            return 1;\n        if(b%2==0){\n            ans=pow(a,b\/2)%mod;\n            return ((ans%mod)*(ans%mod))%mod;\n        }else{\n            return ((a%mod)*(ans%mod))%mod;\n        }\n    }\n\n}\nclass GraphInteger{\n    HashMap<Integer,vertex> vtces;\n    class vertex{\n        HashMap<Integer,Integer> children;\n        public vertex(){\n            children=new HashMap<>();\n        }\n    }\n    public GraphInteger(){\n        vtces=new HashMap<>();\n    }\n    public void addVertex(int a){\n        vtces.put(a,new vertex());\n    }\n    public void addEdge(int a,int b,int cost){\n        if(!vtces.containsKey(a)){\n            vtces.put(a,new vertex());\n        }\n        if(!vtces.containsKey(b)){\n            vtces.put(b,new vertex());\n        }\n        vtces.get(a).children.put(b,cost);\n\/\/        vtces.get(b).children.put(a,cost);\n    }\n    public boolean isCyclicDirected(){\n        boolean isdone[]=new boolean[vtces.size()+1];\n        boolean check[]=new boolean[vtces.size()+1];\n        for(int i=1;i<=vtces.size();i++) {\n            if (!isdone[i] && isCyclicDirected(i,isdone, check)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private boolean isCyclicDirected(int i,boolean isdone[],boolean check[]){\n        if(check[i])\n            return true;\n        if(isdone[i])\n            return false;\n        check[i]=true;\n        isdone[i]=true;\n        Set<Integer> set=vtces.get(i).children.keySet();\n        for(Integer ii:set){\n            if(isCyclicDirected(ii,isdone,check))\n                return true;\n        }\n        check[i]=false;\n        return false;\n    }\n}","#include <bits\/stdc++.h>\nusing namespace std;\n#pragma GCC target( \\\n    \"sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\nconst long long inf = 1e18;\nconst double pi = 3.14159265358979323846264338327950288419716939937510;\nconst long long mod = 1e9 + 7;\nconst long long mod2 = 998244353;\nconst double eps = (0.00000000001);\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  a %= b;\n  return gcd(b, a);\n}\nlong long gcdExtended(long long, long long, long long*, long long*);\nlong long gcdExtended(long long a, long long b, long long* x, long long* y) {\n  if (a == 0) {\n    *x = 0, *y = 1;\n    return b;\n  }\n  long long x1, y1;\n  long long gcd = gcdExtended(b % a, a, &x1, &y1);\n  *x = y1 - (b \/ a) * x1;\n  *y = x1;\n  return gcd;\n}\nlong long powerForInverse(long long x, long long y, long long m) {\n  if (y == 0) return 1;\n  long long temp = powerForInverse(x, y \/ 2, m);\n  temp = (temp * temp) % m;\n  if (y & 1) temp = ((temp % m) * (x % m)) % m;\n  return temp;\n}\nlong long modInverse(long long a, long long m) {\n  return powerForInverse(a, m - 2, m);\n}\nlong long nCr(long long n, long long r) {\n  if (r > n) return 0;\n  if (r > n - r) r = n - r;\n  long long ans = 1;\n  for (long long i = 1; i < r + 1; i++) {\n    ans *= (n - i + 1);\n    ans *= modInverse(i, mod);\n  }\n  return ans;\n}\nlong long nCrM(long long n, long long r) {\n  if (r > n) return 0;\n  if (r > n - r) r = n - r;\n  long long ans = 1;\n  for (long long i = 1; i < r + 1; i++) {\n    ans *= (n - i + 1);\n    ans %= mod;\n    ans *= modInverse(i, mod);\n    ans %= mod;\n  }\n  return ans;\n}\nlong long lcm(long long a, long long b) { return (a \/ gcd(a, b)) * b; }\nlong long binpowM(long long a, long long b) {\n  if (b == 0) return 1;\n  if (b == 1) return a % mod;\n  long long res = binpowM(a, b \/ 2) % mod;\n  if (b % 2 == 1)\n    return (((res * res) % mod) * a) % mod;\n  else\n    return (res * res) % mod;\n}\nlong long binpow(long long a, long long b) {\n  if (b == 0) return 1;\n  if (b == 1) return a;\n  long long res = binpow(a, b \/ 2);\n  if (b % 2 == 1)\n    return (((res * res)) * a);\n  else\n    return (res * res);\n}\nvoid sieve(vector<long long>& primes, long long n, vector<long long>& touched) {\n  primes.clear();\n  long long arr[n + 1];\n  for (long long i = 0; i < n + 1; i++) arr[i] = i;\n  touched[0] = true;\n  touched[1] = true;\n  for (long long i = 2; i < (int)sqrt(n) + 1; i++) {\n    if (!touched[i]) {\n      touched[i] = true;\n      primes.push_back(i);\n      for (long long j = i * i; j < n + 1; j++) {\n        touched[j] = true;\n        j--;\n        j += i;\n      }\n    }\n  }\n  for (long long i = (int)sqrt(n) + 1; i < n; i++) {\n    if (!touched[i]) primes.push_back(i);\n  }\n}\nlong long binary_search(long long arr[], long long n, long long elem) {\n  long long l = 0, r = n - 1;\n  while (r >= l) {\n    long long mid = (l + r) \/ 2;\n    if (arr[mid] > elem)\n      r = mid - 1;\n    else if (arr[mid] < elem)\n      l = mid + 1;\n    else\n      return mid;\n  }\n  return -1;\n}\nlong long binary_search_vector(vector<long long>& arr, long long elem) {\n  long long n = arr.size();\n  long long l = 0, r = n - 1;\n  while (r >= l) {\n    long long mid = (l + r) \/ 2;\n    if (arr[mid] > elem)\n      r = mid - 1;\n    else if (arr[mid] < elem)\n      l = mid + 1;\n    else\n      return mid;\n  }\n  return -1;\n}\nlong long factorial(long long n) {\n  long long res = 1;\n  for (long long i = 2; i < n + 1; i++) res *= i;\n  return res;\n}\nlong long factorialM(long long n) {\n  long long res = 1;\n  for (long long i = 2; i < n + 1; i++) res = (res * i) % mod;\n  return res % mod;\n}\nbool checkPrime(long long n) {\n  long long count = 0;\n  for (long long i = 2; i < 1 + (long long)sqrt(n); i++) {\n    if (n % i == 0) count++;\n  }\n  if (count > 0)\n    return false;\n  else\n    return true;\n}\nbool compare(pair<long long, long long> p1, pair<long long, long long> p2) {\n  if (p1.second > p2.second)\n    return true;\n  else if (p1.second == p2.second)\n    return p1.first < p2.first;\n  else\n    return false;\n}\nclass Graph {\n public:\n  vector<vector<long long> > adj;\n  vector<bool> visited;\n  Graph(long long n) {\n    adj.resize(n + 1);\n    visited.resize(n + 1);\n  }\n  void addEdge(long long first, long long second, bool directed = false);\n  void dfs(long long start);\n  void check(long long ans[], long long n);\n};\nvoid Graph::addEdge(long long first, long long second, bool directed) {\n  adj[first].push_back(second);\n  if (!directed) adj[second].push_back(first);\n}\nvoid Graph::dfs(long long start) {\n  visited[start] = true;\n  cout << start << \" \";\n  for (long long i = 0; i < adj[start].size(); i++) {\n    if (!visited[adj[start][i]]) dfs(adj[start][i]);\n  }\n}\nvoid Graph::check(long long ans[], long long n) {\n  for (long long i = 0; i < adj.size(); i++) {\n    ans[adj[i].size()]++;\n  }\n}\nlong long noOfDigits(long long x) {\n  long long digits = 0;\n  while (x > 0) {\n    x \/= 10;\n    digits++;\n  }\n  return digits;\n}\nlong long sumOfDigits(long long n) {\n  long long sum = 0;\n  while (n > 0) {\n    sum += n % 10;\n    n \/= 10;\n  }\n  return sum;\n}\nbool cmp(pair<long long, long long> a, pair<long long, long long> b) {\n  return a.first < b.first;\n}\nvoid reverse(string& str, long long start, long long end) {\n  for (long long i = start; i < start + ((end - start + 1) \/ 2); i++) {\n    swap(str[i], str[end + start - i]);\n  }\n}\nlong long findGCD(long long arr[], long long n) {\n  long long result = arr[0];\n  for (int i = 1; i < n; i++) {\n    result = gcd(arr[i], result);\n    if (result == 1) {\n      return 1;\n    }\n  }\n  return result;\n}\nlong long findGCD1(long long arr[], long long n, long long i1, long long i2) {\n  long long result;\n  if (i1 == 0) {\n    result = arr[0] * arr[i2];\n  } else {\n    result = arr[0];\n  }\n  for (int i = 1; i < n; i++) {\n    if (i == i1) {\n      result = gcd(arr[i] * arr[i2], result);\n    } else if (i == i2) {\n      result = gcd(arr[i] * arr[i1], result);\n    } else {\n      result = gcd(arr[i], result);\n    }\n    if (result == 1) {\n      return 1;\n    }\n  }\n  return result;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  srand(time(NULL));\n  long long t;\n  cin >> t;\n  for (long long tc = 1; tc <= t; tc++) {\n    long long n;\n    cin >> n;\n    long long arr[n];\n    for (long long i = 0; i < n; i++) {\n      cin >> arr[i];\n    };\n    sort(arr, arr + n);\n    if (n == 1) {\n      cout << arr[0] << \"\\n\";\n      continue;\n    } else if (n == 2) {\n      cout << max(arr[0], arr[1] - arr[0]) << \"\\n\";\n      continue;\n    }\n    long long ans = INT_MIN;\n    for (long long i = 0; i < n - 1; i++) {\n      if (arr[i + 1] >= 2 * arr[i]) {\n        ans = arr[i + 1] - arr[i];\n      } else {\n        break;\n      };\n    }\n    if (ans == INT_MIN) {\n      ans = arr[0];\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint t, n;\nlong long a[200005], ans;\nint main() {\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n    if (n == 1) {\n      printf(\"%lld\\n\", a[0]);\n      continue;\n    }\n    sort(a, a + n);\n    long long temp = 0;\n    for (int i = 0; i < n; i++) {\n      if (a[i] < 0) temp -= (a[i]);\n    }\n    if (a[n - 2] >= 0) {\n      ans = a[n - 1] - a[n - 2];\n    } else {\n      ans = a[n - 1] - temp;\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n","import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.lang.*;\nimport static java.lang.Math.*;\n\n\/\/ Sachin_2961 submission \/\/\npublic class Codeforces {\n\n    static void solve(){\n        int n = fs.nInt();\n        long[]ar = new long[n];\n        for(int i=0;i<n;i++)\n            ar[i] = fs.nLong();\n\n        Arrays.sort(ar);\n        long d = ar[0];\n        long ans = ar[0];\n        for(int i=1;i<n;i++){\n\n            if( ar[i] - d < ans ){\n                break;\n            }\n            ans = ar[i] - d;\n            d = d + (ar[i] - d);\n        }\n        out.println(ans);\n    }\n    \n    static class Pair{\n        int f,s;\n        Pair(int f,int s){\n            this.f = f;\n            this.s = s;\n        }\n    }\n    static boolean multipleTestCase = true;\n    static FastScanner fs;\n    static PrintWriter out;\n    public static void main(String[]args){\n       try{\n           out = new PrintWriter(System.out);\n           fs = new FastScanner();\n           int tc = multipleTestCase?fs.nInt():1;\n           while (tc-->0)solve();\n           out.flush();\n           out.close();\n       }catch (Exception e){\n           e.printStackTrace();\n       }\n    }\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String n() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        String Line()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        int nInt() {return Integer.parseInt(n()); }\n        long nLong() {return Long.parseLong(n());}\n        double nDouble(){return Double.parseDouble(n());}\n        int[]aI(int n){\n            int[]ar = new int[n];\n            for(int i=0;i<n;i++)\n                ar[i] = nInt();\n            return ar;\n        }\n    }\n    public static void sort(int[] arr){\n        ArrayList<Integer> ls = new ArrayList<Integer>();\n        for(int x: arr)\n            ls.add(x);\n        Collections.sort(ls);\n        for(int i=0; i < arr.length; i++)\n            arr[i] = ls.get(i);\n    }\n    public static void sort(long[] arr){\n        ArrayList<Long> ls = new ArrayList<>();\n        for(long x: arr)\n            ls.add(x);\n        Collections.sort(ls);\n        for(int i=0; i < arr.length; i++)\n            arr[i] = ls.get(i);\n    }\n}","#include <bits\/stdc++.h>\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define drep(i,j,n) for(int i=0;i<(int)(n-1);i++)for(int j=i+1;j<(int)(n);j++)\n#define trep(i,j,k,n) for(int i=0;i<(int)(n-2);i++)for(int j=i+1;j<(int)(n-1);j++)for(int k=j+1;k<(int)(n);k++)\n#define codefor int test;scanf(\"%d\",&test);while(test--)\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define yes(ans) if(ans)printf(\"yes\\n\");else printf(\"no\\n\")\n#define Yes(ans) if(ans)printf(\"Yes\\n\");else printf(\"No\\n\")\n#define YES(ans) if(ans)printf(\"YES\\n\");else printf(\"NO\\n\")\n#define popcount(v) __builtin_popcount(v)\n#define vector1d(type,name,...) vector<type>name(__VA_ARGS__)\n#define vector2d(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define vector3d(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\nusing namespace std;\nusing ll = long long;\ntemplate<class T>using rpriority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD=1000000007;\nconst int MOD2=998244353;\nconst int INF=1<<30;\nconst ll INF2=(ll)1<<60;\n\/\/\u5165\u529b\u7cfb\nvoid scan(int& a){scanf(\"%d\",&a);}\nvoid scan(long long& a){scanf(\"%lld\",&a);}\ntemplate<class T,class L>void scan(pair<T, L>& p){scan(p.first);scan(p.second);}\ntemplate<class T> void scan(T& a){cin>>a;}\ntemplate<class T> void scan(vector<T>& vec){for(auto&& it:vec)scan(it);}\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){scan(head);in(tail...);}\n\/\/\u51fa\u529b\u7cfb\nvoid print(const int& a){printf(\"%d\",a);}\nvoid print(const long long& a){printf(\"%lld\",a);}\nvoid print(const double& a){printf(\"%.15lf\",a);}\ntemplate<class T,class L>void print(const pair<T, L>& p){print(p.first);putchar(' ');print(p.second);}\ntemplate<class T> void print(const T& a){cout<<a;}\ntemplate<class T> void print(const vector<T>& vec){if(vec.empty())return;print(vec[0]);for(auto it=vec.begin();++it!= vec.end();){putchar(' ');print(*it);}}\nvoid out(){putchar('\\n');}\ntemplate<class T> void out(const T& t){print(t);putchar('\\n');}\ntemplate <class Head, class... Tail> void out(const Head& head,const Tail&... tail){print(head);putchar(' ');out(tail...);}\n\/\/\u30c7\u30d0\u30c3\u30b0\u7cfb\ntemplate<class T> void dprint(const T& a){cerr<<a;}\ntemplate<class T> void dprint(const vector<T>& vec){if(vec.empty())return;cerr<<vec[0];for(auto it=vec.begin();++it!= vec.end();){cerr<<\" \"<<*it;}}\nvoid debug(){cerr<<endl;}\ntemplate<class T> void debug(const T& t){dprint(t);cerr<<endl;}\ntemplate <class Head, class... Tail> void debug(const Head& head, const Tail&... tail){dprint(head);cerr<<\" \";debug(tail...);}\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b \/= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b \/= 2; } return ans; }\nll modinv(ll a, ll m) {ll b = m, u = 1, v = 0;while (b) {ll t = a \/ b;a -= t * b; swap(a, b);u -= t * v; swap(u, v);}u %= m;if (u < 0) u += m;return u;}\nll updivide(ll a,ll b){if(a%b==0) return a\/b;else return (a\/b)+1;}\ntemplate<class T> void chmax(T &a,const T b){if(b>a)a=b;}\ntemplate<class T> void chmin(T &a,const T b){if(b<a)a=b;}\n\nnamespace internal {\nconstexpr long long safe_mod(long long x, long long m) {x %= m;if (x < 0) x += m;return x;}\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n    explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) \/ m + 1) {}\n    unsigned int umod() const { return _m; }\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned long long)(z)*im));\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d \/= 2;\n    constexpr long long bases[3] = {2, 7, 61};\n    for (long long a : bases) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {y = y * y % n;t <<= 1;}\n        if (y != n - 1 && t % 2 == 0) {return false;}\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n    while (t) {long long u = s \/ t;s -= t * u;m0 -= m1 * u;auto tmp = s;s = t;t = tmp;tmp = m0;m0 = m1;m1 = tmp;}\n    if (m0 < 0) m0 += b \/ s;\n    return {s, m0};\n}\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) \/ 2;\n    while (x % 2 == 0) x \/= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {divs[cnt++] = i;while (x % i == 0) {x \/= i;}}\n    }\n    if (x > 1) {divs[cnt++] = x;}\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) \/ divs[i], m) == 1) {ok = false;break;}\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\nunsigned long long floor_sum_unsigned(unsigned long long n,unsigned long long m,unsigned long long a,unsigned long long b) {\n    unsigned long long ans = 0;\n    while (true) {\n        if (a >= m) {ans += n * (n - 1) \/ 2 * (a \/ m);a %= m;}\n        if (b >= m) {ans += n * (b \/ m);b %= m;}\n        unsigned long long y_max = a * n + b;\n        if (y_max < m) break;\n        n = (unsigned long long)(y_max \/ m);\n        b = (unsigned long long)(y_max % m);\n        std::swap(m, a);\n    }\n    return ans;\n}\ntemplate <class T> using is_integral = typename std::is_integral<T>;\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\ntemplate <class T> using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\ntemplate <class T> using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n}  \/\/ namespace internal\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {mint x;x._v = v;return x;}\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();_v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {_v = (unsigned int)(v % umod());}\n    unsigned int val() const { return _v; }\n    mint& operator++() {_v++;if (_v == umod()) _v = 0;return *this;}\n    mint& operator--() {if (_v == 0) _v = umod();_v--;return *this;}\n    mint operator++(int) {mint result = *this;++*this;return result;}\n    mint operator--(int) {mint result = *this;--*this;return result;}\n    mint& operator+=(const mint& rhs) {_v += rhs._v;if (_v >= umod()) _v -= umod();return *this;}\n    mint& operator-=(const mint& rhs) {_v -= rhs._v;if (_v >= umod()) _v += umod();return *this;}\n    mint& operator*=(const mint& rhs) {unsigned long long z = _v;z *= rhs._v;_v = (unsigned int)(z % umod());return *this;}\n    mint& operator\/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {assert(0 <= n);mint x = *this, r = 1;while (n) {if (n & 1) r *= x;x *= x;n >>= 1;}return r;}\n    mint inv() const {if (prime) {assert(_v);return pow(umod() - 2);} else {auto eg = internal::inv_gcd(_v, m);assert(eg.first == 1);return eg.second;}}\n    friend mint operator+(const mint& lhs, const mint& rhs) {return mint(lhs) += rhs;}\n    friend mint operator-(const mint& lhs, const mint& rhs) {return mint(lhs) -= rhs;}\n    friend mint operator*(const mint& lhs, const mint& rhs) {return mint(lhs) *= rhs;}\n    friend mint operator\/(const mint& lhs, const mint& rhs) {return mint(lhs) \/= rhs;}\n    friend bool operator==(const mint& lhs, const mint& rhs) {return lhs._v == rhs._v;}\n    friend bool operator!=(const mint& lhs, const mint& rhs) {return lhs._v != rhs._v;}\n    \/\/\u81ea\u5206\u3067\u52a0\u3048\u305f\u3082\u306e\n    friend istream& operator>>(istream& os,mint& rhs) noexcept {\n        long long v;\n        rhs = mint{(os >> v, v)};\n        return os;\n    }\n    friend constexpr ostream& operator << (ostream &os, const mint& rhs) noexcept {\n        return os << rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\nusing mint=static_modint<1000000007>;\nusing mint2=static_modint<998244353>;\n\nint main(){\n    codefor{\n        INT(n);\n        deque<ll> a(n);\n        rep(i,n)in(a[i]);\n        sort(all(a));\n        ll sumv=0;\n        \/*rep(i,n){\n            if(i)cerr<<' ';\n            cerr<<a[i];\n        }\n        cerr<<endl;*\/\n        while(a.size()>=2){\n            if(sumv+a[1]-(sumv+a[0])>=sumv+a[0]){\n                sumv-=sumv+a[0];\n                a.pop_front();\n            }else break;\n        }\n        out(sumv+a[0]);\n    }\n}","\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\npublic class MinimumExtraction {\n\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint n = in.nextInt();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint o = in.nextInt();\n\t\t\t\tint [] a = new int[o];\n\t\t\t\tfor (int j = 0; j < a.length; j++) {\n\t\t\t\t\ta[j] = in.nextInt();\n\t\t\t\t}\n\t\t\t\tint[] p = new int[o];\n\t\t\tfor (int j = 0; j < a.length; j++) {\n\t\t\t\tArrays.sort(a);\n\t\t\t\tint m = a[j];\n\t\t\t\tp[j]=m;\n\t\t\t\tfor (int k = (j+1); k < a.length; k++) {\n\t\t\t\t\ta[k] = a[k]-m;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(p);\n\t\t\tif(o==1) {\n\t\t\t\tSystem.out.println(a[0]);\n\t\t\t}else {\n\t\t\tSystem.out.println(p[o-1]);\n\t\t\t}\n\t\t\t}\n\t\t\tin.close();\n\t\t\n\t}\n\n}\n\n","import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\n\/*\n * mprodev for codeforces\n *  8\n    1\n    10\n    2\n    0 0\n    3\n    -1 2 0\n    4\n    2 10 1 7\n    2\n    2 3\n    5\n    3 2 -4 -2 0\n    2\n    -1 1\n    1\n    -2\n *\/\n\npublic class C {\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        int T = fs.nextInt();\n        OUTER:\n        for (int tt = 0; tt < T; tt++) {\n            int n = fs.nextInt();\n            int[] arr = fs.readArray(n);\n            sort(arr);\n            int prev = arr[0];\n            int subtraction = arr[0];\n            for (int i = 1; i < n; i++) {\n                int curr = arr[i];\n                int possible = curr - subtraction;\n                if (prev > possible) {\n                    System.out.println(prev);\n                    continue OUTER;\n                }\n                prev = possible;\n                subtraction += possible;\n            }\n            System.out.println(prev);\n        }\n\n    }\n\n    static void sort(int[] a) {\n        ArrayList<Integer> l = new ArrayList<>();\n        for (int i : a) l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++) a[i] = l.get(i);\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n\n}","t = int(input())\n\nans = []\nfor _ in range(t):\n    n = int(input())\n    nums = [int(_) for _ in input().split()]\n    nums.sort()\n    x = 0\n    y = float('-inf')\n    pre = 0\n    for i, n in enumerate(nums):\n        if n < 0:\n            y = max(y, x + n)\n            x -= n\n        else:\n            if y == None:\n                y = n + x\n            else:\n                y = max(y, n - pre)\n        pre = n\n    ans.append(str(y))\n\nprint('\\n'.join(ans))","from sys import stdin,stdout\ninput = stdin.readline\nfor _ in range(int(input())):\n    n=int(input())\n    li=list(map(int,input().split()))\n    if n==1:\n        print(li[0])\n        continue\n    neg=0\n    li.sort()\n    for ele in li:\n        if ele>0:\n            break\n        elif ele<0:\n            neg+=1\n    if li[0]>=0:\n        print(li[0])\n    else:\n        ans=li[0]\n        for i in range(1,n):\n            ans=max(ans,li[i]-li[i-1])\n        print(ans)","import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\/**\n *\n * @author eslam\n *\/\npublic class MinimumExtraction {\n\n    static class FastReader {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(\n                    new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        FastReader input = new FastReader();\n        BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));\n        int t =  input.nextInt();\n        loop:for (int i = 0; i < t; i++) {\n            int n = input.nextInt();\n            Long a[] = new Long[n];\n            for (int j = 0; j < n; j++) {\n                a[j] = input.nextLong();\n            }\n            if(n==1){\n                log.write(a[0]+\"\\n\");\n            }else{\n                Arrays.parallelSort(a);\n                long sum = a[0];\n                for (int j = 0; j < n-1; j++) {\n                    long d = a[j+1]-sum;\n                    if(d<=a[j]&&j+1==n-1){\n                        log.write(a[j]+\"\\n\");\n                        continue loop;\n                    }else{\n                        a[j+1]-=(sum);\n                        sum+=a[j+1];\n                    }\n                }\n                log.write(a[n-1]+\"\\n\");\n            }\n        }\n        log.flush();\n    }\n    \n}\n","for t in range(int(input())):\n    n= int(input())\n    lis = list(map(int, input().split()))\n    if len(lis)==1:\n        print(lis[0])\n    else:\n        lis.sort()\n        maximum=lis[-1]\n        count=0\n        index=-1\n        for i in range(n):\n            if lis[i]<0:\n                count+=1\n                index=i\n        if index == n-1:\n            print(count+lis[-1])\n        else:\n            lis = lis[index+1:]\n            for i in range(len(lis)):\n                lis[i] += count\n            #print(lis)\n            if len(lis)==1:\n                print(lis[0])\n            else:\n                count=0\n                res=lis[0]\n                for i in range(len(lis)):\n                    val=lis[i]-count\n                    #print(val,i)\n                    if val>res:\n                        res=val\n                    count+=val\n                print(res)","import heapq\nfor step in range(int(input())):\n  n = int(input())\n  heap = list(map(int,input().split()))\n  heapq.heapify(heap)\n  ans = -10^9-1\n  res = 0\n  for i in range(n):\n    m = heapq.heappop(heap)\n    ans = max(m-res,ans)\n    res = m\n  print(ans)","t=int(input())\nfor _ in range(t):\n    n=int(input())\n    l=list(map(int,input().split()))\n    l.sort()\n    ans=[]\n    if(n==1):\n        print(l[0])\n    else:\n        for i in range(n-1):\n            ans.append(l[i+1]-l[i])\n        print(max(ans))","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 9;\nconst long long M = 5e5 + 9;\nconst long long mod = 1e9 + 7;\nlong long Max(long long a, long long b) { return a > b ? a : b; }\nlong long Min(long long a, long long b) { return a > b ? b : a; }\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long lcm(long long a, long long b) { return a * (b \/ gcd(a, b)); }\nlong long Abs(long long x) { return x < 0 ? -x : x; }\nvoid updata(long long &a, long long b) {\n  if (b > a) a = b;\n}\nvoid lowdata(double &a, double b) {\n  if (b < a) a = b;\n}\nvoid swapp(long long &a, long long &b) {\n  long long t = a;\n  a = b;\n  b = t;\n}\nlong long roundd(double number) {\n  return (number > 0.0) ? (number + 0.5) : (number - 0.5);\n}\nlong long multi(long long a, long long b, long long modd) {\n  long long res = 0;\n  while (b) {\n    if (b & 1) res = (res + a) % modd;\n    a = (a + a) % modd;\n    b \/= 2;\n  }\n  return res;\n}\nlong long fastPower(long long base, long long power) {\n  long long result = 1;\n  while (power > 0) {\n    if (power & 1) {\n      result = result * base;\n    }\n    power >>= 1;\n    base = (base * base);\n  }\n  return result;\n}\nstring s, s1;\nint main() {\n  long long x, n;\n  cin >> x >> n;\n  cout << \"\ufffd\ufffd\u38fa\" << x << \"   \ufffd\ufffd\" << n << \"\ufffd\ufffd\\n\";\n  for (int i = 1; i <= n; i++) {\n    if (x & 1)\n      x += i;\n    else\n      x -= i;\n    if ((i & 1)) cout << \"\ufffd\ufffd\" << i << \"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\" << x << \"\\n\";\n  }\n  return 0;\n}\n","'''Author- Akshit Monga'''\nfrom sys import stdin, stdout\ninput = stdin.readline\n\ndef ceil(a,b):\n    return (a+b-1)\/\/b\n\nt = int(input())\nfor _ in range(t):\n    n=int(input())\n    a=[int(x) for x in input().split()]\n    a=sorted(a)\n    ans=a[0]\n    delta=0\n    for i in range(n-1):\n        delta-=a[i]\n        ans=max(ans,a[i+1]+delta)\n    print(ans)","import sys\nimport time\nimport os\nfrom io import BytesIO, IOBase\nimport math\nfrom random import randint\n\nM=10**9+7\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \ndef inputf(): \n    return sys.stdin.readline().rstrip(\"\\r\\n\")   \n \ndef get_ints(): \n    return list(map(int, inputf().split()))\n \n \ndef get_string(): \n    return list(map(str, inputf().split()))\n\n\n\n\n\nglobal maximum\n \n \ndef _lis(arr, n):\n \n    global maximum\n \n    if n == 1:\n        return 1\n \n    maxEndingHere = 1\n    for i in range(1, n):\n        res = _lis(arr, i)\n        if arr[i-1] < arr[n-1] and res+1 > maxEndingHere:\n            maxEndingHere = res + 1\n \n    maximum = max(maximum, maxEndingHere)\n \n    return maxEndingHere\n \n \ndef LIS(arr):\n \n    global maximum\n \n    n = len(arr)\n \n    maximum = 1\n \n    _lis(arr, n)\n \n    return maximum\n \n\ndef binary_search(data, elem):\n    \n    low = 0\n    high = len(data) - 1\n    while low <= high:\n      \n        middle = (low + high)\/\/2\n        if data[middle] == elem:\n            return middle\n            \n        elif data[middle] > elem:\n\n            high = middle - 1\n        else:\n            low = middle + 1\n\n    return middle   \n\ndef upper_bound(my_list, key):\n    large = len(my_list) -1\n    small = 0\n\n    while (small <= large):\n        mid = (small + large) \/\/ 2\n        if my_list[mid] < key:\n            small = mid + 1\n        elif my_list[mid] > key:\n            large = mid - 1\n        else:\n            return mid\n    if my_list[mid]>key:\n        return mid\n    else:\n        return mid+1\n\n\ndef lower_bound(my_list, key):\n    large = len(my_list) -1\n    small = 0\n\n    while (small <= large):\n        mid = (small + large) \/\/ 2\n        if my_list[mid] < key:\n            small = mid + 1\n        elif my_list[mid] > key:\n            large = mid - 1\n        else:\n            return mid\n    if my_list[mid]<key:\n        return mid\n    else:\n        return mid-1\n\n\na=[]\ndef SieveOfEratosthenes(n):\n    \n\tprime = [True for i in range(n+1)]\n\tp = 2\n\twhile (p * p <= n):\n\n\t\tif (prime[p] == True):\n\n\t\t\tfor i in range(p * p, n+1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\n\tfor p in range(2, n+1):\n\t\tif prime[p]:\n\t\t\ta.append(p)\n\ndef roman_number(x):\n    if x > 15999:\n        return\n    value = [5000, 4000, 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbol = [\"F\", \"MF\", \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman = \"\"\n    i = 0\n    while x > 0:\n        div = x \/\/ value[i]\n        x = x % value[i]\n        while div:\n            roman += symbol[i]\n            div -= 1\n        i += 1\n    return roman\n\ndef maxSubArraySum(a,size):\n     \n    max_so_far = a[0]   \n    max_ending_here = 0\n     \n    for i in range(0, size):\n        max_ending_here = max_ending_here + a[i]\n        if max_ending_here < 0:\n            max_ending_here = 0\n         \n        elif (max_so_far < max_ending_here):   \n            max_so_far = max_ending_here\n             \n    return max_so_far\n\n    \ndef prefixSum(test_list):\n    res = [sum(test_list[ : i + 1]) for i in range(len(test_list))]\n    return res\n\n# Python Program to find the L.C.M. of two input number\n\ndef lcm(x, y):\n\n   # choose the greater number\n   if x > y:\n       greater = x\n   else:\n       greater = y\n\n   while(True):\n       if((greater % x == 0) and (greater % y == 0)):\n           lcm = greater\n           break\n       greater += 1\n\n   return lcm\n\"\"\"\ndef find_shortest_path(graph, start, end, path):\n    path = path + [start]\n    if start == end:\n        return path\n    if start not in graph:\n        return None\n    shortest = None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_shortest_path(graph, node, end, path)\n            if newpath:\n                if not shortest or len(newpath) < len(shortest):\n                    shortest = newpath\n    return shortest\n\"\"\" \n\n\"\"\"\ndef dfs(root,nodeVal,nodeConnection,visited):\n    leftVal = nodeVal[root][0]\n    rightVal = nodeVal[root][1]\n    solution = []\n    if nodeConnection[root]:\n        visited.add(root)\n        for i in nodeConnection[root]:\n            if i not in visited:\n                solution.append(dfs(i,nodeVal,nodeConnection,visited))\n        leftMax = 0\n        rightMax = 0\n        for i in solution:\n            l, r = i\n            leftMax += max(abs(leftVal - l[0]) + l[1], abs(leftVal - r[0]) + r[1])\n            rightMax += max(abs(rightVal - l[0]) + l[1], abs(rightVal - r[0]) + r[1])\n        return ((leftVal, leftMax), (rightVal, rightMax))\n    else:\n        return ((leftVal, 0), (rightVal, 0))\n \n\"\"\"\n \n\"\"\"\ndef BFS(adj,src,dist,paths,n):\n    visited=[False]*n\n    dist[src]=0\n    paths[0]=1\n    q=[src]\n    visited[src]=True\n    while(q):\n        p=q.pop(0)\n        for j in adj[p]:\n            if not visited[j]:\n                q.append(j)\n                visited[j]=True\n            if dist[j]>dist[p]+1:\n                dist[j] = dist[p]+1\n                paths[j] = paths[p]\n            elif dist[j]==dist[p]+1:\n                paths[j] +=paths[p]\n    return paths\n \n\"\"\"\n\n\ntestcase=int(inputf())\n\nfor test in range(testcase):\n    n=int(inputf())\n    a=get_ints()\n    if n==1:\n        res=a[0]\n    else:\n        stop=False\n        while stop==False:\n            if len(a)==1:\n                stop=True\n                res=a[0]\n            else:\n                nhonhat=min(a)\n                a.remove(nhonhat)\n                n-=1\n                nhonhi=min(a)\n\n                if nhonhi-nhonhat>=nhonhat:\n                    for k in range  (0,n):\n                        a[k]-=nhonhat\n                else:\n                    res=nhonhat\n                    stop=True\n    print(res)\n\n","t=int(input())\nfor i in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    a.sort()\n    k=1\n    b=[0]*n\n    for j in range(1,n):\n        b[j]=-a[j-1]\n    for j in range(1,n):\n        b[j]+=b[j-1]\n        a[j]-=b[j]\n    print(max(a))","import sys, collections, math, bisect, heapq, random, functools\n\ninput = sys.stdin.readline\nout = sys.stdout.flush\n\n\ndef solve():\n    n = int(input())\n    queue = []\n    a = list(map(int, input().split()))\n    va = collections.Counter(a)\n    for v in va:\n        heapq.heappush(queue,[v,va[v]])\n    diff = 0\n    k = len(queue)\n    while k > 1 and queue[0][0] - diff <= 0:\n        cur,cnt = heapq.heappop(queue)\n        cur -= diff\n        diff += cur\n        k -= 1\n\n    while k > 1 and queue[1][0] - queue[0][0] >= queue[0][0] - diff:\n        cur,cnt = heapq.heappop(queue)\n\n        cur -= diff\n        diff += cur\n        k -= 1\n\n    if queue[0][0] - diff < 0:\n        if queue[0][1] > 1:\n            print(0)\n        else:\n            print(queue[0][0])\n    else:\n        print(queue[0][0] - diff)\n\n\n\n\n\n\nif __name__ == '__main__':\n    for i in range(int(input())):\n        solve()","#include <bits\/stdc++.h>\nusing namespace std;\nlong long int combi(int n, int k) {\n  long long int ans = 1;\n  if (k > n) {\n    ans = 0;\n  } else {\n    k = k > n - k ? n - k : k;\n    long long int j = 1;\n    for (; j <= k; j++, n--) {\n      if (n % j == 0) {\n        ans *= n \/ j;\n      } else if (ans % j == 0) {\n        ans = ans \/ j * n;\n      } else {\n        ans = (ans * n) \/ j;\n      }\n    }\n  }\n  return ans;\n}\nunordered_map<int, int> hm;\nvoid countFreq(int b[], int n) {\n  for (int i = 0; i < n; i++) hm[b[i]]++;\n  int max_count = 0, res = -1;\n  for (auto i : hm) {\n    if (max_count < i.second) {\n      res = i.first;\n      max_count = i.second;\n    }\n  }\n}\nint query(int x) { return hm[x]; }\nint previousFibonacci(int n) {\n  double a = n \/ ((1 + sqrt(5)) \/ 2.0);\n  return round(a);\n}\nint maxRepeating(string str) {\n  int n = str.length();\n  int count = 0;\n  char res = str[0];\n  int cur_count = 1;\n  for (int i = 0; i < n; i++) {\n    if (i < n - 1 && str[i] == str[i + 1]) {\n      cur_count++;\n    } else {\n      if (cur_count > count) {\n        count = cur_count;\n        res = str[i];\n      }\n      cur_count = 1;\n    }\n  }\n  return count;\n}\nbool sortbysec(const pair<int, int> &a, const pair<int, int> &b) {\n  return (a.second < b.second);\n}\nint findIndex(int n) {\n  float fibo = 2.078087 * log(n) + 1.672276;\n  return round(fibo);\n}\nstring fib(int n) {\n  int a = 0, b = 1, c, i;\n  string s0 = \"0\", s1 = \"1\", s;\n  for (i = 2; i <= n; i++) {\n    c = a + b;\n    a = b;\n    b = c;\n    s = s1 + s0;\n    s0 = s1;\n    s1 = s;\n  }\n  return s1;\n}\nint findSubSequence(string s, int num) {\n  int res = 0;\n  int i = 0;\n  while (num) {\n    if (num & 1) res += s[i] - '0';\n    i++;\n    num = num >> 1;\n  }\n  return res;\n}\nint combinedSum(string s) {\n  int n = s.length();\n  int c_sum = 0;\n  int range = (1 << n) - 1;\n  for (int i = 0; i <= range; i++)\n    c_sum += (findSubSequence(s, i) % 1000000007);\n  return c_sum;\n}\nint maxFreq(int *arr, int n) {\n  int res = 0;\n  int count = 1;\n  for (int i = 1; i < n; i++) {\n    if (arr[i] == arr[res]) {\n      count++;\n    } else {\n      count--;\n    }\n    if (count == 0) {\n      res = i;\n      count = 1;\n    }\n  }\n  return arr[res];\n}\nint getIndex(vector<string> v, string K) {\n  auto it = find(v.begin(), v.end(), K);\n  int index;\n  if (it != v.end()) {\n    index = it - v.begin();\n  } else {\n    index = -1;\n  }\n  return index;\n}\nint const N = 10000000;\nint is_prime[N];\nbool sieve() {\n  int i = 2;\n  while (i * i <= N) {\n    if (is_prime[i] == 0) {\n      i++;\n      continue;\n    }\n    int j = 2 * i;\n    while (j < N) {\n      is_prime[j] = 0;\n      j += i;\n    }\n    i++;\n  }\n}\nint mod(string num, int a) {\n  int res = 0;\n  for (int i = 0; i < num.length(); i++)\n    res = (res * 10 + (int)num[i] - '0') % a;\n  return res;\n}\nstring decimalToBinary(long long int n) {\n  string s = bitset<64>(n).to_string();\n  const auto loc1 = s.find('1');\n  if (loc1 != string::npos) return s.substr(loc1);\n  return \"0\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int a[n], b[n - 1];\n    for (int i = 0; i < n; i++) cin >> a[i];\n    if (n == 1)\n      cout << a[0] << endl;\n    else {\n      sort(a, a + n);\n      for (int i = 0; i < n - 1; i++) b[i] = a[i + 1] - a[i];\n      sort(b, b + n - 1);\n      cout << b[n - 2] << endl;\n    }\n  }\n}\n","t = int(input())\nres = []\nfor j in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  minA = [0] * n\n  newA = a.copy()\n  x = 0\n  minA[n - 1] = min(a)\n  x = minA[n - 1]\n  del newA[newA.index(x)]\n  newA = list(map(lambda y: y - x, newA))\n  for i in range(n - 1):\n    if len(newA) == 1:\n      break\n    val = max(minA[n - 2 - i + 1], min(newA))\n    if minA[n - 2 - i + 1] <= val:\n      minA[n - 2 - i] = val\n      x = minA[n - 2 - i]\n      if x in newA:\n        del newA[newA.index(x)]\n      newA = list(map(lambda y: y - x, newA))\n    else:\n      break\n  res.append(x)\n\nfor index in range(t):\n  print(res[index])","#include <bits\/stdc++.h>\n#include <ext\/pb_ds\/assoc_container.hpp>\n#define ll long long\n#define endl '\\n'\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<typename T>\nusing ordered_set =\ntree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\nconst int mod=1e9+7;\n\n\nint main() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin>>t;\n    while(t--){\n        int n;\n        cin>>n;\n        multiset<int>se;\n        for(int i=0;i<n;i++){\n            int x;\n            cin>>x;\n            se.insert(x);\n        }\n        if(n==1){\n            cout<<*se.begin()<<endl;\n            continue;\n        }\n        ll sum=0;\n        ll mi =-2e18;\n        while(!se.empty() && (1LL**se.begin()-sum)>=mi){\n            mi=1LL**se.begin()-sum;\n            \/\/sum+=(1LL**se.begin()-sum);\n            sum+=mi;\n            se.erase(se.find(*se.begin()));\n            \/\/cout<<mi<<' '<<sum<<endl;\n        }\n        cout<<mi<<endl;\n    }\n}\n","import sys, collections, math, bisect, heapq, random, functools\n\ninput = sys.stdin.readline\nout = sys.stdout.flush\n\n\ndef solve():\n    n = int(input())\n    queue = []\n    a = list(map(int, input().split()))\n    a = list(set(a))\n    for i in range(len(a)):\n        heapq.heappush(queue, a[i])\n    diff = 0\n    k = len(queue)\n    while k > 1 and queue[0] - diff <= 0:\n        cur = heapq.heappop(queue) - diff\n        diff += cur\n        k -= 1\n\n    ans = -float('inf')\n    while k > 1:\n        minv = heapq.heappop(queue)\n        two = queue[0]\n        if two - diff - (minv - diff) >= minv - diff:\n           cur = minv - diff\n           diff += cur\n           k -= 1\n        else:\n            ans = minv - diff\n            break\n\n    if ans == -float('inf'):\n        print(queue[0] - diff)\n    else:\n        print(ans)\n\n\n\nif __name__ == '__main__':\n    for i in range(int(input())):\n        solve()","import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    static long startTime = System.currentTimeMillis();\n\n    \/\/ for global initializations and methods starts here\n    static int hash;\n\n    \/\/ global initialisations and methods end here\n\n    static void run() {\n        boolean tc = true;\n        AdityaFastIO r = new AdityaFastIO();\n        \/\/FastReader r = new FastReader();\n\n        try (OutputStream out = new BufferedOutputStream(System.out)) {\n\n            \/\/long startTime = System.currentTimeMillis();\n\n            int testcases = tc ? r.ni() : 1;\n            int tcCounter = 1;\n            \/\/ Hold Here Sparky------------------->>>\n            \/\/ Solution Starts Here\n\n            start:\n            while (testcases-- > 0) {\n\n                int n = r.ni();\n                List<Long> al = new ArrayList<>();\n                for (int i = 0; i < n; i++) al.add(r.nl());\n\n                PriorityQueue<Long> pq = new PriorityQueue<>();\n                for (long ele : al) pq.add(ele - hash);\n\n                Collections.sort(al);\n\n                long ans = al.get(0);\n                for (int i = 0; i < n; i++) {\n                    long get = pq.poll() + hash;\n                    ans = Math.max(ans, get);\n                    hash -= get;\n                }\n\n                out.write((ans + \" \").getBytes());\n                out.write((\"\\n\").getBytes());\n\n            }\n            \/\/ Solution Ends Here\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class AdityaFastIO {\n        final private int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n        public BufferedReader br;\n        public StringTokenizer st;\n\n        public AdityaFastIO() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public AdityaFastIO(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String word() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String line() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[100000001]; \/\/ line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int ni() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public long nl() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public double nd() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') \/ (div *= 10);\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null) return;\n            din.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        run();\n    }\n\n    static long mod = 998244353;\n\n    static long modInv(long base, long e) {\n        long result = 1;\n        base %= mod;\n        while (e > 0) {\n            if ((e & 1) > 0) result = result * base % mod;\n            base = base * base % mod;\n            e >>= 1;\n        }\n        return result;\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String word() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String line() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int ni() {\n            return Integer.parseInt(word());\n        }\n\n        long nl() {\n            return Long.parseLong(word());\n        }\n\n        double nd() {\n            return Double.parseDouble(word());\n        }\n    }\n\n    static int MOD = (int) (1e9 + 7);\n\n    static long powerLL(long x, long n) {\n        long result = 1;\n        while (n > 0) {\n            if (n % 2 == 1) result = result * x % MOD;\n            n = n \/ 2;\n            x = x * x % MOD;\n        }\n        return result;\n    }\n\n    static long powerStrings(int i1, int i2) {\n        String sa = String.valueOf(i1);\n        String sb = String.valueOf(i2);\n        long a = 0, b = 0;\n        for (int i = 0; i < sa.length(); i++) a = (a * 10 + (sa.charAt(i) - '0')) % MOD;\n        for (int i = 0; i < sb.length(); i++) b = (b * 10 + (sb.charAt(i) - '0')) % (MOD - 1);\n        return powerLL(a, b);\n    }\n\n    static long gcd(long a, long b) {\n        if (a == 0) return b;\n        else return gcd(b % a, a);\n    }\n\n    static long lcm(long a, long b) {\n        return (a * b) \/ gcd(a, b);\n    }\n\n    static long lower_bound(int[] arr, int x) {\n        int l = -1, r = arr.length;\n        while (l + 1 < r) {\n            int m = (l + r) >>> 1;\n            if (arr[m] >= x) r = m;\n            else l = m;\n        }\n        return r;\n    }\n\n    static int upper_bound(int[] arr, int x) {\n        int l = -1, r = arr.length;\n        while (l + 1 < r) {\n            int m = (l + r) >>> 1;\n            if (arr[m] <= x) l = m;\n            else r = m;\n        }\n        return l + 1;\n    }\n\n    static void addEdge(ArrayList<ArrayList<Integer>> graph, int edge1, int edge2) {\n        graph.get(edge1).add(edge2);\n        graph.get(edge2).add(edge1);\n    }\n\n    public static class Pair implements Comparable<Pair> {\n        int first;\n        int second;\n\n        public Pair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(Pair o) {\n            \/\/ TODO Auto-generated method stub\n            if (this.first != o.first)\n                return (int) (this.first - o.first);\n            else return (int) (this.second - o.second);\n        }\n    }\n\n    public static class PairC<X, Y> implements Comparable<PairC> {\n        X first;\n        Y second;\n\n        public PairC(X first, Y second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(PairC o) {\n            \/\/ TODO Auto-generated method stub\n            return o.compareTo((PairC) first);\n        }\n    }\n\n    static boolean isCollectionsSorted(List<Long> list) {\n        if (list.size() == 0 || list.size() == 1) return true;\n        for (int i = 1; i < list.size(); i++) if (list.get(i) <= list.get(i - 1)) return false;\n        return true;\n    }\n\n    static boolean isCollectionsSortedReverseOrder(List<Long> list) {\n        if (list.size() == 0 || list.size() == 1) return true;\n        for (int i = 1; i < list.size(); i++) if (list.get(i) >= list.get(i - 1)) return false;\n        return true;\n    }\n\n}","#include <bits\/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long log_a_to_base_b(long long a, long long b) { return log(a) \/ log(b); }\nbool isPrime(long long n) {\n  if (n == 1) {\n    return false;\n  }\n  long long i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      return false;\n    }\n    i += 1;\n  }\n  return true;\n}\nvector<long long> prime_fact(long long n) {\n  vector<long long> v;\n  for (long long i = 2; i * i <= n; i++)\n    if (n % i == 0) {\n      while (n % i == 0) n \/= i;\n      v.push_back(i);\n    }\n  if (n > 1) v.push_back(n);\n  return v;\n}\nlong long power(long long a, long long n) {\n  long long res = 1;\n  while (n) {\n    if (n % 2)\n      res *= a, n--;\n    else\n      a *= a, n \/= 2;\n  }\n  return res;\n}\nlong long euler_totient(long long n) {\n  long long res = n;\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      res \/= i;\n      res *= (i - 1);\n      while (n % i == 0) n \/= i;\n    }\n  }\n  if (n > 1) res \/= n, res *= (n - 1);\n  return res;\n}\nbool isKthBitSet(long long n, long long k) {\n  if (n & (1 << k))\n    return true;\n  else\n    return false;\n}\nlong long no_of_set_bits(long long n) {\n  long long cnt = 0;\n  while (n > 0) {\n    cnt++;\n    n = n & (n - 1);\n  }\n  return cnt;\n}\nvoid init() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nsigned main() {\n  init();\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> v(n);\n    for (auto &i : v) cin >> i;\n    sort(v.begin(), v.end());\n    if (n == 1) {\n      cout << v[0] << \"\\n\";\n      continue;\n    }\n    if (n == 2) {\n      cout << max(v[0], (v[1] - v[0])) << \"\\n\";\n      continue;\n    }\n    long long ans = 0ll;\n    long long i = 0ll;\n    for (; i < n - 1ll; i++) ans = max(ans, (long long)(v[i + 1] - v[i]));\n    cout << (long long)ans << \"\\n\";\n  }\n  return 0;\n}\n","import java.io.*;\nimport java.util.*;\n\npublic class Solution{\n  public static void main(String[] args){\n   FastReader fs = new FastReader();\n   PrintWriter out = new PrintWriter(System.out);\t\n   \n   int t = fs.nextInt();\n   while(t > 0){\n   int n = fs.nextInt();\n   int[] a = new int[n];\n   for(int i = 0; i < a.length; i++){\n      a[i] = fs.nextInt();\n   }\n\n   Arrays.sort(a);\n   int i = 0;\n   int j = 1;\n   int om = Integer.MIN_VALUE;\n   if(n == 1){\n      om = a[0];\n   }\n   else {\n   while(i < a.length - 1){\n       while(j < a.length){\n         a[j] = Math.abs(a[j] - a[i]);\n         j++;\n       }    \n       i++;\n       j = i+1; \n   }\n    int min = a[i-1];\n    if(min < a[j-1]){\n       om = a[j-1];\n    }else{\n      om = min;\n     }\n  }\n   out.println(om);\n   t--;\n   }\n   out.flush();\n}\n\n  \n\n  static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(\n                new InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() { return Integer.parseInt(next()); }\n \n        long nextLong() { return Long.parseLong(next()); }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n   }\n}\n","import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n    \/\/ Graph\n    \/\/ prefix sums\n    \/\/inputs\n    public static void main(String args[])throws Exception{\n        Input sc=new Input();\n        precalculates p=new precalculates();\n        StringBuilder sb=new StringBuilder();\n        int t=sc.readInt();\n        for(int f=0;f<t;f++){\n            int n=sc.readInt();\n            long a[]=sc.readArrayLong();\n            HashSet<Long> map=new HashSet<>();\n            for(int i=0;i<n;i++){\n                map.add(a[i]);\n            }\n            n=map.size();\n            a=new long[n];\n            int j=0;\n            for(Long val:map){\n                a[j++]=val;\n            }\n            Arrays.sort(a);\n            long sum=0;\n            long prev=0;long ans=Long.MIN_VALUE;\n            for(int i=0;i<n-1;i++){\n                sum=sum+((a[i])-prev);\n                ans=Math.max(ans,a[i]-prev);\n                prev=sum;\n            }\n\n            if(ans!=Long.MIN_VALUE)\n            sb.append(Math.max(ans,a[n-1]-prev)+\"\\n\");\n            else\n                sb.append(a[n-1]+\"\\n\");\n\n        }\n        \/\/ 1 2 7 10   1\n        \/\/ 0 1 6 9    2\n        \/\/ 0 0 5 8\n        \/\/ -1 0 2\n        \/\/ 0  1 3\n        \/\/ 0 0 2\n        System.out.print(sb);\n    }\n}\nclass Input{\n    BufferedReader br;\n    StringTokenizer st;\n    Input(){\n        br=new BufferedReader(new InputStreamReader(System.in));\n        st=new StringTokenizer(\"\");\n    }\n    public int[] readArray() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        int a[]=new int[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Integer.parseInt(st.nextToken());\n        }\n        return a;\n    }\n    public long[] readArrayLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        long a[]=new long[st.countTokens()];\n        for(int i=0;i<a.length;i++){\n            a[i]=Long.parseLong(st.nextToken());\n        }\n        return a;\n    }\n    public int readInt() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Integer.parseInt(st.nextToken());\n    }\n    public long readLong() throws Exception{\n        st=new StringTokenizer(br.readLine());\n        return Long.parseLong(st.nextToken());\n    }\n    public String readString() throws Exception{\n        return br.readLine();\n    }\n    public int[][] read2dArray(int n,int m)throws Exception{\n        int a[][]=new int[n][m];\n        for(int i=0;i<n;i++){\n            st=new StringTokenizer(br.readLine());\n            for(int j=0;j<m;j++){\n                a[i][j]=Integer.parseInt(st.nextToken());\n            }\n        }\n        return a;\n    }\n}\nclass precalculates{\n    public int[] prefixSumOneDimentional(int a[]){\n        int n=a.length;\n        int dp[]=new int[n];\n        for(int i=0;i<n;i++){\n            if(i==0)\n                dp[i]=a[i];\n            else\n                dp[i]=dp[i-1]+a[i];\n        }\n        return dp;\n    }\n    public int[] postSumOneDimentional(int a[]) {\n        int n = a.length;\n        int dp[] = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            if (i == n - 1)\n                dp[i] = a[i];\n            else\n                dp[i] = dp[i + 1] + a[i];\n        }\n        return dp;\n    }\n    public int[][] prefixSum2d(int a[][]){\n        int n=a.length;int m=a[0].length;\n        int dp[][]=new int[n+1][m+1];\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=m;j++){\n                dp[i][j]=a[i-1][j-1]+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];\n            }\n        }\n        return dp;\n    }\n    public long pow(long a,long b){\n        long mod=1000000007;\n        long ans=0;\n        if(b<=0)\n            return 1;\n        if(b%2==0){\n            ans=pow(a,b\/2)%mod;\n            return ((ans%mod)*(ans%mod))%mod;\n        }else{\n            return ((a%mod)*(ans%mod))%mod;\n        }\n    }\n\n}\nclass GraphInteger{\n    HashMap<Integer,vertex> vtces;\n    class vertex{\n        HashMap<Integer,Integer> children;\n        public vertex(){\n            children=new HashMap<>();\n        }\n    }\n    public GraphInteger(){\n        vtces=new HashMap<>();\n    }\n    public void addVertex(int a){\n        vtces.put(a,new vertex());\n    }\n    public void addEdge(int a,int b,int cost){\n        if(!vtces.containsKey(a)){\n            vtces.put(a,new vertex());\n        }\n        if(!vtces.containsKey(b)){\n            vtces.put(b,new vertex());\n        }\n        vtces.get(a).children.put(b,cost);\n\/\/        vtces.get(b).children.put(a,cost);\n    }\n    public boolean isCyclicDirected(){\n        boolean isdone[]=new boolean[vtces.size()+1];\n        boolean check[]=new boolean[vtces.size()+1];\n        for(int i=1;i<=vtces.size();i++) {\n            if (!isdone[i] && isCyclicDirected(i,isdone, check)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private boolean isCyclicDirected(int i,boolean isdone[],boolean check[]){\n        if(check[i])\n            return true;\n        if(isdone[i])\n            return false;\n        check[i]=true;\n        isdone[i]=true;\n        Set<Integer> set=vtces.get(i).children.keySet();\n        for(Integer ii:set){\n            if(isCyclicDirected(ii,isdone,check))\n                return true;\n        }\n        check[i]=false;\n        return false;\n    }\n}\n\n\n\n\n","def vigoda(mas):\n    for i in mas:\n        if i <= 0:\n            return True \n    return False\ndef step(mas):\n    m = min(mas)\n    mas.pop(mas.index(m))\n    for i in range(0, len(mas)):\n        mas[i] -= m\n    return mas\n\nt = int(input())\nwhile t:\n    n = int(input())\n    s = input()\n    s = s.split(' ')\n    for i in range(0, n):\n        s[i] = int(s[i])\n    s.sort()\n    maxraz = 0\n    if len(s) > 1:\n        for i in range(1, len(s)):\n            if s[i] - s[i - 1] > maxraz:\n                maxraz = s[i] - s[i - 1] \n        print(maxraz)\n    else:\n        print(s[0])\n\n    t -= 1\n\n","import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic long[]fac=new long[200100];\n\tstatic long[] two= new long[200100] ;\n\tstatic long mod=((long)1e18)+7;\n\tstatic String[]pow=new String[63];\n\tstatic int n;\n\tstatic int x=0;\n\tstatic int[][]perm,b;\n\tstatic int[]pe,aa,a;\n\tpublic static void main(String[] args) throws IOException, InterruptedException{\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tint n=sc.nextInt();\n\t\t\tLong[]a=new Long[n];\n\t\t\tlong min=Long.MAX_VALUE;\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextLong();\n\t\t\t\tmin=Math.min(min, a[i]);\n\t\t\t}\n\t\t\tif(n==1) {\n\t\t\t\tpw.println(min);\n\t\t\t}else if(n==2){\n\t\t\t\tpw.println(Math.max(Math.min(a[0], a[1]), Math.abs(a[0]-a[1])));\n\t\t\t}else {\n\t\t\t\tif(min<0) {\n\t\t\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\t\t\ta[i]-=min;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tArrays.sort(a);\n\t\t\t\tlong o=min<0?a[1]:a[0];\n\t\t\t\tlong sub=0;\n\t\t\t\tfor (int i = min<0?2:1; i < a.length; i++) {\n\t\t\t\t\tif(a[i]-sub>=2*(a[i-1]-sub)) {\n\t\t\t\t\t\to=a[i]-a[i-1];\n\t\t\t\t\t\tsub+=a[i-1]-sub;\n\t\t\t\t\t}else break;\n\t\t\t\t}\n\t\t\t\tpw.println(o);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tpw.close();\n\t}\t\n\t\n\tpublic static long[] Extended(long p, long q) {\n\t      if (q == 0)\n\t         return new long[] { p, 1, 0 };\n\n\t      long[] vals = Extended(q, p % q);\n\t      long d = vals[0];\n\t      long a = vals[2];\n\t      long b = vals[1] - (p \/ q) * vals[2];\n\t      return new long[] { d, a, b };\n\t   }\n\t\n\tstatic class STree{\n\t\tint N;\n\t\tlong[]arr;\n\t\tlong[]tree;\n\t\tint[]lazy;\n\t\tlong id;\n\t\tpublic static long operation(long x,long y) {\n\t\t\treturn x^y;\n\t\t}\n\t\t\n\t\tpublic STree(int[]a,long id) {\n\t\t\tthis.id=id;\n\t\t\tN=1;\n\t\t\tint n=a.length;\n\t\t\twhile(N<n) {\n\t\t\t\tN*=2;\n\t\t\t}\n\t\t\tarr=new long[N+1];\n\t\t\tArrays.fill(arr, id);\n\t\t\tfor (int i = 1; i <= a.length; i++) {\n\t\t\t\tarr[i]=a[i-1];\n\t\t\t}\n\t\t\ttree=new long[2*N];\n\t\t\tArrays.fill(tree, id);\n\t\t\tbuild(1,N,1);\n\t\t\tlazy=new int[2*N];\n\t\t}\n\t\t\n\t\tpublic void build(int l,int r,int node) {\n\t\t\tif(l==r) {\n\t\t\t\ttree[node]=arr[l];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mid=(l+r)\/2;\n\t\t\tbuild(l,mid,node*2);\n\t\t\tbuild(mid+1,r,node*2+1);\n\t\t\ttree[node]=operation(tree[node*2],tree[node*2+1]);\n\t\t}\n\t\t\n\/\/\t\tpublic void update(int node,int value) {\n\/\/\t\t\tint i=node+N-1;\n\/\/\t\t\ttree[i]=value;\n\/\/\t\t\ti\/=2;\n\/\/\t\t\twhile(i>0) {\n\/\/\t\t\t\ttree[i]=operation(tree[i*2], tree[i*2+1]);\n\/\/\t\t\t\ti\/=2;\n\/\/\t\t\t}\n\/\/\t\t}\n\/\/\t\t\n\/\/\t\tpublic void updateRange(int l,int r,int v) {\n\/\/\t\t\tupdateRange(1, N, l, r, 1,v);\n\/\/\t\t}\n\/\/\t\t\n\/\/\t\tpublic void updateRange(int s,int e,int l,int r,int node,int v) {\n\/\/\t\t\tif(s>=l&&e<=r) {\n\/\/\t\t\t\tlazy[node]^=v;\n\/\/\t\t\t\ttree[node]=propagate(tree[node],lazy[node],e-s+1);\n\/\/\/\/\t\t\t\tlazy[node]=0;\n\/\/\t\t\t\treturn;\n\/\/\t\t\t}\n\/\/\t\t\tif(s>r||e<l)return;\n\/\/\t\t\tint mid=(s+e)\/2;\n\/\/\t\t\tlazy[node*2] ^= lazy[node];\n\/\/\t\t\tlazy[node*2+1] ^= lazy[node];\n\/\/\t\t\ttree[node*2] = propagate(tree[node*2], v, (e-s+1)\/2);\n\/\/\t\t\ttree[node*2+1] =  propagate(tree[node*2+1], v, (e-s+1)\/2);\n\/\/\t\t\tlazy[node] = 0;\n\/\/\t\t\tupdateRange(s, mid, l, r, node*2, v);\n\/\/\t\t\tupdateRange(mid+1, e, l, r, node*2+1, v);\n\/\/\t\t\ttree[node]=operation(tree[node*2], tree[node*2+1]);\n\/\/\t\t\treturn;\n\/\/\t\t}\n\/\/\t\t\n\t\tpublic long q(int l,int r) {\n\t\t\treturn q(1,N,l,r,1);\n\t\t}\n\t\t\n\t\tpublic long q(int s,int e,int l,int r,int node) {\n\t\t\tif(s>=l&&r>=e) {\n\t\t\t\treturn tree[node];\n\t\t\t}\n\t\t\tif(s>r||e<l)\n\t\t\t\treturn id;\n\t\t\tint mid=(s+e)\/2;\n\t\t\t\n\t\t\treturn operation(q(s,mid,l,r,node*2), q(mid+1,e,l,r,node*2+1));\n\t\t}\n\/\/\t\tpublic static segment propagate(segment x,int v,int length) {\n\/\/\t\t\tint[]bit=x.bit.clone();\n\/\/\t\t\tlong sum=x.sum;\n\/\/\t\t\tfor (int i = 0; i < bit.length; i++) {\n\/\/\t\t\t\tif((v&1<<i)!=0) {\n\/\/\t\t\t\t\tsum-=(1<<i)*(bit[i]);\n\/\/\t\t\t\t\tsum+=(1<<i)*(length-bit[i]);\n\/\/\t\t\t\t\tbit[i]=length-bit[i];\n\/\/\t\t\t\t}\n\/\/\t\t\t}\n\/\/\t\t\treturn new segment(sum, bit);\n\/\/\t\t}\n\t}\n\n\tpublic static class segment{\n\t\tlong sum;\n\t\tint[] bit;\n\t\t\n\t\tpublic segment (long sum,int[]bit) {\n\t\t\tthis.sum=sum;\n\t\t\tthis.bit=bit.clone();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn sum+\" \"+Arrays.toString(bit);\n\t\t}\n\t}\n\t\n\tpublic static int LIS(int[] a) {\n\n\t\tint n = a.length;\n\t\tint[] ser = new int[n];\n\t\tint[]ser1=new int[n];\n\t\tArrays.fill(ser1, Integer.MAX_VALUE);\n\t\tArrays.fill(ser, Integer.MAX_VALUE);\n\t\tint cur = -1;\n\t\tint[]inc=new int[n];\n\t\tint[]dec=new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint low = 0;\n\t\t\tint high = n - 1;\n\t\t\tint mid = (low + high) \/ 2;\n\t\t\twhile (low <= high) {\n\t\t\t\tif (ser[mid] < a[i]) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}\n\t\t\t\tmid = (low + high) \/ 2;\n\t\t\t}\n\t\t\tinc[i]=high+2;\n\t\t\tcur = Math.max(cur, high + 1);\n\t\t\tser[high + 1] = Math.min(ser[high + 1], a[i]);\n\t\t}\n\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\tint low = 0;\n\t\t\tint high = n - 1;\n\t\t\tint mid = (low + high) \/ 2;\n\t\t\twhile (low <= high) {\n\t\t\t\tif (ser1[mid] < a[i]) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}\n\t\t\t\tmid = (low + high) \/ 2;\n\t\t\t}\n\t\t\tdec[i]=high+2;\n\t\t\tcur = Math.max(cur, high + 1);\n\t\t\tser1[high + 1] = Math.min(ser1[high + 1], a[i]);\n\t\t}\n\t\tint ans=1;\n\t\tfor (int i = 0; i < dec.length; i++) {\n\t\t\tans=Math.max(ans, 2*Math.min(inc[i], dec[i])-1);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tpublic static void permutation(int idx,int v) {\n\t\tif(v==(1<<n)-1) {\n\t\t\tperm[x++]=pe.clone();\n\t\t\treturn ;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif((v&1<<i)==0) {\n\t\t\t\tpe[idx]=aa[i];\n\t\t\t\tpermutation(idx+1, v|1<<i);\n\t\t\t}\n\t\t}\n\t\treturn ;\n\t}\n\t\n\tpublic static void pre2() {\n\t\tfor (int i = 0; i < pow.length; i++) {\n\t\t\tlong x=1l<<i;\n\t\t\tpow[i]=x+\"\";\n\t\t}\n\t}\n\t\t\n\tpublic static void sort(int[]a) {\n\t\tmergesort(a, 0, a.length-1);\n\t}\n\t\n\tpublic static void sortIdx(long[]a,long[]idx) {\n\t\tmergesortidx(a, idx, 0, a.length-1);\n\t}\n\t\n\tpublic static long C(int a,int b) {\n\t\tlong x=fac[a];\n\t\tlong y=fac[a-b]*fac[b];\n\t\treturn x*pow(y,mod-2)%mod;\n\t}\n\t\n\tpublic static long pow(long a,long b) {\n\t\tlong ans=1;a%=mod;\n\t\tfor(long i=b;i>0;i\/=2) {\n\t\t\tif((i&1)!=0)\n\t\t\t\tans=ans*a%mod;\n\t\t\ta=a*a%mod;\n\t\t }    \n\t\t    \n\t\t return ans;\n\t}\n\t\n\tpublic static void pre(){\n\t\tfac[0]=1;\n\t\tfac[1]=1;\n\t\tfac[2]=1;\n\t\tfor (int i = 3; i < fac.length; i++) {\n\t\t\tfac[i]=((fac[i-1]*2*i)\/2)%mod;\n\t\t}\n\t}\n\t\n\tpublic static long eval(String s) {\n\t\tlong p=1;\n\t\tlong res=0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tres+=p*(s.charAt(s.length()-1-i)=='1'?1:0);\n\t\t\tp*=2;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static String binary(long x) {\n\t\tString s=\"\";\n\t\twhile(x!=0) {\n\t\t\ts=(x%2)+s;\n\t\t\tx\/=2;\n\t\t}\n\t\treturn s;\n\t}\n\t\n\tpublic static boolean allSame(String s) {\n\t\tchar x=s.charAt(0);\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif(s.charAt(i)!=x)return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isPalindrom(String s) {\n\t\tint l=0;\n\t\tint r=s.length()-1;\n\t\twhile(l<r) {\n\t\t\tif(s.charAt(r--)!=s.charAt(l++))return false;\n\t\t\t\n\t\t}\n\t\treturn true;\n\t}\n\t \n\t\n\tpublic static boolean isSubString(String s,String t) {\n\t\tint ls=s.length();\n\t\tint lt=t.length();\n\t\tboolean res=false;\n\t\tfor (int i = 0; i <=lt-ls; i++) {\n\t\t\tif(t.substring(i, i+ls).equals(s)) {\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static boolean isSorted(long[]a) {\n\t\tfor (int i = 0; i < a.length-1; i++) {\n\t\t\tif(a[i]>a[i+1])return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isPrime(long n)\n    {\n \n        \/\/ Check if number is less than\n        \/\/ equal to 1\n        if (n <= 1)\n            return false;\n \n        \/\/ Check if number is 2\n        else if (n == 2)\n            return true;\n \n        \/\/ Check if n is a multiple of 2\n        else if (n % 2 == 0)\n            return false;\n \n        \/\/ If not, then just check the odds\n        for (int i = 3; i <= Math.sqrt(n); i += 2)\n        {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\tpublic static int whichPower(int x) {\n\t\tint res=0;\n\t\tfor (int j = 0; j < 31; j++) {\n\t\t\tif((1<<j&x)!=0) {\n\t\t\t\tres=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n \n\tpublic static long evaln(String x,int n) {\n\t\tlong res=0;\n\t\tfor (int i = 0; i < x.length(); i++) {\n\t\t\tres+=Long.parseLong(x.charAt(x.length()-1-i)+\"\")*Math.pow(n, i);\n\t\t}\n\t\treturn res;\n\t}\n\tstatic void merge(int[] arr,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tint[] l=new int[len1];\n\t\tint[] r=new int[len2];\n\t\tfor(int i=0;i<len1;i++)l[i]=arr[b+i];\n\t\tfor(int i=0;i<len2;i++)r[i]=arr[m+1+i];\n\t\tint i=0,j=0,k=b;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<r[j])arr[k++]=l[i++];\n\t\t\telse arr[k++]=r[j++];\n\t\t}\n\t\twhile(i<len1)arr[k++]=l[i++];\n\t\twhile(j<len2)arr[k++]=r[j++];\n\t\treturn;\n\t}\n\tstatic void mergesortidx(long[] arr,long[]idx,int b,int e) {\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tmergesortidx(arr,idx,b,m);\n\t\t\tmergesortidx(arr,idx,m+1,e);\n\t\t\tmergeidx(arr,idx,b,m,e);\n\t\t}\n\t\treturn;\n\t\t\n\t}\n\tstatic void mergeidx(long[] arr,long[]idx,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tlong[] l=new long[len1];\n\t\tlong[] lidx=new long[len1];\n\t\tlong[] r=new long[len2];\n\t\tlong[] ridx=new long[len2];\n\t\tfor(int i=0;i<len1;i++) {\n\t\t\tl[i]=arr[b+i];\n\t\t\tlidx[i]=idx[b+i];\n\t\t}\n\t\tfor(int i=0;i<len2;i++) {\n\t\t\tr[i]=arr[m+1+i];\n\t\t\tridx[i]=idx[m+1+i];\n\t\t}\n\t\tint i=0,j=0,k=b;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<=r[j]) {\n\t\t\t\tarr[k++]=l[i++];\n\t\t\t\tidx[k-1]=lidx[i-1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarr[k++]=r[j++];\n\t\t\t\tidx[k-1]=ridx[j-1];\n\t\t\t}\n\t\t}\n\t\twhile(i<len1) {\n\t\t\tidx[k]=lidx[i];\n\t\t\tarr[k++]=l[i++];\n\t\t}\n\t\twhile(j<len2) {\n\t\t\tidx[k]=ridx[j];\n\t\t\tarr[k++]=r[j++];\n\t\t}\n\t\treturn;\n\t}\n\tstatic void mergesort(int[] arr,int b,int e) {\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tmergesort(arr,b,m);\n\t\t\tmergesort(arr,m+1,e);\n\t\t\tmerge(arr,b,m,e);\n\t\t}\n\t\treturn;\n\t\t\n\t}\n\t\n\tstatic long mergen(int[] arr,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tint[] l=new int[len1];\n\t\tint[] r=new int[len2];\n\t\tfor(int i=0;i<len1;i++)l[i]=arr[b+i];\n\t\tfor(int i=0;i<len2;i++)r[i]=arr[m+1+i];\n\t\tint i=0,j=0,k=b;\n\t\tlong c=0;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<r[j])arr[k++]=l[i++];\n\t\t\telse {\n\t\t\t\tarr[k++]=r[j++];\n\t\t\t\tc=c+(long)(len1-i);\n\t\t\t}\n\t\t}\n\t\twhile(i<len1)arr[k++]=l[i++];\n\t\twhile(j<len2)arr[k++]=r[j++];\n\t\treturn c;\n\t}\n\tstatic long mergesortn(int[] arr,int b,int e) {\n\t\tlong c=0;\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tc=c+(long)mergesortn(arr,b,m);\n\t\t\tc=c+(long)mergesortn(arr,m+1,e);\n\t\t\tc=c+(long)mergen(arr,b,m,e);\n\t\t}\n\t\treturn c;\n\t\t\n\t}\n\tpublic static long fac(int n) {\n\t\tif(n==0)return 1;\n\t\treturn n*fac(n-1);\n\t}\n\tpublic static long gcd(long a, long b)\n    {\n      if (b == 0)\n        return a;\n      return gcd(b, a % b);\n    }\n     \n\tpublic static long summ(long x) {\n\t\tlong sum=0;\n\t\twhile(x!=0) {\n\t\t\tsum+=x%10;\n\t\t\tx=x\/10;\n\t\t}\n\t\treturn sum;\n\t\t\t\t\n\t}\n\t\n\tpublic  static ArrayList<Integer> findDivisors(int n){\n\t        ArrayList<Integer>res=new ArrayList<Integer>();\n\t        for (int i=1; i<=Math.sqrt(n); i++)\n\t        {\n\t            if (n%i==0)\n\t            {\n\t                \/\/ If divisors are equal, print only one\n\t                if (n\/i == i)\n\t                \tres.add(i);\n\t                else {\n\t                \tres.add(i);\n\t                \tres.add(n\/i);\n\t                }\t\n\t            }\n\t        }\n\t        return res;\n\t    }\n\n\t\n\tpublic static void sort2darray(Integer[][]a){\n\t\tArrays.sort(a,Comparator.<Integer[]>comparingInt(x -> x[0]).thenComparingInt(x -> x[1]));\n \n\t}\n\t\n\t\n\t\n\t\t\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\t\tpublic Scanner(String file) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t\tpublic int[] nextArrint(int size) throws IOException {\n\t\t\tint[] a=new int[size];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic long[] nextArrlong(int size) throws IOException {\n\t\t\tlong[] a=new long[size];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextLong();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic int[][] next2dArrint(int rows,int columns) throws IOException{\n\t\t\tint[][]a=new int[rows][columns];\n\t\t\tfor (int i = 0; i < rows; i++) {\n\t\t\t\tfor (int j = 0; j < columns; j++) {\n\t\t\t\t\ta[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic long[][] next2dArrlong(int rows,int columns) throws IOException{\n\t\t\tlong[][]a=new long[rows][columns];\n\t\t\tfor (int i = 0; i < rows; i++) {\n\t\t\t\tfor (int j = 0; j < columns; j++) {\n\t\t\t\t\ta[i][j]=sc.nextLong();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}\n\t\n\tstatic class Side{\n\t\tPoint a;\n\t\tPoint b;\n\t\tpublic Side(Point a,Point b) {\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tSide s=(Side)obj;\n\t\t\treturn (s.a.equals(a)&&s.b.equals(b))||(s.b.equals(a)&&s.a.equals(b));\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\n\t\t\treturn \"(\"+a.toString()+\",\"+b.toString()+\")\";\n\t\t}\n\t}\n\tstatic class Point{\n\t\tint x;\n\t\tint y;\n\t\tint z;\n\t\tpublic Point(int x,int y,int z) {\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.z=z;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tPoint p=(Point)obj;\n\t\t\treturn x==p.x&&y==p.y&&z==p.z;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\"+x+\",\"+y+\",\"+z+\")\";\n\t\t}\n\t}\n\tstatic class Pair implements Comparable{\n\t\tlong x;\n\t\tlong y;\n\t\tpublic Pair(long x,long y) {\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tPair p=(Pair)obj;\n\t\t\treturn x==p.x&&y==p.y;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\/\/ TODO Auto-generated method stub\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Object o) {\n\t\t\tPair p=(Pair)o;\n\t\t\treturn x>p.x?1:x==p.x?0:-1;\n\t\t}\n\t}\n\tstatic class sPair{\n\t\tString s;\n\t\tPair p;\n\t\tpublic sPair(String s,Pair p) {\n\t\t\tthis.p=p;\n\t\t\tthis.s=s;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\/\/ TODO Auto-generated method stub\n\t\t\treturn s+\" \"+p;\n\t\t}\n\t}\n\tstatic Scanner sc=new Scanner(System.in);\n\tstatic PrintWriter pw=new PrintWriter(System.out);\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  int t;\n  for (cin >> t; t; t--) {\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a, a + n);\n    int len = n;\n    while (len > 1) {\n      if (a[n - len] > a[n - len + 1] - a[n - len] && a[n - len] > 0) break;\n      for (int i = n - len + 1; i < n; i++) a[i] -= a[n - len];\n      len--;\n    }\n    cout << a[n - len] << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\n#pragma GCC target( \\\n    \"sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\nconst long long inf = 1e18;\nconst double pi = 3.14159265358979323846264338327950288419716939937510;\nconst long long mod = 1e9 + 7;\nconst long long mod2 = 998244353;\nconst double eps = (0.00000000001);\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  a %= b;\n  return gcd(b, a);\n}\nlong long gcdExtended(long long, long long, long long*, long long*);\nlong long gcdExtended(long long a, long long b, long long* x, long long* y) {\n  if (a == 0) {\n    *x = 0, *y = 1;\n    return b;\n  }\n  long long x1, y1;\n  long long gcd = gcdExtended(b % a, a, &x1, &y1);\n  *x = y1 - (b \/ a) * x1;\n  *y = x1;\n  return gcd;\n}\nlong long powerForInverse(long long x, long long y, long long m) {\n  if (y == 0) return 1;\n  long long temp = powerForInverse(x, y \/ 2, m);\n  temp = (temp * temp) % m;\n  if (y & 1) temp = ((temp % m) * (x % m)) % m;\n  return temp;\n}\nlong long modInverse(long long a, long long m) {\n  return powerForInverse(a, m - 2, m);\n}\nlong long nCr(long long n, long long r) {\n  if (r > n) return 0;\n  if (r > n - r) r = n - r;\n  long long ans = 1;\n  for (long long i = 1; i < r + 1; i++) {\n    ans *= (n - i + 1);\n    ans *= modInverse(i, mod);\n  }\n  return ans;\n}\nlong long nCrM(long long n, long long r) {\n  if (r > n) return 0;\n  if (r > n - r) r = n - r;\n  long long ans = 1;\n  for (long long i = 1; i < r + 1; i++) {\n    ans *= (n - i + 1);\n    ans %= mod;\n    ans *= modInverse(i, mod);\n    ans %= mod;\n  }\n  return ans;\n}\nlong long lcm(long long a, long long b) { return (a \/ gcd(a, b)) * b; }\nlong long binpowM(long long a, long long b) {\n  if (b == 0) return 1;\n  if (b == 1) return a % mod;\n  long long res = binpowM(a, b \/ 2) % mod;\n  if (b % 2 == 1)\n    return (((res * res) % mod) * a) % mod;\n  else\n    return (res * res) % mod;\n}\nlong long binpow(long long a, long long b) {\n  if (b == 0) return 1;\n  if (b == 1) return a;\n  long long res = binpow(a, b \/ 2);\n  if (b % 2 == 1)\n    return (((res * res)) * a);\n  else\n    return (res * res);\n}\nvoid sieve(vector<long long>& primes, long long n, vector<long long>& touched) {\n  primes.clear();\n  long long arr[n + 1];\n  for (long long i = 0; i < n + 1; i++) arr[i] = i;\n  touched[0] = true;\n  touched[1] = true;\n  for (long long i = 2; i < (int)sqrt(n) + 1; i++) {\n    if (!touched[i]) {\n      touched[i] = true;\n      primes.push_back(i);\n      for (long long j = i * i; j < n + 1; j++) {\n        touched[j] = true;\n        j--;\n        j += i;\n      }\n    }\n  }\n  for (long long i = (int)sqrt(n) + 1; i < n; i++) {\n    if (!touched[i]) primes.push_back(i);\n  }\n}\nlong long binary_search(long long arr[], long long n, long long elem) {\n  long long l = 0, r = n - 1;\n  while (r >= l) {\n    long long mid = (l + r) \/ 2;\n    if (arr[mid] > elem)\n      r = mid - 1;\n    else if (arr[mid] < elem)\n      l = mid + 1;\n    else\n      return mid;\n  }\n  return -1;\n}\nlong long binary_search_vector(vector<long long>& arr, long long elem) {\n  long long n = arr.size();\n  long long l = 0, r = n - 1;\n  while (r >= l) {\n    long long mid = (l + r) \/ 2;\n    if (arr[mid] > elem)\n      r = mid - 1;\n    else if (arr[mid] < elem)\n      l = mid + 1;\n    else\n      return mid;\n  }\n  return -1;\n}\nlong long factorial(long long n) {\n  long long res = 1;\n  for (long long i = 2; i < n + 1; i++) res *= i;\n  return res;\n}\nlong long factorialM(long long n) {\n  long long res = 1;\n  for (long long i = 2; i < n + 1; i++) res = (res * i) % mod;\n  return res % mod;\n}\nbool checkPrime(long long n) {\n  long long count = 0;\n  for (long long i = 2; i < 1 + (long long)sqrt(n); i++) {\n    if (n % i == 0) count++;\n  }\n  if (count > 0)\n    return false;\n  else\n    return true;\n}\nbool compare(pair<long long, long long> p1, pair<long long, long long> p2) {\n  if (p1.second > p2.second)\n    return true;\n  else if (p1.second == p2.second)\n    return p1.first < p2.first;\n  else\n    return false;\n}\nclass Graph {\n public:\n  vector<vector<long long> > adj;\n  vector<bool> visited;\n  Graph(long long n) {\n    adj.resize(n + 1);\n    visited.resize(n + 1);\n  }\n  void addEdge(long long first, long long second, bool directed = false);\n  void dfs(long long start);\n  void check(long long ans[], long long n);\n};\nvoid Graph::addEdge(long long first, long long second, bool directed) {\n  adj[first].push_back(second);\n  if (!directed) adj[second].push_back(first);\n}\nvoid Graph::dfs(long long start) {\n  visited[start] = true;\n  cout << start << \" \";\n  for (long long i = 0; i < adj[start].size(); i++) {\n    if (!visited[adj[start][i]]) dfs(adj[start][i]);\n  }\n}\nvoid Graph::check(long long ans[], long long n) {\n  for (long long i = 0; i < adj.size(); i++) {\n    ans[adj[i].size()]++;\n  }\n}\nlong long noOfDigits(long long x) {\n  long long digits = 0;\n  while (x > 0) {\n    x \/= 10;\n    digits++;\n  }\n  return digits;\n}\nlong long sumOfDigits(long long n) {\n  long long sum = 0;\n  while (n > 0) {\n    sum += n % 10;\n    n \/= 10;\n  }\n  return sum;\n}\nbool cmp(pair<long long, long long> a, pair<long long, long long> b) {\n  return a.first < b.first;\n}\nvoid reverse(string& str, long long start, long long end) {\n  for (long long i = start; i < start + ((end - start + 1) \/ 2); i++) {\n    swap(str[i], str[end + start - i]);\n  }\n}\nlong long findGCD(long long arr[], long long n) {\n  long long result = arr[0];\n  for (int i = 1; i < n; i++) {\n    result = gcd(arr[i], result);\n    if (result == 1) {\n      return 1;\n    }\n  }\n  return result;\n}\nlong long findGCD1(long long arr[], long long n, long long i1, long long i2) {\n  long long result;\n  if (i1 == 0) {\n    result = arr[0] * arr[i2];\n  } else {\n    result = arr[0];\n  }\n  for (int i = 1; i < n; i++) {\n    if (i == i1) {\n      result = gcd(arr[i] * arr[i2], result);\n    } else if (i == i2) {\n      result = gcd(arr[i] * arr[i1], result);\n    } else {\n      result = gcd(arr[i], result);\n    }\n    if (result == 1) {\n      return 1;\n    }\n  }\n  return result;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  srand(time(NULL));\n  long long t;\n  cin >> t;\n  for (long long tc = 1; tc <= t; tc++) {\n    long long n;\n    cin >> n;\n    long long arr[n];\n    for (long long i = 0; i < n; i++) {\n      cin >> arr[i];\n    };\n    sort(arr, arr + n);\n    if (n == 1) {\n      cout << arr[0] << \"\\n\";\n      continue;\n    } else if (n == 2) {\n      cout << max(arr[0], arr[1] - arr[0]) << \"\\n\";\n      continue;\n    }\n    long long ans = INT_MIN;\n    for (long long i = 0; i < n - 1; i++) {\n      if (arr[i + 1] >= 2 * arr[i]) {\n        ans = arr[i + 1] - arr[i];\n      } else\n        break;\n    }\n    cout << max(ans, arr[0]) << \"\\n\";\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base ::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  int n;\n  vector<long long> a;\n  while (t > 0) {\n    cin >> n;\n    int tmp;\n    long long maxN;\n    for (int i = 0; i < n; i++) {\n      cin >> tmp;\n      a.push_back(tmp);\n    }\n    if (n == 1) {\n      cout << tmp << endl;\n      t--;\n      continue;\n    }\n    sort(a.begin(), a.end());\n    maxN = a[0];\n    for (int i = 1; i < n; i++) {\n      maxN = max(maxN, a[i] - a[i - 1]);\n    }\n    cout << maxN << endl;\n    a.clear();\n    t--;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  int n;\n  cin >> n;\n  set<long long> order;\n  for (int i = 0; i < n; ++i) {\n    int a;\n    cin >> a;\n    order.insert(a);\n  }\n  long long add = 0, ans = -1e18;\n  while (order.size() > 1) {\n    long long cur = *order.begin() + add;\n    ans = max(ans, cur);\n    add -= cur;\n    order.erase(order.begin());\n  }\n  ans = max(ans, *order.begin() + add);\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) solve();\n  return 0;\n}\n","import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n##########################################################\nfrom collections import Counter, defaultdict\nimport math\nimport heapq\nimport bisect\ndef nck(n, k):\n    res = 1\n    for i in range(1, k + 1):\n        res = res * (n - i + 1) \/\/ i\n    return res\n\nfor _ in range(int(input())):\n    n=int(input())\n    #n,k=map(int, input().split())\n    #if abs(n)%2==1:\n    arr=sorted(list(map(int, input().split())))\n    a=0\n    if n==1:\n        print(arr[0])\n    else:\n        if arr[0]<0:\n            a+=abs(arr[0])\n            print(a+arr[1])\n        else:\n            print(arr[0])\n","t=int(input())\nfor i in range(t) :\n    n=int(input())\n    araye=input().split()\n    for ii in range(n) :\n        araye[ii]=int(araye[ii])\n    araye.sort()\n    mini=araye[0]\n    while (len(araye) > 1) :\n        if (araye[0] >(araye[1]-araye[0])) and araye[0] >= 0:\n            break\n        adad=araye[0]\n        for j in range (len(araye)) :\n            araye[j]= araye[j] - adad\n        araye.pop(0)\n        araye.sort()\n        if mini< araye[0] :\n            mini=araye[0]    \n    if mini< araye[0] :\n            mini=araye[0]\n    print(mini)\n\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> a(n);\n  for (auto &i : a) cin >> i;\n  sort((a).begin(), (a).end());\n  long long vic = 0;\n  long long mn = a[0];\n  for (long long j = 0; j < n - 1; ++j) {\n    vic -= (a[j] - vic);\n    mn = max(mn, a[j + 1] - vic);\n  }\n  cout << mn << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  long long n;\n  cin >> n;\n  for (long long i = 0; i < n; ++i) {\n    solve();\n  }\n}\n","t = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split(' ')))\n    if n == 1:\n        print(arr[0])\n    else:\n        sorted_arr = sorted(arr)\n        i = 0\n        while(i < (len(sorted_arr)-2)):\n            a = sorted_arr[i]\n            for j in range(len(arr)):\n                sorted_arr[j] -= a\n                \n            i += 1\n        \n        print(sorted_arr[-2])","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve();\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  int a[n];\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  if (n == 1) {\n    cout << a[0] << endl;\n    return;\n  }\n  sort(a, a + n);\n  if (n == 2) {\n    if (a[0] < 0)\n      cout << a[1] - a[0] << endl;\n    else\n      cout << a[0] << endl;\n    return;\n  }\n  int ans1 = a[n - 2] - a[n - 3];\n  int ans2 = a[n - 1] - a[n - 2];\n  int ans = ans1 > ans2 ? ans1 : ans2;\n  cout << ans << endl;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int64_t t;\n  cin >> t;\n  for (int i = 0; i < t; i++) {\n    int64_t n;\n    cin >> n;\n    int64_t a[n];\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a, a + n);\n    int64_t s = a[0], ans = a[0];\n    for (int i = 1; i < n; i++) {\n      s = max(ans, a[i] - a[i - 1]);\n      ans = a[i] - a[i - 1];\n    }\n    cout << s << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 7;\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d\", &n);\n    set<long long> s;\n    for (int i = 1; i <= n; i++) {\n      long long x;\n      cin >> x;\n      s.insert(x);\n    }\n    if (n == 1) {\n      printf(\"%lld\\n\", *(s.begin()));\n      continue;\n    }\n    long long ans = *(s.begin()), cnt = 0;\n    while (s.size() > 1) {\n      long long minn = *(s.begin());\n      s.erase(s.begin());\n      cnt += minn;\n      ans = max(ans, *(s.begin()) - minn);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n","from os import path, truncate\nfrom sys import int_info, stdin, stdout\nif path.exists('tc.txt'):\n    stdin = open('tc.txt', 'r')\ndef gmi(): return map(int, stdin.readline().strip().split())\ndef gms(): return map(str, stdin.readline().strip().split())\ndef gari(): return list(map(int, stdin.readline().strip().split()))\ndef gart(): return tuple(map(int, stdin.readline().strip().split()))\ndef gars(): return list(map(str, stdin.readline().strip().split()))\ndef gs(): return stdin.readline().strip()\ndef gls(): return list(stdin.readline().strip())\ndef gi(): return int(stdin.readline())\n\nfor _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    if n==1:\n        print(a[0])\n        continue\n    else:\n        cnt=min(a)\n        a=list(set(a))\n        a.sort()\n        n=len(a)\n        for i in range(1,n):\n            cnt=max(cnt,a[i]-a[i-1])\n        print(cnt)\n\n\n\n\n\n\n    \n\n   \n\n    \n\n   \n\n# def maxsum(arr):\n#     n=len(arr)\n#     su=0\n#     leftdp=[0]*n\n#     rightdp=[0]*n\n#     c=0\n#     for i in range(0,n,2):\n#         su+=arr[i]\n#     for i in range(1, n, 2):\n#         leftdiff = arr[i]-arr[i-1]\n#         if c-1<0:\n#             leftdp[i]=leftdiff\n#         else:\n#             if leftdp[i-2]>0:\n#                 leftdp[i]=leftdiff+leftdp[i-2]\n#             else:\n#                 leftdp[i]=leftdiff\n#         rightdiff=0\n#         if i+1>=n:\n#             rightdiff=0\n#         else:\n#             rightdiff=arr[i]-arr[i+1]\n#         if c-1<0:\n#             rightdp[i]=rightdiff\n#         else:\n#             if rightdp[i-2]>0:\n#                 rightdp[i]=rightdiff+rightdp[i-2]\n#             else:\n#                 rightdp[i]=rightdiff\n#         c+=1\n#     maxm=0\n#     for i  in range(1,n,2):\n#          maxm=max(maxm,max(leftdp[i],rightdp[i]))\n#     return maxm + su\n        \n        \n\n# arr =list(map(int,input().split()))\n# re=maxsum(arr)\n# print(re)\n\n# x = math.floor(math.log(b)\/math.log(2))\n# y = math.floor(math.log(a)\/math.log(5))\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long ar[n];\n    for (int i = 0; i < n; i++) cin >> ar[i];\n    sort(ar, ar + n);\n    long long ans = -1e18;\n    if (n == 1) {\n      ans = ar[0];\n      cout << ans << \"\\n\";\n    } else if (n == 2) {\n      ans = max(ans, max(ar[0], abs(ar[0] - ar[1])));\n      cout << ans << \"\\n\";\n    } else {\n      for (int i = 1; i < n; i++) {\n        ans = max(ans, abs(ar[i] - ar[i - 1]));\n      }\n      cout << ans << \"\\n\";\n    }\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t;\n  scanf(\"%lld\", &t);\n  while (t--) {\n    long long n;\n    scanf(\"%lld\", &n);\n    vector<long long> v(n);\n    for (long long i = 0; i < n; i++) {\n      scanf(\"%lld\", &v[i]);\n    }\n    sort(v.begin(), v.end());\n    long long kuota = (-1) * v[0], minim = v[0];\n    for (long long i = 1; i < n; i++) {\n      if (v[i] + kuota >= minim) {\n        minim = v[i] + kuota;\n        kuota -= minim;\n      } else {\n        break;\n      }\n    }\n    printf(\"%lld\\n\", minim);\n  }\n  return 0;\n}\n","import sys\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\ninp_vars_int = lambda: map(int, input().split())\ninp_list_int = lambda: list(map(int, input().split()))\n\nt = int(input())\n\nfor _ in range(t):\n    _ = input()\n    a = inp_list_int()\n    n = len(a)\n    a_s = sorted(a)\n    diff = [a_s[i] - a_s[i-1] for i in range(1, n)]\n    d_s = sorted(diff)\n    if n == 1:\n        print(a[0])\n    else:\n        print(max(d_s))","t=int(input())\nfor i in range(t) :\n    n=int(input())\n    araye=input().split()\n    for ii in range(n) :\n        araye[ii]=int(araye[ii])\n    araye.sort()\n    mini=araye[0]\n    while (len(araye) > 1) :\n        if mini >(araye[1]-araye[0]) :\n            break\n        adad=araye[0]\n        for j in range (len(araye)) :\n            araye[j]= araye[j] - adad\n        araye.pop(0)\n        araye.sort()\n        if mini< araye[0] :\n            mini=araye[0]    \n    if mini< araye[0] :\n            mini=araye[0]\n    print(mini)\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long modular_pow(long long b, long long e, long long m) {\n  if (m == 1) return 0;\n  b %= m;\n  long long r = 1;\n  while (e > 0) {\n    if (e & 1) r = (r * b) % m;\n    b = (b * b) % m;\n    e >>= 1;\n  }\n  return r;\n}\nlong long npow(long long x, long long n) {\n  long long res = 1;\n  while (n) {\n    if (n % 2) res = (res * x);\n    n \/= 2;\n    x = (x * x);\n  }\n  return res;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return a \/ gcd(a, b) * b; }\nvoid io() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n}\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> a(n);\n  for (long long i = 0; i < n; i++) cin >> a[i];\n  if (n < 2) {\n    cout << a[0] << \"\\n\";\n    return;\n  }\n  sort(a.begin(), a.end());\n  long long i = 0, cnt = 0, c_cnt = 0;\n  while (i < n) {\n    a[i] += cnt;\n    cnt += 0 - a[i];\n    if (i < n - 1 && a[i] > a[i + 1] + cnt) break;\n    i++;\n  }\n  if (i == n) i--;\n  cout << a[i] << \"\\n\";\n}\nsigned main() {\n  io();\n  long long test;\n  cin >> test;\n  while (test--) {\n    solve();\n  }\n  return 0;\n}\n","import sys\n\ninput = sys.stdin.readline\nprint = sys.stdout.write\n\n\n\n","import java.util.*;\nimport java.io.*;\npublic class minExtraction{\n   public static void main(String[] args) throws IOException{\n      BufferedReader f= new BufferedReader(new InputStreamReader(System.in));\n      StringTokenizer s=new StringTokenizer(f.readLine());\n      int t=Integer.parseInt(s.nextToken());\n      for(int i=0;i<2*t;i+=2){\n         ArrayList<Integer> arr=new ArrayList<Integer>();\n         s=new StringTokenizer(f.readLine());\n         int n=Integer.parseInt(s.nextToken());\n         s=new StringTokenizer(f.readLine());\n         for(int k=0;k<n;k++){\n            arr.add(Integer.parseInt(s.nextToken()));\n         }\n         Collections.sort(arr);\n         int max=Integer.MIN_VALUE;\n         for(int k=1;k<arr.size();k++){\n            max=Math.max(max,arr.get(k)-arr.get(k-1));\n         }\n         if(arr.size()==1)max=arr.get(0);\n         System.out.println(max);\n      }\n   }\n}","def vigoda(mas):\n    for i in mas:\n        if i <= 0:\n            return True \n    return False\ndef step(mas):\n    m = min(mas)\n    mas.pop(mas.index(m))\n    for i in range(0, len(mas)):\n        mas[i] -= m\n    return mas\n\nt = int(input())\nwhile t:\n    n = int(input())\n    s = input()\n    s = s.split(' ')\n    if len(s) == 1:\n        print(s[0])\n    else:\n        for i in range(0, n):\n            s[i] = int(s[i])\n        while vigoda(s):\n            if len(s) > 1:\n                s = step(s)\n            else: break\n        s.sort()\n        maxraz = 0\n        if len(s) > 1:\n            for i in range(1, len(s)):\n                if s[i] - s[i - 1] > maxraz:\n                    maxraz = s[i] - s[i - 1] \n            print(maxraz)\n        else: \n            print(s[0])\n    \n    \n\n    t -= 1\n\n","t=int(input())\nfor i in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    if(n==1):\n        print(a[0])\n    else:\n        list1=[]\n        if(n==2):\n            list1.append(min(a[0],a[1]))\n            \n        \n        while(len(a)>1):\n            \n            p=min(a)\n            a.remove(p)\n            for i in range(len(a)):\n                a[i]=a[i]-p\n            \n            list1.append(min(a))\n        print(max(list1))\n        \n    \n        \n            \n        \n        \n        \n    ","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n;\n  cin >> n;\n  long long a[n];\n  set<long long> s;\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i];\n    s.insert(a[i]);\n  }\n  if (n == 1) {\n    cout << a[0] << endl;\n    return;\n  }\n  sort(a, a + n);\n  if (s.size() != n) {\n    cout << max((long long)0, a[0]) << endl;\n    return;\n  }\n  if (n == 2) {\n    cout << max(min(a[0], a[1]), a[1] - a[0]) << endl;\n    return;\n  }\n  long long largest = a[n - 1], secondlargest = a[n - 2], third = a[n - 3];\n  largest -= third;\n  secondlargest -= third;\n  cout << max(min(largest, secondlargest), largest - secondlargest) << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long test = 1;\n  cin >> test;\n  while (test--) {\n    solve();\n  }\n  return 0;\n}\n","t=int(input())\nfor _ in range(t):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    arr.sort()\n    if n==1:\n        print(arr[0])\n        continue\n    mx=arr[1]-arr[0]\n    for i in range(n-1):\n        if arr[i+1]-arr[i]>mx:\n            mx=arr[i+1]-arr[i]\n    print(mx)","import java.io.*;\nimport java.util.*;\npublic class GFG {\n\tpublic static void main (String[] args)throws IOException {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tint t=Integer.parseInt(br.readLine());\n\t\twhile(t-->0)\n\t\t{\n\t\t    int n=Integer.parseInt(br.readLine());\n\t\t    String s[]=br.readLine().split(\" \");\n\t\t    if(n==1)\n\t\t    {\n\t\t        bw.write((Integer.parseInt(s[0]))+\"\\n\");\n\t\t    }\n\t\t    else \n\t\t    {\n\t\t        ArrayList<Integer> pos=new ArrayList<>();\n\t\t        ArrayList<Integer> neg=new ArrayList<>();\n\t\t        for(int i=0;i<n;i++)\n\t\t        {\n\t\t            int temp=Integer.parseInt(s[i]);\n\t\t            if(temp>=0)\n\t\t                pos.add(temp);\n\t\t            else \n\t\t                neg.add(temp);\n\t\t        }\n\t\t        if(pos.size()==0)\n\t\t        {\n\t\t            Collections.sort(neg);\n\t\t            bw.write((neg.get(neg.size()-1)-neg.get(neg.size()-2))+\"\\n\");\n\t\t        }\n\t\t        else if(pos.size()==1)\n\t\t        {\n\t\t            Collections.sort(neg);\n\t\t            bw.write((pos.get(0)-(neg.get(neg.size()-1)))+\"\\n\");\n\t\t        }\n\t\t        else \n\t\t        {\n\t\t            int max=0;\n\t\t            Collections.sort(pos);\n\t\t            for(int i=1;i<pos.size();i++)\n\t\t            {\n\t\t                if(pos.get(i)-pos.get(i-1)>max)\n\t\t                max=pos.get(i)-pos.get(i-1);\n\t\t            }\n\t\t            bw.write(max+\"\\n\");\n\t\t        }\n\t\t        \n\t\t    }\n\t\t}\n\t\tbw.flush();\n\t\t\n\t}\n}","#include <bits\/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long log_a_to_base_b(long long a, long long b) { return log(a) \/ log(b); }\nbool isPrime(long long n) {\n  if (n == 1) {\n    return false;\n  }\n  long long i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      return false;\n    }\n    i += 1;\n  }\n  return true;\n}\nvector<long long> prime_fact(long long n) {\n  vector<long long> v;\n  for (long long i = 2; i * i <= n; i++)\n    if (n % i == 0) {\n      while (n % i == 0) n \/= i;\n      v.push_back(i);\n    }\n  if (n > 1) v.push_back(n);\n  return v;\n}\nlong long power(long long a, long long n) {\n  long long res = 1;\n  while (n) {\n    if (n % 2)\n      res *= a, n--;\n    else\n      a *= a, n \/= 2;\n  }\n  return res;\n}\nlong long euler_totient(long long n) {\n  long long res = n;\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      res \/= i;\n      res *= (i - 1);\n      while (n % i == 0) n \/= i;\n    }\n  }\n  if (n > 1) res \/= n, res *= (n - 1);\n  return res;\n}\nbool isKthBitSet(long long n, long long k) {\n  if (n & (1 << k))\n    return true;\n  else\n    return false;\n}\nlong long no_of_set_bits(long long n) {\n  long long cnt = 0;\n  while (n > 0) {\n    cnt++;\n    n = n & (n - 1);\n  }\n  return cnt;\n}\nvoid init() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nsigned main() {\n  init();\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> v(n);\n    for (auto &i : v) cin >> i;\n    sort(v.begin(), v.end());\n    if (n == 1) {\n      cout << v[0] << \"\\n\";\n      continue;\n    }\n    if (n == 2) {\n      cout << max(v[0], (v[1] - v[0])) << \"\\n\";\n      continue;\n    }\n    long long ans = 0ll;\n    long long i = 0ll;\n    if (v[0ll] < 0ll) {\n      for (i = 1ll; i < n; i++)\n        if (v[i] < 0ll)\n          continue;\n        else\n          break;\n      i--;\n      ans = (long long)(v[i] - v[0]);\n      i++;\n    }\n    for (long long j = i; j < n; j++) v[j] -= ans;\n    for (; i < n - 1ll; i++) ans = max(ans, (long long)(v[i + 1] - v[i]));\n    cout << (long long)ans << \"\\n\";\n  }\n  return 0;\n}\n","def get_new_numbers(numbers, mn):\n    s = [numbers[i] - mn for i in range(len(numbers) - 1)]\n    try:\n        mn = max(mn, s[-1])\n        if numbers[-2] == numbers[-1]:\n            mn = max(mn, 0)\n    except IndexError:\n        pass\n    return s, mn\n\n\ndef main():\n    _ = int(input())\n    numbers = sorted([int(x) for x in input().split()], reverse=True)\n    mn = numbers[-1]\n    while len(numbers) > 1:\n        numbers, mt = get_new_numbers(numbers, numbers[-1])\n        if mn > mt:\n            break\n        mn = max(mt, mn)\n    print(mn)\n\n\nif __name__ == '__main__':\n    # tests = 1\n    tests = int(input())\n    while tests > 0:\n        tests -= 1\n        main()\n","import sys, collections, math, bisect, heapq, random, functools\n\ninput = sys.stdin.readline\nout = sys.stdout.flush\n\n\ndef solve():\n    n = int(input())\n    queue = []\n    a = list(map(int, input().split()))\n    va = collections.Counter(a)\n    for v in va:\n        heapq.heappush(queue,[v,va[v]])\n    diff = 0\n    k = len(queue)\n    while k > 1 and queue[0][0] - diff <= 0:\n        cur,cnt = heapq.heappop(queue)\n        cur -= diff\n        diff += cur\n        k -= 1\n\n    flag = 1\n    ans = -1\n    while k > 1:\n        minv,cnt = heapq.heappop(queue)\n        k -= 1\n        if queue[0][0] - minv > minv - diff:\n            cur,cnt1 = queue[0][0],queue[0][1]\n            cur -= diff\n            diff += minv - diff\n        else:\n            flag = 0\n            ans = minv - diff\n            break\n\n    if not flag:\n        print(ans)\n    else:\n        if queue[0][0] - diff < 0:\n           if queue[0][1] > 1:\n              print(0)\n           else:\n              print(queue[0][0])\n        else:\n           print(queue[0][0] - diff)\n\n\n\n\n\n\nif __name__ == '__main__':\n    for i in range(int(input())):\n        solve()","#include <bits\/stdc++.h>\nusing namespace std;\nint result() {\n  int result = 0, len, i;\n  string keyboard, word;\n  cin >> keyboard >> word;\n  len = word.length();\n  i = len - 1;\n  for (int i = len - 1; i > 0; i--) {\n    int f = keyboard.find(word[i]) + 1;\n    int g = keyboard.find(word[i - 1]) + 1;\n    result += abs(f - g);\n  }\n  return result;\n}\nint minimum() {\n  long long n, min, maxmin, integer;\n  cin >> n;\n  vector<long long> arr;\n  for (int i = 0; i < n; i++) {\n    cin >> integer;\n    arr.push_back(integer);\n  }\n  if (n == 1)\n    return arr[n - 1];\n  else {\n    min = *min_element(arr.begin(), arr.end());\n    while (arr.size() > 1) {\n      maxmin = min;\n      min = *min_element(arr.begin(), arr.end());\n      if (maxmin < min) maxmin = min;\n      arr.erase(find(arr.begin(), arr.end(), min));\n      for (int i = 0; i < arr.size(); i++) {\n        arr[i] = arr[i] - min;\n        if (arr[i] < min) min = arr[i];\n      }\n    }\n    return maxmin;\n  }\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    cout << minimum() << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 1000;\nlong long p[N];\nint main() {\n  int n;\n  cin >> n;\n  while (n--) {\n    memset(p, 0, sizeof p);\n    int a;\n    cin >> a;\n    for (int i = 0; i < a; i++) {\n      cin >> p[i];\n    }\n    sort(p, p + a);\n    long long j = 0, s;\n    long long max = -1e18 - 1;\n    for (int i = 0; i < a; i++) {\n      if (p[i] + j > max) {\n        max = p[i];\n        s = j;\n      }\n      j -= p[i] + j;\n    }\n    cout << max + s << endl;\n  }\n  return 0;\n}\n","import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\n\/**\n *\n * @author Acer\n *\/\npublic class NewClass2 {\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int T = sc.nextInt();\n        while(T-- > 0){\n            int n = sc.nextInt();\n            ArrayList<Integer> arr = new ArrayList<Integer>();           \n            for (int i = 0; i < n; i++) {\n                arr.add(sc.nextInt());\n            }\n            \n            if(n == 1){\n                System.out.println(arr.get(0));\n                continue;\n            }\n            \n            Collections.sort(arr);\n            \n            int prev = arr.get(0);\n            int max = arr.get(0);\n            int ans = 0;\n            for (int i = 1; i < n; i++) {\n                ans = arr.get(0)-prev;\n                prev = prev+ans;\n                max = Math.max(max, ans);\n            }\n            System.out.println(max);\n        }\n    }\n    \n}","import sys\ninput = sys.stdin.readline\n\nT = int(input())\nresult = []\nfor _ in range(T):\n    _ = input()\n    a = list(map(int, input()[:-1].split()))\n\n    # Values\n    max_val = float(-float('inf'))\n    sub_count = 0\n\n    # Sorting\n    a.sort()\n\n    if len(a) == 1:\n        result.append(str(a[0]))\n        continue\n\n    for i in range(0, len(a) - 1):\n        # Checking max_val\n        fst = a[i]\n        max_val = max(max_val, fst)\n        \n        # set sub_count\n        sub_count += max_val\n        # calculate\n        a[i + 1] -= sub_count\n\n    # Last\n    result.append(str(max(max_val, a[-1])))\n\n\nprint('\\n'.join(result))","import heapq as hq\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    ans = -1e9\n    ad = 0\n    hq.heapify(a)\n\n    for i in range(n):\n        x = hq.heappop(a) + ad\n        ad -= x\n        ans = max(ans, x)\n        #print(a)\n    print(ans)","import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic long[]fac=new long[200100];\n\tstatic long[] two= new long[200100] ;\n\tstatic long mod=((long)1e18)+7;\n\tstatic String[]pow=new String[63];\n\tstatic int n;\n\tstatic int x=0;\n\tstatic int[][]perm,b;\n\tstatic int[]pe,aa,a;\n\tpublic static void main(String[] args) throws IOException, InterruptedException{\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tint n=sc.nextInt();\n\t\t\tLong[]a=new Long[n];\n\t\t\tlong min=Long.MAX_VALUE;\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextLong();\n\t\t\t\tmin=Math.min(min, a[i]);\n\t\t\t}\n\t\t\tif(n==1) {\n\t\t\t\tpw.println(min);\n\t\t\t}else {\n\t\t\t\tif(min<0) {\n\t\t\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\t\t\ta[i]-=min;\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(a);\n\t\t\t\t\tlong o=a[1];\n\t\t\t\t\tfor (int i = 2; i < a.length; i++) {\n\t\t\t\t\t\tif(a[i]>=2*a[i-1]) {\n\t\t\t\t\t\t\to=a[i]-a[i-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpw.println(o);\n\t\t\t\t}else {\n\t\t\t\t\tArrays.sort(a);\n\t\t\t\t\tlong o=a[0];\n\t\t\t\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\t\t\t\tif(a[i]>=2*a[i-1]) {\n\t\t\t\t\t\t\to=a[i]-a[i-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpw.println(o);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tpw.close();\n\t}\t\n\t\n\tpublic static long[] Extended(long p, long q) {\n\t      if (q == 0)\n\t         return new long[] { p, 1, 0 };\n\n\t      long[] vals = Extended(q, p % q);\n\t      long d = vals[0];\n\t      long a = vals[2];\n\t      long b = vals[1] - (p \/ q) * vals[2];\n\t      return new long[] { d, a, b };\n\t   }\n\t\n\tstatic class STree{\n\t\tint N;\n\t\tlong[]arr;\n\t\tlong[]tree;\n\t\tint[]lazy;\n\t\tlong id;\n\t\tpublic static long operation(long x,long y) {\n\t\t\treturn x^y;\n\t\t}\n\t\t\n\t\tpublic STree(int[]a,long id) {\n\t\t\tthis.id=id;\n\t\t\tN=1;\n\t\t\tint n=a.length;\n\t\t\twhile(N<n) {\n\t\t\t\tN*=2;\n\t\t\t}\n\t\t\tarr=new long[N+1];\n\t\t\tArrays.fill(arr, id);\n\t\t\tfor (int i = 1; i <= a.length; i++) {\n\t\t\t\tarr[i]=a[i-1];\n\t\t\t}\n\t\t\ttree=new long[2*N];\n\t\t\tArrays.fill(tree, id);\n\t\t\tbuild(1,N,1);\n\t\t\tlazy=new int[2*N];\n\t\t}\n\t\t\n\t\tpublic void build(int l,int r,int node) {\n\t\t\tif(l==r) {\n\t\t\t\ttree[node]=arr[l];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mid=(l+r)\/2;\n\t\t\tbuild(l,mid,node*2);\n\t\t\tbuild(mid+1,r,node*2+1);\n\t\t\ttree[node]=operation(tree[node*2],tree[node*2+1]);\n\t\t}\n\t\t\n\/\/\t\tpublic void update(int node,int value) {\n\/\/\t\t\tint i=node+N-1;\n\/\/\t\t\ttree[i]=value;\n\/\/\t\t\ti\/=2;\n\/\/\t\t\twhile(i>0) {\n\/\/\t\t\t\ttree[i]=operation(tree[i*2], tree[i*2+1]);\n\/\/\t\t\t\ti\/=2;\n\/\/\t\t\t}\n\/\/\t\t}\n\/\/\t\t\n\/\/\t\tpublic void updateRange(int l,int r,int v) {\n\/\/\t\t\tupdateRange(1, N, l, r, 1,v);\n\/\/\t\t}\n\/\/\t\t\n\/\/\t\tpublic void updateRange(int s,int e,int l,int r,int node,int v) {\n\/\/\t\t\tif(s>=l&&e<=r) {\n\/\/\t\t\t\tlazy[node]^=v;\n\/\/\t\t\t\ttree[node]=propagate(tree[node],lazy[node],e-s+1);\n\/\/\/\/\t\t\t\tlazy[node]=0;\n\/\/\t\t\t\treturn;\n\/\/\t\t\t}\n\/\/\t\t\tif(s>r||e<l)return;\n\/\/\t\t\tint mid=(s+e)\/2;\n\/\/\t\t\tlazy[node*2] ^= lazy[node];\n\/\/\t\t\tlazy[node*2+1] ^= lazy[node];\n\/\/\t\t\ttree[node*2] = propagate(tree[node*2], v, (e-s+1)\/2);\n\/\/\t\t\ttree[node*2+1] =  propagate(tree[node*2+1], v, (e-s+1)\/2);\n\/\/\t\t\tlazy[node] = 0;\n\/\/\t\t\tupdateRange(s, mid, l, r, node*2, v);\n\/\/\t\t\tupdateRange(mid+1, e, l, r, node*2+1, v);\n\/\/\t\t\ttree[node]=operation(tree[node*2], tree[node*2+1]);\n\/\/\t\t\treturn;\n\/\/\t\t}\n\/\/\t\t\n\t\tpublic long q(int l,int r) {\n\t\t\treturn q(1,N,l,r,1);\n\t\t}\n\t\t\n\t\tpublic long q(int s,int e,int l,int r,int node) {\n\t\t\tif(s>=l&&r>=e) {\n\t\t\t\treturn tree[node];\n\t\t\t}\n\t\t\tif(s>r||e<l)\n\t\t\t\treturn id;\n\t\t\tint mid=(s+e)\/2;\n\t\t\t\n\t\t\treturn operation(q(s,mid,l,r,node*2), q(mid+1,e,l,r,node*2+1));\n\t\t}\n\/\/\t\tpublic static segment propagate(segment x,int v,int length) {\n\/\/\t\t\tint[]bit=x.bit.clone();\n\/\/\t\t\tlong sum=x.sum;\n\/\/\t\t\tfor (int i = 0; i < bit.length; i++) {\n\/\/\t\t\t\tif((v&1<<i)!=0) {\n\/\/\t\t\t\t\tsum-=(1<<i)*(bit[i]);\n\/\/\t\t\t\t\tsum+=(1<<i)*(length-bit[i]);\n\/\/\t\t\t\t\tbit[i]=length-bit[i];\n\/\/\t\t\t\t}\n\/\/\t\t\t}\n\/\/\t\t\treturn new segment(sum, bit);\n\/\/\t\t}\n\t}\n\n\tpublic static class segment{\n\t\tlong sum;\n\t\tint[] bit;\n\t\t\n\t\tpublic segment (long sum,int[]bit) {\n\t\t\tthis.sum=sum;\n\t\t\tthis.bit=bit.clone();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn sum+\" \"+Arrays.toString(bit);\n\t\t}\n\t}\n\t\n\tpublic static int LIS(int[] a) {\n\n\t\tint n = a.length;\n\t\tint[] ser = new int[n];\n\t\tint[]ser1=new int[n];\n\t\tArrays.fill(ser1, Integer.MAX_VALUE);\n\t\tArrays.fill(ser, Integer.MAX_VALUE);\n\t\tint cur = -1;\n\t\tint[]inc=new int[n];\n\t\tint[]dec=new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint low = 0;\n\t\t\tint high = n - 1;\n\t\t\tint mid = (low + high) \/ 2;\n\t\t\twhile (low <= high) {\n\t\t\t\tif (ser[mid] < a[i]) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}\n\t\t\t\tmid = (low + high) \/ 2;\n\t\t\t}\n\t\t\tinc[i]=high+2;\n\t\t\tcur = Math.max(cur, high + 1);\n\t\t\tser[high + 1] = Math.min(ser[high + 1], a[i]);\n\t\t}\n\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\tint low = 0;\n\t\t\tint high = n - 1;\n\t\t\tint mid = (low + high) \/ 2;\n\t\t\twhile (low <= high) {\n\t\t\t\tif (ser1[mid] < a[i]) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}\n\t\t\t\tmid = (low + high) \/ 2;\n\t\t\t}\n\t\t\tdec[i]=high+2;\n\t\t\tcur = Math.max(cur, high + 1);\n\t\t\tser1[high + 1] = Math.min(ser1[high + 1], a[i]);\n\t\t}\n\t\tint ans=1;\n\t\tfor (int i = 0; i < dec.length; i++) {\n\t\t\tans=Math.max(ans, 2*Math.min(inc[i], dec[i])-1);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tpublic static void permutation(int idx,int v) {\n\t\tif(v==(1<<n)-1) {\n\t\t\tperm[x++]=pe.clone();\n\t\t\treturn ;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif((v&1<<i)==0) {\n\t\t\t\tpe[idx]=aa[i];\n\t\t\t\tpermutation(idx+1, v|1<<i);\n\t\t\t}\n\t\t}\n\t\treturn ;\n\t}\n\t\n\tpublic static void pre2() {\n\t\tfor (int i = 0; i < pow.length; i++) {\n\t\t\tlong x=1l<<i;\n\t\t\tpow[i]=x+\"\";\n\t\t}\n\t}\n\t\t\n\tpublic static void sort(int[]a) {\n\t\tmergesort(a, 0, a.length-1);\n\t}\n\t\n\tpublic static void sortIdx(long[]a,long[]idx) {\n\t\tmergesortidx(a, idx, 0, a.length-1);\n\t}\n\t\n\tpublic static long C(int a,int b) {\n\t\tlong x=fac[a];\n\t\tlong y=fac[a-b]*fac[b];\n\t\treturn x*pow(y,mod-2)%mod;\n\t}\n\t\n\tpublic static long pow(long a,long b) {\n\t\tlong ans=1;a%=mod;\n\t\tfor(long i=b;i>0;i\/=2) {\n\t\t\tif((i&1)!=0)\n\t\t\t\tans=ans*a%mod;\n\t\t\ta=a*a%mod;\n\t\t }    \n\t\t    \n\t\t return ans;\n\t}\n\t\n\tpublic static void pre(){\n\t\tfac[0]=1;\n\t\tfac[1]=1;\n\t\tfac[2]=1;\n\t\tfor (int i = 3; i < fac.length; i++) {\n\t\t\tfac[i]=((fac[i-1]*2*i)\/2)%mod;\n\t\t}\n\t}\n\t\n\tpublic static long eval(String s) {\n\t\tlong p=1;\n\t\tlong res=0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tres+=p*(s.charAt(s.length()-1-i)=='1'?1:0);\n\t\t\tp*=2;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static String binary(long x) {\n\t\tString s=\"\";\n\t\twhile(x!=0) {\n\t\t\ts=(x%2)+s;\n\t\t\tx\/=2;\n\t\t}\n\t\treturn s;\n\t}\n\t\n\tpublic static boolean allSame(String s) {\n\t\tchar x=s.charAt(0);\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif(s.charAt(i)!=x)return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isPalindrom(String s) {\n\t\tint l=0;\n\t\tint r=s.length()-1;\n\t\twhile(l<r) {\n\t\t\tif(s.charAt(r--)!=s.charAt(l++))return false;\n\t\t\t\n\t\t}\n\t\treturn true;\n\t}\n\t \n\t\n\tpublic static boolean isSubString(String s,String t) {\n\t\tint ls=s.length();\n\t\tint lt=t.length();\n\t\tboolean res=false;\n\t\tfor (int i = 0; i <=lt-ls; i++) {\n\t\t\tif(t.substring(i, i+ls).equals(s)) {\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static boolean isSorted(long[]a) {\n\t\tfor (int i = 0; i < a.length-1; i++) {\n\t\t\tif(a[i]>a[i+1])return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isPrime(long n)\n    {\n \n        \/\/ Check if number is less than\n        \/\/ equal to 1\n        if (n <= 1)\n            return false;\n \n        \/\/ Check if number is 2\n        else if (n == 2)\n            return true;\n \n        \/\/ Check if n is a multiple of 2\n        else if (n % 2 == 0)\n            return false;\n \n        \/\/ If not, then just check the odds\n        for (int i = 3; i <= Math.sqrt(n); i += 2)\n        {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\tpublic static int whichPower(int x) {\n\t\tint res=0;\n\t\tfor (int j = 0; j < 31; j++) {\n\t\t\tif((1<<j&x)!=0) {\n\t\t\t\tres=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n \n\tpublic static long evaln(String x,int n) {\n\t\tlong res=0;\n\t\tfor (int i = 0; i < x.length(); i++) {\n\t\t\tres+=Long.parseLong(x.charAt(x.length()-1-i)+\"\")*Math.pow(n, i);\n\t\t}\n\t\treturn res;\n\t}\n\tstatic void merge(int[] arr,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tint[] l=new int[len1];\n\t\tint[] r=new int[len2];\n\t\tfor(int i=0;i<len1;i++)l[i]=arr[b+i];\n\t\tfor(int i=0;i<len2;i++)r[i]=arr[m+1+i];\n\t\tint i=0,j=0,k=b;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<r[j])arr[k++]=l[i++];\n\t\t\telse arr[k++]=r[j++];\n\t\t}\n\t\twhile(i<len1)arr[k++]=l[i++];\n\t\twhile(j<len2)arr[k++]=r[j++];\n\t\treturn;\n\t}\n\tstatic void mergesortidx(long[] arr,long[]idx,int b,int e) {\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tmergesortidx(arr,idx,b,m);\n\t\t\tmergesortidx(arr,idx,m+1,e);\n\t\t\tmergeidx(arr,idx,b,m,e);\n\t\t}\n\t\treturn;\n\t\t\n\t}\n\tstatic void mergeidx(long[] arr,long[]idx,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tlong[] l=new long[len1];\n\t\tlong[] lidx=new long[len1];\n\t\tlong[] r=new long[len2];\n\t\tlong[] ridx=new long[len2];\n\t\tfor(int i=0;i<len1;i++) {\n\t\t\tl[i]=arr[b+i];\n\t\t\tlidx[i]=idx[b+i];\n\t\t}\n\t\tfor(int i=0;i<len2;i++) {\n\t\t\tr[i]=arr[m+1+i];\n\t\t\tridx[i]=idx[m+1+i];\n\t\t}\n\t\tint i=0,j=0,k=b;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<=r[j]) {\n\t\t\t\tarr[k++]=l[i++];\n\t\t\t\tidx[k-1]=lidx[i-1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarr[k++]=r[j++];\n\t\t\t\tidx[k-1]=ridx[j-1];\n\t\t\t}\n\t\t}\n\t\twhile(i<len1) {\n\t\t\tidx[k]=lidx[i];\n\t\t\tarr[k++]=l[i++];\n\t\t}\n\t\twhile(j<len2) {\n\t\t\tidx[k]=ridx[j];\n\t\t\tarr[k++]=r[j++];\n\t\t}\n\t\treturn;\n\t}\n\tstatic void mergesort(int[] arr,int b,int e) {\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tmergesort(arr,b,m);\n\t\t\tmergesort(arr,m+1,e);\n\t\t\tmerge(arr,b,m,e);\n\t\t}\n\t\treturn;\n\t\t\n\t}\n\t\n\tstatic long mergen(int[] arr,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tint[] l=new int[len1];\n\t\tint[] r=new int[len2];\n\t\tfor(int i=0;i<len1;i++)l[i]=arr[b+i];\n\t\tfor(int i=0;i<len2;i++)r[i]=arr[m+1+i];\n\t\tint i=0,j=0,k=b;\n\t\tlong c=0;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<r[j])arr[k++]=l[i++];\n\t\t\telse {\n\t\t\t\tarr[k++]=r[j++];\n\t\t\t\tc=c+(long)(len1-i);\n\t\t\t}\n\t\t}\n\t\twhile(i<len1)arr[k++]=l[i++];\n\t\twhile(j<len2)arr[k++]=r[j++];\n\t\treturn c;\n\t}\n\tstatic long mergesortn(int[] arr,int b,int e) {\n\t\tlong c=0;\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)\/2;\n\t\t\tc=c+(long)mergesortn(arr,b,m);\n\t\t\tc=c+(long)mergesortn(arr,m+1,e);\n\t\t\tc=c+(long)mergen(arr,b,m,e);\n\t\t}\n\t\treturn c;\n\t\t\n\t}\n\tpublic static long fac(int n) {\n\t\tif(n==0)return 1;\n\t\treturn n*fac(n-1);\n\t}\n\tpublic static long gcd(long a, long b)\n    {\n      if (b == 0)\n        return a;\n      return gcd(b, a % b);\n    }\n     \n\tpublic static long summ(long x) {\n\t\tlong sum=0;\n\t\twhile(x!=0) {\n\t\t\tsum+=x%10;\n\t\t\tx=x\/10;\n\t\t}\n\t\treturn sum;\n\t\t\t\t\n\t}\n\t\n\tpublic  static ArrayList<Integer> findDivisors(int n){\n\t        ArrayList<Integer>res=new ArrayList<Integer>();\n\t        for (int i=1; i<=Math.sqrt(n); i++)\n\t        {\n\t            if (n%i==0)\n\t            {\n\t                \/\/ If divisors are equal, print only one\n\t                if (n\/i == i)\n\t                \tres.add(i);\n\t                else {\n\t                \tres.add(i);\n\t                \tres.add(n\/i);\n\t                }\t\n\t            }\n\t        }\n\t        return res;\n\t    }\n\n\t\n\tpublic static void sort2darray(Integer[][]a){\n\t\tArrays.sort(a,Comparator.<Integer[]>comparingInt(x -> x[0]).thenComparingInt(x -> x[1]));\n \n\t}\n\t\n\t\n\t\n\t\t\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\t\tpublic Scanner(String file) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t\tpublic int[] nextArrint(int size) throws IOException {\n\t\t\tint[] a=new int[size];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic long[] nextArrlong(int size) throws IOException {\n\t\t\tlong[] a=new long[size];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextLong();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic int[][] next2dArrint(int rows,int columns) throws IOException{\n\t\t\tint[][]a=new int[rows][columns];\n\t\t\tfor (int i = 0; i < rows; i++) {\n\t\t\t\tfor (int j = 0; j < columns; j++) {\n\t\t\t\t\ta[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic long[][] next2dArrlong(int rows,int columns) throws IOException{\n\t\t\tlong[][]a=new long[rows][columns];\n\t\t\tfor (int i = 0; i < rows; i++) {\n\t\t\t\tfor (int j = 0; j < columns; j++) {\n\t\t\t\t\ta[i][j]=sc.nextLong();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}\n\t\n\tstatic class Side{\n\t\tPoint a;\n\t\tPoint b;\n\t\tpublic Side(Point a,Point b) {\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tSide s=(Side)obj;\n\t\t\treturn (s.a.equals(a)&&s.b.equals(b))||(s.b.equals(a)&&s.a.equals(b));\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\n\t\t\treturn \"(\"+a.toString()+\",\"+b.toString()+\")\";\n\t\t}\n\t}\n\tstatic class Point{\n\t\tint x;\n\t\tint y;\n\t\tint z;\n\t\tpublic Point(int x,int y,int z) {\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.z=z;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tPoint p=(Point)obj;\n\t\t\treturn x==p.x&&y==p.y&&z==p.z;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\"+x+\",\"+y+\",\"+z+\")\";\n\t\t}\n\t}\n\tstatic class Pair implements Comparable{\n\t\tlong x;\n\t\tlong y;\n\t\tpublic Pair(long x,long y) {\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tPair p=(Pair)obj;\n\t\t\treturn x==p.x&&y==p.y;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\/\/ TODO Auto-generated method stub\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Object o) {\n\t\t\tPair p=(Pair)o;\n\t\t\treturn x>p.x?1:x==p.x?0:-1;\n\t\t}\n\t}\n\tstatic class sPair{\n\t\tString s;\n\t\tPair p;\n\t\tpublic sPair(String s,Pair p) {\n\t\t\tthis.p=p;\n\t\t\tthis.s=s;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t\/\/ TODO Auto-generated method stub\n\t\t\treturn s+\" \"+p;\n\t\t}\n\t}\n\tstatic Scanner sc=new Scanner(System.in);\n\tstatic PrintWriter pw=new PrintWriter(System.out);\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  long long t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<long long> vi(n);\n    for (int i = 0; i < n; i++) {\n      cin >> vi[i];\n    }\n    long long mx = 2 * 10e-5;\n    if (n == 1) {\n      mx = vi[0];\n    } else if (n == 2) {\n      mx = max(vi[0], abs(vi[1] - vi[0]));\n    } else {\n      sort(vi.begin(), vi.end());\n      for (int j = 1; j < n; j++) {\n        mx = max(mx, abs(vi[j] - vi[j - 1]));\n      }\n      mx = max(mx, vi[0]);\n    }\n    cout << mx << \"\\n\";\n  }\n  return 0;\n}\n","t = int(input())\n\nfor test in range(t):\n    n = int(input())\n    p = list(map(int,input().split()))\n    if(len(p)==1):\n        print(p[0])\n        continue\n    elif(len(p)==2):\n        print(max(min(p[0],p[1]),abs(p[0]-p[1])))\n        continue\n    ans = 0\n    p.sort()\n    for i in range(len(p)-2,-1,-1):\n        ans = max(ans,p[i+1]-p[i])\n    print(ans)\n","    #from _typeshed import SupportsKeysAndGetItem\nimport sys\nfrom collections import deque\nimport heapq\nimport bisect\nimport copy\n# sys.stdin=open(\"input.txt\",\"r\");\n# sys.stdout=open(\"output.txt\",\"w\")\n####### GLOBAL ###############\nMOD=1000000007\nNO=lambda:print(\"NO\")\nYES=lambda:print(\"YES\")\n_1=lambda:print(-1)\nari=lambda:[int(_) for _ in input().split()]\ncin=lambda:int(input())\ncis=lambda:input()\nshow=lambda x: print(x)\nfast= lambda:sys.stdin.readline()\n\n########### END #########\n######\ntest_case=1\ntest_case=int(input())\n######\nsys.setrecursionlimit(10**6)\n    \ndef ans():\n    n=cin()\n    \n    arr=ari()\n    if n==1:\n        print(*arr)\n        return\n    maxi=-float('inf')\n    arr.sort()\n    # arr.append(0)\n    for i in range(len(arr)-1):\n        maxi=max(maxi,arr[i+1]-arr[i])\n    print(maxi)\n    return\nfor _ in range(test_case):\n    ans()\n    ","import java.io.*;\nimport java.util.*;\n \npublic class MinimumExtraction {\n\n    public static void main(String[] args) throws IOException {\n        FastScanner in = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int t = in.nextInt();\n        for (int i = 1; i <= t; i++)  {\n        \tint n = in.nextInt();\n        \tlong[] a = new long[n];\n        \tfor (int j = 0; j < n; j++)  {\n        \t\ta[j] = in.nextLong();\n        \t}\n        \tArrays.sort(a);\n        \tif (n == 1)  {\n        \t\tout.println(a[0]);\n        \t}\n        \telse  {\n        \t\tif (n == 2)  {\n        \t\t\tlong min = Math.min(a[0], a[1]);\n        \t\t\tlong max = Math.max(a[0], a[1]);\n        \t\t\tout.println(Math.max(min, max - min));\n        \t\t}\n        \t\telse  {\n        \t\t\tlong biggestGap = Long.MIN_VALUE;\n        \t\t\tfor (int j = n - 1; j > 0; j--)  {\n        \t\t\t\tlong gap = a[j] - a[j - 1];\n        \t\t\t\tif (gap > biggestGap)  {\n        \t\t\t\t\tbiggestGap = gap;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t\tout.println(biggestGap);\n        \t\t}\n        \t}\n        }\n        out.close();\n    }\n    \n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try { \n                    st = new StringTokenizer(br.readLine());                               \n                } catch (IOException e) {\n                    \/\/ noop\n                }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble()  {\n            return Double.parseDouble(next());\n        }\n    }\n\n}","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 1000;\nlong long p[N];\nint main() {\n  int n;\n  cin >> n;\n  while (n--) {\n    int a;\n    cin >> a;\n    for (int i = 0; i < a; i++) {\n      scanf(\"%d\", &p[i]);\n    }\n    sort(p, p + a);\n    long long j = 0, s = 0;\n    long long max = -1e9;\n    for (int i = 0; i < a; i++) {\n      if (p[i] + j > max) {\n        max = p[i] + j;\n      }\n      j -= p[i] + j;\n    }\n    cout << max << endl;\n  }\n  return 0;\n}\n","t = int(input())\n\ninf = -(10**17)\n\nans = []\nfor _ in range(t):\n    n = int(input())\n    nums = [int(_) for _ in input().split()]\n    nums.sort()\n    x = 0\n    y = inf\n    pre = 0\n    flag = True\n    for n in nums:\n        if n < 0:\n            y = max(y, x + n)\n            x -= n\n        else:\n            if flag:\n                y = n + x\n                flag = False\n            else:\n                y = max(y, n - pre)\n        pre = n\n    ans.append(str(y))\n\nprint('\\n'.join(ans))","#include <bits\/stdc++.h>\nusing namespace std;\nlong long M = 1000000007;\nlong long bin(long long n, long long k) {\n  long long res = 1;\n  if (k > n - k) k = n - k;\n  for (int i = 0; i < k; i++) {\n    res *= (n - i);\n    res \/= (i + 1);\n    res %= M;\n  }\n  return res;\n}\nvoid solve() {\n  long long n, i, k, x, ct = 0, ans = 0;\n  cin >> n;\n  long long a[n];\n  for (i = 0; i < n; i++) cin >> a[i];\n  sort(a, a + n);\n  long long mn = a[0];\n  k = a[0];\n  for (i = 1; i < n; i++) {\n    mn = max(mn, a[i] - k);\n    k += mn;\n  }\n  cout << mn << endl;\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n;\n  cin >> n;\n  long long a[n];\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  if (n == 1) {\n    cout << a[0] << endl;\n    return;\n  }\n  sort(a, a + n);\n  if (n == 2) {\n    cout << max(min(a[0], a[1]), a[1] - a[0]) << endl;\n    return;\n  }\n  long long largest = a[n - 1], secondlargest = a[n - 2], third = a[n - 3];\n  largest -= third;\n  secondlargest -= third;\n  cout << max(min(largest, secondlargest), largest - secondlargest) << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long test = 1;\n  cin >> test;\n  while (test--) {\n    solve();\n  }\n  return 0;\n}\n","# Sujith\nfrom sys import stdin,stdout,setrecursionlimit\nfrom io import BytesIO, IOBase\n# from heapq import heappush as push,heappop as hp,heapify as h\n# from math import gcd,floor,sqrt,ceil\nfrom collections import Counter,deque as dq,defaultdict\n# from itertools import accumulate as acc,permutations as perm\n# from bisect import bisect_left as bl,bisect_right as br,bisect as bis\n\nsetrecursionlimit(10000)\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n        self.BUFSIZE = 8192\n\n    def read(self):\n        while True:\n            a = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n            if not a:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(a), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            a = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n            self.newlines = a.count(b\"\\n\") + (not a)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(a), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nstdin, stdout = IOWrapper(stdin), IOWrapper(stdout)\ninput = lambda: stdin.readline().rstrip(\"\\r\\n\")\n\n# inf = float('inf')\n# ninf = float('-inf')\n# abc = 'abcdefghijklmnopqrstuvwxyz'\ninp = lambda: int(input())\nst = lambda: input().strip()\njn = lambda x,l: x.join(map(str,l))\nint_arr = lambda : list(map(int,input().strip().split()))\nstr_arr = lambda :list(map(str,input().split()))\nget_str = lambda : map(str,input().strip().split())\nget_int = lambda: map(int,input().strip().split())\nget_float = lambda : map(float,input().strip().split())\n\nmod = 1000000007\n\n#main()\nfor _ in range(inp()):\n    n = inp()\n    arr = int_arr()\n\n    if n == 1:\n        print(arr[0])\n    else:\n        arr.sort()\n        ele = arr[0]\n        mx = float('-inf')\n        tot = 0\n        for i in range(1,n):\n            arr[i] -= ele + tot\n            tot += ele\n            mx = max(arr[i],mx)\n            ele = arr[i]\n        print(mx)\n\n\n\n\n\n\n","t=int(input())\nfor _ in range(t):\n    n=int(input())\n    aaa=list(map(int,input().split()))\n    aaa.sort()\n    go=True\n    s=0\n    b=aaa[0]\n    bm=b\n    for j in range (1,n):\n        s-=aaa[j-1]\n        #print(j,aaa[j],s,b)\n        if aaa[j]+s >bm : bm=aaa[j]\n        #print(j,s,b,bm)\n        \n    \n    \n    print(bm)\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> a(n, 0);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    long long ans = a[0];\n    long long b = 0;\n    for (int i = 0; i < n - 1; i++) {\n      a[i + 1] -= b;\n      if (a[i] == a[i + 1]) {\n        break;\n      }\n      if (a[i + 1] - a[i] >= a[i]) {\n        b += a[i];\n        a[i + 1] -= a[i];\n        ans = a[i + 1];\n      } else {\n        break;\n      }\n    }\n    cout << ans << endl;\n  }\n}\n","t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    mx = -100000000000000\n    while True:\n        l = len(a)\n        mn = min(a)\n        mx = max(mn,mx)\n        if l == 1:\n            break\n        if a.count(mn) == l:\n            break\n        else:\n            a.remove(mn)\n            for x in range(l-1):\n                a[x] -= mn\n    if mx > mn:\n        print(mx)\n    else:\n        print(mn)\n ","#include <bits\/stdc++.h>\n#include <ext\/pb_ds\/assoc_container.hpp>\n#define ll long long\n#define endl '\\n'\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<typename T>\nusing ordered_set =\ntree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\nconst int mod=1e9+7;\n\n\nint main() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin>>t;\n    while(t--){\n        int n;\n        cin>>n;\n        multiset<int>se;\n        for(int i=0;i<n;i++){\n            int x;\n            cin>>x;\n            se.insert(x);\n        }\n        if(n==1){\n            cout<<*se.begin()<<endl;\n            continue;\n        }\n        ll sum=0;\n        ll mi =-2e9;\n        while(!se.empty() && (1LL**se.begin()-sum)>=mi){\n            mi=1LL**se.begin()-sum;\n            sum+=(1LL**se.begin()-sum);\n            se.erase(se.find(*se.begin()));\n        }\n        cout<<mi<<endl;\n    }\n}\n","#include <bits\/stdc++.h>\n#include <ext\/pb_ds\/assoc_container.hpp>\n#define ll long long\n#define endl '\\n'\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<typename T>\nusing ordered_set =\ntree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\nconst int mod=1e9+7;\n\n\nint main() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin>>t;\n    while(t--){\n        int n;\n        cin>>n;\n        multiset<int>se;\n        for(int i=0;i<n;i++){\n            int x;\n            cin>>x;\n            se.insert(x);\n        }\n        if(n==1){\n            cout<<*se.begin()<<endl;\n            continue;\n        }\n        ll sum=0;\n        ll mi =-2e18;\n        while(!se.empty() && (1LL**se.begin()-sum)>=mi){\n            mi=1LL**se.begin()-sum;\n            sum+=(1LL**se.begin()-sum);\n            se.erase(se.find(*se.begin()));\n        }\n        cout<<mi<<endl;\n    }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int q;\n  cin >> q;\n  while (q--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto& x : a) cin >> x;\n    sort(a.begin(), a.end());\n    a.resize(unique(a.begin(), a.end()) - a.begin());\n    n = (int)a.size();\n    int ans = a[0];\n    for (int i = 1; i < n; i++) ans = max(ans, a[i] - a[i - 1]);\n    cout << ans << \"\\n\";\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 1000;\nlong long p[N];\nint main() {\n  int n;\n  cin >> n;\n  while (n--) {\n    memset(p, 0, sizeof p);\n    int a;\n    cin >> a;\n    for (int i = 0; i < a; i++) {\n      cin >> p[i];\n    }\n    sort(p, p + a);\n    long long j = 0, s;\n    long long max = -1e9 - 1;\n    for (int i = 0; i < a; i++) {\n      if (p[i] + j >= max) {\n        max = p[i];\n        s = j;\n      }\n      j -= p[i] + j;\n    }\n    cout << max + s << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long log_a_to_base_b(long long a, long long b) { return log(a) \/ log(b); }\nbool isPrime(long long n) {\n  if (n == 1) {\n    return false;\n  }\n  long long i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      return false;\n    }\n    i += 1;\n  }\n  return true;\n}\nvector<long long> prime_fact(long long n) {\n  vector<long long> v;\n  for (long long i = 2; i * i <= n; i++)\n    if (n % i == 0) {\n      while (n % i == 0) n \/= i;\n      v.push_back(i);\n    }\n  if (n > 1) v.push_back(n);\n  return v;\n}\nlong long power(long long a, long long n) {\n  long long res = 1;\n  while (n) {\n    if (n % 2)\n      res *= a, n--;\n    else\n      a *= a, n \/= 2;\n  }\n  return res;\n}\nlong long euler_totient(long long n) {\n  long long res = n;\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      res \/= i;\n      res *= (i - 1);\n      while (n % i == 0) n \/= i;\n    }\n  }\n  if (n > 1) res \/= n, res *= (n - 1);\n  return res;\n}\nbool isKthBitSet(long long n, long long k) {\n  if (n & (1 << k))\n    return true;\n  else\n    return false;\n}\nlong long no_of_set_bits(long long n) {\n  long long cnt = 0;\n  while (n > 0) {\n    cnt++;\n    n = n & (n - 1);\n  }\n  return cnt;\n}\nvoid init() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nsigned main() {\n  init();\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> v(n);\n    for (auto &i : v) cin >> i;\n    sort(v.begin(), v.end());\n    if (n == 1) {\n      cout << v[0] << \"\\n\";\n      continue;\n    }\n    if (n == 2) {\n      cout << max(v[0], (v[1] - v[0])) << \"\\n\";\n      continue;\n    }\n    long long ans = 0ll;\n    long long i = 0ll;\n    if (v[0ll] < 0ll) {\n      for (i = 1ll; i < n; i++)\n        if (v[i] < 0ll)\n          continue;\n        else\n          break;\n      i--;\n      for (long long j = 0; i < i; i++)\n        ans = max(ans, (long long)(v[j + 1] - v[j]));\n      i++;\n    }\n    for (; i < n - 1ll; i++) ans = max(ans, (long long)(v[i + 1] - v[i]));\n    cout << (long long)ans << \"\\n\";\n  }\n  return 0;\n}\n","import sys, collections, math, bisect, heapq, random, functools\ninput = sys.stdin.readline\nout = sys.stdout.flush\n \ndef solve():\n      n = int(input())\n      queue = []\n      a = list(map(int,input().split()))\n      for i in range(n):\n            heapq.heappush(queue,a[i])\n      diff = 0\n      k = len(queue)\n      while k > 1 and queue[0] - diff <= 0:\n            cur = heapq.heappop(queue)\n            diff += cur\n            k -= 1\n      #print(diff)\n      while k > 1 and queue[1] - diff - (queue[0] - diff) >= queue[0] - diff:\n            cur = heapq.heappop(queue) - diff\n         \n            diff += cur\n            k -= 1\n \n      print(queue[0] - diff)\n \n \n \n \n \n \n \nif __name__ == '__main__':\n      for i in range(int(input())):\n          solve()","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int64_t t;\n  cin >> t;\n  for (int i = 0; i < t; i++) {\n    int64_t n;\n    cin >> n;\n    int64_t a[n];\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a, a + n);\n    int64_t s = a[0];\n    for (int i = 1; i < n; i++) {\n      s = max(a[i], a[i] - a[i - 1]);\n    }\n    cout << s << endl;\n  }\n  return 0;\n}\n","import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class minextraction {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n        try{\n            int t = scn.nextInt();\n            while(t-- > 0){\n                int n = scn.nextInt();\n                long[] arr= new long[n];\n                long sum = 0;\n                for (int i = 0; i < n; i++) {\n                    arr[i] = scn.nextLong();\n                    sum += arr[i];\n                }\n                if(n == 1){\n                    System.out.println(arr[0]);\n                }\n                else{\n                    Arrays.sort(arr);\n                    long[] diff = new long[n];\n                    for (int i = 0; i < n-1; i++) {\n                        diff[i] = arr[i + 1] - arr[i];\n\n                    }\n                    Arrays.sort(diff);\n                    if(n == 2){\n                        if(arr[0] > diff[1]){\n                            System.out.println(arr[0]);\n                        }\n                        else{\n                            System.out.println(diff[1]);\n                        }\n                    }\n                    else {\n                        System.out.println(diff[diff.length - 1]);\n                    }\n                }\n            }\n\n        }\n        catch (Exception e){\n            return;\n        }\n    }\n}\n","import java.io.*;\nimport java.util.*;\npublic class GFG {\n\tpublic static void main (String[] args)throws IOException {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tint t=Integer.parseInt(br.readLine());\n\t\twhile(t-->0)\n\t\t{\n\t\t    int n=Integer.parseInt(br.readLine());\n\t\t    String s[]=br.readLine().split(\" \");\n\t\t    if(n==1)\n\t\t    {\n\t\t        bw.write((Integer.parseInt(s[0]))+\"\\n\");\n\t\t    }\n\t\t    else \n\t\t    {\n\t\t        ArrayList<Integer> pos=new ArrayList<>();\n\t\t        ArrayList<Integer> neg=new ArrayList<>();\n\t\t        for(int i=0;i<n;i++)\n\t\t        {\n\t\t            int temp=Integer.parseInt(s[i]);\n\t\t            if(temp>=0)\n\t\t                pos.add(temp);\n\t\t            else \n\t\t                neg.add(temp);\n\t\t        }\n\t\t        if(pos.size()==0)\n\t\t        {\n\t\t            Collections.sort(neg);\n\t\t            bw.write((neg.get(neg.size()-1)-neg.get(neg.size()-2))+\"\\n\");\n\t\t        }\n\t\t        else if(pos.size()==1)\n\t\t        {\n\t\t            Collections.sort(neg);\n\t\t            bw.write((pos.get(0)-(neg.get(neg.size()-1)))+\"\\n\");\n\t\t        }\n\t\t        else if(neg.size()!=0)\n\t\t        {\n\t\t            int max=0;\n\t\t            Collections.sort(pos);\n\t\t            for(int i=1;i<pos.size();i++)\n\t\t            {\n\t\t                if(pos.get(i)-pos.get(i-1)>max)\n\t\t                max=pos.get(i)-pos.get(i-1);\n\t\t            }\n\t\t            bw.write(max+\"\\n\");\n\t\t        }\n\t\t        else\n\t\t        {\n\t\t            int max=pos.get(0);\n\t\t            Collections.sort(pos);\n\t\t            max=Math.max((pos.get(pos.size()-1)-pos.get(pos.size()-2)),max);\n\t\t            bw.write(max+\"\\n\");\n\t\t        }\n\t\t        \n\t\t    }\n\t\t}\n\t\tbw.flush();\n\t\t\n\t}\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  long long q, init_poz, nr_jumps;\n  cin >> q;\n  for (int i = 1; i <= q; i++) {\n    long long ans;\n    cin >> init_poz >> nr_jumps;\n    if (init_poz % 2 == 0) {\n      long long rest = nr_jumps % 4;\n      if (rest == 1) {\n        ans = init_poz - nr_jumps;\n      } else {\n        if (rest == 2)\n          ans = init_poz + 1;\n        else if (rest == 3)\n          ans = nr_jumps + 1 + init_poz;\n        else\n          ans = init_poz;\n      }\n    } else {\n      long long rest = nr_jumps % 4;\n      if (rest == 3)\n        ans = init_poz - nr_jumps + 1;\n      else if (rest == 0)\n        ans = init_poz;\n      else if (rest == 1)\n        ans = init_poz + nr_jumps;\n      else\n        ans = init_poz - 1;\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n","\/\/ Working program with FastReader \nimport java.io.*;\nimport java.util.*;\npublic class hh\n{ \n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n\n        public FastReader() \n        { \n            br = new BufferedReader(new\n                InputStreamReader(System.in)); \n        } \n\n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n\n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n\n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n\n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n\n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n\n    static final int MAXN = 100001;\n    \/\/ stores smallest prime factor for every number\n    static int spf[] = new int[MAXN];\n    \/\/ Calculating SPF (Smallest Prime Factor) for every\n    \/\/ number till MAXN.\n    \/\/ Time Complexity : O(nloglogn)\n    static void sieve()\n    {\n        spf[1] = 1;\n        for (int i=2; i<MAXN; i++)\n\n        \/\/ marking smallest prime factor for every\n        \/\/ number to be itself.\n            spf[i] = i;\n\n        \/\/ separately marking spf for every even\n        \/\/ number as 2\n        for (int i=4; i<MAXN; i+=2)\n            spf[i] = 2;\n\n        for (int i=3; i*i<MAXN; i++)\n        {\n            \/\/ checking if i is prime\n            if (spf[i] == i)\n            {\n                \/\/ marking SPF for all numbers divisible by i\n                for (int j=i*i; j<MAXN; j+=i)\n\n                \/\/ marking spf[j] if it is not\n                \/\/ previously marked\n                    if (spf[j]==j)\n                        spf[j] = i;\n            }\n        }\n    }\n    \/\/ A O(log n) function returning primefactorization\n    \/\/ by dividing by smallest prime factor at every step\n    static int getFactorization(int x)\n    {\n        int c=0;\n        while (x != 1)\n        {\n            c++;\n            x = x \/ spf[x];\n        }\n        return c;\n    }\n\n    \/*\n    static int LowerBound(int a[], int x) { \/\/ x is the target value or key\n    int l=-1,r=a.length;\n    while(l+1<r) {\n    int m=(l+r)>>>1;\n    if(a[m]>=x) r=m;\n    else l=m;\n    }\n    return r;\n    }\n\n    static int UpperBound(int a[], int x) {\/\/ x is the key or target value\n    int l=-1,r=a.length;\n    while(l+1<r) {\n    int m=(l+r)>>>1;\n    if(a[m]<=x) l=m;\n    else r=m;\n    }\n    return l+1;\n    }\n     *\/\n    static int gcd(int a, int b)\n    {\n        if (a == 0)\n            return b; \n        return gcd(b % a, a); \n    }\n\n    \/\/ method to return LCM of two numbers\n    static int lcm(int a, int b)\n    {\n        return (a \/ gcd(a, b)) * b;\n    }\n\n    public static int[] swap(int a[], int left, int right)\n    {\n        int temp = a[left];\n        a[left] = a[right];\n        a[right] = temp;\n        return a;\n    }\n\n    public static int[] reverse(int a[], int left, int right)\n    {\n        \/\/ Reverse the sub-array\n        while (left < right) {\n            int temp = a[left];\n            a[left++] = a[right];\n            a[right--] = temp;\n        }\n        return a;\n    }\n\n    public static int[] findNextPermutation(int a[])\n    {\n        int last = a.length - 2;\n\n        \/\/ find the longest non-increasing suffix\n        \/\/ and find the pivot\n        while (last >= 0) {\n            if (a[last] < a[last + 1]) {\n                break;\n            }\n            last--;\n        }\n        \/\/ If there is no increasing pair\n        \/\/ there is no higher order permutation\n        if (last < 0)\n            return a;\n\n        int nextGreater = a.length - 1;\n\n        \/\/ Find the rightmost successor to the pivot\n        for (int i = a.length - 1; i > last; i--) {\n            if (a[i] > a[last]) {\n                nextGreater = i;\n                break;\n            }\n        }\n\n        \/\/ Swap the successor and the pivot\n        a = swap(a, nextGreater, last);\n\n        \/\/ Reverse the suffix\n        a = reverse(a, last + 1, a.length - 1);\n\n        \/\/ Return true as the next_permutation is done\n        return a;\n    }\n\n    static void sort(int[] a) {\n        ArrayList<Integer> l = new ArrayList<>();\n        for (int i : a)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n\n    static double pow(double p,double tt)\n    {\n        double ii,q,r;\n        q=1;\n        r=p;\n        while(tt>1)\n        {\n            for(ii=1;2*ii<=tt;ii*=2)\n                p*=p;\n            tt-=ii;\n            q*=p;\n            p=r;\n        }\n        if(tt==1)\n            q*=r;\n        return q;\n    }\n\n    static long pow(long p,long tt,long mod)\n    {\n        long ii,q,r;\n        q=1l;\n        r=p;\n        while(tt>1)\n        {\n            for(ii=1l;2*ii<=tt;ii*=2l)\n                p=((p%mod)*(p%mod))%mod;\n            tt-=ii;\n            q=((q%mod)*(p%mod))%mod;\n            p=r;\n        }\n        if(tt==1)\n            q=((q%mod)*(r%mod))%mod;\n        return q;\n    }\n\n    static int factorial(int n)\n    {\n        return (n == 1 || n == 0) ? 1 : n * factorial(n - 1);\n    }\n\n    public static long primeFactors(long n)\n    {\n        long c=0l;\n        long max=0l;\n        long z=0l;\n        \/\/ArrayList <Integer> ll=new ArrayList<>();\n        \/\/ Print the number of 2s that divide n\n        while (n%2==0)\n        {\n            c++;\n            n \/= 2l;\n            \/\/ll.add(2);\n        }\n        if(c>max)\n        {\n            max=c;\n            z=2;\n        }\n        \/\/ n must be odd at this point. So we can\n        \/\/ skip one element (Note i = i +2)\n        for (int i = 3; i <= Math.sqrt(n); i+= 2)\n        {\n            \/\/ While i divides n, print i and divide n\n            c=0;\n            while (n%i == 0)\n            {\n                c++;\n                n \/= i;\n                \/\/ll.add(i);\n            }\n            if(c>max)\n            {\n                max=c;\n                z=i;\n            }\n        }\n        c=0;\n        \/\/ This condition is to handle the case whien\n        \/\/ n is a prime number greater than 2\n        if (n > 2)\n        {\n            c++;\n            \/\/ll.add((int)n);\n        }\n        if(c>max)\n        {\n            max=c;\n            z=n;\n        }\n        return z;\n    }\n\n    static void PrimeList(){\n        int i,j;\n        int sieve[]=new int[100001];\n        for(i=2;i*i<=100000;i++)\n        {\n            if(sieve[i]==0)\n            {\n                for(j=i*i;j<=100000;j+=i)\n                    sieve[j]=1;\n            }\n        }\n        ArrayList<Integer> primes=new ArrayList<>();\n        for(i=2;i<=100000;i++)\n        {\n            if(sieve[i]==0)\n                primes.add(i);\n        }\n    }\n\n    static int comp(int a[],int b[],int n)\n    {\n        int z=0;\n        for(int i=0;i<n;i++)\n        {\n            if(a[i]!=b[i])\n            {\n                z=1;\n                break;\n            }\n        }\n        if(z==0)\n            return 1;\n        else\n            return 0;\n    }\n\n    static boolean isPowerOfTwo(int x)\n    {\n        return x!=0 && ((x&(x-1))==0);\n    }\n\n    static long calc (int a[],int b[],int n,int mod)\n    {\n        long sum=0l;\n        int i;\n        HashMap<Long,Long>x=new HashMap<>();\n        HashMap<Long,Long>y=new HashMap<>();\n        for(i=0;i<n;i++)\n        {\n            x.put((long)a[i],(long)i);\n            y.put((long)b[i],(long)i);\n        }\n        for(i=0;i<n;i++)\n        {\n            sum=(sum+Math.abs(x.get((long)i)-y.get((long)i))%mod)%mod;\n        }\n        return sum;\n    }\n\n    static int[] rotate(int arr[])\n    {\n        int x = arr[arr.length-1], i;\n        for (i = arr.length-1; i > 0; i--)\n            arr[i] = arr[i-1];\n        arr[0] = x;\n        return arr;\n    }\n\n    public static void main(String[] args) \n    {\n        \/\/try\n        \/\/{\n        FastReader d=new FastReader();\n        PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        StringBuilder sb=new StringBuilder();\n        int t,i,j,k,l,r,n;\n        int mod = (int) 1e9 + 7;\n\n        int Inf=Integer.MAX_VALUE;\n        int negInf=Integer.MIN_VALUE;\n        t=d.nextInt();\n        \/\/t=1;\n        String s,s1;\n        \/\/char ch1,ch2,ch3,ch4;\n        long ans,c,z;\n\n        while(t-->0)\n        {\n            z=c=0l;\n            ans=0l;\n            n=d.nextInt();\n            int a[]=new int[n];\n            for(i=0;i<n;i++)\n                a[i]=d.nextInt();\n            sort(a);\n            int x=0;\n            if(n==1)\n                pr.println(a[0]);\n            else\n            {\n                for(i=0;i<n-1;i++)\n                {\n                    if(a[i+1]-a[i]-x>=a[i])\n                    {\n                        \n                        a[i+1]=a[i+1]-a[i]-x;\n                        x+=a[i];\n                    }\n                    else\n                    {\n                        pr.println(a[i]);\n                        z=1;\n                        break;\n                    }\n                }\n                if(z==0)\n                pr.println(a[i]);\n            }\n        }\n        \/*\n        }catch(Exception e) {\n        System.out.println(0);\n        }*\/\n        pr.flush();\n    }\n}","import sys, collections, math, bisect, heapq, random, functools\n\ninput = sys.stdin.readline\nout = sys.stdout.flush\n\n\ndef solve():\n    n = int(input())\n    queue = []\n    a = list(map(int, input().split()))\n    for i in range(n):\n        heapq.heappush(queue, a[i])\n    diff = 0\n    k = len(queue)\n    while k > 1 and queue[0] - diff <= 0:\n        cur = heapq.heappop(queue) - diff\n        diff += cur\n        k -= 1\n\n    ans = -float('inf')\n    while k > 1:\n        minv = heapq.heappop(queue)\n        two = queue[0]\n        if two - diff - (minv - diff) >= minv - diff:\n           cur = minv - diff\n           diff += cur\n           k -= 1\n        else:\n            ans = minv - diff\n            break\n\n    if ans == -float('inf'):\n        print(queue[0] - diff)\n    else:\n        print(ans)\n\n\n\nif __name__ == '__main__':\n    for i in range(int(input())):\n        solve()","import java.util.*;\nimport java.io.*;\n\npublic class C {\n    static StringBuilder sb;\n    static long fact[];\n    static long mod = (long) (1e9 + 7);\n    static int[] arr = { 0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111 };\n\n    static void solve(int[] arr) {\n        if (arr.length == 1) {\n            sb.append(arr[0] + \"\\n\");\n            return;\n        }\n\n        HashSet<Integer> visited = new HashSet<>();\n        ArrayList<Integer> uniqueElements = new ArrayList<>();\n        for (int ele : arr) {\n            if (!visited.contains(ele)) {\n                uniqueElements.add(ele);\n                visited.add(ele);\n            }\n        }\n\n        Collections.sort(uniqueElements);\n\n        long ans = uniqueElements.get(0);\n        for (int i = 0; i < uniqueElements.size() - 1; i++) {\n            int diff = uniqueElements.get(i + 1) - uniqueElements.get(i);\n            ans = Math.max(ans, diff);\n        }\n        sb.append(ans + \"\\n\");\n    }\n\n    public static void main(String[] args) {\n        sb = new StringBuilder();\n        int test = i();\n        while (test-- > 0) {\n            int n = i();\n            int[] arr = readArray(n);\n            solve(arr);\n        }\n        out.printLine(sb);\n        out.flush();\n        out.close();\n\n    }\n\n    \/*\n     * fact=new long[(int)1e6+10]; fact[0]=fact[1]=1; for(int i=2;i<fact.length;i++)\n     * { fact[i]=((long)(i%mod)1L(long)(fact[i-1]%mod))%mod; }\n     *\/\n    \/\/ **************NCR%P******************\n\n    static long p(long x, long y)\/\/ POWER FXN \/\/\n    {\n        if (y == 0)\n            return 1;\n\n        long res = 1;\n        while (y > 0) {\n            if (y % 2 == 1) {\n                res = (res * x) % mod;\n                y--;\n            }\n\n            x = (x * x) % mod;\n            y = y \/ 2;\n\n        }\n        return res;\n    }\n\n    static long ncr(int n, int r) {\n        if (r > n)\n            return (long) 0;\n\n        long res = fact[n] % mod;\n        \/\/ System.out.println(res);\n        res = ((long) (res % mod) * (long) (p(fact[r], mod - 2) % mod)) % mod;\n        res = ((long) (res % mod) * (long) (p(fact[n - r], mod - 2) % mod)) % mod;\n        \/\/ System.out.println(res);\n        return res;\n\n    }\n\n    \/\/ **************END******************\n\n    \/\/ *************Disjoint set\n    \/\/ union*********\/\/\n\n    \/\/ ***************PRIME FACTORIZE\n    \/\/ ***********************************\/\/\n    static TreeMap<Integer, Integer> prime(long n) {\n        TreeMap<Integer, Integer> h = new TreeMap<>();\n        long num = n;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (n % i == 0) {\n                int nt = 0;\n                while (n % i == 0) {\n                    n = n \/ i;\n                    nt++;\n                }\n                h.put(i, nt);\n            }\n        }\n        if (n != 1)\n            h.put((int) n, 1);\n        return h;\n\n    }\n\n    \/\/ *****CLASS PAIR\n    \/\/ *************************************************\n    static class Pair implements Comparable<Pair> {\n        int x;\n        long y;\n\n        Pair(int x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Pair o) {\n            return (int) (this.y - o.y);\n\n        }\n\n    }\n    \/\/ *****CLASS PAIR\n    \/\/ ***************************************************\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int Int() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String String() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return String();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void flush() {\n            writer.flush();\n        }\n    }\n\n    static InputReader in = new InputReader(System.in);\n    static OutputWriter out = new OutputWriter(System.out);\n\n    public static long[] sortlong(long[] a2) {\n        int n = a2.length;\n        ArrayList<Long> l = new ArrayList<>();\n        for (long i : a2)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < l.size(); i++)\n            a2[i] = l.get(i);\n        return a2;\n    }\n\n    public static int[] sortint(int[] a2) {\n        int n = a2.length;\n        ArrayList<Integer> l = new ArrayList<>();\n        for (int i : a2)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < l.size(); i++)\n            a2[i] = l.get(i);\n        return a2;\n    }\n\n    public static long pow(long x, long y) {\n        long res = 1;\n        while (y > 0) {\n            if (y % 2 != 0) {\n                res = (res * x);\/\/ % modulus;\n                y--;\n\n            }\n            x = (x * x);\/\/ % modulus;\n            y = y \/ 2;\n        }\n        return res;\n    }\n\n    \/\/ GCD___+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n    public static long gcd(long x, long y) {\n        if (x == 0)\n            return y;\n        else\n            return gcd(y % x, x);\n    }\n    \/\/ ******LOWEST COMMON MULTIPLE\n    \/\/ *********************************************\n\n    public static long lcm(long x, long y) {\n        return (x * (y \/ gcd(x, y)));\n    }\n\n    \/\/ INPUT\n    \/\/ PATTERN********************************************************\n    public static int i() {\n        return in.Int();\n    }\n\n    public static long l() {\n        String s = in.String();\n        return Long.parseLong(s);\n    }\n\n    public static String s() {\n        return in.String();\n    }\n\n    public static int[] readArray(int n) {\n        int A[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            A[i] = i();\n        }\n        return A;\n    }\n\n    public static long[] readArray(long n) {\n        long A[] = new long[(int) n];\n        for (int i = 0; i < n; i++) {\n            A[i] = l();\n        }\n        return A;\n    }\n\n}","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    long long arr[n];\n    for (long long i = 0; i < n; i++) {\n      cin >> arr[i];\n    }\n    if (n == 1) {\n      cout << arr[0] << endl;\n      continue;\n    } else {\n      sort(arr, arr + n);\n      vector<long long> v;\n      for (long long i = 0; i < n - 1; i++) {\n        v.push_back(arr[i + 1] - arr[i]);\n      }\n      if (n == 2) {\n        cout << max(v[0], arr[0]) << endl;\n      } else\n        cout << *max_element(v.begin(), v.end()) << endl;\n    }\n  }\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint p[N];\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> p[i];\n    sort(p, p + n + 1);\n    int ans = p[1];\n    for (int i = 2; i <= n; i++) ans = max(p[i] - p[i - 1], ans);\n    cout << ans << endl;\n  }\n  return 0;\n}\n","for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print(a[0])\n    else:\n        a.sort()\n        plus = 0\n        for i in range(n):\n            if a[i] < 0:\n                plus -= a[i]\n            else:\n                break\n        a = a[i:]\n        if len(a) == 1:\n            print(a[0] + plus)\n        else:\n            ans1 = min(a)\n            ans = min(a)\n            for i in range(len(a) - 1, -1, -1):\n                ans = max(ans, a[i] - a[i - 1])\n            if ans == ans1:\n                print(ans + plus)\n            else:\n                print(ans)","import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.lang.*;\nimport static java.lang.Math.*;\n\n\/\/ Sachin_2961 submission \/\/\npublic class Codeforces {\n\n    static void solve(){\n        int n = fs.nInt();\n        int[]ar = new int[n];\n        for(int i=0;i<n;i++)\n            ar[i] = fs.nInt();\n\n        Arrays.sort(ar);\n        long sum = ar[0];\n        long min = ar[0];\n        for(int i=1;i<n;i++){\n            if( ar[i] - sum < min )\n                break;\n            min = ar[i] - sum;\n            sum = sum + (ar[i]-sum);\n        }\n        out.println(min);\n    }\n    \n    static class Pair{\n        int f,s;\n        Pair(int f,int s){\n            this.f = f;\n            this.s = s;\n        }\n    }\n    static boolean multipleTestCase = true;\n    static FastScanner fs;\n    static PrintWriter out;\n    public static void main(String[]args){\n       try{\n           out = new PrintWriter(System.out);\n           fs = new FastScanner();\n           int tc = multipleTestCase?fs.nInt():1;\n           while (tc-->0)solve();\n           out.flush();\n           out.close();\n       }catch (Exception e){\n           e.printStackTrace();\n       }\n    }\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String n() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        String Line()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        int nInt() {return Integer.parseInt(n()); }\n        long nLong() {return Long.parseLong(n());}\n        double nDouble(){return Double.parseDouble(n());}\n        int[]aI(int n){\n            int[]ar = new int[n];\n            for(int i=0;i<n;i++)\n                ar[i] = nInt();\n            return ar;\n        }\n    }\n    public static void sort(int[] arr){\n        ArrayList<Integer> ls = new ArrayList<Integer>();\n        for(int x: arr)\n            ls.add(x);\n        Collections.sort(ls);\n        for(int i=0; i < arr.length; i++)\n            arr[i] = ls.get(i);\n    }\n    public static void sort(long[] arr){\n        ArrayList<Long> ls = new ArrayList<>();\n        for(long x: arr)\n            ls.add(x);\n        Collections.sort(ls);\n        for(int i=0; i < arr.length; i++)\n            arr[i] = ls.get(i);\n    }\n}","\/\/package Codeforces;\nimport java.util.*;\n\nimport java.io.*;\npublic  class template{\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\tString next () {\n\t\t\twhile(!st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t}catch(IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tint[] readArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\t\n\tstatic class helper{\n\t\t\n\t\t\/\/reverse 1-d Array\n\t\tpublic static void reverse(int arr[]) {\n\t\t\tint i = 0;\n\t\t\tint j = arr.length - 1;\n\t\t\twhile(i<j) {\n\t\t\t\tint temp = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/gcd of two numbers\n\t\tpublic static int gcd(int a,int b) {\n\t\t\tif(b == 0) {\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\treturn gcd(b,a%b);\n\t\t}\n\t\t\n\t\t\/\/calculate ncr\n\t\tpublic static int ncr(int n,int r) {\n\t\t\tint num = n;\n\t\t\tint deno = r;\n\t\t\tint a1 = 1;\n\t\t\tint a2 = 1;\n\t\t\tfor(int i=0;i<r;i++) {\n\t\t\t\ta1 *= num;\n\t\t\t\ta2 *= deno;\n\t\t\t\tnum--;\n\t\t\t\tdeno--;\n\t\t\t}\n\t\t\tint ans = a1\/a2;\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t\/\/isPalindrome\n\t\tpublic static boolean isPalindrome(String substring){\n\t\t    char ch[] = substring.toCharArray();\n\t\t    int i = 0;\n\t\t    int j = ch.length-1;\n\t\t    while(i<j){\n\t\t        char temp = ch[i];\n\t\t        ch[i] = ch[j];\n\t\t        ch[j] = temp;\n\t\t        i++;\n\t\t        j--;\n\t\t    }\n\t\t    String rev = String.valueOf(ch);\n\t\t    if(rev.equals(substring)){\n\t\t        return true;\n\t\t    }\n\t\t    else{\n\t\t        return false;\n\t\t    }\n\t\t}\n\t\t\n\t\t\/\/isPowerOfTwo\n\t\tpublic static boolean isPowerOfTwo(long x)\n\t    {\n\t        \/* First x in the below expression is\n\t        for the case when x is 0 *\/\n\t        return x != 0 && ((x & (x - 1)) == 0);\n\t    }\n\t\t\n\t\t\/\/nextPowerOfTwo\n\t\tpublic static long nextPowerOfTwo(long n)\n\t    {\n\t        n--;\n\t        n |= n >> 1;\n\t        n |= n >> 2;\n\t        n |= n >> 4;\n\t        n |= n >> 8;\n\t        n |= n >> 16;\n\t        n++;\n\t         \n\t        return n;\n\t    }\n\t}\n\t\n\n\t\n\tpublic static void main(String[] args) {\n\t\t  FastScanner sc = new FastScanner();\n\t\t  PrintWriter out = new PrintWriter(System.out);\n\t\t  helper help = new helper();\n\t\t  long test = sc.nextLong();\n\t\t  while(test-->0) {\n\t\t\t  int n = sc.nextInt();\n\t\t\t  int arr[] = sc.readArray(n);\n\t\t\t  if(n == 1) {\n\t\t\t\t  out.println(arr[0]);\n\t\t\t\t  continue;\n\t\t\t  }\n\t\t\t  Arrays.sort(arr);\n\/\/\t\t\t  int pre[] = new int[n];\n\/\/\t\t\t  pre[0] = arr[0];\n\/\/\t\t\t  for(int i=1;i<arr.length;i++) {\n\/\/\t\t\t\t  pre[i] = pre[i-1] + arr[i];\n\/\/\t\t\t  }\n\t\t\t  int max = arr[0];\n\t\t\t  \n\t\t\t  for(int i=1;i<arr.length-1;i++) {\n\t\t\t\t \n\t\t\t\t  int value = arr[i]-arr[i-1];\n\t\t\t\t \n\t\t\t\t  if(value > max) {\n\t\t\t\t\t  max = value;\n\t\t\t\t  }\n\t\t\t\t\n\t\t\t  }\n\t\t\t  out.println(max);\n\t\t  }\n\t\t  out.flush();\n\t}\n\t\n}\nclass lavesh {\n\tint value;\n\tString color;\n\tlavesh(int value,String color){\n\t\tthis.value = value;\n\t\tthis.color = color;\n\t}\n\tpublic int getValue() {\n\t\treturn value;\n\t}\n\tpublic void setValue(int value) {\n\t\tthis.value = value;\n\t}\n\tpublic String getColor() {\n\t\treturn color;\n\t}\n\tpublic void setColor(String color) {\n\t\tthis.color = color;\n\t}\n}\nclass pair {\n\tint value;\n\tint index;\n\tpair(int value,int index){\n\t\tthis.value = value;\n\t\tthis.index = index;\n\t}\n\tpublic int getValue() {\n\t\treturn value;\n\t}\n\tpublic void setValue(int value) {\n\t\tthis.value = value;\n\t}\n\tpublic int getIndex() {\n\t\treturn index;\n\t}\n\tpublic void setIndex(int index) {\n\t\tthis.index = index;\n\t}\n}\n","for _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    if(n==1 or len(set(a))==1):\n        print(a[0])\n        continue\n    else:\n        a.sort()\n        m=a[0]\n        for i in range(len(a)-1):\n            m=max(a[i+1]-a[i],m)\n        print(m)","for _ in range(int(input())):\n    n=int(input())\n    ans=-1e10\n    if(n==1):\n        ans=input()\n    elif n==2:\n        arr=list(map(int, input().split()))\n        ans=min(arr)\n    else:\n        arr=list(map(int, input().split()))\n        #print(arr)\n        arr.sort()\n        #print(arr)\n        \n        for i in range(1,n):\n            h=arr[i]-arr[i-1]\n            if ans<=h:\n                #print(\"debug\",h, ans)\n                ans=h\n    print(ans)","#include <bits\/stdc++.h>\nusing namespace std;\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long tt;\n  cin >> tt;\n  while (tt--) {\n    long long x;\n    cin >> x;\n    long long d;\n    cin >> d;\n    vector<long long> foo;\n    long long cur = x;\n    for (long long i = 0; i < 4; i++) {\n      long long min = i + 1;\n      if (cur & 1) {\n        cur += min;\n      } else {\n        cur -= min;\n      }\n      foo.push_back(cur);\n    }\n    long long temp = d % 4;\n    if (temp == 2 or temp == 0) {\n      if (temp == 0) temp += 4;\n      cout << foo[temp - 1] << '\\n';\n    } else {\n      if (temp == 1) {\n        d--;\n        long long dem = d \/ 4.0;\n        if (x & 1) {\n          cout << foo[temp - 1] + dem * 4 << '\\n';\n        } else {\n          cout << foo[temp - 1] - dem * 4 << '\\n';\n        }\n      } else {\n        d--;\n        long long dem = d \/ 4.0;\n        if (x & 1) {\n          cout << foo[temp - 1] - dem * 4 << '\\n';\n        } else {\n          cout << foo[temp - 1] + dem * 4 << '\\n';\n        }\n      }\n    }\n  }\n  return 0;\n}\n","\nimport java.util.*;\n\nimport javax.swing.text.Segment;\n\nimport java.io.*;\nimport java.math.*;\nimport java.sql.Array;\n\n\n\npublic class Main {\n\t  static class Scanner{\n\t\t  \n\t\t\tBufferedReader br;\n\t\t\tStringTokenizer st;\n\t\t\tpublic Scanner() {\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t}\n\t\t\tString next() \n\t\t    { \n\t\t        while (st == null || !st.hasMoreElements()) \n\t\t        { \n\t\t            try\n\t\t            { \n\t\t                st = new StringTokenizer(br.readLine()); \n\t\t            } \n\t\t            catch (IOException  e) \n\t\t            { \n\t\t                e.printStackTrace(); \n\t\t            } \n\t\t        } \n\t\t        return st.nextToken(); \n\t\t    } \n\n\t\t    int nextInt() \n\t\t    { \n\t\t        return Integer.parseInt(next()); \n\t\t    } \n\n\t\t    long nextLong() \n\t\t    { \n\t\t        return Long.parseLong(next()); \n\t\t    } \n\n\t\t    double nextDouble() \n\t\t    { \n\t\t        return Double.parseDouble(next()); \n\t\t    } \n\n\t\t    String nextLine() \n\t\t    { \n\t\t        String str = \"\"; \n\t\t        try\n\t\t        { \n\t\t            str = br.readLine(); \n\t\t        } \n\t\t        catch (IOException e) \n\t\t        { \n\t\t            e.printStackTrace(); \n\t\t        } \n\t\t        return str; \n\t\t    } \n\t\t}\n\t \n\t  static long mod = (long)(1e9 + 7);\n\t \n\tstatic void sort(long[] arr ) {\n\t\t ArrayList<Long> al = new ArrayList<>();\n\t\t for(long e:arr) al.add(e);\n\t\t Collections.sort(al);\n\t\t for(int i = 0 ; i<al.size(); i++) arr[i] = al.get(i);\n\t }\n\tstatic void sort(int[] arr ) {\n\t\t ArrayList<Integer> al = new ArrayList<>();\n\t\t for(int e:arr) al.add(e);\n\t\t Collections.sort(al);\n\t\t for(int i = 0 ; i<al.size(); i++) arr[i] = al.get(i);\n\t }\n\tstatic void sort(char[] arr) {\n\t\tArrayList<Character> al = new ArrayList<Character>();\n\t\tfor(char cc:arr) al.add(cc);\n\t\tCollections.sort(al);\n\t\tfor(int i = 0 ;i<arr.length ;i++) arr[i] = al.get(i);\n\t}\n\tstatic void rvrs(int[] arr) {\n\t\tint i =0 , j = arr.length-1;\n\t\twhile(i>=j) {\n\t\t\tint temp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\tstatic void rvrs(long[] arr) {\n\t\tint i =0 , j = arr.length-1;\n\t\twhile(i>=j) {\n\t\t\tlong temp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\n\tstatic long mod_mul(long a , long b ,long mod) {\n\t\treturn ((a%mod)*(b%mod))%mod;\n\t}\n\t static long gcd(long a, long b)\n\t  {      \n\t     if (b == 0)\n\t        return a;\n\t     return gcd(b, a % b); \n\t  }\n\t static boolean[] prime(int num) {\n\t\t\tboolean[] bool = new boolean[num];\n\t\t     \n\t\t      for (int i = 0; i< bool.length; i++) {\n\t\t         bool[i] = true;\n\t\t      }\n\t\t      for (int i = 2; i< Math.sqrt(num); i++) {\n\t\t         if(bool[i] == true) {\n\t\t            for(int j = (i*i); j<num; j = j+i) {\n\t\t               bool[j] = false;\n\t\t            }\n\t\t         }\n\t\t      }\n\t\t      if(num >= 0) {\n\t\t    \t  bool[0] = false;\n\t\t    \t  bool[1] = false;\n\t\t      }\n\t\t      \n\t\t      return bool;\n\t\t}\n\n\t static long modInverse(long a, long m)\n\t    {\n\t        long g = gcd(a, m);\n\t       \n\t          return   power(a, m - 2, m);\n\t        \n\t    }\n\t   static long lcm(long a , long b) {\n\t\t   return (a*b)\/gcd(a, b);\n\t   }\n\t   static int lcm(int a , int b) {\n\t\t   return (int)((a*b)\/gcd(a, b));\n\t   }\n\t static long power(long x, long y, long m){\n\t        if (y == 0) return 1; long p = power(x, y \/ 2, m) % m; p = (int)((p * (long)p) % m);\n\t        if (y % 2 == 0) return p; else return (int)((x * (long)p) % m); }\n\t   \n     static class Combinations{\n\t    \t private long[] z;\n\t    \t private long[] z1;\n\t    \t private long[] z2;\n\t    \t  public Combinations(long N , long mod) {\n\t\t\t\tz = new long[(int)N+1];\n\t\t\t\tz1 = new long[(int)N+1];\n\t\t\t\tz[0] = 1;\n\t\t\t\tfor(int i =1 ; i<=N ; i++) z[i] = (z[i-1]*i)%mod;\n\t\t\t     z2 = new long[(int)N+1];\n\t\t\t\tz2[0] = z2[1] = 1;\n\t\t\t    for (int i = 2; i <= N; i++)\n\t\t\t        z2[i] = z2[(int)(mod % i)] * (mod - mod \/ i) % mod;\n\t\t\t    \n\t\t\t    \n\t\t\t    z1[0] = z1[1] = 1;\n\t\t\t    \n\t\t\t    for (int i = 2; i <= N; i++)\n\t\t\t        z1[i] = (z2[i] * z1[i - 1]) % mod;\n\t\t\t}\n\t    \t  long fac(long n) {\n\t    \t\t  return z[(int)n];\n\t    \t  }\n\t    \t  long invrsNum(long n) {\n\t    \t\t  return z2[(int)n];\n\t    \t  }\n\t    \t  long invrsFac(long n) {\n\t    \t\t  return invrsFac((int)n);\n\t    \t  }\n\t    \t  long ncr(long N, long R, long mod)\n\t    \t  {\t\tif(R<0 || R>N ) return 0;\n\t    \t\t    long ans = ((z[(int)N] * z1[(int)R])\n\t    \t\t              % mod * z1[(int)(N - R)])\n\t    \t\t             % mod;\n\t    \t\t    return ans;\n\t    \t\t}\n\t      }\n\t      static class DisjointUnionSets {\n\t\t\t    int[] rank, parent;\n\t\t\t    int n;\n\t\t\t  \n\t\t\t    public DisjointUnionSets(int n)\n\t\t\t    {\n\t\t\t        rank = new int[n];\n\t\t\t        parent = new int[n];\n\t\t\t        this.n = n;\n\t\t\t        makeSet();\n\t\t\t    }\n\t\t\t  \n\t\t\t    void makeSet()\n\t\t\t    {\n\t\t\t        for (int i = 0; i < n; i++) {\n\t\t\t          \n\t\t\t            parent[i] = i;\n\t\t\t        }\n\t\t\t    }\n\t\t\t  \n\t\t\t    int find(int x)\n\t\t\t    {\n\t\t\t        if (parent[x] != x) {\n\t\t\t        \n\t\t\t            parent[x] = find(parent[x]);\n\t\t\t  \n\t\t\t        }\n\t\t\t  \n\t\t\t        return parent[x];\n\t\t\t    }\n\t\t\t  \n\t\t\t    void union(int x, int y)\n\t\t\t    {\n\t\t\t        int xRoot = find(x), yRoot = find(y);\n\t\t\t  \n\t\t\t        if (xRoot == yRoot)\n\t\t\t            return;\n\t\t\t  \n\t\t\t        if (rank[xRoot] < rank[yRoot])\n\t\t\t  \n\t\t\t            parent[xRoot] = yRoot;\n\t\t\t  \n\t\t\t        else if (rank[yRoot] < rank[xRoot])\n\t\t\t  \n\t\t\t            parent[yRoot] = xRoot;\n\t\t\t  \n\t\t\t        else\n\t\t\t        {\n\t\t\t            parent[yRoot] = xRoot;\n\t\t\t  \n\t\t\t            rank[xRoot] = rank[xRoot] + 1;\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t      static int max(int a , int b) {\n\t    \t  if(b>a) return b;\n\t    \t  return a;  \n\t      }\n\t      static long max(long a , long b) {\n\t    \t  if(b>a) return b;\n\t    \t  return a;  \n\t      }\n\t      static int min(int a , int b) {\n\t    \t  if(b<a) return b;\n\t    \t  return a;\n\t      }\n\t      static long min(long a , long b) {\n\t    \t  if(b<a) return b;\n\t    \t  return a;\n\t      }\n\t      static int[] KMP(String str) {\n\t    \t  int n = str.length();\n\t    \t  int[] kmp = new int[n];\n\t    \t  for(int i = 1 ; i<n ; i++) {\n\t    \t\t  int j = kmp[i-1];\n\t    \t\t  while(j>0 && str.charAt(i) != str.charAt(j)) {\n\t    \t\t\t  j = kmp[j-1];\n\t    \t\t  }\n\t    \t\t  if(str.charAt(i) == str.charAt(j)) j++;\n\t    \t\t  kmp[i] = j;\n\t    \t  }\n\t    \t  \n\t    \t  return kmp;\n\t      }\n\t      \n\t      \n\/************************************************ Query **************************************************************************************\/\t  \n\t \n\/***************************************** \t\tSparse Table\t********************************************************\/\n\t      static class SparseTable{\n\t    \t\t\n\t    \t\tprivate long[][] st;\n\t    \t\t\n\t    \t\tSparseTable(long[] arr){\n\t    \t\t\tint n = arr.length;\n\t    \t\t\tst = new long[n][25];\n\t    \t\t\tlog = new int[n+2];\n\t    \t\t\tbuild_log(n+1);\n\t    \t\t\tbuild(arr);\n\t    \t\t}\n\t    \t\t\n\t    \t\tprivate void build(long[] arr) {\n\t    \t\t\tint n = arr.length;\n\t    \t\t\t\n\t    \t\t\tfor(int i = n-1 ; i>=0 ; i--) {\n\t    \t\t\t\tfor(int j = 0 ; j<25 ; j++) {\n\t    \t\t\t\t\tint r = i + (1<<j)-1;\n\t    \t\t\t\t\tif(r>=n) break;\n\t    \t\t\t\t\tif(j == 0 ) st[i][j] = arr[i];\n\t    \t\t\t\t\telse st[i][j] = Math.max(st[i][j-1] , st[ i + ( 1 << (j-1) ) ][ j-1 ] );\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t}\n\t    \t\tpublic long gcd(long a  ,long b) {\n\t    \t\t\tif(a == 0) return b;\n\t    \t\t\treturn gcd(b%a , a);\n\t    \t\t}\n\t    \t\tpublic long query(int l ,int r) {\n\t    \t\t\tint w = r-l+1;\n\t    \t\t\tint power = log[w];\n\t    \t\t\treturn Math.max(st[l][power],st[r - (1<<power) + 1][power]);\n\t    \t\t}\n\t    \t\tprivate int[] log;\n\t    \t\tvoid build_log(int n) {\n\t    \t\t\tlog[1] = 0;\n\t    \t\t\tfor(int i = 2 ; i<=n ; i++) {\n\t    \t\t\t\tlog[i] = 1 + log[i\/2];\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t      \n\t      \n\/********************************************************\tSegement Tree\t*****************************************************\/\n\/**\n\t \t static class SegmentTree{\n\t\t\t long[] tree;\n\t\t\t long[] arr;\n\t\t\t int n;\n\t\t\t SegmentTree(long[] arr){\n\t\t\t\t this.n = arr.length;\n\t\t\t\t tree = new long[4*n+1];\n\t\t\t\t this.arr = arr;\n\t\t\t\t buildTree(0, n-1, 1);\n\t\t\t }\n\t\t\t \n\t\t\t \n\t\t\t  void buildTree(int s ,int e  ,int index ) {\n\t\t\t\t\tif(s == e) {\n\t\t\t\t\t\ttree[index] = arr[s];\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tint mid = (s+e)\/2;\n\t\t\t\t\t\n\t\t\t\t\tbuildTree( s,  mid, 2*index);\n\t\t\t\t\tbuildTree( mid+1, e, 2*index+1);\n\t\t\t\t\t\n\t\t\t\t\ttree[index] = Math.min(tree[2*index] , tree[2*index+1]);\n\t\t\t\t}\n\t\t\t  \n\t\t\t long query(int si ,int ei) {\n\t\t\t\t return query(0 ,n-1 , si ,ei , 1   );\n\t\t\t }\n\t\t\t private long query( int ss ,int se ,int qs , int qe,int index) {\n\t\t\t\t\t\n\t\t\t\t\tif(ss>=qs && se<=qe) return tree[index];\n\t\t\t\t\t\n\t\t\t\t\tif(qe<ss || se<qs) return (long)(1e17);\n\t\t\t\t\t\n\t\t\t\t\tint mid = (ss + se)\/2;\n\t\t\t\t\tlong left = query( ss , mid , qs ,qe , 2*index);\n\t\t\t\t\tlong right= query(mid + 1 , se , qs ,qe , 2*index+1);\n\t\t\t\t\treturn Math.min(left, right);\n\t\t\t\t}\n\t\t\t public void update(int index , int val) {\n\t\t\t\t arr[index] = val;\n\t\t\t\t for(long e:arr) System.out.print(e+\" \");\n\t\t\t\t update(index , 0 , n-1 , 1);\n\t\t\t }\n\t\t\t private void update(int id ,int si , int ei , int index) {\n\t\t\t\t if(id < si || id>ei) return;\n\t\t\t\t if(si == ei ) { \n\t\t\t\t\t tree[index] = arr[id];\n\t\t\t\t\t return;\n\t\t\t\t }\n\t\t\t\t if(si > ei) return;\n\t\t\t\t int mid = (ei + si)\/2;\n\t\t\t\t\t\n\t\t\t\t\tupdate( id,  si, mid , 2*index);\n\t\t\t\t\tupdate( id , mid+1, ei , 2*index+1);\n\t\t\t\t\t\n\t\t\t\t\ttree[index] = Math.min(tree[2*index] ,tree[2*index+1]);\n\t\t\t }\n\t\t\t  \n\t\t }\n\t\t *\/\n\n\/* ***************************************************************************************************************************************************\/\t \n\t \n\t      static Scanner sc = new Scanner();\n\t static StringBuilder sb = new StringBuilder();\n\t public static void main(String args[]) throws IOException {\n\n\t\t int tc = 1;\n\t\t  tc = sc.nextInt();\n\t\t\n\t\t for(int i = 1 ; i<=tc ; i++) {\n\n\/\/\t\t\t sb.append(\"Case #\" + i + \": \"  );\t\/\/ During KickStart && HackerCup\n\t\t\t TEST_CASE();\n\t\t\t  \n\t\t }\n\t\t System.out.println(sb);\n\t }\n\n\t static void TEST_CASE() {\n\t\t int n = sc.nextInt();\n\t\t long[] arr = new long[n];\n\t\tfor(int i = 0 ; i<n ; i++)\n\t\t\tarr[i] = sc.nextLong();\n\t\tsort(arr);\n\t\tlong[] suf = new long[n];\n\t\tsuf[n-1] = arr[n-1];\n\t\tfor(int i = n-2 ; i>=0 ; i--) {\n\t\t\tsuf[i] = arr[i] + suf[i+1];\n\t\t}\n\t\tlong max = arr[n-1];\n\t\tfor(int i = n-2 ; i>=0 ;i--) {\n\t\t\tmax = Math.max(max,suf[i] );\n\t\t}\n\t\tsb.append(max+\"\\n\");\n\t }\n}\n\n\t \n\n\/*******************************************************************************************************************************************************\/\n\n\/**\n\t\n\t\n *\/\n\n \n\n","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  size_t t;\n  cin >> t;\n  while (t--) {\n    long long n;\n    cin >> n;\n    vector<long long> a(n);\n    for (size_t i = 0; i < n; ++i) {\n      cin >> a[i];\n    }\n    if (a.size() == 1) {\n      cout << a[0] << endl;\n    }\n    sort(a.begin(), a.end());\n    long long s = 0;\n    long long res = 0;\n    size_t i;\n    for (i = 0; i < n - 1; ++i) {\n      if (a[i] + s <= 0) {\n        s -= a[i] + s;\n        continue;\n      }\n      break;\n    }\n    vector<long long> diffs(n - i + 1);\n    diffs[0] = a[i] + s;\n    for (size_t j = i; j < n - 1; ++j) {\n      diffs[j - i + 1] = a[j + 1] - a[j];\n    }\n    cout << *max_element(diffs.begin(), diffs.end()) << endl;\n  }\n  return 0;\n}\n","import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\/**\n *\n * @author eslam\n *\/\npublic class MinimumExtraction {\n\n    static class FastReader {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(\n                    new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        FastReader input = new FastReader();\n        BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));\n        int t =  input.nextInt();\n        loop:for (int i = 0; i < t; i++) {\n            int n = input.nextInt();\n            Long a[] = new Long[n];\n            for (int j = 0; j < n; j++) {\n                a[j] = input.nextLong();\n            }\n            if(n==1){\n                log.write(a[0]+\"\\n\");\n            }else{\n                Arrays.parallelSort(a);\n                long ans = 0;\n                for (int j = 0; j < n-1; j++) {\n                    ans = Math.max(a[j+1]-a[j], ans);\n                }\n                log.write(ans+\"\\n\");\n            }\n        }\n        log.flush();\n    }\n    \n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nconst long long MAXN = 2e5 + 10;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e18;\nlong long a[MAXN];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    long long mx = -INF;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      mx = max(mx, a[i]);\n    }\n    sort(a, a + n);\n    int p = 0;\n    long long m = 0;\n    for (int i = 0; i < n - 1 && a[i] < 0; i++) {\n      if (i > 0) m += a[i - 1] - a[i];\n      p++;\n    }\n    if (p - 1 >= 0) {\n      m += a[p - 1];\n    }\n    long long s = m;\n    while (p < n - 1 && a[p] - s < mx - s - a[p]) {\n      s += a[p] - s;\n      p++;\n    }\n    cout << a[p] - s << endl;\n  }\n  return 0;\n}\n","#include <bits\/stdc++.h>\nusing namespace std;\nint t, n;\nconst int maxn = 2e5 + 5;\nint a[maxn];\nint max1;\nvoid solve() {\n  cin >> n;\n  max1 = -0x7fffffff;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  if (n == 1) {\n    cout << a[1] << endl;\n    return;\n  }\n  sort(a + 1, a + n + 1);\n  if (n == 2) {\n    cout << max(a[1], a[2] - a[1]) << endl;\n    return;\n  }\n  max1 = max(max1, a[n] - a[n - 1]);\n  max1 = max(max1, a[n - 1] - a[n - 2]);\n  cout << max1 << endl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n","import sys, collections, math, bisect, heapq, random, functools\n\ninput = sys.stdin.readline\nout = sys.stdout.flush\n\n\ndef solve():\n    n = int(input())\n    queue = []\n    a = list(map(int, input().split()))\n    for i in range(n):\n        heapq.heappush(queue, a[i])\n    diff = 0\n    k = len(queue)\n    while k > 1 and queue[0] - diff <= 0:\n        cur = heapq.heappop(queue) - diff\n        diff += cur\n        k -= 1\n\n    while k > 1 and queue[1] - diff - (queue[0] - diff) >= queue[0] - diff:\n        cur = heapq.heappop(queue) - diff\n        diff += cur\n        k -= 1\n\n    print(queue[0] - diff)\n\n\nif __name__ == '__main__':\n    for i in range(int(input())):\n        solve()","#include <bits\/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t, y;\n  cin >> t;\n  for (int i = 0; i < t; i++) {\n    int n, mn = 1000000001;\n    cin >> n;\n    vector<int> v(n);\n    if (n == 1) {\n      int a;\n      cin >> a;\n      cout << a << '\\n';\n    } else {\n      for (int j = 0; j < n; j++) {\n        cin >> v[j];\n        if (v[j] < mn) mn = v[j];\n      }\n      int x = mn;\n      for (int k = 0; k < n - 1; k++) {\n        int mnn = 1000000001, cnt = 0;\n        for (int j = 0; j < n - k - 1; j++) {\n          v[j] -= x;\n          if (v[j] == 0 && cnt == 0) {\n            v.erase(v.begin() + j);\n            j--;\n            cnt++;\n          } else if (v[j] < mnn)\n            mnn = v[j];\n        }\n        y = max(x, mnn);\n        x = mnn;\n      }\n      cout << y << '\\n';\n    }\n  }\n}\n","def get_new_numbers(numbers, mn):\n    s = [numbers[i] - mn for i in range(len(numbers) - 1) if numbers[i] != numbers[-1]]\n    if len(s) > 0:\n        mn = max(mn, s[-1])\n    if len(numbers) > 1 and numbers[-2] == numbers[-1]:\n        mn = max(mn, 0)\n    return s, mn\n\n\ndef main():\n    _ = int(input())\n    numbers = sorted([int(x) for x in input().split()], reverse=True)\n    mn = numbers[-1]\n    while len(numbers) > 1:\n        numbers, mt = get_new_numbers(numbers, numbers[-1])\n        if mn > mt:\n            break\n        mn = max(mt, mn)\n    print(mn)\n\n\nif __name__ == '__main__':\n    # tests = 1\n    tests = int(input())\n    while tests > 0:\n        tests -= 1\n        main()\n"]}}
